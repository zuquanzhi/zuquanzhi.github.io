<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode0485</title>
    <url>/2023/11/21/LeetCode0485/</url>
    <content><![CDATA[<h1 id="最大连续-1-的个数"><a href="#最大连续-1-的个数" class="headerlink" title="最大连续 1 的个数"></a><a href="https://leetcode.cn/problems/max-consecutive-ones/">最大连续 1 的个数</a></h1><hr>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二进制数组 <code>nums</code> ， 计算其中最大连续 <code>1</code> 的个数。</p>
 <span id="more"></span>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,0,1,1,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：开头的两位和最后的三位都是连续<span class="number"> 1 </span>，所以最大连续<span class="number"> 1 </span>的个数是 3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="string">[1,0,1,1,0,1]</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 105</code></p>
</li>
<li><p><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>.</p>
</li>
</ul>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>本题中存在两个技术点：连续数和最大。</p>
<p>连续数是比较好求的，只需要条件判定再加上计数器就可以做到。</p>
<p>关键在于最大，使我引入了一个缓存变量tmp，用来实时更新“最大连击数”并不会占用1太多空间。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMaxConsecutiveOnes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; numsSize &amp;&amp; nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            tmp++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &lt; tmp) &#123;</span><br><span class="line">            count = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode0498</title>
    <url>/2023/11/23/LeetCode0498/</url>
    <content><![CDATA[<h1 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a><a href="https://leetcode.cn/problems/diagonal-traverse/">对角线遍历</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>
<span id="more"></span>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：mat = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,4,7,5,3,6,8,9]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">输入：mat = <span class="string">[[1,2],[3,4]]</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 104</code></li>
<li><code>1 &lt;= m * n &lt;= 104</code></li>
<li><code>-105 &lt;= mat[i][j] &lt;= 105</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>根据题目要求，矩阵按照对角线进行遍历。设矩阵的行数为 m, 矩阵的列数为 n, 我们仔细观察对角线遍历的规律可以得到如下信息:</p>
<p><img src="C:\Users\祖全之\AppData\Roaming\Typora\typora-user-images\image-20231123183323953.png" alt="image-20231123183323953" style="zoom:80%;" /></p>
<p><strong>根据以上观察得出的结论，我们直接模拟遍历所有的对角线即可。</strong></p>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">findDiagonalOrder</span><span class="params">(<span class="type">int</span>** mat, <span class="type">int</span> matSize, <span class="type">int</span>* matnSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = matSize;</span><br><span class="line">    <span class="type">int</span> n = matnSize[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m * n);</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历矩阵的所有对角线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果对角线序号为奇数</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = i &lt; n ? <span class="number">0</span> : i - n + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> y = i &lt; n ? i : n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前对角线并将元素存入结果数组</span></span><br><span class="line">            <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res[pos] = mat[x][y];</span><br><span class="line">                pos++;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 如果对角线序号为偶数</span></span><br><span class="line">            <span class="type">int</span> x = i &lt; m ? i : m - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> y = i &lt; m ? <span class="number">0</span> : i - m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前对角线并将元素存入结果数组</span></span><br><span class="line">            <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                res[pos] = mat[x][y];</span><br><span class="line">                pos++;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置返回的数组大小</span></span><br><span class="line">    *returnSize = m * n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>一看就会一做就废系列</em></p>
<p>大体上把情况分为两种：奇数和偶数对角线——这两种对角线也代表着不同的遍历顺序（从下到上or从上到下）</p>
<p>一边遍历一边把得到元素存到res数组里，得到新数组，及完成任务。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake入门</title>
    <url>/2024/01/12/CMake%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><h4 id="1-1Cmake是什么"><a href="#1-1Cmake是什么" class="headerlink" title="1 .1Cmake是什么"></a>1 .1Cmake是什么</h4><p>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。可以构建、测试、打包项目。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。对于c++工程来说，通过cmake配置，然后通过cmake工具自动生成makefile文件，最后通过make编译出二进制文件。也就是说CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。</p>
<span id="more"></span>
<h4 id="1-2-Cmake-优缺点"><a href="#1-2-Cmake-优缺点" class="headerlink" title="1.2 Cmake 优缺点"></a>1.2 Cmake 优缺点</h4><ul>
<li><p>优点</p>
</li>
<li><ul>
<li>编程式的配置</li>
<li>支持跨平台</li>
<li>支持强依赖受控管理</li>
<li>官方提供的依赖查找方式</li>
<li>支持配置分离</li>
<li>支持多种外部调用方式</li>
<li>官方提供多种系统检测接口</li>
<li>支持工具链（Toolchain）以传递配置</li>
<li>官方提供了多种工具链实现</li>
<li>自身具有版本控制及约束功能</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><ul>
<li>文档太差。cmake的文档差是一个公认的问题，那官方文档上连一个具体实例都没有，关键点也不会明确体现出来。</li>
<li>弱变量及未定义的变量导致非预期行为。cmake是一个弱语言，其变量没有具体的类型之分。你可以使用某个变量代表一个字符串，也可以代表一个列表。而在其他部分使用此变量作为非预期的类型会导致无穷无尽的问题。当然，这是弱语言的共通问题。而在一处使用未被定义的变量更容易发生未预期的行为。</li>
<li>调试困难。cmake官方目前不支持断点调试功能。</li>
</ul>
</li>
</ul>
<h3 id="2-Cmake环境配置"><a href="#2-Cmake环境配置" class="headerlink" title="2 Cmake环境配置"></a>2 Cmake环境配置</h3><p>先安装cmake然后进行环境变量配置即可。 验证是否成功，在命令窗口执行 cmake —verson 即可。</p>
<h3 id="3-简单的Cmake工程"><a href="#3-简单的Cmake工程" class="headerlink" title="3 简单的Cmake工程"></a>3 简单的Cmake工程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">D:/code/vscodeProject 目录下的文件列表，文档后面都会用到这个路径，后续不在说明。</span><br><span class="line">├─.vscode</span><br><span class="line">├─build</span><br><span class="line">│  ├─.cmak</span><br><span class="line">│  ├─CMakeFiles</span><br><span class="line">│  ├─main</span><br><span class="line">│  ├─src</span><br><span class="line">│  └─Testing</span><br><span class="line">├─exe</span><br><span class="line">├─include</span><br><span class="line">├─main</span><br><span class="line">├─script</span><br><span class="line">└─src</span><br></pre></td></tr></table></figure>
<p>通过cmake搭建的一个c++编译工程 链接 github: <a href="https://github.com/Persist-Forever/cmakeProc.git">https://github.com/Persist-Forever/cmakeProc.git</a></p>
<h3 id="4-基本命令"><a href="#4-基本命令" class="headerlink" title="4 基本命令"></a>4 基本命令</h3><h4 id="4-1-描述命令"><a href="#4-1-描述命令" class="headerlink" title="4.1 描述命令"></a>4.1 描述命令</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.0</span><span class="number">.0</span>)  # 指定cmake的最小版本</span><br><span class="line"><span class="built_in">project</span>(getestProc VERSION <span class="number">0.1</span><span class="number">.0</span>)      # 指定项目名称及版本号，初始化项目相关变量</span><br><span class="line"><span class="built_in">project</span>(getestProc C CXX)                # 指定项目支持的语言 C C++</span><br></pre></td></tr></table></figure>
<h4 id="4-2-关键路径"><a href="#4-2-关键路径" class="headerlink" title="4.2 关键路径"></a>4.2 关键路径</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># PROJECT_SOURCE_DIR 项目的目录 也就是 D:/code/<span class="function">vscodeProject</span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span>$&#123;PROJECT_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"># PROJECT_BINARY_DIR 项目的构建目录 D:/code/vscodeProject/build</span></span><br><span class="line"><span class="function">MESSAGE(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> $&#123;</span>PROJECT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="4-3-设置关键字"><a href="#4-3-设置关键字" class="headerlink" title="4.3 设置关键字"></a>4.3 设置关键字</h4><p>SET关键字用来显示指定的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SET</span>(SRC_LIST XXX.cpp xx2.cpp xx3.cpp ...)</span><br><span class="line"># $&lt;TARGET_OBJECTS:src-dltest-object&gt; 这个设置到一个变量中是因为add_libary可以使用</span><br><span class="line"><span class="built_in">set</span>(src-dltest</span><br><span class="line">     $&lt;TARGET_OBJECTS:src-dltest-object&gt;</span><br><span class="line">     PARENT_SCOPE)</span><br></pre></td></tr></table></figure>
<h4 id="4-4-获取目录下所有源文件"><a href="#4-4-获取目录下所有源文件" class="headerlink" title="4.4 获取目录下所有源文件"></a>4.4 获取目录下所有源文件</h4><p>该函数用的比较多，注意不会递归。构建文件中经常使用到这一句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br></pre></td></tr></table></figure>
<h4 id="4-5-信息打印-MASSAGE关键字"><a href="#4-5-信息打印-MASSAGE关键字" class="headerlink" title="4.5 信息打印 MASSAGE关键字"></a>4.5 信息打印 MASSAGE关键字</h4><p>MESSAGE关键字主要用于向终端输出用户自定义的信息，主要包含三种信息</p>
<ul>
<li>SEND_ERROR，产生错误，生成过程被跳过</li>
<li>STATUS，输出前缀为–的信息</li>
<li>FATAL_ERROR，立即终止所有cmake过程</li>
</ul>
<h4 id="4-6-add-library"><a href="#4-6-add-library" class="headerlink" title="4.6 add_library"></a>4.6 add_library</h4><ul>
<li>第一种用法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [&lt;source&gt;...])</span><br><span class="line"># 生成 liboptical.<span class="function">so</span></span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(optical share optical.cpp $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>add_library根据源码来生成一个库供他人使用。是个逻辑名称，在项目中必须唯一。完整的库名依赖于具体构建方式（可能为lib.a or .lib）。</p>
<p>STATIC指静态库，SHARED指动态库，MODULE指在运行期通过类似于dlopen的函数动态加载。</p>
<ul>
<li>第二种用法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(&lt;name&gt; OBJECT [&lt;source&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>(... $&lt;TARGET_OBJECTS:name&gt; ...)</span><br><span class="line"><span class="built_in">add_executable</span>(... $&lt;TARGET_OBJECTS:name&gt; ...)</span><br></pre></td></tr></table></figure>
<p>生成一个obj对象，该对象库只编译源文件，但不链接。由add_library()或add_executable()创建的目标可以使用$<TARGET_OBJECTS:name>这样的表达式作为源引用对象，其中，name是对象库的名称。</p>
<h4 id="4-6-add-subdirectory"><a href="#4-6-add-subdirectory" class="headerlink" title="4.6 add_subdirectory"></a>4.6 add_subdirectory</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"># 将 optical otn目录加入到构建系统中，另外参数一般不需要使用</span><br><span class="line"><span class="built_in">add_subdirectory</span>(optical)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(otn)</span><br></pre></td></tr></table></figure>
<p>将子目录添加到构建系统中。source_dir指定一个目录，其中存放CMakeLists.txt文件和代码文件。binary_dir指定的目录存放输出文件，如果没有指定则使用source_dir。</p>
<h4 id="4-7-add-executable"><a href="#4-7-add-executable" class="headerlink" title="4.7 add_executable"></a>4.7 add_executable</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 第一种：<span class="function">Normal Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span></span></span><br><span class="line"><span class="params"><span class="function">               [EXCLUDE_FROM_ALL]</span></span></span><br><span class="line"><span class="params"><span class="function">               [source1] [source2 ...])</span></span></span><br><span class="line"><span class="function"># 第二种：Imported Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; IMPORTED [GLOBAL])</span></span></span><br><span class="line"><span class="function"># 第三种：Alias Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; ALIAS &lt;target&gt;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#第一种是项目中经常用到的，这里就用第一种举例</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(main main.cpp $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>该关键字使用指定的源文件来生成目标可执行文件。具体分为三类：普通、导入、别名。此处我们就以普通可执行文件进行说明，其中是可执行文件的名称，在cmake工程中必须唯一。<strong>WIN32用于在windows下创建一个以WinMain为入口的可执行文件</strong>。MACOSX_BUNDLE用于mac系统或者IOS系统下创建一个GUI可执行应用程序。</p>
<h4 id="4-8-target-link-libraries"><a href="#4-8-target-link-libraries" class="headerlink" title="4.8 target_link_libraries"></a>4.8 target_link_libraries</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(&lt;target&gt; ... &lt;item&gt;... ...)</span><br></pre></td></tr></table></figure>
<p>指定链接给定目标和/或其依赖项时要使用的库。命名的必须是由add_executable()或add_library()之类的命令创建的。一般与 link_directories连用（添加外部库的搜索路径 ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 第一种方式 一般引入第三方库用这种</span><br><span class="line"><span class="built_in">add_library</span>(hello hello.cpp)        # 生成对象库文件</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp)       # 生成可执行文件</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Demo hello)   # 链接对象库</span><br><span class="line"></span><br><span class="line"># 第二种方式  本项目的研发代码链路</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp)  # 生成对象库文件，不链接</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp $&lt;TARGET_OBJECTS:hello&gt;)</span><br><span class="line"></span><br><span class="line"># 第三种 完全没必要多次一举罗</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Demo hello)</span><br></pre></td></tr></table></figure>
<h4 id="4-9-include"><a href="#4-9-include" class="headerlink" title="4.9 include"></a>4.9 include</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">include</span>(&lt;file|<span class="keyword">module</span>&gt; [OPTIONAL] [RESULT_VARIABLE &lt;VAR&gt;]</span><br><span class="line">                      [NO_POLICY_SCOPE])</span><br><span class="line"># 导入device_cfg.cmake文件 其他参数很少用</span><br><span class="line"><span class="built_in">include</span>(device_cfg.cmake)</span><br></pre></td></tr></table></figure>
<p>从指定的文件加载、运行CMake代码。如果指定文件，则直接处理。如果指定module，则寻找module.cmake文件，首先在${CMAKE_MODULE_PATH}中寻找，然后在CMake的module目录中查找。</p>
<h4 id="4-10-target-include-directories"><a href="#4-10-target-include-directories" class="headerlink" title="4.10 target_include_directories"></a>4.10 target_include_directories</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">target_include_directories</span>(&lt;target&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line">  </span><br><span class="line"># 生成对象库文件</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp) </span><br><span class="line"># 添加头文件目录</span><br><span class="line"><span class="built_in">target_include_directories</span>(hello PUBLIC $&#123;CMAKE_SOURCE_DIR&#125;/<span class="keyword">public</span>)</span><br></pre></td></tr></table></figure>
<p>在编译目标文件时指定头文件。必须是通过add_executable()或add_library()创建，且不能是ALIAS目标。<INTERFACE|PUBLIC|PRIVATE>修饰其紧跟参数items的作用范围。</p>
<h4 id="4-11-link-directories"><a href="#4-11-link-directories" class="headerlink" title="4.11 link_directories"></a>4.11 link_directories</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">link_directories</span>([AFTER|BEFORE] directory1 [directory2 ...])</span><br></pre></td></tr></table></figure>
<p>LINK_DIRECTORIES 命令来指定第三方库所在路径，比如，你的动态库在/home/myproject/libs这个路径下，则通过命令：LINK_DIRECTORIES(/home/myproject/libs)，把该路径添加到第三方库搜索路径中，这样就可以使用相对路径了，使用TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。<strong>官方不建议使用该命令，取而代之的为find_package() find_library()</strong>。</p>
<h4 id="4-12-find-package"><a href="#4-12-find-package" class="headerlink" title="4.12 find_package()"></a>4.12 find_package()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## 共支持两种模式</span><br><span class="line"># mode1: Module, 此模式需访问Find&lt;PackageName&gt;.cmake文件</span><br><span class="line"><span class="built_in">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE]</span><br><span class="line">             [REQUIRED] [[COMPONENTS] [components...]]</span><br><span class="line">             [OPTIONAL_COMPONENTS components...]</span><br><span class="line">             [NO_POLICY_SCOPE])</span><br><span class="line"><span class="built_in">find_package</span>(uts MODULE) #去找 Finduts.cmake  注意指定路径</span><br><span class="line"></span><br><span class="line"># mode2: Config, 此模式需访问&lt;lowercasePackageName&gt;-config.cmake <span class="keyword">or</span> &lt;PackageName&gt;Config.<span class="function">cmake</span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(&lt;PackageName&gt; [version] [EXACT] [QUIET]</span></span></span><br><span class="line"><span class="params"><span class="function">             [REQUIRED] [[COMPONENTS] [components...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [OPTIONAL_COMPONENTS components...]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CONFIG|NO_MODULE]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_POLICY_SCOPE]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NAMES name1 [name2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CONFIGS config1 [config2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [HINTS path1 [path2 ... ]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [PATHS path1 [path2 ... ]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [PATH_SUFFIXES suffix1 [suffix2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_DEFAULT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_PACKAGE_ROOT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_ENVIRONMENT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_SYSTEM_ENVIRONMENT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_PACKAGE_REGISTRY]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing.</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_SYSTEM_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CMAKE_FIND_ROOT_PATH_BOTH |</span></span></span><br><span class="line"><span class="params"><span class="function">              ONLY_CMAKE_FIND_ROOT_PATH |</span></span></span><br><span class="line"><span class="params"><span class="function">              NO_CMAKE_FIND_ROOT_PATH])</span></span></span><br></pre></td></tr></table></figure>
<p>find_package一般用于加载外部库到项目中，并且会加载库的细节信息。如上find_package有两种模式：Module与Config。</p>
<p>该命令描述特别复杂，参考博客： <a href="https://blog.csdn.net/fengbingchun/article/details/127473202">(41条消息) CMake中find_package的使用_fengbingchun的博客-CSDN博客</a></p>
<h4 id="4-13-find-libary"><a href="#4-13-find-libary" class="headerlink" title="4.13 find_libary()"></a>4.13 find_libary()</h4><p>该函数用于库查找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_library</span>(</span><br><span class="line">          &lt;VAR&gt;</span><br><span class="line">          name | NAMES name1 [name2 ...] [NAMES_PER_DIR]</span><br><span class="line">          [HINTS [path | ENV var]... ]</span><br><span class="line">          [PATHS [path | ENV var]... ]</span><br><span class="line">          [<span class="built_in">REGISTRY_VIEW</span> (<span class="number">64</span>|<span class="number">32</span>|<span class="number">64</span>_32|<span class="number">32</span>_64|HOST|TARGET|BOTH)]</span><br><span class="line">          [PATH_SUFFIXES suffix1 [suffix2 ...]]</span><br><span class="line">          [DOC <span class="string">&quot;cache documentation string&quot;</span>]</span><br><span class="line">          [NO_CACHE]</span><br><span class="line">          [REQUIRED]</span><br><span class="line">          [NO_DEFAULT_PATH]</span><br><span class="line">          [NO_PACKAGE_ROOT_PATH]</span><br><span class="line">          [NO_CMAKE_PATH]</span><br><span class="line">          [NO_CMAKE_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_SYSTEM_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_SYSTEM_PATH]</span><br><span class="line">          [NO_CMAKE_INSTALL_PREFIX]</span><br><span class="line">          [CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="line">           ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="line">           NO_CMAKE_FIND_ROOT_PATH]</span><br><span class="line">)</span><br><span class="line"># 在默认路径下查找/usr/lib/...  libJSON-C.<span class="function">so</span></span><br><span class="line"><span class="function"><span class="title">find_libary</span><span class="params">(json NAMES JSON-C)</span></span></span><br></pre></td></tr></table></figure>
<p>详细介绍见参考博客： <a href="https://blog.csdn.net/fengbingchun/article/details/127232175">(41条消息) CMake中find_library的使用_fengbingchun的博客-CSDN博客</a></p>
<h3 id="5-场景实战"><a href="#5-场景实战" class="headerlink" title="5 场景实战"></a>5 场景实战</h3><p>该章节的是为了更好的将cmake应用在构建工程中，分不同场景来练习和实战，将多条cmake命令组合起来完成各种场景的需求。这样才能更好的使用cmake.一些场景后续根据实际需求补上。</p>
<h4 id="5-1-一个目录一个object"><a href="#5-1-一个目录一个object" class="headerlink" title="5.1 一个目录一个object"></a>5.1 一个目录一个object</h4><p>将一个目录下的源文件通过一个makelist.txt文件编译成一个 object，这样有利于代码结构化管理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="built_in">add_library</span>(src-dltest-object OBJECT $(SRC_LIST))</span><br><span class="line"><span class="built_in">set</span>(src-dltest</span><br><span class="line">     $&lt;TARGET_OBJECTS:src-dltest-object&gt;</span><br><span class="line">     PARENT_SCOPE)</span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/lib/)</span><br><span class="line"><span class="built_in">set</span>(src</span><br><span class="line">    $&#123;src-dltest&#125;</span><br><span class="line">    PARENT_SCOPE)</span><br></pre></td></tr></table></figure>
<h4 id="5-2-编译链-toolchain"><a href="#5-2-编译链-toolchain" class="headerlink" title="5.2 编译链 toolchain"></a>5.2 编译链 toolchain</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># -Dxxx指定编译参数  cmake和makelist里面可以用变量 LLT  CPU_BIT_FLAG 等</span><br><span class="line">cmake .. -DCOMPILER=<span class="string">&quot;$&#123;platform&#125;&quot;</span> -DMODULE=<span class="string">&quot;$&#123;module&#125;&quot;</span> -DLLT=<span class="string">&quot;true&quot;</span> -DCPU_BIT_FLAG=<span class="string">&quot;FLAG_64&quot;</span> </span><br><span class="line">-DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;$&#123;root_path&#125;&quot;</span>/cmake/toolchain/<span class="string">&quot;$&#123;platform&#125;&quot;</span>_toolchain.cmake</span><br><span class="line">#  编译链cmake 主要设置编译选项等 x86_toolchain.cmake</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_FLAGS <span class="string">&quot; -Wall -Werror -Wfloat-equal -Wshadow XXX&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot; -g -m64 -std=c++17 -Wall -Werror -Wfloat-equal -Wshadow XXX&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="5-3-第三方库引入"><a href="#5-3-第三方库引入" class="headerlink" title="5.3 第三方库引入"></a>5.3 第三方库引入</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># 方式一 制定绝对路径</span><br><span class="line"><span class="built_in">set</span>(xxx_path xxxx)</span><br><span class="line"><span class="built_in">set</span>(xxx_lib_path $&#123;xxx_path&#125;/lib)</span><br><span class="line"><span class="built_in">set</span>(xxx_include_path $&#123;xxx_path&#125;/include)</span><br><span class="line"></span><br><span class="line"># 方式二 <span class="function">find_package  find_path  find_library</span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(thirdParty REQUIRED)</span></span></span><br><span class="line"><span class="function"># 自动寻找 FindthirdParty.cmake, 路径会根据find_package的规则寻找</span></span><br><span class="line"><span class="function">- thirdParty</span></span><br><span class="line"><span class="function">	- party</span></span><br><span class="line"><span class="function"><span class="title">get_filename_component</span><span class="params">(THIRDPARTY_ROOT  <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/xxx/thirdParty&quot;</span> ABSOLUTE)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(THIRDPARTY_INCLUDE_PATH  party</span></span></span><br><span class="line"><span class="params"><span class="function">    HINTS         $&#123;THIRDPARTY_ROOT&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PATH_SUFFIXES  include)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package_handle_standard_args</span><span class="params">(thirdParty REQUIRED_VARS THIRDPARTY_INCLUDE_PATH)</span></span></span><br><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(THIRDPARTY_LIB_PATH  libdrv_thirdParty.so</span></span></span><br><span class="line"><span class="params"><span class="function">    HINTS         $&#123;THIRDPARTY_ROOT&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PATH_SUFFIXES lib)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package_handle_standard_args</span><span class="params">(thirdParty REQUIRED_VARS THIRDPARTY_LIB_PATH)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>本文通过六个章节对cmake做了一定的介绍，其中第一章节属于cmake是用来干啥的和优缺点做了说明，第二三章节简要说明了cmake环境配置和一个简单的cmake工程github上可下载。第四章节是一些常用命令的介绍和学习。第五章节是一些场景实战，目前场景比较少，后续根据实际慢慢补上。第六章节是对整篇文章做个总结。</p>
<p>总体来说，cmake是一们比较容易的语言，系统/项目构建中用的比较多，对于程序员来说都应该对构建有一定的了解和实战经验。也许我们会觉得ide使用起来比较方便，但ide只适合实际学习语言的时候使用。真正开发的构建工程大部分使用cmake来搭建的。</p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>Cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2024/09/20/KMP/</url>
    <content><![CDATA[<h1 id="KMP-算法（Knuth-Morris-Pratt）笔记"><a href="#KMP-算法（Knuth-Morris-Pratt）笔记" class="headerlink" title="KMP 算法（Knuth-Morris-Pratt）笔记"></a>KMP 算法（Knuth-Morris-Pratt）笔记</h1><h2 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h2><p>KMP 算法用于 <strong>字符串匹配</strong>，通过预处理模式串，避免重复的字符比较，从而实现高效匹配。它的时间复杂度是 <strong>O(n + m)</strong>，其中 n 是主串长度，m 是模式串长度。</p>
<h2 id="2-主要思想"><a href="#2-主要思想" class="headerlink" title="2. 主要思想"></a>2. 主要思想</h2><p>当模式串中的某个字符匹配失败时，利用已知的部分匹配结果，跳过不必要的比较。这是通过 <strong>部分匹配表</strong>（也称为 <strong>前缀表</strong>）实现的。</p>
<h2 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3. 术语解释"></a>3. 术语解释</h2><ul>
<li><strong>前缀</strong>：从字符串的第一个字符开始，不包含最后一个字符的子串。</li>
<li><strong>后缀</strong>：从字符串的最后一个字符开始，不包含第一个字符的子串。</li>
<li><strong>部分匹配表</strong>：记录每个字符位置前的部分字符串的最长相同前缀和后缀的长度。</li>
</ul>
<h2 id="4-部分匹配表的构建"><a href="#4-部分匹配表的构建" class="headerlink" title="4. 部分匹配表的构建"></a>4. 部分匹配表的构建</h2><p>部分匹配表记录模式串在匹配失败时，可以跳过的字符数量。假设模式串为 <code>pattern</code>，前缀表 <code>prefix[i]</code> 的值表示在 <code>pattern[0...i]</code> 中，最长相同前缀和后缀的长度。</p>
<p><strong>构建步骤</strong>：</p>
<ol>
<li>初始时，<code>prefix[0] = 0</code>，表示第一个字符没有前缀和后缀。</li>
<li>使用双指针法遍历模式串，一个指针指向当前字符，一个指向最长前缀的下一个字符。</li>
<li>若当前字符匹配，前缀长度加 1；否则，回退到前一个匹配的前缀位置。</li>
</ol>
<h2 id="5-KMP-主算法步骤"><a href="#5-KMP-主算法步骤" class="headerlink" title="5. KMP 主算法步骤"></a>5. KMP 主算法步骤</h2><ol>
<li>预处理模式串，计算其部分匹配表。</li>
<li>在主串中按顺序比较字符，若匹配成功，则继续比较下一个字符；若匹配失败，根据部分匹配表跳过一部分字符，减少不必要的比较。</li>
<li>重复步骤 2 直到找到所有匹配位置或遍历完整个主串。</li>
</ol>
<h2 id="6-KMP-代码实现"><a href="#6-KMP-代码实现" class="headerlink" title="6. KMP 代码实现"></a>6. KMP 代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表（前缀表）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computePrefixFunction</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m, <span class="type">int</span>* prefix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; pattern[k] != pattern[i]) &#123;</span><br><span class="line">            k = prefix[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[k] == pattern[i]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 主算法，返回匹配的起始位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span>* matches, <span class="type">int</span>&amp; match_count)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="type">int</span> prefix[m];</span><br><span class="line">    <span class="built_in">computePrefixFunction</span>(pattern, m, prefix);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">    match_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; pattern[q] != text[i]) &#123;</span><br><span class="line">            q = prefix[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[q] == text[i]) &#123;</span><br><span class="line">            ++q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == m) &#123;</span><br><span class="line">            matches[match_count++] = i - m + <span class="number">1</span>;</span><br><span class="line">            q = prefix[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> matches[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> match_count;</span><br><span class="line">    <span class="built_in">kmpSearch</span>(text, pattern, matches, match_count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (match_count == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;匹配位置：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; match_count; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; matches[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-时间复杂度"><a href="#7-时间复杂度" class="headerlink" title="7. 时间复杂度"></a>7. 时间复杂度</h2><ul>
<li><strong>预处理模式串</strong>：O(m)</li>
<li><strong>主串匹配</strong>：O(n)<br>因此，整个算法的时间复杂度为 <strong>O(n + m)</strong>。</li>
</ul>
<h2 id="8-应用场景"><a href="#8-应用场景" class="headerlink" title="8. 应用场景"></a>8. 应用场景</h2><p>KMP 算法适用于以下场景：</p>
<ul>
<li>字符串匹配问题，例如在文本中查找某个单词或子字符串。</li>
<li>DNA 序列匹配等生物信息学领域。</li>
</ul>
<h2 id="9-优势"><a href="#9-优势" class="headerlink" title="9. 优势"></a>9. 优势</h2><ul>
<li>当模式串包含大量重复部分时，KMP 算法能显著减少比较次数，效率高于朴素的字符串匹配算法。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>718校内赛技术报告</title>
    <url>/2023/11/27/718%E6%A0%A1%E5%86%85%E8%B5%9B%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>此篇博客用于记录校内赛的技术细节和感悟（屎山预警！！！）</p>
<span id="more"></span>
<h1 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1. 硬件"></a>1. 硬件</h1><h2 id="1-1-红外对管"><a href="#1-1-红外对管" class="headerlink" title="1.1 红外对管"></a>1.1 红外对管</h2><p>排布见下图：</p>
<p><img src="2.png" alt="红外对管排布"></p>
<p>其中4 5作为循迹灯，其余全部用于路口判断。</p>
<h3 id="1-1-1-循迹"><a href="#1-1-1-循迹" class="headerlink" title="1.1.1 循迹"></a>1.1.1 循迹</h3><p>利用左右循迹灯实现循迹，使用了PID算法，只使用了P和D，详细说明见2.1。</p>
<h3 id="1-1-2-路口判断逻辑"><a href="#1-1-2-路口判断逻辑" class="headerlink" title="1.1.2 路口判断逻辑"></a>1.1.2 路口判断逻辑</h3><p>利用1 2 3 0四个红外对管实现对路口的识别。</p>
<p>另外规定ADC的值&gt;1900为完全踩上线，ADC的值小于lowx为完全没踩上线，ADC的值大于lowx+200（需要大些）为正在踩上线。</p>
<p>我们对路口的分类如下：</p>
<p><img src="1.png" alt="公式"></p>
<h2 id="1-2-机械臂"><a href="#1-2-机械臂" class="headerlink" title="1.2 机械臂"></a>1.2 机械臂</h2><p>构成：亚克力板，三个MG90S舵机，胶带，热熔胶，夹子，螺丝，螺母。</p>
<p>自由度：3</p>
<p>设计想法：为了便于能量块的夹取和定点投放</p>
<h1 id="2-软件"><a href="#2-软件" class="headerlink" title="2. 软件"></a>2. 软件</h1><p>注：此部分主要内容及解释都在代码注释中</p>
<h2 id="2-1-宏及全局变量"><a href="#2-1-宏及全局变量" class="headerlink" title="2.1 宏及全局变量"></a>2.1 宏及全局变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PWM.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AD.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x_it.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> kp 0.90     </span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> kd -80      </span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> high1 2100</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> low1 1800</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> high2 2400</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> low2  2000</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> delaytime 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换通道个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NOFCHANEL 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER_SIZE 5  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> filtered_AD0[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD1[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD2[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD3[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD4[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int16_t</span> filtered_AD5[FILTER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//用于储存ADC返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 ADC1 转换的电压值通过 DMA 方式传到 SRAM</span></span><br><span class="line"><span class="keyword">extern</span> __IO <span class="type">uint16_t</span> ADC_ConvertedValue[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量，用于保存转换计算后的电压值</span></span><br><span class="line"><span class="type">float</span> ADC_ConvertedValueLocal[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> et = <span class="number">0</span>;</span><br><span class="line"><span class="type">int16_t</span> det = <span class="number">0</span>;</span><br><span class="line"><span class="type">int16_t</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int16_t</span> wucha =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//PID中变量，用于更新误差等数据</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-主函数及初始化"><a href="#2-2-主函数及初始化" class="headerlink" title="2.2 主函数及初始化"></a>2.2 主函数及初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    USART_Config();</span><br><span class="line">    TIM1_CH4_PWM_Init();</span><br><span class="line">    PWM_Init();</span><br><span class="line">    AD_Init();</span><br><span class="line">    wucha =AD_Value[<span class="number">4</span>]-AD_Value[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;7&#x27;</span>==ucTemp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pid();</span><br><span class="line">                <span class="comment">// 在特殊路口执行特殊操作</span></span><br><span class="line">                <span class="keyword">if</span> (isTIntersection()) &#123;</span><br><span class="line">                    handleTIntersection();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftTurn()) &#123;</span><br><span class="line">                    handleLeftTurn();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRightTurn()) &#123;</span><br><span class="line">                    handleRightTurn();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRoundabout()) &#123;</span><br><span class="line">                    handleRoundabout();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isRound()) &#123;</span><br><span class="line">                    handleROUND();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;6&#x27;</span>==ucTemp	)</span><br><span class="line">                &#123;Motor_Run(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                 Motor_Run(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                 <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;5&#x27;</span>==ucTemp)</span><br><span class="line">        &#123;<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BlueTeeth();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;6&#x27;</span>==ucTemp	)</span><br><span class="line">            &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;8&#x27;</span>==ucTemp)</span><br><span class="line">        &#123;<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pid();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27;6&#x27;</span>==ucTemp)</span><br><span class="line">            &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-PID"><a href="#2-3-PID" class="headerlink" title="2.3 PID"></a>2.3 PID</h2><p>我们的小车只使用了P和D，因为我们实现闭环的不是加速度，所以不需要用积分项去逼近目标位置。P好理解，就是正比于误差的量；但P也不能太小，否则P太小的话转弯太慢，导致S弯绕不过去。D作为斜率可以通过抑制P的趋势来实现消抖的功能。</p>
<p>理论学习如下：</p>
<ul>
<li>整体思路：ADC采样—&gt;对ADC采样数据的数学处理—&gt;对得到的数据进行PID算法运算—&gt;赋值给ccr调整pwm波输出占空比驱动电机。循环此过程则可实现速度闭环实现直角弯道除外的赛道。</li>
<li>方案：两灯and三灯。但考虑到两灯操作更简单，对硬件兼容性更高。最终采用两灯方案。 </li>
<li>理论理解：</li>
</ul>
<p>尽可能的扩大两个参数的值域：ADC数学处理获得值、小车识别黑线范围。针对第一个参数，当此值变化范围很大时，可以获得更高的精度调控；针对第二个参数，当此值变化范围很大时，可以扩大小车的“视野”，即使已经偏线也可以回归正轨。</p>
<p>归根结底，重点在于数学处理。</p>
<ul>
<li>实操理解：</li>
</ul>
<p>@针对采样：</p>
<p><strong>重要参数：</strong>单个采样范围及变化趋势，单个采样值。</p>
<p><strong>单个采样范围及变化趋势：</strong>非常有限，几乎不触及黑线采样值变化很小，但一接近黑线立即成指数增长。</p>
<p><strong>单个采样值：</strong>几百个体差异到约2300的原始值。但转化为电压值之后仅为 0~3.3，大量数据被压缩，损失了很多精度，最终决定采用原始值进行操作。</p>
<p><strong>误差来源</strong>：环境红外线影响，红外对管个体差异，红外对管彼此距离，红外对管对地距离。</p>
<p><strong>环境红外线影响</strong>：很大。非常影响红外对管采集数据。最终解决办法有两种，一是在每个红外对管四周缠上黑胶布，用以反射环境红外线并聚合红外对管发出的红外线；二是在代码中初始化过程中消除环境误差并不需要测得，但随着小车运动导致的位置改变，环境误差在变化，而我们只消除了开始的误差，我们选择使用动态消除误差。</p>
<p><strong>红外对管个体差异：</strong>不同红外对管的峰值大致相同，但最低值各有千秋。有的一两百，有的却五六百。考虑到对ADC采样数据进行处理时，个体误差的存在会影响很多计算结果造成两个灯调节作用差别很大。故必须消除。最终我们采用个体采样值域大的红外对管，以输出更加灵敏的值，并在代码中在初始化过程中，连同环境误差一起消除。</p>
<p><strong>红外对管彼此距离：</strong>主要影响两点，一是识别范围，二是数学处理时产生漏洞。对于第一点，两灯距离太小时，识别范围就太小，小车遇到稍抖一点的弯路时极易偏线，但两灯距离过大时，就相当于允许小车有一定程度的偏线，造成循迹不流畅。对于第二点，若两灯距离过小，此时可以忽略个体误差，但同时ADC数学处理获得值值域很小，调节精度或说范围很小，若两灯距离过大，两灯之间会留出一个处理值为0的空白区允许小车一定程度偏线，这是我们不希望看到的。</p>
<p><strong>红外对管对地距离</strong>：主要影响红外对管的采样值域。对地距离过低时红外对管接收不到反射光，采样值很低，对地距离过高时很受环境光干扰，接收红外线很多，采样值很高，通过打印波形图来观察何对地距离红外对管的检测距离最大，以及采样值域最大。</p>
<p>@针对数学处理：</p>
<p><strong>处理参数：</strong>识别范围，输出值。</p>
<p><strong>识别范围：</strong>即小车的“视野”，能够允许偏线程度最大的情况下依然可以回归正轨。</p>
<p><strong>输出值：</strong>作为偏差，进行PID运算后，改变ccr来改变电机占空比。</p>
<p><strong>处理方法与消除误差：</strong></p>
<p> 缺少能够作为条件的判断，所以只有让两灯采样值相减，同时让两灯在同一环境下初始化，记录两灯差值，然后代入程序中来消除个体误差和环境误差，然后调用ADC数据处理函数。</p>
<p>@针对PID：</p>
<p>本次任务中采用位置式PID，且用到P与D参与运算。</p>
<p>采用PD系统调节原因：通过P进行主导线形控制，通过D来计算未来趋势抑制系统震荡，即通过PD系统获得更快的反应速度。符合循迹需求。</p>
<p>输入值：实时计算ADC数学处理获得值与目标值0的差值</p>
<p>输出值：除了初始占空比以外的用于控制电机的pwm</p>
<p>偏差：ADC数学处理获得值与目标值0的差值，用于P计算</p>
<p>二次偏差：前后两次偏差的差值，用于D计算</p>
<p>调参注意：P过小调节作用小，P过大造成过冲系统震荡。D过小调节作用小，D过大会放大系统趋势的影响，使系统震荡。</p>
<p>调参顺序：先设D=0，调P，从0逐渐增大，直到系统震荡。再调D使其逐渐增大，直到系统震荡。之后进行微调，直到系统稳定。</p>
<p>@针对电机控制：</p>
<p>调节方式：对两边电机附PID不同运算值，以达到使两侧不同性能电机具有相同效果的调节作用。</p>
<p>调节精度及限制：</p>
<p>考虑到可供调节的ccr范围为0~500( 有点小，占空比的相对调节精度小），但考虑到对循迹小车来讲500的调节范围够用，所以没改，但后来调车发现问题，发现有些曲率较大的弯转不过去，起初认为是P设的过小，但经过数学运算后发现问题是数值溢出，即能转过这个弯路的PID处理值没发挥出它的作用，因为溢出下限即占空比为0，溢出上限即占空比为100，所以最终采用【循迹电机反转函数】的使用，使溢出值得到充分利用。事实上增大ccr的可操作区间亦可。</p>
<p>初始值设置：一开始设置为50%占空比，因为考虑到想使PID调节具有对称性。事实效果很好，循迹很丝滑，但后来考虑到走直线速度较慢，故逐渐增大初始占空比，再具体进行调参。</p>
<p>详细解释见下方代码注释。</p>
<h3 id="2-3-1-PID代码"><a href="#2-3-1-PID代码" class="headerlink" title="2.3.1 PID代码"></a>2.3.1 PID代码</h3><h4 id="2-3-1-1-PID基本原理"><a href="#2-3-1-1-PID基本原理" class="headerlink" title="2.3.1.1 PID基本原理"></a>2.3.1.1 PID基本原理</h4><p><strong>PID详解</strong></p>
<ul>
<li><strong>比例增益（P）：</strong> 比例部分根据当前误差的大小调整输出。如果误差较大，比例增益会产生更大的输出变化，以更快地减小误差。然而，如果比例增益设置得太大，系统可能会变得不稳定。 </li>
<li><strong>积分时间（I）：</strong> 积分部分考虑了误差随时间的积累。它用于消除系统稳态误差，因为它会持续增加控制输出，直到误差为零。但如果积分时间设置得太大，可能导致系统的超调或振荡。 </li>
<li><strong>微分时间（D）：</strong> 微分部分考虑了误差变化的速度。它可以帮助系统抑制振荡，因为它对误差变化的速度进行响应，减小输出的变化速度。然而，如果微分时间设置得太大，可能会导致系统对噪声敏感。 </li>
</ul>
<p><strong>PID算法基本原理</strong></p>
<p><em>PID算法的执行流程是非常简单的，即利用反馈来检测偏差信号，并通过偏差信号来控制被控量。而控制器本身就是比例、积分、微分三个环节的加和。</em></p>
<p><img src="3.png" alt="公式"></p>
<p>根据上图我们考虑在某个特定的时刻t，此时输入量为rin(t)，输出量为rout(t)，于是偏差就可计算为err(t)=rin(t)-rout(t)。于是PID的基本控制规律就可以表示为如下公式：</p>
<p><img src="4.png" alt="公式"><br><em>其中Kp为比例带，TI为积分时间，TD为微分时间。</em></p>
<p>PID算法离散化</p>
<p>由于在计算机上应实现离散化问题，我们对比例，积分，微分特性做简单说明。</p>
<p>比例就是用来对系统的偏差进行反应，所以只要存在偏差，比例就会起作用。积分主要是用来消除静差，所谓静差就是指系统稳定后输入输出之间依然存在的差值，而积分就是通过偏差的累计来抵消系统的静差。而微分则是对偏差的变化趋势做出反应，根据偏差的变化趋势实现超前调节，提高反应速度。</p>
<p>在实现离散前，我们假设系统采样周期为T。假设我们检查第K个采样周期，很显然系统进行第K次采样。此时的偏差可以表示为err(K)=rin(K)-rout(K)，那么积分就可以表示为：err(K)+ err(K+1)+┈┈，而微分就可以表示为：(err(K)- err(K-1))/T。于是我们可以将第K次采样时，PID算法的离线形式表示为：</p>
<p><img src="5.png" alt="公式"><br>这就是所谓的PID算法离散描述公式。还有一个增量型PID算法，下面来推导一下。<br>上面的公式描述了第k哥采样周期的结果，那么前一时刻也就是k-1哥采样周期可表示为：</p>
<p><img src="6.png" alt="公式"><br>那么我们再来说第K个采样周期的增量，很显然就是U(k)-U(k-1)。于是我们用第k个采样周期公式减去第k-1个采样周期的公式，就得到了增量型PID算法的表示公式：</p>
<p><img src="7.png" alt="公式"></p>
<p>当然，增量型PID必须记得一点，就是在记住U(k)=U(k-1)+∆U(k)</p>
<p><strong>PID控制器基本实现</strong></p>
<p>完成了离散化后，我们就可以来实现它了。已经用离散化的数据公式表示出来后，再进型计算机编程已经不是问题了。接下来我们就使用C语言分别针对位置型公式和增量型公式来具体实现。</p>
<p>位置型PID简单实现</p>
<p>位置型PID的实现就是以前面的位置型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散位置型PID公式的计算机语言化。<br>首先定义PID对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integral;<span class="comment">//积分值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure>
<p>接下来<strong>实现PID控制器：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PIDRegulation</span><span class="params">(PID *vPID, <span class="type">float</span> processValue)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> thisError;</span><br><span class="line"></span><br><span class="line">  thisError=vPID-&gt;setpoint-processValue;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;integral+=thisError;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;result=vPID-&gt;proportiongain*thisError+vPID-&gt;integralgain*vPID-&gt;integral+vPID-&gt;derivativegain*(thisError-vPID-&gt;lasterror);</span><br><span class="line"></span><br><span class="line">  vPID-&gt;lasterror=thisError;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就实现了一个最简单的位置型PID控制器，当然没有考虑任何干扰条件，仅仅只是对数学公式的计算机语言化。</p>
<p><strong>增量型PID简单实现</strong></p>
<p>增量型PID的实现就是以前面的增量型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散增量型PID公式的计算机语言化。</p>
<p>首先定义PID对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> preerror;     <span class="comment">//前两拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> deadband;     <span class="comment">//死区</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure>
<p><strong>位置型PID控制器的基本特点：</strong></p>
<ul>
<li>位置型PID控制的输出与整个过去的状态有关，用到了偏差的累加值，容易产生累积偏差。</li>
<li>位置型PID适用于执行机构不带积分部件的对象。</li>
<li>位置型的输出直接对应对象的输出，对系统的影响比较大。</li>
</ul>
<p><strong>增量型PID控制器的基本特点：</strong></p>
<ul>
<li>增量型PID算法不需要做累加，控制量增量的确定仅与最近几次偏差值有关，计算偏差的影响较小。</li>
<li>增量型PID算法得出的是控制量的增量，对系统的影响相对较小。</li>
<li>采用增量型PID算法易于实现手动到自动的无扰动切换。</li>
</ul>
<h4 id="2-3-1-2-最终代码实现"><a href="#2-3-1-2-最终代码实现" class="headerlink" title="2.3.1.2 最终代码实现"></a>2.3.1.2 最终代码实现</h4><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取滤波后的值</span></span><br><span class="line">    <span class="type">int16_t</span> filtered_AD4_value = getFilteredValue(filtered_AD4);</span><br><span class="line">    <span class="type">int16_t</span> filtered_AD5_value = getFilteredValue(filtered_AD5);</span><br><span class="line"></span><br><span class="line">    et = filtered_AD4_value - filtered_AD5_value - wucha;</span><br><span class="line">    det = et - temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((kp) * et &lt; <span class="number">200</span>) &amp;&amp; ((kp) * et &gt; <span class="number">-200</span>)) &#123;</span><br><span class="line">        MotorControl(FRONT, <span class="number">1000</span> + (kp)/<span class="number">2</span> * et - kd * det);</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (kp * et &lt;= <span class="number">-50</span>) &#123;  </span><br><span class="line">        MotorControl(LEFT, <span class="number">-100</span> - kp * et + kd * det);  </span><br><span class="line">        MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (kp* et &gt;= <span class="number">50</span>) &#123;</span><br><span class="line">        MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">        MotorControl(RIGHT, kp * et - <span class="number">100</span> - kd * det);</span><br><span class="line">    &#125;</span><br><span class="line">    temp = et;<span class="comment">//pid输出值暂存</span></span><br><span class="line"></span><br><span class="line">    updateFilter(filtered_AD4, AD_Value[<span class="number">4</span>]);</span><br><span class="line">    updateFilter(filtered_AD5, AD_Value[<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">//更新滤波输入，减小误差</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-路口识别"><a href="#2-4-路口识别" class="headerlink" title="2.4 路口识别"></a>2.4 路口识别</h2><p>在本节中，详细讲讲判断环岛及真假环岛的逻辑（即连续两次左/右T型路口，左手定则为右T型，右手定则为左T型），其余路口都较为简单，不多赘述。</p>
<p>以左手定则走右环岛为例，首先不论环岛的真假，先判断连续两个右T型路口。我们设置了标志位flag（详见2.2主函数），在每次识别到非右T型路口时将其置零；在判断到右T型路口时将其取反，然后在下面写个若flag为0就进环岛函数的if，这样就实现了判断连续两个右T型路口。（详见2.4.1，2.4.3）</p>
<p>接着就是环岛的走法及判断环岛的真假。</p>
<p>(1) 环岛走法的大致逻辑就是，首先在第二个右T型路口右拐进环岛，然后识别环岛内第一个路口为右拐（第一个while，右拐后跳出），然后识别第二个路口为右拐（第二个while，右拐后跳出），然后识别第三个路口为T字型路口（第三个while，右拐后跳出），并return0，出函数再把flag置0，防止其一直走环岛。</p>
<p>(2) 判断环岛真假的大致逻辑是，在上述依次识别三个路口过程中，只要有一个识别到的路口与我们设定的路口不一致，就立马结束整个环岛函数并return相应的值（比如第一个路口不一致了就返回1，第二个不一致就返回2，第三个不一致就返回3），然后在循迹函数里做相应的处理。这里的处理也好理解，先让小车转180度，然后用switch case语句，从case3开始往case1写，内容便是按原路返回，然后在最初始的路口右拐。</p>
<p>比较有趣的是，我们发现在左手定则的大前提下，如果在同一个路口连续使用偶数次右手定则，则完全不会破坏左手定则的逻辑，换句话说，同一路口的偶数次右手定则等价于1次左手定则。</p>
<p>当然，从假环岛出来后还得把flag置1，这样又能解决走右T型+右环岛时进不了环岛的问题。</p>
<p>其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否为断头路</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isRound</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">7</span>] &lt; <span class="number">2000</span>	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理断头路的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleROUND</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	  performAction(BACK_ACTION, <span class="number">300</span>);</span><br><span class="line">    performAction(LEFT_ACTION, <span class="number">1300</span>);</span><br><span class="line">	 performAction(LEFT_ACTION, <span class="number">900</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为 T 字灯特殊路口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTIntersection</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">1</span>] &lt; low1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 T 字灯特殊路口的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleTIntersection</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">	  performAction(STOP_ACTION, <span class="number">500</span>);</span><br><span class="line">	  <span class="comment">//performAction(BACK_ACTION, 300);</span></span><br><span class="line">    performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为左拐路口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLeftTurn</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">	<span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &gt; high2 &amp;&amp; AD_Value[<span class="number">0</span>] &lt; low2 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为右拐路口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isRightTurn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &lt; low1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理左拐路口的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleLeftTurn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  performAction(STOP_ACTION, <span class="number">500</span>);  </span><br><span class="line">	<span class="comment">//performAction(BACK_ACTION, 300);</span></span><br><span class="line">    performAction(LEFT_ACTION, <span class="number">1400</span>);</span><br><span class="line">	 performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">    pid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理右拐路口的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRightTurn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    performAction(STOP_ACTION, <span class="number">500</span>);</span><br><span class="line">	  <span class="comment">//performAction(BACK_ACTION, 300);</span></span><br><span class="line">    performAction(RIGHT_ACTION, <span class="number">1500</span>);</span><br><span class="line">	  performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">     pid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为环岛</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isRoundabout</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (AD_Value[<span class="number">2</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">0</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">1</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">4</span>] &gt; high1 &amp;&amp; AD_Value[<span class="number">5</span>] &gt; high1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理进入环岛的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handleRoundabout</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    performAction(STOP_ACTION, <span class="number">500</span>);</span><br><span class="line">    performAction(FRONT_ACTION, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">CROSS_JUDG</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(AD_Value[<span class="number">1</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">2</span>]&gt;<span class="number">2000</span>)</span><br><span class="line">     &#123;a=<span class="number">1</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(AD_Value[<span class="number">1</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">0</span>]&gt;<span class="number">2000</span>)</span><br><span class="line">			&#123;a=<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(AD_Value[<span class="number">1</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">0</span>]&gt;<span class="number">2000</span>&amp;&amp;AD_Value[<span class="number">2</span>]&gt;<span class="number">2000</span>)</span><br><span class="line">			&#123;a=<span class="number">3</span>;&#125;</span><br><span class="line">		<span class="keyword">switch</span>(a)</span><br><span class="line">			&#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				      <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				     MoveDirection(LEFT);</span><br><span class="line">			       Delay_s(<span class="number">1</span>);</span><br><span class="line">			       <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				     MoveDirection(RIGHT);</span><br><span class="line">			       Delay_s(<span class="number">1</span>);</span><br><span class="line">			       <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				     MoveDirection(RIGHT);</span><br><span class="line">			       Delay_s(<span class="number">1</span>);</span><br><span class="line">			       <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-蓝牙"><a href="#2-5-蓝牙" class="headerlink" title="2.5 蓝牙"></a>2.5 蓝牙</h2><p>蓝牙这块比较简单，只是一个简单的通信协议，其中给i赋的值都是ASCII码，然后在手机的按键里设置相应的字符即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BlueTeeth</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span> == ucTemp)<span class="comment">//前进</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(FRONT);</span><br><span class="line">        <span class="comment">//	ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;2&#x27;</span> == ucTemp)<span class="comment">//后退</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(BACK);</span><br><span class="line">        <span class="comment">//ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;3&#x27;</span> == ucTemp)<span class="comment">//左转</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(LEFT);</span><br><span class="line">        <span class="comment">//ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;4&#x27;</span> == ucTemp)<span class="comment">//右转</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveDirection(RIGHT);</span><br><span class="line">        <span class="comment">//ucTemp = &#x27;0&#x27;;</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> == ucTemp)<span class="comment">//松开手机上的按键就让其停下</span></span><br><span class="line">            &#123;</span><br><span class="line">                MoveDirection(STOP);</span><br><span class="line">                ucTemp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-电机控制"><a href="#2-6-电机控制" class="headerlink" title="2.6 电机控制"></a>2.6 电机控制</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制电机运行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MotorControl</span><span class="params">(Direction direction, <span class="type">int</span> speed)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> FRONT:</span><br><span class="line">            left_up();</span><br><span class="line">            right_up();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACK:</span><br><span class="line">            left_down();</span><br><span class="line">            right_down();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT:</span><br><span class="line">            left_down();</span><br><span class="line">            right_up();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT:</span><br><span class="line">            left_up();</span><br><span class="line">            right_down();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,speed);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,speed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STOP:</span><br><span class="line">            left_up();</span><br><span class="line">            right_up();</span><br><span class="line">            Motor_Run(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            Motor_Run(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制轮子正反转</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">performAction</span><span class="params">(ActionType action, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> STOP_ACTION:</span><br><span class="line">            MotorControl(STOP, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FRONT_ACTION:</span><br><span class="line">            MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACK_ACTION:</span><br><span class="line">            MotorControl(BACK, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT_ACTION:</span><br><span class="line">            MotorControl(LEFT, <span class="number">1300</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT_ACTION:</span><br><span class="line">            MotorControl(RIGHT, <span class="number">1300</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Delay_ms(duration);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制轮子旋转90°</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MoveDirection</span><span class="params">(Direction direction)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> FRONT:</span><br><span class="line">            MotorControl(FRONT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACK:</span><br><span class="line">            MotorControl(BACK, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT:</span><br><span class="line">            MotorControl(LEFT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT:</span><br><span class="line">            MotorControl(RIGHT, <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STOP:</span><br><span class="line">            MotorControl(STOP, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">轮子的直接控制</span><br></pre></td></tr></table></figure>
<p>这一部分的代码主要是电机四个轮子的直接控制封装，由于左右两侧的轮子分别可以看作统一步调，故可以调整电机参数后统一输出PWM，达到同步效果。（底层封装略）</p>
<h2 id="2-7机械臂"><a href="#2-7机械臂" class="headerlink" title="2.7机械臂"></a>2.7机械臂</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NeoSWSerial.h&quot;</span></span></span><br><span class="line">NeoSWSerial <span class="title function_">mySerial</span><span class="params">(<span class="number">12</span>, <span class="number">13</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVOS      (4)     <span class="comment">// 机械臂需要的舵机个数</span></span></span><br><span class="line"></span><br><span class="line">Servo arm_servos[SERVOS];   <span class="comment">// 声明SERVOS个舵机</span></span><br><span class="line"><span class="type">int</span> servo_pins[SERVOS];         <span class="comment">// 舵机要接入的主板IO口</span></span><br><span class="line"><span class="type">int</span> servo_cur_angle[SERVOS];    <span class="comment">// 舵机当前的旋转角度</span></span><br><span class="line"><span class="type">int</span> servo_min_angle[SERVOS];    <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line"><span class="type">int</span> servo_max_angle[SERVOS];    <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line"><span class="type">int</span> servo_init_angle[SERVOS];   <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"><span class="type">int</span> joystick_value[SERVOS];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_MIN_THRESH     (300)   <span class="comment">// 摇杆ADC值的最小阈值，用于判断摇杆向哪边推动了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_MAX_THRESH     (700)   <span class="comment">// 摇杆ADC值的最大阈值，用于判断摇杆向哪边推动了</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLAW_OPEN_ANGLE     (45)    <span class="comment">// 爪子张开时的舵机角度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLAW_CLOSE_ANGLE    (5)    <span class="comment">// 爪子闭合时的舵机角度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLAW_SERVO_INDEX    (SERVOS-1)  <span class="comment">// 爪子舵机的序号，倒数第一个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARN_MAX_ACTIONS   (100)   <span class="comment">// 学习模式最多可记录的动作个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> learning_mode = <span class="literal">false</span>;  <span class="comment">// 是否进入学习模式？</span></span><br><span class="line"><span class="type">bool</span> repeat_mode = <span class="literal">false</span>;  <span class="comment">// 是否重复刚才学习到的动作？(配合学习模式使用)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> learn_actions[LEARN_MAX_ACTIONS][SERVOS];   <span class="comment">// 学习模式存储记录动作</span></span><br><span class="line"><span class="type">int</span> learn_action_count = <span class="number">0</span>;                     <span class="comment">// 学习模式记录了多少动作？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSPEED    (10)    <span class="comment">// 舵机最大旋转速度</span></span></span><br><span class="line"><span class="type">int</span> demo_speed = <span class="number">1</span>;         <span class="comment">// 1倍速、2倍速......</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_LEFT_BUTTON    (2)     <span class="comment">// 左键用于学习模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_RIGHT_BUTTON   (4)     <span class="comment">// 右键用于播放预设动作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOYSTICK_LED            (3)     <span class="comment">// 摇杆模块上面的LED灯，接入主板3号脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> has_btn_been_pressed = <span class="literal">false</span>;          <span class="comment">// 记录上次的按键状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  pinMode(JOYSTICK_LEFT_BUTTON, INPUT_PULLUP);      <span class="comment">// 左键用于学习模式</span></span><br><span class="line">  pinMode(JOYSTICK_RIGHT_BUTTON, INPUT_PULLUP);     <span class="comment">// 右键用于播放预设动作</span></span><br><span class="line"></span><br><span class="line">  pinMode(JOYSTICK_LED, OUTPUT);</span><br><span class="line">  digitalWrite(JOYSTICK_LED, HIGH); <span class="comment">// 亮灯</span></span><br><span class="line"></span><br><span class="line">  Serial.println(<span class="string">&quot;System Running...&quot;</span>);</span><br><span class="line">  Serial.print(digitalRead(JOYSTICK_LEFT_BUTTON));      <span class="comment">//读取并串口打印按键状态</span></span><br><span class="line">  Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">  Serial.println(digitalRead(JOYSTICK_RIGHT_BUTTON));   <span class="comment">//读取并串口打印按键状态</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bluetooth Module UART default baudrate is 9600</span></span><br><span class="line">  mySerial.begin(<span class="number">9600</span>);</span><br><span class="line">  delay(<span class="number">200</span>);</span><br><span class="line">  test_bluetooth_module();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化工作</span></span><br><span class="line">  initialization();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == digitalRead(JOYSTICK_LEFT_BUTTON))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 左键用于学习模式</span></span><br><span class="line">    learning_mode = <span class="literal">true</span>;</span><br><span class="line">    has_btn_been_pressed = <span class="literal">true</span>;  <span class="comment">// 记录有按键按下了！</span></span><br><span class="line">    learn_action_count = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    digitalWrite(JOYSTICK_LED, LOW);    <span class="comment">// 灭灯</span></span><br><span class="line"></span><br><span class="line">    Serial.println(<span class="string">&quot;Enter learning_mode!!&quot;</span>);    <span class="comment">// 进入学习模式</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == digitalRead(JOYSTICK_RIGHT_BUTTON))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 右键用于播放预设动作</span></span><br><span class="line">    play_demo_mode = <span class="literal">true</span>;</span><br><span class="line">    has_btn_been_pressed = <span class="literal">true</span>;  <span class="comment">// 记录有按键按下了！</span></span><br><span class="line">    Serial.println(<span class="string">&quot;Enter play_demo_mode!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始播放预设动作序列</span></span><br><span class="line">    play_demo();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 炫耀武力，爪子抓2次</span></span><br><span class="line">    cut_cut();</span><br><span class="line">    Serial.println(<span class="string">&quot;Enter Bluetooth/JoyStick Control Mode!!&quot;</span>);    <span class="comment">// 进入摇杆操控模式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 手机APP 操控机械臂工作</span></span><br><span class="line">  move_by_bluetooth();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 摇杆模块操控机械臂工作</span></span><br><span class="line">  move_by_joystick_contrl();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 学习模式，需要和摇杆操控互相配合</span></span><br><span class="line">  learning_actions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_bluetooth_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.print(<span class="string">&quot;\nTest Bluetooth Module: start\n&quot;</span>);</span><br><span class="line">  <span class="type">char</span> cmd[<span class="number">16</span>] = <span class="string">&quot;AT+NAME\r\n\r\n&quot;</span>;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  Serial.println(cmd);</span><br><span class="line">  Serial.println(len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    mySerial.write(cmd[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (mySerial.available())</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.print(mySerial.read(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.print(<span class="string">&quot;\nTest Bluetooth Module: end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialization</span><span class="params">()</span> &#123;</span><br><span class="line">  servo_pins[<span class="number">0</span>] = <span class="number">11</span>;           <span class="comment">// pin 11 -- Servo base   底座舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">0</span>] = <span class="number">0</span>;       <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">0</span>] = <span class="number">180</span>;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">0</span>] = <span class="number">90</span>;     <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  servo_pins[<span class="number">1</span>] = <span class="number">10</span>;           <span class="comment">// 10 : Servo left   左臂舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">1</span>] = <span class="number">10</span>;      <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">1</span>] = <span class="number">140</span>;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">1</span>] = <span class="number">90</span>;     <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  servo_pins[<span class="number">2</span>] = <span class="number">9</span>;            <span class="comment">//  9 : Servo right  右臂舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">2</span>] = <span class="number">40</span>;      <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">2</span>] = <span class="number">170</span>;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">2</span>] = <span class="number">90</span>;     <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  servo_pins[<span class="number">3</span>] = <span class="number">5</span>;                        <span class="comment">//  5 : Servo claw   爪子舵机</span></span><br><span class="line">  servo_min_angle[<span class="number">3</span>] = CLAW_CLOSE_ANGLE;    <span class="comment">// 允许舵机旋转到达的最小值</span></span><br><span class="line">  servo_max_angle[<span class="number">3</span>] = CLAW_OPEN_ANGLE;     <span class="comment">// 允许舵机旋转到达的最大值</span></span><br><span class="line">  servo_init_angle[<span class="number">3</span>] = CLAW_OPEN_ANGLE;   <span class="comment">// 刚上电时，舵机的初始角度</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 学习模式清空所有动作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; LEARN_MAX_ACTIONS; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; SERVOS; j++) &#123;</span><br><span class="line">      learn_actions[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给所有舵机设置初始角度</span></span><br><span class="line">  init_servos();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_servos</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SERVOS; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    arm_servos[i].attach(servo_pins[i], <span class="number">500</span>, <span class="number">2500</span>);      <span class="comment">// 把舵机关联到对应的PWM引脚上</span></span><br><span class="line">    arm_servos[i].write(servo_init_angle[i]); <span class="comment">// 写入舵机的初始角度</span></span><br><span class="line">    joystick_value[i] = <span class="number">0</span>;                    <span class="comment">// 摇杆ADC值初始化为0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 炫耀武力，爪子抓2次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cut_cut</span><span class="params">()</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    close_claw(<span class="literal">true</span>);</span><br><span class="line">    delay(<span class="number">150</span>);</span><br><span class="line">    close_claw(<span class="literal">false</span>);</span><br><span class="line">    delay(<span class="number">150</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制爪子开闭</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">close_claw</span><span class="params">(<span class="type">bool</span> close)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (close) &#123;</span><br><span class="line">    arm_servos[CLAW_SERVO_INDEX].write(CLAW_CLOSE_ANGLE);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    arm_servos[CLAW_SERVO_INDEX].write(CLAW_OPEN_ANGLE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_by_joystick_contrl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> joy_changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SERVOS; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 读取摇杆ADC值</span></span><br><span class="line">    <span class="comment">// A0 --&gt; joystick_value[0] --&gt; 左摇杆左右推，控制底座舵机旋转；</span></span><br><span class="line">    <span class="comment">// A1 --&gt; joystick_value[1] --&gt; 左摇杆前后推，控制左臂舵机旋转；</span></span><br><span class="line">    <span class="comment">// A2 --&gt; joystick_value[2] --&gt; 右摇杆前后推，控制右臂舵机旋转；</span></span><br><span class="line">    <span class="comment">// A3 --&gt; joystick_value[3] --&gt; 右摇杆左右推，控制爪子舵机旋转；</span></span><br><span class="line">    joystick_value[i] = analogRead(i);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// 串口打印摇杆ADC值</span></span><br><span class="line">    Serial.print(<span class="string">&quot;A[&quot;</span>);</span><br><span class="line">    Serial.print(i);</span><br><span class="line">    Serial.print(<span class="string">&quot;]=&quot;</span>);</span><br><span class="line">    Serial.print(joystick_value[i]);</span><br><span class="line">    Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取舵机当前的旋转角度</span></span><br><span class="line">    servo_cur_angle[i] = arm_servos[i].read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (joystick_value[i] &gt; JOYSTICK_MAX_THRESH)    <span class="comment">// 摇杆ADC值超过最大阈值</span></span><br><span class="line">    &#123;</span><br><span class="line">      joy_changed = <span class="literal">true</span>;    <span class="comment">// 摇杆被推动过了！</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (servo_cur_angle[i] &gt; servo_min_angle[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">        --servo_cur_angle[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i == CLAW_SERVO_INDEX)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果是爪子舵机，则直接闭合爪子</span></span><br><span class="line">        servo_cur_angle[i] = CLAW_OPEN_ANGLE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (joystick_value[i] &lt; JOYSTICK_MIN_THRESH)   <span class="comment">// 摇杆ADC值小于最小阈值</span></span><br><span class="line">    &#123;</span><br><span class="line">      joy_changed = <span class="literal">true</span>;   <span class="comment">// 摇杆被推动过了！</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (servo_cur_angle[i] &lt; servo_max_angle[i])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">        ++servo_cur_angle[i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i == CLAW_SERVO_INDEX)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果是爪子舵机，则直接打开爪子</span></span><br><span class="line">        servo_cur_angle[i] = CLAW_CLOSE_ANGLE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> == joy_changed)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 只要摇杆被推动过了，就刷新一遍舵机角度: 将当前最新的舵机角度值，写入舵机</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; SERVOS; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">      <span class="comment">// 串口打印舵机角度</span></span><br><span class="line">      Serial.print(<span class="string">&quot;servo[&quot;</span>);</span><br><span class="line">      Serial.print(i);</span><br><span class="line">      Serial.print(<span class="string">&quot;]=&quot;</span>);</span><br><span class="line">      Serial.print(servo_cur_angle[i]);</span><br><span class="line">      Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      arm_servos[i].write(servo_cur_angle[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_by_bluetooth</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">bool</span> joy_changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mySerial.available())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> inByte = mySerial.read();</span><br><span class="line">    Serial.print(inByte);</span><br><span class="line">    <span class="keyword">if</span> ((inByte != (<span class="type">char</span>)<span class="number">0xFF</span>) &amp;&amp; (inByte != (<span class="type">char</span>)<span class="number">0x0A</span>) &amp;&amp; (inByte != (<span class="type">char</span>)<span class="number">0x0D</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      joy_changed = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (inByte)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">0</span>] &lt; servo_max_angle[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">              ++servo_cur_angle[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">0</span>] &gt; servo_min_angle[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">              --servo_cur_angle[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">1</span>] &lt; servo_max_angle[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">              ++servo_cur_angle[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">1</span>] &gt; servo_min_angle[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">              --servo_cur_angle[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 爪子舵机，直接闭合爪子</span></span><br><span class="line">            servo_cur_angle[<span class="number">3</span>] = CLAW_CLOSE_ANGLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">          &#123;            </span><br><span class="line">            <span class="comment">// 爪子舵机，直接打开爪子</span></span><br><span class="line">            servo_cur_angle[<span class="number">3</span>] = CLAW_OPEN_ANGLE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">2</span>] &gt; servo_min_angle[<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，大于，允许舵机旋转到达的最小值，则舵机角度降低1度</span></span><br><span class="line">              --servo_cur_angle[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (servo_cur_angle[<span class="number">2</span>] &lt; servo_max_angle[<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 如果舵机当前角度，小于，允许舵机旋转到达的最大值，则舵机角度增加1度</span></span><br><span class="line">              ++servo_cur_angle[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          &#123;</span><br><span class="line">            joy_changed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> == joy_changed)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 只要手机APP摇杆被推动过了，就刷新一遍舵机角度: 将当前最新的舵机角度值，写入舵机</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; SERVOS; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">      <span class="comment">// 串口打印舵机角度</span></span><br><span class="line">      Serial.print(<span class="string">&quot;servo[&quot;</span>);</span><br><span class="line">      Serial.print(i);</span><br><span class="line">      Serial.print(<span class="string">&quot;]=&quot;</span>);</span><br><span class="line">      Serial.print(servo_cur_angle[i]);</span><br><span class="line">      Serial.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      arm_servos[i].write(servo_cur_angle[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Serial.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    move_from_to:</span></span><br><span class="line"><span class="comment">    目的是，让机械臂的2个动作之间的变化、运动、转移，更加平滑，</span></span><br><span class="line"><span class="comment">    不要让舵机瞬间完成角度切换，一方面增加舵机使用寿命，一方面机械臂工作更加自然。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move_from_to</span><span class="params">(<span class="type">int</span> *action_from, <span class="type">int</span> *action_to)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> max_angle = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> max_steps = <span class="number">0</span>;</span><br><span class="line">  <span class="type">float</span> step_angle[SERVOS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调整机械臂的运动、转移速度</span></span><br><span class="line">  adjust_speed();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 找到角度变化最大的那个舵机，算出角度变化绝对值max_angle；</span></span><br><span class="line"><span class="comment">    2. 角度变化值max_angle ÷ 舵机旋转速度demo_speed，就是舵机要运行的步数max_steps；</span></span><br><span class="line"><span class="comment">    3. 根据总步数max_steps，计算出每个舵机单步转动的角度step_angle；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  max_angle = max(max(<span class="built_in">abs</span>(action_to[<span class="number">0</span>] - action_from[<span class="number">0</span>]), <span class="built_in">abs</span>(action_to[<span class="number">1</span>] - action_from[<span class="number">1</span>])), <span class="built_in">abs</span>(action_to[<span class="number">2</span>] - action_from[<span class="number">2</span>]));</span><br><span class="line">  max_steps = max_angle / demo_speed;</span><br><span class="line">  max_steps = max_steps &lt; <span class="number">1</span> ? <span class="number">1</span> : max_steps;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLAW_SERVO_INDEX; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    step_angle[i] = <span class="type">float</span>(action_to[i] - action_from[i]) / <span class="type">float</span>(max_steps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= max_steps; j++) <span class="comment">// 步数j累加</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CLAW_SERVO_INDEX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 随着j慢慢增大，new_angle 会慢慢趋近于 action_to[i]，也就实现了运动平滑的效果</span></span><br><span class="line">      <span class="type">int</span> new_angle = action_from[i] + j * step_angle[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((new_angle &lt; servo_min_angle[i]) || (new_angle &gt; servo_max_angle[i]))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 舵机角度值超出范围，忽略</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      arm_servos[i].write(new_angle);  <span class="comment">// 将最新的角度值，写入舵机</span></span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 爪子舵机的开闭动作，不需要平滑过渡，直接设置角度给舵机</span></span><br><span class="line">  arm_servos[CLAW_SERVO_INDEX].write(action_to[CLAW_SERVO_INDEX]);</span><br><span class="line">  delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 播放预设动作序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">play_demo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算总共有多少个动作？</span></span><br><span class="line">  <span class="type">int</span> counts = <span class="keyword">sizeof</span>(demo_actions) / (SERVOS * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  Serial.print(<span class="string">&quot;demo_actions counts = &quot;</span>);</span><br><span class="line">  Serial.println(counts);</span><br><span class="line"></span><br><span class="line">  move_from_to(servo_init_angle, demo_actions[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; counts - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 摇杆左右键，任何按键按下，结束播放预设动作序列</span></span><br><span class="line">      <span class="keyword">if</span> (is_btn_pressed())</span><br><span class="line">      &#123;</span><br><span class="line">        learning_mode = <span class="literal">false</span>;</span><br><span class="line">        repeat_mode = <span class="literal">false</span>;</span><br><span class="line">        play_demo_mode = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 机械臂从当前动作，运动、转移至下一个动作</span></span><br><span class="line">      move_from_to(demo_actions[i], demo_actions[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整机械臂的运动、转移速度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust_speed</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 任何一个摇杆推动任何一个方向，都可以调整速度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SERVOS; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (analogRead(i) &gt; JOYSTICK_MAX_THRESH) demo_speed++; <span class="comment">// 速度加</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (analogRead(i) &lt; JOYSTICK_MIN_THRESH) demo_speed--; <span class="comment">// 速度减</span></span><br><span class="line">  &#125;</span><br><span class="line">  demo_speed = demo_speed &lt; <span class="number">1</span> ? <span class="number">1</span> : demo_speed;</span><br><span class="line">  demo_speed = demo_speed &gt; MAXSPEED ? MAXSPEED : demo_speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_btn_pressed</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="literal">false</span> == has_btn_been_pressed) &amp;&amp; ((<span class="number">0</span> == digitalRead(JOYSTICK_RIGHT_BUTTON)) || (<span class="number">0</span> == digitalRead(JOYSTICK_LEFT_BUTTON))))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果上次没有按键按下，而现在左键或者右键按下了，则认为现在确实有按键按下了</span></span><br><span class="line">    has_btn_been_pressed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="number">1</span> == digitalRead(JOYSTICK_RIGHT_BUTTON)) &amp;&amp; (<span class="number">1</span> == digitalRead(JOYSTICK_LEFT_BUTTON)))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果左右键都没有按下，则认为确实没有按键按下</span></span><br><span class="line">    has_btn_been_pressed = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>机械臂使用的是arduino生态，主要使用了arduinoUNO这个板子，同时也加装了蓝牙模块，代码封装函数和stm32略有不同。</p>
<h2 id="2-8滤波器"><a href="#2-8滤波器" class="headerlink" title="2.8滤波器"></a>2.8滤波器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">updateFilter</span><span class="params">(<span class="type">int16_t</span>* buffer, <span class="type">int16_t</span> newValue)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = FILTER_SIZE - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        buffer[i] = buffer[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[<span class="number">0</span>] = newValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">getFilteredValue</span><span class="params">(<span class="type">int16_t</span>* buffer)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算缓冲区内所有值的平均值</span></span><br><span class="line">    <span class="type">int32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FILTER_SIZE; i++) &#123;</span><br><span class="line">        sum += buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / FILTER_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>加入滤波器相关程序的考虑如下：</strong></p>
<p><strong>1.减少控制器的灵敏度：</strong> 滤波器可以减少PID控制器对高频噪声和干扰的敏感度。这有助于防止PID控制器对系统中不必要的快速变化作出响应，从而提高系统的稳定性。</p>
<p><strong>2.滤波测量信号：</strong> 在PID控制中，测量信号可能受到噪声的影响。通过对测量信号应用滤波器，可以改善系统对实际状态的感知，提高控制性能。</p>
<p><strong>3.避免控制器振荡：</strong> 滤波器有助于减小系统中可能引起控制器振荡的高频成分。这有助于防止控制器在某些条件下产生不稳定的振荡。</p>
<p>后来经过测试证明，我们的设计是有很大效果的，极大程度上降低了红外对管物种多样性的阴间影响</p>
<h1 id="3-总结及反思"><a href="#3-总结及反思" class="headerlink" title="3. 总结及反思"></a>3. 总结及反思</h1><h2 id="3-1-软件方面"><a href="#3-1-软件方面" class="headerlink" title="3.1 软件方面"></a>3.1 软件方面</h2><ul>
<li>由于缺乏经验和想法，在最开始的直接控制上浪费了很多时间（and金钱），当代码完成后，可以发现很多封装其实是没有必要的，而且会降低循迹的反应速度和稳定性。</li>
<li>在封装控制函数的过程中出现了“各自为政的现象”，造成了大量的冗余。直到后来才发现有些参数几乎是可以复用的，完全可以通过定义少数的宏来节省大量空间，并增强代码的可读性，提高运行效率。</li>
<li>我们在最终的代码里尝试定义了一个类似于摩擦系数的宏，所有的参数可以根据这个宏计算来调节，理论上只要知道比赛场地的路况等信息就可以一键调节所有的速度、角度等参数，从而节省了大量的调参时间。但是在最终的结果中我们发现这种定义方式并不足以满足各种复杂情况，主要因素如下：</li>
</ul>
<p>1.各个电机和红外对管的性能不同，统一调控会导致系统整体的兼容性和稳定性下降。</p>
<p>2.路况复杂的情况下，盲目地追求减少调参时间是不可取的。</p>
<p>因此，虽然宏的使用是一个很好的尝试，但在实践中，我们也意识到需要更为灵活和细致的参数调整，以适应不同的实际情况。这一过程是一个不断优化和润色代码的过程，通过反复实验和调整，逐步找到最优的参数配置。这也是在机器人控制领域中常见的挑战之一，需要不断学习和改进。</p>
<h2 id="3-2-硬件方面"><a href="#3-2-硬件方面" class="headerlink" title="3.2 硬件方面"></a>3.2 硬件方面</h2><ul>
<li>由于对新生板的使用不够熟悉，我们在参赛前最后一天先后损坏了数块板子的电源等模块，为正式比赛优化代码造成了很恶劣的影响。</li>
<li>由于对比赛规则的不熟悉，在选购机械臂时出现了严重失误，机械臂的抬升高度不足以支持能量块的投放，故在正式比赛时我们放弃了给机械臂通电，避免电能的无效浪费。</li>
<li>面对IO口稀少的情况，我们使用的焊接杜邦线的骚操作，我们承认这一行为给我们减少了很多麻烦，但是电流的减弱也曾一度让我们的电机面临驱动力不足等问题，好在可以通过更改PWM占空比缓解这一问题。</li>
</ul>
<h2 id="3-3-工程经验方面"><a href="#3-3-工程经验方面" class="headerlink" title="3.3 工程经验方面"></a>3.3 工程经验方面</h2><ul>
<li>工程经验的缺少使我们分工不够明确，效率不够高效。好在大家目标一致，最终较为圆满地完成了部分任务，离不开所有队员的倾力合作和集思广益。</li>
</ul>
<h1 id="4-感悟"><a href="#4-感悟" class="headerlink" title="4.感悟"></a>4.感悟</h1><ul>
<li><p>肝了一个月，这是大上学以来第一次独立做出可使用的工程（<em>虽然垃圾得一批</em>），学到了很多以前自认为要大三甚至大四才能碰到的知识，像L298电驱，PWM波占空比的调节，PID控制算法，各种路口判断的设计，在现场实地修（乱）改参数等，碰到了各种各样逆天且玄学的问题，such as芯片的神奇短路，电源模块莫名暴毙，ADC接口的梦幻联动，（至今工位上还摆放着四块待救治的板子）。——<strong>特此衷心感谢硬件陈学长的力挽狂澜</strong></p>
</li>
<li><p>与此同时明显感觉到C语言的能力得到了大幅度提升（尤其时造轮子的能力仿佛登峰造极），还练就了一身从屎里找吃的硬能力。</p>
<p>本篇博客就当成一个里程碑吧，纪念这疯狂熬夜的一个月（以及未来将要熬的无数个月），同时感谢718的各位学长（不）厌其烦的讲解和帮助。</p>
</li>
</ul>
<p><strong>外链：<a href="https://www.yuque.com/quanzhi-ndfvt/azx1dc/udzvfrcvol51mwr4?singleDoc#">https://www.yuque.com/quanzhi-ndfvt/azx1dc/udzvfrcvol51mwr4?singleDoc#</a> 《2023校内赛技术报告》</strong></p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>寻迹车 蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode0238</title>
    <url>/2023/11/22/LeetCode0238/</url>
    <content><![CDATA[<h1 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请 <strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p>
<span id="more"></span>
<p><strong>示例 1:</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出: [<span class="number">24,12,8,6</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: nums = <span class="comment">[-1,1,0,-3,3]</span></span><br><span class="line">输出: <span class="comment">[0,0,9,0,0]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
<li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li>
</ul>
<hr>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>刚开始我想得比较简单，认为只需要把所有元素的乘积求出，再在循环里一个个除就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* answer = (<span class="type">int</span>*)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (answer == <span class="literal">NULL</span>) &#123; <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        product *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        answer[i] = product / nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Line 16: Char 29: runtime error: division by zero [solution.c]</code>把我拉回了现实：只要有个0，这段代码全线崩盘，而且根本没有修改的余地，故舍弃此方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//除自身的乘积的的值 等于 左乘积 *  右乘积</span></span><br><span class="line">    <span class="type">int</span> leftPro[numsSize];</span><br><span class="line">    <span class="type">int</span> rightPro[numsSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左乘积</span></span><br><span class="line">    leftPro[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        leftPro[i] =  leftPro[i<span class="number">-1</span>] *  nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//右乘积</span></span><br><span class="line">    rightPro[numsSize<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = numsSize - <span class="number">1</span> - <span class="number">1</span>; i  &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        rightPro[i] =  rightPro[i+<span class="number">1</span>] *  nums[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="type">int</span> * returnNums = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * numsSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        returnNums[i] = leftPro[i] * rightPro[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnNums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正确的思路应该像是这样，分别求出左边和右边序列的乘积加以乘法。</p>
<p>后来我在评论区看到这样一种思路：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ra[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">productExceptSelf</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        ra[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pre = <span class="number">1</span>, suf = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        pre *= nums[i - <span class="number">1</span>];</span><br><span class="line">        suf *= nums[numsSize - i];</span><br><span class="line">        ra[i] *= pre;</span><br><span class="line">        ra[numsSize - i - <span class="number">1</span>] *= suf;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：随心</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/product-of-array-except-self/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>（话说大佬都是不写注释的嘛）</p>
<p>这种算法的思路大致如下：</p>
<ul>
<li>初始化数组<code>ra</code>的前缀和和后缀和都为1。</li>
<li>遍历数组<code>nums</code>，从第二个元素开始（下标为1）。</li>
<li>对于第<code>i</code>个元素，计算前缀和（即前面所有元素的乘积）并赋值给<code>pre</code>，计算后缀和（即后面所有元素的乘积）并赋值给<code>suf</code>。</li>
<li>将前缀和和后缀和的乘积赋值给<code>ra[i]</code>，即<code>ra[i] = pre * suf</code>。</li>
<li>将数组的长度赋值给返回值<code>*returnSize</code>，并返回动态分配的数组<code>ra</code>。</li>
</ul>
<p>这种算法好处在于：</p>
<ol>
<li><p>空间利用率高：使用了一个数组<code>ra</code>来存储每个元素与其他元素乘积的结果，避免了重复计算，提高了空间利用率。</p>
</li>
<li><p>计算效率高：通过计算前缀和和后缀和，减少了乘法操作的次数，提高了计算效率。</p>
<p>(草怎么写得这么牛逼)</p>
<p><strong>学到了有木有 </strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode66</title>
    <url>/2023/11/19/LeetCode66/</url>
    <content><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a><a href="https://leetcode.cn/problems/plus-one/">加一</a></h1><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<span id="more"></span>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：digits = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[1,2,4]</span></span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：digits = [<span class="number">4,3,2,1</span>]</span><br><span class="line">输出：[<span class="number">4,3,2,2</span>]</span><br><span class="line">解释：输入数组表示数字 <span class="number">4321</span>。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：digits = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 100</code></li>
<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">plusOne</span><span class="params">(<span class="type">int</span>* digits, <span class="type">int</span> digitsSize, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 从数组的最后一位开始向前加一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = digitsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前位加一不产生进位，直接返回数组</span></span><br><span class="line">            digits[i]++;</span><br><span class="line">            *returnSize = digitsSize;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前位加一产生进位，将当前位设为0，继续向前一位加一</span></span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 如果遍历完成后，最高位仍然产生进位，需要在数组最前面添加一个新的元素1</span></span><br><span class="line">	<span class="type">int</span>* result = (<span class="type">int</span>*)<span class="built_in">malloc</span>((digitsSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= digitsSize; i++) &#123;</span><br><span class="line">    	result[i] = digits[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	*returnSize = digitsSize + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode0206</title>
    <url>/2023/11/30/Leetcode0206/</url>
    <content><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<span id="more"></span>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基本想法是把列表的首尾节点调换，即每一个指针都指向前一个节点。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span><span class="literal">NULL</span>;<span class="comment">//创建一个空头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span>=</span>head;<span class="comment">//创建curr用于遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span>curr-&gt;next;</span><br><span class="line">        curr-&gt;next =prev;</span><br><span class="line">        prev =curr;<span class="comment">//把pre遍历到当前节点</span></span><br><span class="line">        curr=next;<span class="comment">//把当前指针遍历到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode83</title>
    <url>/2023/11/30/Leetcode83/</url>
    <content><![CDATA[<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<span id="more"></span>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2,3,3]</span></span><br><span class="line">输出：<span class="comment">[1,2,3]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序 <strong>排列</strong></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>根据题干描述，链表已经按照升序排列，即只需要判断前后两个节点是否相等从而确定删除与否即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//即链表为空，没有重复元素可以删除。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next) &#123;<span class="comment">//条件是当前节点的下一个节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode0203</title>
    <url>/2023/11/30/Leetcode0203/</url>
    <content><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">移除链表元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<span id="more"></span>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[7,7,7,7]</span>, val = 7</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>刚开始思路非常简单：检测到下一个节点是val，删除该节点。写出了下面这段蠢到家的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span>=</span>head;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next==val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>仔细一看题：发现“<strong>新的头节点</strong>”还特意加粗了，看起来如果第一个节点就是空节点程序会直接寄掉。</p>
<ol>
<li><code>cur-&gt;next = cur-&gt;next-&gt;next;</code> 表示删除当前节点的下一个节点。这会导致无法处理连续相同值的节点。正确的做法是将当前节点的 <code>next</code> 指针直接指向下下个节点，而不是跳过一个节点。</li>
<li>函数的返回值是链表的头指针 <code>head</code>，但是在删除节点的过程中，链表头部可能发生变化。因此，应该在删除节点后返回新的头指针。</li>
</ol>
<p>修改为以下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;next = head;<span class="comment">//在头节点前创建一个空节点，用于解决其为val的情况</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> dummy;<span class="comment">//基操用cur遍历</span></span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val==val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> dummy-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newHead;<span class="comment">//返回新的头节点，并释放dummy的空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode0724</title>
    <url>/2023/11/20/LeetCode0724/</url>
    <content><![CDATA[<h1 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a><a href="https://leetcode.cn/problems/find-pivot-index/">寻找数组的中心下标</a></h1><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p>
<p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>
<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>
<span id="more"></span>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是<span class="number"> 3 </span>。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] =<span class="number"> 1 </span>+<span class="number"> 7 </span>+<span class="number"> 3 </span>=<span class="number"> 11 </span>，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] =<span class="number"> 5 </span>+<span class="number"> 6 </span>=<span class="number"> 11 </span>，二者相等。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1, 2, 3]</span></span><br><span class="line"><span class="string">输出：-1</span></span><br><span class="line"><span class="string">解释：</span></span><br><span class="line"><span class="string">数组中不存在满足此条件的中心下标。</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是<span class="number"> 0 </span>。</span><br><span class="line">左侧数之和 sum =<span class="number"> 0 </span>，（下标<span class="number"> 0 </span>左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] =<span class="number"> 1 </span>+ -1 =<span class="number"> 0 </span>。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>刚开始没什么具体思路，非常脑残地一点点计算出SUM(左右)，代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum_left = <span class="number">0</span>, sum_right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                sum_left += nums[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = i + <span class="number">1</span>; p &lt; numsSize; p++)</span><br><span class="line">                sum_right += nums[p];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sum_left == sum_right)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置 sum_left 和 sum_right</span></span><br><span class="line">            sum_left = <span class="number">0</span>;</span><br><span class="line">            sum_right = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>中间那个重置千万别忘掉</strong></p>
<ul>
<li><p>在GPT的帮助下，我把代码重构了一下，主要是针对右侧sum的计算逻辑修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pivotIndex</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum_left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum_right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        sum_right = sum - sum_left - nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum_left == sum_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum_left += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个逻辑中无需先预判[0]元素是否可以直接PASS（其实前一个也不用，写麻烦了），并且用全数列的sum-左sum-当前元素，少了一丢丢运算过程，更加简洁明了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode0234</title>
    <url>/2023/11/30/Leetcode0234/</url>
    <content><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
 <span id="more"></span>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2,2,1]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="法一：复制到数组"><a href="#法一：复制到数组" class="headerlink" title="法一：复制到数组"></a>法一：复制到数组</h3><p>小生不才，链表使用不够熟练，先用复制链表到数组的笨方法做出来一遍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配数组</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新遍历链表，将值存入数组</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        a[i] = cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为回文</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[count - <span class="number">1</span> - i]) &#123;</span><br><span class="line">            <span class="built_in">free</span>(a);  <span class="comment">// 释放动态分配的数组内存</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);  <span class="comment">// 释放动态分配的数组内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="法二：快慢指针"><a href="#法二：快慢指针" class="headerlink" title="法二：快慢指针"></a>法二：快慢指针</h3><p>这也是我想到的第二个方法。</p>
<p>整个流程可以分为以下五个步骤：</p>
<ol>
<li><p>找到前半部分链表的尾节点。</p>
</li>
<li><p>反转后半部分链表。</p>
</li>
<li><p>判断是否回文。</p>
</li>
<li><p>恢复链表。</p>
</li>
<li><p>返回结果。</p>
</li>
</ol>
<p>   执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p>
<p>   我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p>
<p>   若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>
<p>   步骤二可以使用<a href="[Leetcode0206 | 全之の博客 (zuweicun.top">反转链表</a>](<a href="http://zuweicun.top/2023/11/30/Leetcode0206/#more))问题中的解决方法来反转链表的后半部分。">http://zuweicun.top/2023/11/30/Leetcode0206/#more))问题中的解决方法来反转链表的后半部分。</a></p>
<p>   步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>
<p>   步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p>
<p>   其代码如下：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;<span class="comment">//创建空节点用于存放“前一个”数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> head;<span class="comment">//基操curr遍历</span></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextTemp</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;<span class="comment">//反转函数</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">endOfFirstHalf</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;<span class="comment">//块指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;<span class="comment">//慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;<span class="comment">//一次走两步</span></span><br><span class="line">        slow = slow-&gt;next;<span class="comment">//一次走一步</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;<span class="comment">//由于快慢指针的数量关系，slow返回的应该是链表半节点处</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;<span class="comment">//最终的bool类型判断函数</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">firstHalfEnd</span> =</span> endOfFirstHalf(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">secondHalfStart</span> =</span> reverseList(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否回文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p2</span> =</span> secondHalfStart;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">    firstHalfEnd-&gt;next = reverseList(secondHalfStart);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="法三：递归"><a href="#法三：递归" class="headerlink" title="法三：递归"></a>法三：递归</h3><p><em>这个递归来源于Leetcode官方题解，其风骚是我至今所遇最强。</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，用于存储前半部分链表的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">frontPointer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归检查是否回文</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">recursivelyCheck</span><span class="params">(<span class="keyword">struct</span> ListNode* currentNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点不为空时进行递归检查</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归检查下一个节点，如果返回 false，则整体返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (!recursivelyCheck(currentNode-&gt;next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查当前节点的值是否与前半部分链表的节点值相等</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前半部分链表指针移动到下一个节点</span></span><br><span class="line">        frontPointer = frontPointer-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若所有节点都检查完毕，返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查链表是否为回文</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化全局变量 frontPointer</span></span><br><span class="line">    frontPointer = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归检查函数</span></span><br><span class="line">    <span class="keyword">return</span> recursivelyCheck(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><code>isPalindrome</code> 函数设置 <code>frontPointer</code> 为链表头，并调用 <code>recursivelyCheck</code> 函数。</li>
<li><code>recursivelyCheck</code> 函数首先检查当前节点是否为 <code>NULL</code>，如果是，则返回 <code>true</code>，因为链表的末尾已经达到。</li>
<li>然后，<code>recursivelyCheck</code> 递归调用自己，传递当前节点的下一个节点。</li>
<li>在递归返回之前，检查当前节点的值是否等于 <code>frontPointer</code> 指向的节点的值。如果不等，则返回 <code>false</code>，因为链表不是回文的。</li>
<li>如果值相等，将 <code>frontPointer</code> 移动到下一个节点。</li>
<li>最终，如果整个链表都被成功检查，并且没有发现值不相等的情况，那么整个函数返回 <code>true</code>，表示链表是回文的。</li>
</ol>
<p>这种方法的核心思想是使用递归从链表的末尾开始比较节点的值，同时使用 <code>frontPointer</code> 从链表的头部开始。这两个指针相向移动，逐一比较节点的值，如果在整个过程中没有找到不相等的节点，则链表被认为是回文的。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode189</title>
    <url>/2023/11/19/LeetCode189/</url>
    <content><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a><a href="https://leetcode.cn/problems/plus-one/">加一</a></h1><hr>
<p><strong>题目：</strong></p>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<span id="more"></span>
<p><strong>示例 1:</strong></p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">输入</span><span class="punctuation">:</span> <span class="string">nums = [1,2,3,4,5,6,7], k = 3</span></span><br><span class="line"><span class="attribute">输出</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="attribute">解释</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">向右轮转 1 步</span><span class="punctuation">:</span> <span class="string">[7,1,2,3,4,5,6]</span></span><br><span class="line"><span class="attribute">向右轮转 2 步</span><span class="punctuation">:</span> <span class="string">[6,7,1,2,3,4,5]</span></span><br><span class="line"><span class="attribute">向右轮转 3 步</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="string">-1</span>,<span class="string">-100</span>,3,99], k = 2</span><br><span class="line">输出：[3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,<span class="string">-1</span>,<span class="string">-100</span>,3]</span><br><span class="line">向右轮转 2 步: [3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>
<li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    k %= numsSize; <span class="comment">// 处理 k 大于数组大小的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = numsSize; <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>; <span class="comment">// 循环开始的下标</span></span><br><span class="line">    <span class="type">int</span> tmp = nums[begin]; <span class="comment">// 循环开始的值</span></span><br><span class="line">    <span class="type">int</span> len = begin; <span class="comment">// 在循环中的当前下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行</span></span><br><span class="line">    <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> before = (len - k + numsSize) % numsSize; <span class="comment">// 计算下一个位置</span></span><br><span class="line"></span><br><span class="line">        nums[len] = nums[before]; <span class="comment">// 将上一个值移动到当前值</span></span><br><span class="line">        len = before;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果循环结束，将开始的值赋给结尾的值，进入下一个循环</span></span><br><span class="line">        <span class="keyword">if</span> (before == begin) &#123;</span><br><span class="line">            nums[len] = tmp;</span><br><span class="line">            begin = (begin + <span class="number">1</span>) % numsSize;</span><br><span class="line">            tmp = nums[begin];</span><br><span class="line">            len = begin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ol>
<li>对 <code>k</code> 取余，处理 <code>k</code> 大于数组大小的情况，避免不必要的循环。</li>
<li>使用变量 <code>begin</code> 记录当前循环的开始下标，<code>len</code> 记录在循环中的当前下标。</li>
<li>循环执行，每次计算下一个位置 <code>before</code>，将上一个值移动到当前值。</li>
<li>如果循环结束，将开始的值赋给结尾的值，进入下一个循环。</li>
</ol>
<p>这样，通过不断地将值从上一个位置移动到当前位置，实现数组的循环右移。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>PID算法初探</title>
    <url>/2023/11/03/PID%E7%AE%97%E6%B3%95%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="PID算法初探"><a href="#PID算法初探" class="headerlink" title="PID算法初探"></a>PID算法初探</h1><p>PID（比例-积分-微分）控制算法是一种用于调节控制系统的反馈控制算法。它是一种常见的控制系统设计方法，用于确保系统的输出与期望值（或参考信号）尽可能接近。PID控制算法基于三个主要参数，分别是比例增益（P）、积分时间（I）和微分时间（D）。</p>
<span id="more"></span>
<h3 id="PID详解"><a href="#PID详解" class="headerlink" title="PID详解"></a>PID详解</h3><ul>
<li><p><strong>比例增益（P）：</strong> 比例部分根据当前误差的大小调整输出。如果误差较大，比例增益会产生更大的输出变化，以更快地减小误差。然而，如果比例增益设置得太大，系统可能会变得不稳定。</p>
</li>
<li><p><strong>积分时间（I）：</strong> 积分部分考虑了误差随时间的积累。它用于消除系统稳态误差，因为它会持续增加控制输出，直到误差为零。但如果积分时间设置得太大，可能导致系统的超调或振荡。        </p>
</li>
<li><p><strong>微分时间（D）：</strong> 微分部分考虑了误差变化的速度。它可以帮助系统抑制振荡，因为它对误差变化的速度进行响应，减小输出的变化速度。然而，如果微分时间设置得太大，可能会导致系统对噪声敏感。</p>
</li>
</ul>
<h3 id="PID算法基本原理"><a href="#PID算法基本原理" class="headerlink" title="PID算法基本原理"></a>PID算法基本原理</h3><p><em>PID算法的执行流程是非常简单的，即利用反馈来检测偏差信号，并通过偏差信号来控制被控量。而控制器本身就是比例、积分、微分三个环节的加和。</em></p>
<p><img src="1.jpg" alt="图片"></p>
<p>根据上图我们考虑在某个特定的时刻t，此时输入量为rin(t)，输出量为rout(t)，于是偏差就可计算为err(t)=rin(t)-rout(t)。于是PID的基本控制规律就可以表示为如下公式：</p>
<p><img src="2.png" alt="公式"><br><em>其中Kp为比例带，TI为积分时间，TD为微分时间。</em></p>
<h3 id="PID算法离散化"><a href="#PID算法离散化" class="headerlink" title="PID算法离散化"></a>PID算法离散化</h3><p>由于在计算机上应实现离散化问题，我们对比例，积分，微分特性做简单说明。    </p>
<p>比例就是用来对系统的偏差进行反应，所以只要存在偏差，比例就会起作用。积分主要是用来消除静差，所谓静差就是指系统稳定后输入输出之间依然存在的差值，而积分就是通过偏差的累计来抵消系统的静差。而微分则是对偏差的变化趋势做出反应，根据偏差的变化趋势实现超前调节，提高反应速度。     </p>
<p>在实现离散前，我们假设系统采样周期为T。假设我们检查第K个采样周期，很显然系统进行第K次采样。此时的偏差可以表示为err(K)=rin(K)-rout(K)，那么积分就可以表示为：err(K)+ err(K+1)+┈┈，而微分就可以表示为：(err(K)- err(K-1))/T。于是我们可以将第K次采样时，PID算法的离线形式表示为：<br><img src="3.png" alt="公式"><br>即为<br><img src="4.png" alt="公式"><br>这就是所谓的PID算法离散描述公式。还有一个增量型PID算法，下面来推导一下。<br>上面的公式描述了第k哥采样周期的结果，那么前一时刻也就是k-1哥采样周期可表示为：<br><img src="5.png" alt="公式"><br>那么我们再来说第K个采样周期的增量，很显然就是U(k)-U(k-1)。于是我们用第k个采样周期公式减去第k-1个采样周期的公式，就得到了增量型PID算法的表示公式：<br><img src="6.png" alt="公式"><br>当然，增量型PID必须记得一点，就是在记住U(k)=U(k-1)+∆U(k)</p>
<h3 id="PID控制器基本实现"><a href="#PID控制器基本实现" class="headerlink" title="PID控制器基本实现"></a>PID控制器基本实现</h3><p>完成了离散化后，我们就可以来实现它了。已经用离散化的数据公式表示出来后，再进型计算机编程已经不是问题了。接下来我们就使用C语言分别针对位置型公式和增量型公式来具体实现。</p>
<h4 id="位置型PID简单实现"><a href="#位置型PID简单实现" class="headerlink" title="位置型PID简单实现"></a>位置型PID简单实现</h4><p>位置型PID的实现就是以前面的位置型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散位置型PID公式的计算机语言化。<br>首先定义PID对象的结构体：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integral;<span class="comment">//积分值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure></p>
<p>接下来实现PID控制器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PIDRegulation</span><span class="params">(PID *vPID, <span class="type">float</span> processValue)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> thisError;</span><br><span class="line"></span><br><span class="line">  thisError=vPID-&gt;setpoint-processValue;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;integral+=thisError;</span><br><span class="line"></span><br><span class="line">  vPID-&gt;result=vPID-&gt;proportiongain*thisError+vPID-&gt;integralgain*vPID-&gt;integral+vPID-&gt;derivativegain*(thisError-vPID-&gt;lasterror);</span><br><span class="line"></span><br><span class="line">  vPID-&gt;lasterror=thisError;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就实现了一个最简单的位置型PID控制器，当然没有考虑任何干扰条件，仅仅只是对数学公式的计算机语言化。</p>
<h4 id="增量型PID简单实现"><a href="#增量型PID简单实现" class="headerlink" title="增量型PID简单实现"></a>增量型PID简单实现</h4><p>增量型PID的实现就是以前面的增量型公式为基础。这一节我们只是完成最简单的实现，也就是将前面的离散增量型PID公式的计算机语言化。</p>
<p>首先定义PID对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义结构体和公用体*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> setpoint;       <span class="comment">//设定值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> proportiongain;     <span class="comment">//比例系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> integralgain;      <span class="comment">//积分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> derivativegain;    <span class="comment">//微分系数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> lasterror;     <span class="comment">//前一拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> preerror;     <span class="comment">//前两拍偏差</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> deadband;     <span class="comment">//死区</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> result; <span class="comment">//输出值</span></span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br></pre></td></tr></table></figure>
<p>接下来实现PID控制器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PIDRegulation</span><span class="params">(PID *vPID, <span class="type">float</span> processValue)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> thisError;</span><br><span class="line">  <span class="type">float</span> increment;</span><br><span class="line">  <span class="type">float</span> pError, dError, iError;</span><br><span class="line"></span><br><span class="line">  thisError = vPID-&gt;setpoint - processValue; <span class="comment">// 得到偏差值</span></span><br><span class="line">  pError = thisError; <span class="comment">// 比例部分</span></span><br><span class="line">  iError = vPID-&gt;integralgain * thisError; <span class="comment">// 积分部分</span></span><br><span class="line">  dError = thisError - vPID-&gt;lasterror; <span class="comment">// 微分部分</span></span><br><span class="line">  increment = vPID-&gt;proportiongain * pError + iError + vPID-&gt;derivativegain * dError; <span class="comment">// 增量计算</span></span><br><span class="line"></span><br><span class="line">  vPID-&gt;lasterror = thisError;</span><br><span class="line">  vPID-&gt;result += increment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><p>前面讲述并且实现了PID控制器，包括位置型PID控制器和增量型PID控制器。界限来我们对这两种类型的控制器的特点作一个简单的描述。</p>
<p><strong>位置型PID控制器的基本特点：</strong></p>
<ul>
<li>位置型PID控制的输出与整个过去的状态有关，用到了偏差的累加值，容易产生累积偏差。</li>
<li>位置型PID适用于执行机构不带积分部件的对象。</li>
<li>位置型的输出直接对应对象的输出，对系统的影响比较大。</li>
</ul>
<p><strong>增量型PID控制器的基本特点：</strong></p>
<ul>
<li>增量型PID算法不需要做累加，控制量增量的确定仅与最近几次偏差值有关，计算偏差的影响较小。</li>
<li>增量型PID算法得出的是控制量的增量，对系统的影响相对较小。</li>
<li>采用增量型PID算法易于实现手动到自动的无扰动切换。</li>
</ul>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习</title>
    <url>/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>经过长达一天的重装和环境配置，正式开始OpenCV的学习。</p>
<span id="more"></span>
<h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/Star_ID/article/details/122656593">OpenCV入门【C++版】_opencv c++入门-CSDN博客</a></p>
<p><a href="https://oldpan.me/archives/use-vscode-cmake-tools-build-project">利用VScode和cmake编译构建C++工程代码 - Oldpan的个人博客</a></p>
<p><a href="https://blog.csdn.net/qq_41921826/article/details/129145473">OpenCV - C++实战（05） — 颜色检测_c++图像色素带识别-CSDN博客</a></p>
<h2 id="基本-（图片-amp-视频）操作"><a href="#基本-（图片-amp-视频）操作" class="headerlink" title="基本 （图片&amp;视频）操作"></a>基本 （图片&amp;视频）操作</h2><p>首先在opencv中创建一个文件夹mytest，用于存放后续的测试程序,并创建程序test1（后续同理）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mkdir mytest</span><br><span class="line">cd mytest</span><br><span class="line">gedit test1.cpp</span><br></pre></td></tr></table></figure>
<p>找一张图片（好友丑照）命名为1.jpg存放于这个目录中用于后续测试（蹂躏）。</p>
<h3 id="1-图片腐蚀"><a href="#1-图片腐蚀" class="headerlink" title="1 图片腐蚀"></a>1 图片腐蚀</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat element =<span class="built_in">getStructuringElement</span>(MORPH_RECT,<span class="built_in">Size</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">erode</span>(srcImage,dstImage,element);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]腐蚀操作&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能很简单，就是一个腐蚀操作。</p>
<p>在终端输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ test1.cpp -o test1 `pkg-config --cflags --libs opencv`</span><br><span class="line">./test1</span><br></pre></td></tr></table></figure>
<p>显示原图和腐蚀操作图。</p>
<p>效果展示：</p>
<p><img src="1.png" alt="1"></p>
<p>完美运行。</p>
<h3 id="2-图像模糊"><a href="#2-图像模糊" class="headerlink" title="2.图像模糊"></a>2.图像模糊</h3><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">blur</span>(srcImage,dstImage,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常好理解，载入原图之后调用一次blur函数，最后显示效果图。</p>
<p>效果如下：</p>
<p><img src="2.png" alt="2"></p>
<h3 id="3-Canny边缘检测"><a href="#3-Canny边缘检测" class="headerlink" title="3  Canny边缘检测"></a>3  Canny边缘检测</h3><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage,edge,grayImage;<span class="comment">//参数定义</span></span><br><span class="line">    dstImage.<span class="built_in">create</span>(srcImage.<span class="built_in">size</span>(),srcImage.<span class="built_in">type</span>());</span><br><span class="line">    <span class="comment">//创建与src同类型大小的矩阵（dest）</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//将原图像转换为灰度图像</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">blur</span>(grayImage,edge,<span class="built_in">Size</span>(<span class="number">3</span>,<span class="number">3</span>));<span class="comment">//3x3内核降噪</span></span><br><span class="line">    <span class="built_in">Canny</span>(edge,edge,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>);<span class="comment">//运行Canny算子</span></span><br><span class="line">    dstImage = edge; <span class="comment">//将Canny算子的结果赋值给dstImage</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>(); <span class="comment">//释放所有窗口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="3.png" alt="3"></p>
<h3 id="4-读取视频"><a href="#4-读取视频" class="headerlink" title="4.读取视频"></a>4.读取视频</h3><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="string">&quot;1.avi&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;<span class="comment">//定义Mat变量储存每一帧</span></span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);<span class="comment">//延迟30ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-调取摄像头采集视频"><a href="#5-调取摄像头采集视频" class="headerlink" title="5.调取摄像头采集视频"></a>5.调取摄像头采集视频</h3><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    Mat edges;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">cvtColor</span>(frame,edges,COLOR_BGR2GRAY);<span class="comment">//灰度转换</span></span><br><span class="line">        <span class="built_in">blur</span>(edges,edges,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">        <span class="built_in">Canny</span>(edges,edges,<span class="number">1</span>,<span class="number">31</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（其实就是把Videocapture中的视频源改为参数0）</p>
<h3 id="6-灰度转化"><a href="#6-灰度转化" class="headerlink" title="6.灰度转化"></a>6.灰度转化</h3><p>图片有多种色彩模式，主要就是包括位图模式，灰度模式，RGB模式，CMYK模式和HSB模式。这里就不详细展开了。值得注意的有两个概念，就是图片的深度和通道，深度表示一个图片的一个像素有几位，通道则表示一个图像由几层颜色表示，一般由单通道（灰度），三通道（RGB）以及四通道（RGB+透明度）表示。</p>
<p>在opencv中我们一般采用cvtColor这个函数来转换图像的灰度。</p>
<p><img src="4.png" alt="4"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C++: <span class="function"><span class="type">void</span> <span class="title">cvtColor</span><span class="params">(InputArray src, OutputArray dst, <span class="type">int</span> code, <span class="type">int</span> dstCn=<span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里给出函数的定义和常用的几个转换标识</p>
<h2 id="图像裁剪和缩放"><a href="#图像裁剪和缩放" class="headerlink" title="图像裁剪和缩放"></a>图像裁剪和缩放</h2><p>可以参考</p>
<p><a href="https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc=%7B%22request%5Fid%22%3A%22170480359916800185832024%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170480359916800185832024&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120584785-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv图像裁剪和缩放&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170480359916800185832024%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170480359916800185832024&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120584785-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%A9%E6%94%BE&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="图像尺寸缩放："><a href="#图像尺寸缩放：" class="headerlink" title="图像尺寸缩放："></a>图像尺寸缩放：</h3><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">( InputArray src, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">			 OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">             Size dsize, <span class="comment">//调整成的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fx = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fy = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> interpolation = INTER_LINEAR </span></span></span><br><span class="line"><span class="params"><span class="function">             )</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><ul>
<li>src：输入的图像，Mat类</li>
<li>dst：输出的图像，当参数dsize不为0时，dst的大小由dsize决定；否则，它的大小由参数fx和fy决定</li>
<li>dsize：输出图像的大小，写成Size(宽，高)（单位：像素）</li>
<li>fx和fy：水平/竖直方向上的缩放比例</li>
<li>interpolation：插值方法。取值如下：<br>INTER_NEAREST————-最近邻插值<br>INTER_LINEAR————-双线性插值（默认设置）<br>INTER_AREA————-使用像素区域关系进行重采样<br>INTER_CUBIC————-4x4像素邻域的双三次插值<br>INTER_LANCZOS4————-8x8像素邻域的Lanczos插值</li>
<li>注意：参数dsize和参数(fx, fy)不能够同时为0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat outImg;</span><br><span class="line">    <span class="built_in">resize</span>(img, outImg, <span class="built_in">Size</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="number">0.8</span>, <span class="number">0.8</span>);<span class="comment">//宽和高都变为原来的0.8倍</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;改变尺寸后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h3><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    <span class="function">Rect <span class="title">cropArea</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Mat outImg = <span class="built_in">img</span>(cropArea);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;裁剪后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图像绘制和文字输出"><a href="#图像绘制和文字输出" class="headerlink" title="图像绘制和文字输出"></a>图像绘制和文字输出</h2><p>参考资料：<a href="https://blog.csdn.net/k673656/article/details/129227483?ops_request_misc=%7B%22request%5Fid%22%3A%22170480417316800213038610%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170480417316800213038610&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-129227483-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv图形绘制和文字绘制&amp;spm=1018.2226.3001.4187">Opencv图形绘制与文字输出_opencv mat 显示文字-CSDN博客</a></p>
<h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(InputOutputArray img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中center表示中心位置，radius表示半径，thikness可以表示厚度，-1表示填充，与可以表示位FILLED</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p> 值得注意的是，还可以使用RECT来绘制，函数如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Rect(x,y,width,height), <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="输入文字"><a href="#输入文字" class="headerlink" title="输入文字"></a>输入文字</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">putText</span><span class="params">( InputOutputArray img, <span class="type">const</span> String&amp; text, Point org, <span class="type">int</span> fontFace, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">double</span> fontScale, Scalar color, <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> bottomLeftOrigin = <span class="literal">false</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>img表示初始的文字，text表示文字内容，org表示文字的左下角坐标，fontface表示字体类型，fontscale表示字体大小，最后以为表示图像数据的原点是左下角还是左上角。</p>
<h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p>首先，对几何变换做个简单了解。打开任意一个图像编辑器，一般可以有对图像进行放大、缩小、旋转等操作，这类操作改变了原图中各区域的空间关系。对于这类操作，通常称为图像的<strong>几何变换</strong>。</p>
<p>一般而言，完成一张图像的几何变换需要<strong>两个独立的算法</strong>：<strong>首先</strong>，需要一个算法实现空间坐标变换，用它描述每个像素如何从初始位置移动到终止位置；<strong>其次</strong>，还需要一个<strong>插值算法</strong>完成输出图像的每个像素的灰度值。</p>
<h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><h4 id="仿射矩阵"><a href="#仿射矩阵" class="headerlink" title="仿射矩阵"></a>仿射矩阵</h4><p>对于空间变换的仿射矩阵有两种计算方式，分别是<strong>方程组法</strong>和<strong>矩阵相乘法</strong>。</p>
<p><strong>(1) 方程组法</strong></p>
<p>仿射变换矩阵有六个未知数，所以需要三组对应位置坐标，构造出由六个方程组成的方程组即可解六个未知数。<br>举例：如果(0,0) 、(200,0) 、(0,200)这三个坐标通过某仿射变换矩阵A分别转换为(0,0) 、(100,0) 、(0,100)，则可利用这三组对应坐标构造出六个方程，求解出A。</p>
<p>对于C++的API函数getAffineTransform()输入参数有两种方式，第一种方式是将原位置坐标和对应的变换后的坐标分别保存在Point2f数组中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Point2f src[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">200</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">200</span>) &#125;;</span><br><span class="line">	Point2f dst[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">100</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">100</span>) &#125;;</span><br><span class="line"></span><br><span class="line">	Mat A = <span class="built_in">getAffineTransform</span>(src,dst);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; A&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值A仍然是2行3列的矩阵，指的是<strong>仿射变换矩阵的前两行</strong>。需要注意的是，数据类型是CV_64F而<strong>不是</strong>CV_32F。</p>
<p>第二种方式是<strong>将原位置坐标和对应的变换后的坐标保存在</strong>Mat中，<strong>每一行代表一个坐标，数据类型必须是</strong>CV_32F，否则会报错，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">	Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Mat A = <span class="built_in">getAffineTransform</span>(src, dst);</span><br><span class="line">	cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用矩阵相乘法计算仿射矩阵，<strong>前提是需要知道基本仿射变换步骤</strong>.</p>
<p><strong>需要注意的是</strong>，虽然先缩放再平移，但是仿射变换矩阵是<strong>平移仿射矩阵乘以缩放仿射矩阵，而不是缩放仿射矩阵乘以平移仿射矩阵</strong>，即等式右边的运算是从右向左进行的。</p>
<p>在<a href="https://so.csdn.net/so/search?q=OpenCV&amp;spm=1001.2101.3001.7020">OpenCV</a>中是通过“*”运算符或者gemm函数来实现矩阵的乘法的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//缩放矩阵</span></span><br><span class="line">	Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>,<span class="number">1</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//平移矩阵</span></span><br><span class="line"></span><br><span class="line">	Mat A;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gemm</span>(src,dst,<span class="number">1.0</span>,<span class="built_in">Mat</span>(),<span class="number">0</span>,A,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="透射变换"><a href="#透射变换" class="headerlink" title="透射变换"></a>透射变换</h3><p>仿射变换是在平面上的线性变换加平移，根据其性质可知变换后平行四边形依然是平行四边形，不改变直线的平行关系。透射变换即中心投影变换，利用透视中心、像点、目标点三点共线的条件,按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p>
<p> 透视变换是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射。</p>
<p>移动投影中心和承影面，可得到各种形状的变换。（有点像《三体》里的二向箔）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cv::getPerspectiveTransform</span> <span class="params">(<span class="type">const</span> Point2f src[], <span class="type">const</span> Point2f dst[])</span></span></span><br></pre></td></tr></table></figure>
<p><strong>返回相应 4 个点对的 3x3 透视变换</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpPerspective</span> <span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize, <span class="type">int</span> flags=INTER_LINEAR, <span class="type">int</span> borderMode=BORDER_CONSTANT, <span class="type">const</span> Scalar &amp;borderValue=Scalar())</span></span></span><br></pre></td></tr></table></figure>
<p><strong>对图像应用透视变换</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">Mat matrix, imgWarp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string path = <span class="string">&quot;Resources/cards.jpg&quot;</span>;</span><br><span class="line">	Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">	Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>, <span class="number">142</span>&#125;, &#123;<span class="number">771</span>, <span class="number">190</span>&#125;, &#123;<span class="number">405</span>, <span class="number">395</span>&#125;, &#123;<span class="number">674</span>, <span class="number">457</span>&#125; &#125;;</span><br><span class="line">	Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;, &#123;w, <span class="number">0.0f</span>&#125;, &#123;<span class="number">0.0f</span>, h&#125;, &#123;w, h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">	matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line">	<span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">	<span class="built_in">imshow</span>(<span class="string">&quot;ImageWarp&quot;</span>, imgWarp);</span><br><span class="line">	<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：文档扫描应该就是这种变换。</p>
<h2 id="颜色检测："><a href="#颜色检测：" class="headerlink" title="颜色检测："></a>颜色检测：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::inRange</span> <span class="params">(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure>
<p>检查数组元素是否位于其他两个数组的元素之间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::namedWindow</span> <span class="params">(<span class="type">const</span> String &amp;winname, <span class="type">int</span> flags = WINDOW_AUTOSIZE)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>创建一个窗口</strong>。函数namedWindow创建一个可用作图像和轨迹栏占位符的窗口。创建的窗口由它们的名称引用。如果同名的窗口已经存在，则该函数不执行任何操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cv::createTrackbar</span> <span class="params">(<span class="type">const</span> String &amp;trackbarname, <span class="type">const</span> String &amp;winname, <span class="type">int</span> *value, <span class="type">int</span> count, TrackbarCallback onChange = <span class="number">0</span>, <span class="type">void</span> *userdata = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>创建一个</strong>trackbar<strong>并将其附加到指定窗口</strong>。函数createTrackbar创建一个具有指定名称和范围的trackbar（滑块或范围控件），分配一个变量值作为与trackbar同步的位置，并指定回调函数onChange为 在跟踪栏位置变化时被调用。创建的轨迹栏显示在指定的窗口winname中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Mat imgHSV, mask;</span><br><span class="line"><span class="type">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line"><span class="type">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string path = <span class="string">&quot;resources/lambo.png&quot;</span>;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">2555</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目实操"><a href="#项目实操" class="headerlink" title="项目实操"></a>项目实操</h2><h4 id="参考资料：-1"><a href="#参考资料：-1" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://hitwhlc.yuque.com/tosania">@23沈晨阳</a></p>
<p>此处为语雀内容卡片，点击链接查看：<a href="https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt">https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt</a></p>
<p><a href="https://blog.csdn.net/qq_40344790/article/details/127653557?ops_request_misc=%7B%22request%5Fid%22%3A%22170481303716800188516338%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170481303716800188516338&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv红绿灯识别检测c%2B%2B&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_40344790/article/details/127653557?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170481303716800188516338%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170481303716800188516338&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8Bc%2B%2B&amp;spm=1018.2226.3001.4187</a></p>
<h4 id="任务内容："><a href="#任务内容：" class="headerlink" title="任务内容："></a>任务内容：</h4><h5 id="OpenCV红绿灯检测"><a href="#OpenCV红绿灯检测" class="headerlink" title="OpenCV红绿灯检测"></a>OpenCV红绿灯检测</h5><ul>
<li>使用<strong>c++</strong>版本的opencv对视频进行处理</li>
<li>读取TrafficLight.mp4</li>
<li>检测交通信号灯颜色，并在图像中标出红绿灯位置（中间数字无需检测）</li>
<li>将信号灯颜色以字符串输出到图像左上角</li>
<li>将处理后的视频输出为result.avi，示例为压缩包内“输出示例.avi”</li>
<li><p>可以进行创新，给大家的视频只是一个示例</p>
</li>
<li><p>在语雀中创建文档，完整记录自己的实现方式</p>
</li>
<li>将代码、result.avi放入同一压缩包内上传到语雀中</li>
<li>将result.avi直接传入语雀中，其他人可以直接查看的那种</li>
<li>提交截止时间：下周一例会前(2.14)</li>
</ul>
<h4 id="完成思路："><a href="#完成思路：" class="headerlink" title="完成思路："></a>完成思路：</h4><p>1.将视频的每一帧处理，（高斯模糊，边缘检测，膨胀….），增强特征点的提取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对二值化后的图像进行高斯模糊</span></span><br><span class="line">    <span class="built_in">GaussianBlur</span>(imgDil, imgDil, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对图像进行Canny边缘检测</span></span><br><span class="line">    <span class="built_in">Canny</span>(imgDil, imgDil, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义膨胀操作的内核</span></span><br><span class="line">    Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对Canny边缘检测后的图像进行膨胀</span></span><br><span class="line">    <span class="built_in">dilate</span>(imgDil, imgDil, kernel);</span><br></pre></td></tr></table></figure>
<p>2.由于红绿灯是由许多小像素点组成的，可能会造成误判，故需要检测一下轮廓过滤出最大的画出矩形。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找图像中的轮廓</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="built_in">findContours</span>(imgDil, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储轮廓的多边形逼近和轮廓的矩形边界</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储最大轮廓的相关信息</span></span><br><span class="line"><span class="type">double</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> choose = <span class="number">0</span>, ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，找到最大的符合条件的轮廓</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>) &gt; maxx)</span><br><span class="line">    &#123;</span><br><span class="line">        maxx = <span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        choose = i;</span><br><span class="line">        <span class="keyword">if</span> (maxx &gt; <span class="number">20</span> &amp;&amp; <span class="built_in">contourArea</span>(contours[i]) &gt; <span class="number">2000</span>)</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，绘制最大的轮廓及相关信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choose == i &amp;&amp; ok == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算轮廓的多边形逼近</span></span><br><span class="line">        <span class="type">double</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算轮廓的矩形边界</span></span><br><span class="line">        boundRect[i] = <span class="built_in">boundingRect</span>(conPoly[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形边界</span></span><br><span class="line">        <span class="built_in">rectangle</span>(img, boundRect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">225</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在矩形边界的左上角绘制文本</span></span><br><span class="line">        <span class="built_in">putText</span>(img, c, boundRect[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">100</span>), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于颜色的识别：</li>
</ul>
<p>由于inrange函数的局限性，最好将图像转换成HSV颜色空间，相比于RGB颜色空间，HSV颜色空间更适合处理颜色分割和阈值操作。在HSV中，颜色范围可以更容易地通过阈值进行调整，因为色调和明度是分开的。</p>
<p>使用HSV颜色空间是为了更容易地确定图像中红色和绿色的区域。对于交通灯的颜色检测，通常更关注颜色的种类而不是其亮度或深浅，因此使用HSV更为合适。</p>
<p>主函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 视频文件路径</span></span><br><span class="line">    string path = <span class="string">&quot;1.avi&quot;</span>;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line">    Mat img;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧数</span></span><br><span class="line">    <span class="type">int</span> cnt = cap.<span class="built_in">get</span>(CAP_PROP_FRAME_COUNT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧的大小</span></span><br><span class="line">    Size sizeReturn = <span class="built_in">Size</span>(cap.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH), cap.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建输出视频的写入对象，设置输出视频文件名、编码方式、帧率和大小</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), cap.get(CAP_PROP_FPS), sizeReturn)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历视频的每一帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取当前帧</span></span><br><span class="line">        cap &gt;&gt; img;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换当前帧为HSV颜色空间</span></span><br><span class="line">        Mat imgHSV;</span><br><span class="line">        <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义绿色和红色的HSV阈值范围</span></span><br><span class="line">        <span class="function">Scalar <span class="title">g_lower</span><span class="params">(h_gmin, s_gmin, v_gmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">g_upper</span><span class="params">(h_gmax, s_gmax, v_gmax)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_lower</span><span class="params">(h_rmin, s_rmin, v_rmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_upper</span><span class="params">(h_rmax, s_rmax, v_rmax)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过HSV阈值得到绿色和红色的掩码</span></span><br><span class="line">        Mat g_mask, r_mask;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, g_lower, g_upper, g_mask);</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, r_lower, r_upper, r_mask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对绿色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workg</span>(g_mask, img, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对红色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workr</span>(r_mask, img, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将处理后的帧写入输出视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(img);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;img&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 释放视频捕捉对象和写入对象</span></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来是不用学人脸识别的，感觉好玩所以写了个基于摄像头输入源的人脸识别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CascadeClassifier faceCascade;</span><br><span class="line">	faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	Mat img;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cap.<span class="built_in">read</span>(img);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">		vector&lt;Rect&gt; face;</span><br><span class="line">		faceCascade.<span class="built_in">detectMultiScale</span>(img, face);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">rectangle</span>(img, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">			<span class="built_in">putText</span>(img, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">		<span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>后来感觉不够，完全可以基于主屏幕输入画面进行人脸识别，方便帮舍友识别出藏在床底下的老王（bushi）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xutil.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* display = <span class="built_in">XOpenDisplay</span>(<span class="literal">NULL</span>); <span class="comment">// 打开X11显示</span></span><br><span class="line">    Screen* screen = <span class="built_in">DefaultScreenOfDisplay</span>(display); <span class="comment">// 获取默认屏幕</span></span><br><span class="line">    <span class="type">int</span> width = screen-&gt;width; <span class="comment">// 获取屏幕的宽度</span></span><br><span class="line">    <span class="type">int</span> height = screen-&gt;height; <span class="comment">// 获取屏幕的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载人脸检测分类器</span></span><br><span class="line">    CascadeClassifier faceCascade;</span><br><span class="line">    faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建VideoWriter对象，用于将每一帧屏幕图像写入视频文件</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), <span class="number">30</span>, Size(width, height))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取屏幕的XImage对象</span></span><br><span class="line">        XImage* ximage = <span class="built_in">XGetImage</span>(display, <span class="built_in">DefaultRootWindow</span>(display), <span class="number">0</span>, <span class="number">0</span>, width, height, AllPlanes, ZPixmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为OpenCV的Mat对象</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">image</span><span class="params">(height, width, CV_8UC4, ximage-&gt;data)</span></span>; <span class="comment">// 创建Mat对象</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(image, image, cv::COLOR_BGRA2BGR); <span class="comment">// 转换为BGR格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕图像上进行人脸检测和标注</span></span><br><span class="line">        vector&lt;Rect&gt; face;</span><br><span class="line">        faceCascade.<span class="built_in">detectMultiScale</span>(image, face);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rectangle</span>(image, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">putText</span>(image, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示屏幕图像</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Screen&quot;</span>, image);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将修改后的图像写入视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">XDestroyImage</span>(ximage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭X11显示</span></span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放VideoCapture对象和VideoWriter对象的资源</span></span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS1初步</title>
    <url>/2024/03/11/ROS1%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p><a name="J4y9t"></a></p>
<h1 id="Topic与Message"><a href="#Topic与Message" class="headerlink" title="Topic与Message"></a>Topic与Message</h1><span id="more"></span>
<p>基础概念：<br />1.话题Topic是节点间进行持续通讯的一种形式<br />2.话题通讯的两个节点通过话题的名称建立起话题通讯连接。<br />3.话题中通讯的数据，叫做消息Message<br />4.消息Message通常会按照一定的频率持续不断的发送，以保证消息数据的实时性。<br />5.消息的发送方叫做话题的发布者Publisher<br />6.消息的接收方叫做话题的订阅者Subsciber<br />更多有：<br />1.一个ROS节点网络中，可以同时存在多个话题<br />2.一个话题可以有多个发布者，也可以有多个订阅者<br />3.一个节点可以对多个话题进行订阅，也可以发布多个话题<br />4.不痛得传感器消息通常会拥有各自独立话题名称，每个话题只有一个发布者<br />5.机器人速度指令话题通常会有多个发布者，但是同一时间只能有一个发言人。<br><a name="v1QhS"></a></p>
<h2 id="Topic的C-实现"><a href="#Topic的C-实现" class="headerlink" title="Topic的C++实现"></a>Topic的C++实现</h2><p>发布者的具体步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家发布一个话题并得到消息发送对象<br />4.生成要发送的消息包并进行发送数据的赋值。<br />5.调用消息发送对象的publish()函数将消息包发送到话题当中。<br />为了查看有关的Topic我们可以使用以下的常用工具：<br />rostopic list<br />列出当前系统汇总所有活跃着的话题<br />rostopic echo 主体名称<br />显示指定话题中发送的消息包内容<br />rostopic hz 主体名称<br />统计指定话题中消息包的发送频率<br />而话题的订阅需要满足以下的步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include<ros.h>和消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家订阅一个话题并设置消息接收回调函数<br />4.定义一个回调函数，对接收到的消息包进行处理。<br />5.main函数中需要执行ros::spinOnce()，让回调函数能够响应接受到的消息包<br><a name="JxKTI"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;chao_node&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;node_chao is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//这里第二个参数表示缓存空间</span></span><br><span class="line">  <span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chao is sending\n&quot;</span>);</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    msg.data = <span class="string">&quot;chao is sending message&quot;</span>;</span><br><span class="line">    pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_WARN</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;ma_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>, chao_callback);</span><br><span class="line">	<span class="comment">//这里第三个参数类似于单片机里的中断函数</span></span><br><span class="line">  Subscriber sub_yao = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_yao&quot;</span>, <span class="number">10</span>, yao_callback);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">spinOnce</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="L26MD"></a></p>
<h3 id="图形化界面rqt-graph"><a href="#图形化界面rqt-graph" class="headerlink" title="图形化界面rqt_graph"></a>图形化界面rqt_graph</h3><p>运行三个节点和roscore，然后在一个新的终端中输入rqt_graph可以得到一个用来观察当前消息链路的图形化界面<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705307614453-48eb5146-7ae3-40e1-b12c-6cc0a99ed5cb.png#averageHue=%23817243&amp;clientId=ued9d9fb6-a67b-4&amp;from=paste&amp;height=586&amp;id=u8f7c53f5&amp;originHeight=1172&amp;originWidth=2532&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=466221&amp;status=done&amp;style=none&amp;taskId=u54a4f49e-81fd-4e78-bf60-cd6d364613b&amp;title=&amp;width=1266" alt="image.png"><br><a name="DLwhc"></a></p>
<h3 id="launch文件同时启动多个节点"><a href="#launch文件同时启动多个节点" class="headerlink" title="launch文件同时启动多个节点"></a>launch文件同时启动多个节点</h3><p>launch文件是一种遵循XML语法的描述文件，这里启动多个节点只是launch文件的功能之一。 <br />对应到启动节点，我们可以使用这个流程：<br />1.使用launch文件，可以通过roslaunch指令一次启动多个节点。<br />2.在launch文件中，为节点添加output=”screen”属性，可以容纳个节点信息输出在终端中。（ROS_WARN不受该属性控制）<br />3.在launch文件中，为节点添加launch-prefix=”gnome-terminal -e”属性，可以让节点单独运行在一个独立终端中。<br />具体的，我们使用这个代码：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><br>而我们使用时只需要在终端中使用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">roslaunch 包名 launch文件名</span><br></pre></td></tr></table></figure><br>就可以运行了<br><a name="Xp45g"></a></p>
<h2 id="Topic的python实现"><a href="#Topic的python实现" class="headerlink" title="Topic的python实现"></a>Topic的python实现</h2><p>python实现基本上和c++实现差不多，无非就是c++中的NodeHandler变成了python中的rospy<br />看看代码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment">#说明解释器和编码</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: <span class="comment">#主函数</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;chao_node&quot;</span>)<span class="comment">#申明节点</span></span><br><span class="line">    rospy.logwarn(<span class="string">&quot;node chao is running&quot;</span>)<span class="comment">#启动标签，打个warn让你吓一跳（</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;node_chao&quot;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)<span class="comment">#控制频率</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;node chao is sending message&quot;</span>)</span><br><span class="line">        msg = String()</span><br><span class="line">        msg.data = <span class="string">&quot;this is node chao&#x27;s message&quot;</span></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>接收端：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><br>和c++的程序实现十分相似<br />值得说明的是，在launch中c++直接是一个可执行文件，而python则是要加入后缀py<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><br><a name="Wz45W"></a></p>
<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>service是ros中另一种通讯方式，类似于服务器和终端之间请求式的关系。<br />主要操作步骤分为：<br />1.服务端Server注册<br />2.客户端Client注册<br />3.节点管理器进行话题匹配<br />4.服务端请求服务<br />5.服务端提供服务<br><a name="OQdRg"></a></p>
<h2 id="终端指令的实现"><a href="#终端指令的实现" class="headerlink" title="终端指令的实现"></a>终端指令的实现</h2><p>我们使用ros自带的小乌龟来手动模拟一下一个service实现的过程<br />首先启动ros核心并召唤出小乌龟<br />然后使用<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rosrun rqt_service_caller rqt_service_caller</span><br></pre></td></tr></table></figure><br>召唤出图形化的service界面<br />按照<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388668505-d518fb03-f941-4f5c-b0f6-7f08d92ac516.png#averageHue=%23ede7e5&amp;clientId=u36e31b96-9ee5-4&amp;from=paste&amp;height=435&amp;id=uc21508a1&amp;originHeight=956&amp;originWidth=940&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=271004&amp;status=done&amp;style=none&amp;taskId=uda7225e4-f750-48cd-b154-967e9ec5ca3&amp;title=&amp;width=427.27271801184054" alt="image.png"><br />来配置<br />就能看到图上出现了一只新的小乌龟<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388704513-fa622c00-39a1-498e-85e3-d908b340bc3e.png#averageHue=%234556fe&amp;clientId=u36e31b96-9ee5-4&amp;from=paste&amp;height=255&amp;id=u07d8973e&amp;originHeight=562&amp;originWidth=504&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=20276&amp;status=done&amp;style=none&amp;taskId=u4f0b890d-9656-4f8d-9ad6-8a5d36bee53&amp;title=&amp;width=229.09090412549747" alt="image.png"></p>
<p><a name="zoD2G"></a></p>
<h2 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h2><p><a name="T27RX"></a></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_client</span>();</span><br><span class="line">  ~<span class="built_in">service_client</span>();</span><br><span class="line">  ros::ServiceClient client;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_client::<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">  client = nh.<span class="built_in">serviceClient</span>&lt;service_test::service_test::Request&gt;(<span class="string">&quot;a_b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">service_client::request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;request&quot;</span> &lt;&lt; endl;</span><br><span class="line">  service_test::service_test req;</span><br><span class="line">  req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  <span class="keyword">if</span> (client.<span class="built_in">call</span>(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;request falied&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  a++;</span><br><span class="line">  b += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">service_client::~<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_client&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_client is started&quot;</span>);</span><br><span class="line">  service_client service_client;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    service_client.<span class="built_in">request</span>();</span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里用一个类写了一下这个东西，实现了一个a+b的不断请求<br />注意一下里面的核心语句：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">serviceClient&lt;service_test::service_test::Request&gt;(&quot;a+b&quot;);</span><br></pre></td></tr></table></figure><br>这里定义了最重要的服务名<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  if (client.call(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;=&quot; &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>这里以req为媒介去询问并获得数据<br><a name="rS9TQ"></a></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_server</span>(<span class="comment">/* args */</span>);</span><br><span class="line">  ~<span class="built_in">service_server</span>();</span><br><span class="line">  ros::ServiceServer server;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_server::<span class="built_in">service_server</span>(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">  server = nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">service_server::requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a request is handled&quot;</span> &lt;&lt; endl;</span><br><span class="line">  response.sum = request.numb1 + request.numb2;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service_server::~<span class="built_in">service_server</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_server&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_server is started&quot;</span>);</span><br><span class="line">  service_server server;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里核心为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><br>这里前面是名字，后面有返回参数，不过这个this我看了半天也没明白是什么，我看如果没有写类的话这里好像只有两个参数，所以我大胆猜测这个是用来指向类的一个东西？<br><a name="RRsNw"></a></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>再cmakelists中加入<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(service_client src/service_client.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_client</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_client $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(service_server src/service_server.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_server</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_server $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br></pre></td></tr></table></figure><br>然后编译运行<br />效果：<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705392274716-e9b41739-0415-4df2-964b-0a2a2bb01b27.png#averageHue=%231e1a1a&amp;clientId=ue763d424-91f3-4&amp;from=paste&amp;height=440&amp;id=u37dec1cb&amp;originHeight=968&amp;originWidth=1456&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=257893&amp;status=done&amp;style=none&amp;taskId=uf53eabec-6008-468b-a83f-f7a4cd72232&amp;title=&amp;width=661.8181674736594" alt="image.png"><br><a name="OpNbK"></a></p>
<h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><p><a name="sOxSw"></a></p>
<h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> service_test, service_testResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addCallback</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="built_in">sum</span> = req.numb1 + req.numb2</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;a request is being handled&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> service_testResponse(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建一个名为add_server的server，注册回调函数addCallback,返回类型为service_test</span></span><br><span class="line">    server = rospy.Service(<span class="string">&quot;add_server&quot;</span>, service_test, addCallback)</span><br><span class="line"></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;server is Ready.&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实具体思路和c++很相似，就有个坑，第五行那两个，我本来以为只要自定义两个当作输入输出就行了，后来发现好像不大行，必须严格按照他这个格式。<br><a name="Mphok"></a></p>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    rospy.wait_for_service(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    add_two_ints = rospy.ServiceProxy(<span class="string">&quot;add_server&quot;</span>, service_test)</span><br><span class="line">    resp = add_two_ints(x, y)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;sum:%lf&quot;</span>, resp.<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_client&quot;</span>)</span><br><span class="line">    x = <span class="number">0.1585</span></span><br><span class="line">    y = <span class="number">15.21</span></span><br><span class="line">    add_two_ints_client(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这位更是十分简洁，没啥问题。记得和srv里文件一定就行了。<br />说起来为啥C语言要搞成.h而python只要srv呢（<br><a name="DPKCw"></a></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705478826907-6a743179-d0cd-490d-be0c-760eb509f9b5.png#averageHue=%231e1b1a&amp;clientId=ubbf6ae85-b225-4&amp;from=paste&amp;height=492&amp;id=u874c5b1f&amp;originHeight=984&amp;originWidth=1476&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=191244&amp;status=done&amp;style=none&amp;taskId=ufb54405b-e108-494f-a287-1060d7db19b&amp;title=&amp;width=738" alt="image.png"></h3><p><a name="gMt1l"></a></p>
<h1 id="param"><a href="#param" class="headerlink" title="param"></a>param</h1><p><a name="QUW9p"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>举个栗子，我现在手里有一组数据，现在很多个节点都在想要得到我这个数据，如果使用前面的两种通讯方式，我开个topic在里面公麦喊数据显然不太合理，或者再开一个服务器呢？看起来好像不错，但是我们要维持这个端口一方面得一直开着这个节点，另一方面要不断的对外输出数据还得自己手写，而且各种数据类型还都不好处理。这个时候就需要我们的参数服务器登场了。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705485702889-26424fa6-e2ba-4130-ae19-545ad789e272.png#averageHue=%23f5f5f5&amp;clientId=u670af268-3edf-4&amp;from=paste&amp;height=280&amp;id=u95f2ebc6&amp;originHeight=559&amp;originWidth=1024&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=43576&amp;status=done&amp;style=none&amp;taskId=ufb874013-3788-41b9-8c63-bc7cf6c85c4&amp;title=&amp;width=512" alt="image.png"><br />在这里总计有三个角色，但是实际操作起来的时候，我们并不需要向之前一样像master注册身份，而是只要连接到master之后就可以进行全部的操作。<br />当然了为了书写的方便我们在实现中依旧将get和set分开写。值得注意的是，参数服务器不随着set的关闭而关闭，而是随着roscore的启动一直存在。<br><a name="aKczn"></a></p>
<h2 id="c-的实现"><a href="#c-的实现" class="headerlink" title="c++的实现"></a>c++的实现</h2><p><a name="UUER6"></a></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_set&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    string name = <span class="string">&quot;vbot&quot;</span>;</span><br><span class="line">    string geometry = <span class="string">&quot;rectangle&quot;</span>;</span><br><span class="line">    <span class="type">double</span> wheel_radius = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">int</span> wheel_num = <span class="number">4</span>;</span><br><span class="line">    <span class="type">bool</span> vision = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>&#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;vbot&#x27;</span>);               <span class="comment">// 字符串, 机器人的名字，char*</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);         <span class="comment">// 字符串, 形状，string</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius); <span class="comment">// 车轮半径double</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);        <span class="comment">// 车轮数量int</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;vision&quot;</span>, vision);              <span class="comment">// 是否具有视觉bool</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;base_size&quot;</span>, base_size);        <span class="comment">// 三维体积vector</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);        <span class="comment">// 传感器的id，map</span></span><br><span class="line">    <span class="comment">// 验证是否设置成功</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get name&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get geometry&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_radius&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_num&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get base_size&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get sensor_id&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们描述了一个机器人，将这个机器人的各个参数传入了参数服务器<br />值得说明的是，这里用了两种写法来写入数据，一种是用NodeHandle，一种直接调用了param里的函数<br />另外system这里不知道为什么会给个warning，无视就行了<br><a name="OjksJ"></a></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_get&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  <span class="comment">// 修改参数</span></span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;mybot&quot;</span>); <span class="comment">// 字符串, char*</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.2</span>, <span class="number">0.04</span>&#125;;</span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size); <span class="comment">// vector</span></span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">  sensor_id.<span class="built_in">insert</span>(&#123;<span class="string">&quot;ultrasonic&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line">  param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id); <span class="comment">// map</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line"></span><br><span class="line">  string name;</span><br><span class="line">  string geometry;</span><br><span class="line">  <span class="type">double</span> wheel_radius;</span><br><span class="line">  <span class="type">int</span> wheel_num;</span><br><span class="line">  <span class="type">bool</span> vision;</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;vision&quot;</span>, vision);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, name: %s, geometry: %s, wheel_radius: %lf, wheel: %d, vision: %s, base_size: (%lf, %lf)&quot;</span>,</span><br><span class="line">           name.<span class="built_in">c_str</span>(), geometry.<span class="built_in">c_str</span>(), wheel_radius, wheel_num, vision ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>,</span><br><span class="line">           base_size[<span class="number">0</span>], base_size[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> sensor : sensor_id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, %s_id: %d&quot;</span>, sensor.first.<span class="built_in">c_str</span>(), sensor.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除参数</span></span><br><span class="line"></span><br><span class="line">  nh.<span class="built_in">deleteParam</span>(<span class="string">&quot;vision&quot;</span>);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里好像也没有什么要说明的了，大家看看就行了<br><a name="PVfKq"></a></p>
<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(param_set src/param_set.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(param_get src/param_get.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_set</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_get</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><a name="X1725"></a></p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>param函数直接返回值，不存在则返回default_val，getparamcached函数好象是getparam的进阶版，加了个记搜？getparamnames返回所有值，以vector形式给出。<br><a name="EWhdA"></a></p>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705486990088-41376b0a-9140-4996-8f12-a6679c204d01.png#averageHue=%231f1b1b&amp;clientId=u670af268-3edf-4&amp;from=paste&amp;height=506&amp;id=uf0ed96e3&amp;originHeight=1012&amp;originWidth=1508&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=247069&amp;status=done&amp;style=none&amp;taskId=u607c6b38-a903-4ac5-ab4b-8f6db920f4c&amp;title=&amp;width=754" alt="image.png"><br><a name="dsWxB"></a></p>
<h2 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h2><p><a name="mnReF"></a></p>
<h3 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><a name="pLckx"></a></p>
<h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这个实在是没啥好讲的，看代码就行了（<br><a name="OTwIA"></a></p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p><a name="JC3y8"></a></p>
<h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><p>在实际中，有的时候通讯的时间是非常长的，而在通讯过程中，我们需要掌握中间值，比如我们要下载一个东西，我们可能时不时就要看一看下载进度，这个时候进度就是所需要的反馈feedback值<br />Action在结构上几乎和服务service相似，所以我暂时将其理解为service with feedback(?)<br><a name="yurY8"></a></p>
<h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>说实话这个实现有点阴间，我也只是把教程里的那个东西实现了一下，要自己纯手搓感觉不好实现（<br><a name="fAysR"></a></p>
<h3 id="文件分层："><a href="#文件分层：" class="headerlink" title="文件分层："></a>文件分层：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559399543-95ef64ac-bbf9-47a2-a75d-de38c50c3d9c.png#averageHue=%23060504&amp;clientId=ucf2197ff-0c36-4&amp;from=paste&amp;height=74&amp;id=ub74f1fe7&amp;originHeight=370&amp;originWidth=468&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=41409&amp;status=done&amp;style=none&amp;taskId=u7efe1ed1-fea5-401f-9729-b13df614435&amp;title=&amp;width=93.6" alt="image.png"><br><a name="CiRbu"></a></p>
<h3 id="laundry-action"><a href="#laundry-action" class="headerlink" title="laundry.action"></a>laundry.action</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># goal，洗衣类型 1:开始快洗;2:开始高温洗;3:开始浸泡洗</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_type</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># result，洗涤结果</span></span><br><span class="line"><span class="string">string</span> <span class="string">wash_result</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># feedback，洗涤的进度</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_percent</span></span><br></pre></td></tr></table></figure>
<p><a name="YMVMz"></a></p>
<h3 id="cmake-1"><a href="#cmake-1" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(action_test)</span><br><span class="line"><span class="comment"># catkin构建时依赖的组件包</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line"><span class="comment"># include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 配置action源文件，FILES将引用当前功能包目录的action目录中的*.action文件，自动生成一个头文件（*.h）</span></span><br><span class="line">add_action_files(</span><br><span class="line">  FILES</span><br><span class="line">  Laundry.action</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成消息时依赖于std_msgs、actionlib_msgs</span></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时依赖，描述了库、catkin构建依赖项和系统依赖的功能包</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES action_test</span></span><br><span class="line"> CATKIN_DEPENDS roscpp rospy std_msgs actionlib actionlib_msgs </span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(action_client src/action_client.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(action_server src/action_server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建库和可执行文件之前，预先生成依赖消息</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(action_client <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(action_server <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置目标链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_client</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_server</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><a name="mf7uX"></a></p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/client/simple_action_client.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionClient&lt;action_test::LaundryAction&gt; ActionClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doneCb</span><span class="params">(<span class="type">const</span> actionlib::SimpleClientGoalState &amp;state, <span class="type">const</span> action_test::LaundryResultConstPtr &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state.state_ == state.SUCCEEDED)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;反馈结果:%s&quot;</span>, result-&gt;wash_result.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;任务失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">activeCb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;动作已经被激活....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feedbackCb</span><span class="params">(<span class="type">const</span> action_test::LaundryFeedbackConstPtr &amp;feedback)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;洗涤进度为:%d%s&quot;</span>, feedback-&gt;wash_percent, <span class="string">&quot;%&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.实例化action客户端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作的名称，参数3默认为true，无需再调用ros::spin()，设置为false时需手动调用</span></span><br><span class="line">  <span class="function">ActionClient <span class="title">client</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 等待服务端启动</span></span><br><span class="line">  client.<span class="built_in">waitForServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.定义动作目标数据</span></span><br><span class="line">  action_test::LaundryGoal goal;</span><br><span class="line">  goal.wash_type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.发送目标，同时注册回调，处理反馈以及最终结果</span></span><br><span class="line">  <span class="comment">// 参数1是转换为Done时处理的回调函数，参数2为转换为Active时处理的回调函数，参数3为每当收到此目标的反馈时就调用的回调函数</span></span><br><span class="line">  client.<span class="built_in">sendGoal</span>(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="s4uDJ"></a></p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/server/simple_action_server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionServer&lt;action_test::LaundryAction&gt; ActionServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.收到action的goal后调用的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeCb</span><span class="params">(<span class="type">const</span> action_test::LaundryGoalConstPtr &amp;goal, ActionServer *server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取目标值</span></span><br><span class="line">  <span class="type">uint8_t</span> wash_type = goal-&gt;wash_type;</span><br><span class="line">  std::string wash_mode;</span><br><span class="line">  <span class="keyword">switch</span> (wash_type)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;快洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;高温洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;浸泡洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;目标值为%d，开始%s！&quot;</span>, wash_type, wash_mode.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应连续反馈</span></span><br><span class="line">  action_test::LaundryFeedback feedback;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    feedback.wash_percent = i;</span><br><span class="line">    server-&gt;<span class="built_in">publishFeedback</span>(feedback);</span><br><span class="line">    ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>).<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反馈结果</span></span><br><span class="line">  action_test::LaundryResult result;</span><br><span class="line">  result.wash_result = wash_mode + <span class="string">&quot;完成！&quot;</span>;</span><br><span class="line">  server-&gt;<span class="built_in">setSucceeded</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_server&quot;</span>);</span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="comment">// 3.实例化action服务端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作服务器名称，参数3为当一个新目标被接收时在一个单独的线程中被调用，参数4为告诉ActionServer是否在它出现时立即开始发布</span></span><br><span class="line">  <span class="function">ActionServer <span class="title">server</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, boost::bind(&amp;executeCb, _1, &amp;server), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Vpuri"></a></p>
<h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559548910-bc235096-7d99-4292-b382-b91268dfc171.png#averageHue=%231f1b1b&amp;clientId=ucf2197ff-0c36-4&amp;from=paste&amp;height=506&amp;id=ub6200bb0&amp;originHeight=1012&amp;originWidth=1508&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=286203&amp;status=done&amp;style=none&amp;taskId=u5d1e22a4-1937-479d-8cce-5e1ec8d2b05&amp;title=&amp;width=754" alt="image.png"></p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言中正则匹配的几种思路</title>
    <url>/2023/10/12/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="关于正则匹配的几种思路"><a href="#关于正则匹配的几种思路" class="headerlink" title="关于正则匹配的几种思路"></a>关于正则匹配的几种思路</h1><p>注意：所谓正则表达指一整个字符串，而部分字符串<br>下面来看这样一个实例：<br><strong>写出一个程序，当输入“yuanshen”的时候，输出为“yes”；输入“no”的时候，输出为“no”</strong><br><span id="more"></span></p>
<p>输入示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yuanshen</span><br></pre></td></tr></table></figure><br>输出示例：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">yes</span></span><br></pre></td></tr></table></figure></h2><p>输入示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qidong</span><br></pre></td></tr></table></figure><br>输出示例：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure></h2><p>输入示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">balaba</span><br></pre></td></tr></table></figure><br>输出示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error</span><br></pre></td></tr></table></figure></p>
<h2 id="思路一：无脑匹配"><a href="#思路一：无脑匹配" class="headerlink" title="思路一：无脑匹配"></a>思路一：无脑匹配</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char ans[10];</span><br><span class="line">    int i = 0;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; 9) &#123;</span><br><span class="line">        char c;</span><br><span class="line">        scanf(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        ans[i] = c;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= 2 &amp;&amp; ans[0] == <span class="string">&#x27;y&#x27;</span> &amp;&amp; </span><br><span class="line">    ans[1] == <span class="string">&#x27;u&#x27;</span>&amp;&amp;ans[2] == <span class="string">&#x27;a&#x27;</span>&amp;&amp;ans[3] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;ans[4] == <span class="string">&#x27;s&#x27;</span>&amp;&amp;</span><br><span class="line">    ans[5] == <span class="string">&#x27;h&#x27;</span>&amp;&amp;ans[6] == <span class="string">&#x27;e&#x27;</span>&amp;&amp;ans[7] == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">elif</span> (i &gt;= 2 &amp;&amp; ans[0] == <span class="string">&#x27;q&#x27;</span> &amp;&amp; </span><br><span class="line">    ans[1] == <span class="string">&#x27;i&#x27;</span>&amp;&amp;ans[2] == <span class="string">&#x27;d&#x27;</span>&amp;&amp;ans[3] == <span class="string">&#x27;o&#x27;</span>&amp;&amp;ans[4] == <span class="string">&#x27;n&#x27;</span>&amp;&amp;</span><br><span class="line">    ans[5] == <span class="string">&#x27;g&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种思路看来有点麻烦（蠢），但是笔者作为初学者第一反应就是这样的。<br>首先创建了一个char类型数组，用while持续输入，if换行符作为结束条件，最后再加上“\0”结束输入。<br>匹配阶段则是用if挨个元素匹配。</p>
<h4 id="总而言之，低效、麻烦而直观"><a href="#总而言之，低效、麻烦而直观" class="headerlink" title="总而言之，低效、麻烦而直观"></a><strong>总而言之，低效、麻烦而直观</strong></h4><h2 id="思路二：使用strcmp函数"><a href="#思路二：使用strcmp函数" class="headerlink" title="思路二：使用strcmp函数"></a>思路二：使用strcmp函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char ans[10];</span><br><span class="line">    int i = 0;</span><br><span class="line">    // Read characters into the array <span class="keyword">until</span> newline or reaching array size - 1</span><br><span class="line">    <span class="keyword">while</span> (i &lt; 9 &amp;&amp; scanf(<span class="string">&quot;%c&quot;</span>, &amp;ans[i]) == 1 &amp;&amp; ans[i] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Null-terminate the string</span><br><span class="line">    ans[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strncmp(ans, <span class="string">&quot;yuanshen&quot;</span>, 2) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strncmp(ans, <span class="string">&quot;qidong&quot;</span>, 2) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路二的输入方式与思路一大同小异，关键区别在于判断匹配的方式  </p>
<h3 id="简单介绍一下使用到的strcmp函数："><a href="#简单介绍一下使用到的strcmp函数：" class="headerlink" title="简单介绍一下使用到的strcmp函数："></a>简单介绍一下使用到的strcmp函数：</h3><p>strcmp 函数用于比较两个字符串是否相等。它返回一个整数，用于表示比较结果。这个整数的含义如下：<br>-返回值小于 0：表示第一个字符串小于第二个字符串。<br>-返回值等于 0：表示两个字符串相等。<br>-返回值大于 0：表示第一个字符串大于第二个字符串。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int strcmp(const char *str1, const char *str2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; (*str1 == *str2)) &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> *(unsigned char *)str1 - *(unsigned char *)str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上为strcmp函数的声明代码，采用指针达到字符串的匹配检测。</p>
<h2 id="思路三："><a href="#思路三：" class="headerlink" title="思路三："></a>思路三：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    char ans[10];</span><br><span class="line">    // Read a line of input into ans</span><br><span class="line">    fgets(ans, sizeof(ans), stdin);</span><br><span class="line"></span><br><span class="line">    // Remove newline character <span class="keyword">if</span> present</span><br><span class="line">    size_t len = strlen(ans);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; 0 &amp;&amp; ans[len - 1] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        ans[len - 1] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check <span class="keyword">if</span> ans starts with <span class="string">&quot;yuanshen&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (strncmp(ans, <span class="string">&quot;yuanshen&quot;</span>, 2) == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(strncmp(ans, <span class="string">&quot;qidong&quot;</span>, 2) == 0)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的基本思路是：<br>使用 fgets 函数读取用户输入的字符串，将其存储在名为 ans 的字符数组中，限制最大输入字符数为9。</p>
<p>检查读取到的字符串的长度，如果大于0且最后一个字符是换行符（’\n’），则将该换行符替换为字符串终止符（’\0’），以确保字符串正确终止。</p>
<p>使用 strncmp 函数比较 ans 字符串的前两个字符与预期字符串是否相等。如果相等，输出 “Yes”/“No”，<br>否则输出 “Error”。</p>
<p>（萌新勿骂）</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>正则匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer架构初步</title>
    <url>/2024/09/20/Transformer/</url>
    <content><![CDATA[<h3 id="Transformer-架构及技术细节详解"><a href="#Transformer-架构及技术细节详解" class="headerlink" title="Transformer 架构及技术细节详解"></a>Transformer 架构及技术细节详解</h3><p>Transformer 是近年来自然语言处理 (NLP) 和序列建模任务中最具影响力的神经网络架构。它通过<strong>自注意力机制</strong>替代了传统的 RNN (递归神经网络) 和 LSTM (长短期记忆网络)，并凭借其并行化计算和捕捉长距离依赖的能力，在机器翻译、文本生成、文本分类等任务中取得了显著的效果。</p>
<h4 id="Transformer-的核心模块："><a href="#Transformer-的核心模块：" class="headerlink" title="Transformer 的核心模块："></a>Transformer 的核心模块：</h4><ul>
<li><strong>多头自注意力机制 (Multi-Head Self-Attention)</strong></li>
<li><strong>前馈神经网络 (Feed-Forward Network, FFN)</strong></li>
<li><strong>残差连接 (Residual Connection) 和层归一化 (Layer Normalization)</strong></li>
<li><strong>位置编码 (Positional Encoding)</strong></li>
<li><strong>编码器-解码器架构 (Encoder-Decoder Architecture)</strong></li>
</ul>
<h4 id="Transformer-的架构整体由两个主要部分组成："><a href="#Transformer-的架构整体由两个主要部分组成：" class="headerlink" title="Transformer 的架构整体由两个主要部分组成："></a>Transformer 的架构整体由两个主要部分组成：</h4><ul>
<li><strong>编码器 (Encoder)</strong>：由多个相同的编码器层组成，每一层包含一个多头自注意力模块和一个前馈神经网络模块。</li>
<li><strong>解码器 (Decoder)</strong>：与编码器类似，但有额外的一个注意力机制，用于对编码器的输出进行处理。</li>
</ul>
<p>下面详细介绍各个组成模块。</p>
<h3 id="1-自注意力机制-Self-Attention-Mechanism"><a href="#1-自注意力机制-Self-Attention-Mechanism" class="headerlink" title="1. 自注意力机制 (Self-Attention Mechanism)"></a>1. <strong>自注意力机制 (Self-Attention Mechanism)</strong></h3><p>自注意力机制的核心目标是捕捉序列中的长距离依赖，通过为输入中的每个 token 分配不同的重要性权重。自注意力机制是 Transformer 中最关键的部分，它通过以下步骤实现：</p>
<h4 id="a-Query-Key-Value-矩阵计算："><a href="#a-Query-Key-Value-矩阵计算：" class="headerlink" title="a. Query, Key, Value 矩阵计算："></a>a. <strong>Query, Key, Value 矩阵计算</strong>：</h4><p>每个输入 token $( x_i )$ 经过线性变换，分别得到 Query $( Q_i )$，Key $( K_i )$，Value $( V_i )$：</p>
<script type="math/tex; mode=display">
Q_i = x_i W_Q, \quad K_i = x_i W_K, \quad V_i = x_i W_V</script><p>其中 $( W_Q )$, $( W_K )$, $( W_V )$ 是可学习的权重矩阵。这些矩阵的维度通常为 $( d_k \times d )$ （这里 $( d_k )$ 是 Key 矩阵的维度）。</p>
<h4 id="b-计算注意力得分："><a href="#b-计算注意力得分：" class="headerlink" title="b. 计算注意力得分："></a>b. <strong>计算注意力得分</strong>：</h4><p>通过 Query 和 Key 的点积计算每个 token 之间的相似性，接着通过 softmax 函数计算注意力权重：</p>
<script type="math/tex; mode=display">
\text{Attention}(Q, K, V) = \text{softmax} \left( \frac{QK^T}{\sqrt{d_k}} \right) V</script><p>这里的 $( \sqrt{d_k} )$ 是缩放因子，用来防止点积值过大导致梯度消失或爆炸问题。</p>
<h4 id="c-多头注意力机制-Multi-Head-Attention-："><a href="#c-多头注意力机制-Multi-Head-Attention-：" class="headerlink" title="c. 多头注意力机制 (Multi-Head Attention)："></a>c. <strong>多头注意力机制 (Multi-Head Attention)</strong>：</h4><p>为了让模型从不同的子空间中学习到不同的上下文信息，Transformer 使用多个不同的 Query、Key 和 Value 矩阵来进行多次自注意力计算。然后将各个头的输出拼接起来：</p>
<script type="math/tex; mode=display">
\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \text{head}_2, \dots, \text{head}_h)W_O</script><p>每个头的输出 ( \text{head}_i ) 是通过单独的 Query、Key、Value 矩阵计算的注意力。最终拼接结果通过线性变换 ( W_O ) 进行整合。</p>
<h3 id="2-前馈神经网络-Feed-Forward-Network-FFN"><a href="#2-前馈神经网络-Feed-Forward-Network-FFN" class="headerlink" title="2. 前馈神经网络 (Feed-Forward Network, FFN)"></a>2. <strong>前馈神经网络 (Feed-Forward Network, FFN)</strong></h3><p>每个注意力层的输出都会通过一个全连接前馈神经网络进行进一步处理。这个 FFN 通常包含两个线性变换和一个非线性激活函数：</p>
<script type="math/tex; mode=display">
\text{FFN}(x) = \text{ReLU}(xW_1 + b_1)W_2 + b_2</script><p>其中 $( W_1 )$ 和 $( W_2 )$ 是可学习的权重矩阵，$( b_1 )$ 和 $( b_2 )$ 是偏置向量。</p>
<h3 id="4-位置编码-Positional-Encoding"><a href="#4-位置编码-Positional-Encoding" class="headerlink" title="4. 位置编码 (Positional Encoding)"></a>4. <strong>位置编码 (Positional Encoding)</strong></h3><p>由于 Transformer 结构不依赖 RNN，因此它无法直接从序列中提取位置信息。为了让模型感知序列中的顺序，Transformer 引入了位置编码（Positional Encoding）。最常见的固定位置编码使用正弦和余弦函数表示：</p>
<script type="math/tex; mode=display">
PE_{(pos, 2i)} = \sin \left( \frac{pos}{10000^{2i/d}} \right), \quad PE_{(pos, 2i+1)} = \cos \left( \frac{pos}{10000^{2i/d}} \right)</script><p>其中 $( pos )$ 是序列中的位置，$( i )$ 是维度索引。这样的位置编码允许模型在不同的频率上为每个位置引入唯一的表示。</p>
<h3 id="6-掩码机制-Masking-Mechanism"><a href="#6-掩码机制-Masking-Mechanism" class="headerlink" title="6. 掩码机制 (Masking Mechanism)"></a>6. <strong>掩码机制 (Masking Mechanism)</strong></h3><p>掩码在 Transformer 中是一个重要的概念，特别是在解码器中，它确保模型只处理已生成的部分，避免将未来信息泄露给当前步骤。掩码主要分为两种：</p>
<ul>
<li><strong>填充掩码 (Padding Mask)</strong>：用于忽略序列中的填充部分（padding tokens），以避免这些无关信息影响模型的计算。</li>
<li><strong>未来掩码 (Future Mask or Look-ahead Mask)</strong>：应用于解码器，防止模型在训练时看到未来的 tokens。未来掩码会将位于当前位置之后的 tokens 的注意力分数置为 -∞。</li>
</ul>
<p>如果还有其他部分需要格式化为 LaTeX，欢迎指出，我可以继续帮助你完成整个文档的调整。</p>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>screen命令应用</title>
    <url>/2024/09/18/screen%E5%91%BD%E4%BB%A4%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><code>screen</code> 是一个非常强大的终端会话管理工具，它可以让你在多个终端窗口中运行任务，并在会话断开后继续保持任务的执行状态。特别适合长时间运行的任务或远程连接的任务管理。<br>对于远程服务器player简直是屠龙宝刀。</p>
<h3 id="常见用法："><a href="#常见用法：" class="headerlink" title="常见用法："></a>常见用法：</h3><p>以下是一些常见的 <code>screen</code> 命令和用法：</p>
<h4 id="1-启动新的-screen-会话"><a href="#1-启动新的-screen-会话" class="headerlink" title="1. 启动新的 screen 会话"></a>1. <strong>启动新的 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure>
<ul>
<li>启动一个新的 <code>screen</code> 会话。在新窗口中，你可以运行任何命令。</li>
<li>默认情况下，<code>screen</code> 会自动分配一个会话 ID。</li>
</ul>
<h4 id="2-启动带名称的-screen-会话"><a href="#2-启动带名称的-screen-会话" class="headerlink" title="2. 启动带名称的 screen 会话"></a>2. <strong>启动带名称的 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S session_name</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>-S</code> 选项为会话指定名称 <code>session_name</code>，便于管理多个会话。</li>
</ul>
<h4 id="3-分离（Detach）会话"><a href="#3-分离（Detach）会话" class="headerlink" title="3. 分离（Detach）会话"></a>3. <strong>分离（Detach）会话</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl + A + D</span><br></pre></td></tr></table></figure>
<ul>
<li>使用快捷键 <code>Ctrl + A + D</code>，可以将当前会话暂时分离（detach），但命令仍会继续在后台执行。</li>
</ul>
<h4 id="4-恢复（Reattach）已分离的会话"><a href="#4-恢复（Reattach）已分离的会话" class="headerlink" title="4. 恢复（Reattach）已分离的会话"></a>4. <strong>恢复（Reattach）已分离的会话</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -r</span><br></pre></td></tr></table></figure>
<ul>
<li>恢复上一个分离的 <code>screen</code> 会话。</li>
</ul>
<h4 id="5-查看现有-screen-会话"><a href="#5-查看现有-screen-会话" class="headerlink" title="5. 查看现有 screen 会话"></a>5. <strong>查看现有 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<ul>
<li>列出当前所有的 <code>screen</code> 会话，包括那些分离的会话。例如：<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">There are screens on:</span><br><span class="line">    <span class="number">1234</span><span class="selector-class">.session_name</span>    (Detached)</span><br><span class="line">    <span class="number">5678</span><span class="selector-class">.pts-0</span><span class="selector-class">.hostname</span>  (Attached)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-恢复指定的会话"><a href="#6-恢复指定的会话" class="headerlink" title="6. 恢复指定的会话"></a>6. <strong>恢复指定的会话</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure>
<ul>
<li>恢复名为 <code>session_name</code> 的会话。你可以通过 <code>screen -ls</code> 查看到所有会话名称。</li>
</ul>
<h4 id="7-杀掉-screen-会话"><a href="#7-杀掉-screen-会话" class="headerlink" title="7. 杀掉 screen 会话"></a>7. <strong>杀掉 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -X -S session_name quit</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-S session_name</code> 指定会话名，<code>-X quit</code> 用于杀掉该会话。</li>
</ul>
<h4 id="8-在会话中分屏操作"><a href="#8-在会话中分屏操作" class="headerlink" title="8. 在会话中分屏操作"></a>8. <strong>在会话中分屏操作</strong></h4><ul>
<li><p><strong>水平分屏：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl + A + S</span><br></pre></td></tr></table></figure>
<p>然后使用 <code>Ctrl + A + Tab</code> 来在不同的屏幕之间切换。</p>
</li>
<li><p><strong>垂直分屏：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl + A + |  <span class="comment"># 使用 | 进行垂直分屏</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关闭分屏：</strong><br>将光标聚焦到需要关闭的分屏窗口中，使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl + A + X</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-退出-screen-会话"><a href="#9-退出-screen-会话" class="headerlink" title="9. 退出 screen 会话"></a>9. <strong>退出 <code>screen</code> 会话</strong></h4><p>在会话窗口中直接输入 <code>exit</code>，或在分屏中通过 <code>Ctrl + A + X</code> 来关闭。</p>
<hr>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>nth_element函数深入</title>
    <url>/2024/10/02/nth-element%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<p><code>nth_element</code> 是 C++ 标准模板库 (STL) 中的一个非常有用的算法，它的功能是对范围内的元素进行部分排序，使得第 <code>n</code> 小的元素排到指定位置，其前面的元素都小于等于它，后面的元素都大于等于它，但前后的元素不一定是完全排序的。</p>
<p><code>nth_element</code> 算法基于<a href="http://zuweicun.top/2024/10/02/快排/">快速排序</a>，时间复杂度在平均情况下是 O(n)，最坏情况是 O(n^2)，但通过随机化选取枢轴可以避免最坏情况的频繁发生。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>first</code>: 范围的起始迭代器。</li>
<li><code>nth</code>: 指定要找到的第 n 小元素的迭代器。</li>
<li><code>last</code>: 范围的结束迭代器（不包括 <code>last</code> 指向的元素）。</li>
<li><code>comp</code>: 可选的自定义比较器，用于自定义排序规则。</li>
</ul>
<h3 id="nth-element-的核心特点"><a href="#nth-element-的核心特点" class="headerlink" title="nth_element 的核心特点"></a><code>nth_element</code> 的核心特点</h3><ul>
<li>部分排序：<code>nth_element</code> 不会对整个数组进行完全排序，而只会确保第 <code>n</code> 小的元素排到第 <code>n</code> 位。</li>
<li>前后区间无序：在 <code>nth_element</code> 之后，<code>[first, nth)</code> 中的元素只会比 <code>*nth</code> 小，<code>[nth+1, last)</code> 中的元素比 <code>*nth</code> 大，但这些子区间并不会是有序的。</li>
</ul>
<h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第5小的元素，并确保它位于vec[4]</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">4</span>, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第5小的元素是：&quot;</span> &lt;&lt; vec[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前面的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">begin</span>() + <span class="number">4</span>; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后面的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>() + <span class="number">5</span>; it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">第5小的元素是：5</span><br><span class="line">前面的元素：1<span class="number"> 2 </span>4<span class="number"> 3 </span></span><br><span class="line">后面的元素：10<span class="number"> 7 </span>9<span class="number"> 8 </span>6 </span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，<code>nth_element</code> 保证 <code>vec[4]</code> 是第 5 小的元素（因为从 0 开始计数），并且前 4 个元素小于等于 5，后面的元素大于等于 5，但前后部分的元素是无序的。</p>
<h3 id="nth-element-的应用场景"><a href="#nth-element-的应用场景" class="headerlink" title="nth_element 的应用场景"></a><code>nth_element</code> 的应用场景</h3><ol>
<li><strong>Top K 问题</strong>：你可以用 <code>nth_element</code> 来高效找到数组中前 K 大（或前 K 小）元素，而不需要对整个数组排序。</li>
<li><strong>中位数查找</strong>：用 <code>nth_element</code> 可以高效找到无序数组中的中位数，避免排序的 O(n log n) 时间开销。</li>
<li><strong>数据过滤</strong>：可以用 <code>nth_element</code> 来过滤掉过大或过小的元素，只保留前面或后面的一部分。</li>
</ol>
<h3 id="nth-element-与完整排序的对比"><a href="#nth-element-与完整排序的对比" class="headerlink" title="nth_element 与完整排序的对比"></a><code>nth_element</code> 与完整排序的对比</h3><p>相比 <code>std::sort</code> 或 <code>std::partial_sort</code>，<code>nth_element</code> 只确保第 <code>n</code> 小的元素在正确位置，并且左右部分并不保证是有序的。这使得它在需要部分排序的场景下更加高效。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>nth_element</code> 实际上是基于快速选择 (Quickselect) 算法的变种。它采用与快速排序类似的分区策略，只不过在每次分区后，它仅处理包含第 <code>n</code> 小元素的那一部分。这使得它比对整个数组进行完全排序更快。</p>
<ol>
<li>选取一个枢轴元素，并将比它小的元素放到左边，大的放到右边。</li>
<li>如果 <code>n</code> 恰好是枢轴的位置，则排序结束。</li>
<li>如果 <code>n</code> 小于枢轴的位置，则递归处理左半部分；如果 <code>n</code> 大于枢轴的位置，则递归处理右半部分。</li>
</ol>
<h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><p>可以通过自定义比较器改变 <code>nth_element</code> 的排序规则。例如，按照降序排列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义比较器：从大到小排序</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">4</span>, vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第5大的元素是：&quot;</span> &lt;&lt; vec[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS2初步</title>
    <url>/2024/03/11/ROS2%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p><a name="w3PS4"></a></p>
<h1 id="安装ROS2"><a href="#安装ROS2" class="headerlink" title="安装ROS2"></a>安装ROS2</h1><p>鱼香yyds<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; bash fishros</span><br></pre></td></tr></table></figure><br>卸载ROS<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove ros-foxy-* &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure><br><a name="hoy3W"></a><br><span id="more"></span></p>
<h1 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h1><p>与ROS1类似，ROS中同样具有节点，工作空间，功能包等概念<br><a name="ALm4g"></a></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><a name="RgFga"></a></p>
<h3 id="每一个节点都负责一个单独的模块。"><a href="#每一个节点都负责一个单独的模块。" class="headerlink" title="每一个节点都负责一个单独的模块。"></a>每一个节点都负责一个单独的模块。</h3><p>举个不太恰当的例子：外卖员小哥外卖给主播小姐姐吃，送累了就刷小姐姐直播跳舞，这里外卖小哥和小姐姐都是一个节点，大家共同构成了一个整体，营造出lianghao社会（bushi）<br />ROS2中的节点也是如此，每一个节点也是只负责一个单独的模块化的功能（比如一个节点负责控制车轮转动，一个节点负责从激光雷达获取数据、一个节点负责处理激光雷达的数据、一个节点负责定位等等）</p>
<blockquote>
<p><a name="sQg5i"></a></p>
<h3 id="节点通信（详见）"><a href="#节点通信（详见）" class="headerlink" title="节点通信（详见）"></a>节点通信（详见）</h3></blockquote>
<p>ROS2中主要有以下四种通信方式：</p>
<ul>
<li>话题-topics</li>
<li>服务-services</li>
<li>动作-Action</li>
<li>参数-parameters</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1709952196063-33689e90-6391-444f-b3f8-054f02b98e34.gif#averageHue=%23faf7fb&amp;clientId=uc1f625e0-63bc-4&amp;from=drop&amp;id=u42629f68&amp;originHeight=480&amp;originWidth=854&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=2993370&amp;status=done&amp;style=none&amp;taskId=u5f22b082-1278-4c51-a0b8-8d390e71c3e&amp;title=" alt="Nodes-TopicandService.gif"></p>
<p><a name="SasOs"></a></p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>需要使用指令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;</span><br></pre></td></tr></table></figure><br><a name="qUDBx"></a></p>
<h3 id="命令行查看节点信息"><a href="#命令行查看节点信息" class="headerlink" title="命令行查看节点信息"></a>命令行查看节点信息</h3><p>这里涉及以下两个概念：</p>
<ul>
<li>GUI（Graphical User Interface）就是平常我们说的图形用户界面，大家用的Windows是就是可视化的，我们可以通过鼠标点击按钮等图形化交互完成任务。</li>
<li><p>CLI（Command-Line Interface）就是命令行界面了，我们所用的终端，黑框框就是命令行界面，没有图形化。<br><a name="JdGKJ"></a></p>
<h3 id="节点相关CLI："><a href="#节点相关CLI：" class="headerlink" title="节点相关CLI："></a>节点相关CLI：</h3><p>列举几个常用的：<br />运行节点(</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>查看节点列表(常用)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>查看节点信息(常用)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>重映射节点名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</span><br></pre></td></tr></table></figure>
<p><a name="qg3CI"></a></p>
<h2 id="工作空间-amp-amp-功能包："><a href="#工作空间-amp-amp-功能包：" class="headerlink" title="工作空间&amp;&amp;功能包："></a>工作空间&amp;&amp;功能包：</h2><p>想要找到一个可执行文件（节点）必须依赖于一个功能包，这些包可以统一放在某个工作空间里。<br />创建工作空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p turtle_ws/src</span><br><span class="line"><span class="built_in">cd</span> turtle_ws/src</span><br></pre></td></tr></table></figure>
<p>功能包：<br />可以理解为存放节点的容器。<br />ROS2中功能包根据编译方式的不同分为三种类型。</p>
</li>
<li><p>ament_python，适用于python程序</p>
</li>
<li>cmake，适用于C++</li>
<li><p>ament_cmake，适用于C++程序,是cmake的增强版<br><a name="YUrMN"></a></p>
<h3 id="功能包获取"><a href="#功能包获取" class="headerlink" title="功能包获取"></a>功能包获取</h3></li>
<li><p>安装一般使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ros-&lt;version&gt;-package_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动编译：有点麻烦，一般都是需要对包进行修改的时候shiytong<br><a name="mddWh"></a></p>
<h3 id="相关指令——ros2pkg"><a href="#相关指令——ros2pkg" class="headerlink" title="相关指令——ros2pkg"></a>相关指令——ros2pkg</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create       Create a new ROS2 package</span><br><span class="line">executables  Output a list of package specific executables</span><br><span class="line">list         Output a list of available packages</span><br><span class="line">prefix       Output the prefix path of a package</span><br><span class="line">xml          Output the XML of the package manifest or a specific tag</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>1.创建功能包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create &lt;package-name&gt;  --build-type  &#123;cmake,ament_cmake,ament_python&#125;  --dependencies &lt;依赖名字&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><strong>2.列出可执行文件</strong><br />列出所有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg executablesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>列出某个功能包的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg executables turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709952853767-34253709-40e1-445a-9df0-99407cbf16e4.png#averageHue=%23262321&amp;clientId=uc1f625e0-63bc-4&amp;from=paste&amp;id=u29043447&amp;originHeight=82&amp;originWidth=430&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5ab1ac60-bfbc-4ace-97a5-3a014d2af0f&amp;title=" alt=""><br /><strong>3.列出所有的包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><strong>4.输出某个包所在路径的前缀</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg prefix  &lt;package-name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>比如小乌龟</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg prefix turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><strong>5.列出包的清单描述文件</strong><br /><strong>每一个功能包都有一个标配的manifest.xml文件，用于记录这个包的名字，构建工具，编译信息，拥有者，干啥用的等信息。</strong><br /><strong>通过这个信息，就可以自动为该功能包安装依赖，构建时确定编译顺序等</strong><br />查看小乌龟模拟器功能包的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg xml turtlesim</span><br></pre></td></tr></table></figure>
<p><a name="WrcLt"></a></p>
<h2 id="colcon"><a href="#colcon" class="headerlink" title="colcon:"></a>colcon:</h2><p>colcon其是就是个功能包的构建工具，说白了就是编译器。<br />ros2默认死没有colcon的，所以需要安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-colcon-common-extensions</span><br></pre></td></tr></table></figure>
<p><a name="BzyYh"></a></p>
<h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p><a name="moZ8W"></a></p>
<h3 id="5-1-只编译一个包"><a href="#5-1-只编译一个包" class="headerlink" title="5.1 只编译一个包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_51-%e5%8f%aa%e7%bc%96%e8%af%91%e4%b8%80%e4%b8%aa%e5%8c%85">5.1 只编译一个包</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><a name="Mb0AY"></a></p>
<h3 id="5-2-不编译测试单元"><a href="#5-2-不编译测试单元" class="headerlink" title="5.2 不编译测试单元"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_52-%e4%b8%8d%e7%bc%96%e8%af%91%e6%b5%8b%e8%af%95%e5%8d%95%e5%85%83">5.2 不编译测试单元</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME  --cmake-args -DBUILD_TESTING=0Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><a name="Dt5J5"></a></p>
<h3 id="5-3-运行编译的包的测试"><a href="#5-3-运行编译的包的测试" class="headerlink" title="5.3 运行编译的包的测试"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_53-%e8%bf%90%e8%a1%8c%e7%bc%96%e8%af%91%e7%9a%84%e5%8c%85%e7%9a%84%e6%b5%8b%e8%af%95">5.3 运行编译的包的测试</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon testCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p><a name="Gacar"></a></p>
<h3 id="5-4-允许通过更改src下的部分文件来改变install（重要）"><a href="#5-4-允许通过更改src下的部分文件来改变install（重要）" class="headerlink" title="5.4 允许通过更改src下的部分文件来改变install（重要）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_54-%e5%85%81%e8%ae%b8%e9%80%9a%e8%bf%87%e6%9b%b4%e6%94%b9src%e4%b8%8b%e7%9a%84%e9%83%a8%e5%88%86%e6%96%87%e4%bb%b6%e6%9d%a5%e6%94%b9%e5%8f%98install%ef%bc%88%e9%87%8d%e8%a6%81%ef%bc%89">5.4 允许通过更改src下的部分文件来改变install（重要）</a></h3><p>（每次调整 python 脚本时都不必重新build了）</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">colcon build <span class="comment">--symlink-install</span></span><br></pre></td></tr></table></figure>
<p><a name="DEwTp"></a></p>
<h2 id="手撸节点test（c-）"><a href="#手撸节点test（c-）" class="headerlink" title="手撸节点test（c++）"></a>手撸节点test（c++）</h2><p>由于python的运行效率实在是一言难尽，我们只学习C++_的版本<br><a name="b6gfN"></a></p>
<h3 id="创建工作空间-amp-amp-功能包"><a href="#创建工作空间-amp-amp-功能包" class="headerlink" title="创建工作空间&amp;&amp; 功能包"></a>创建工作空间&amp;&amp; 功能包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p town_ws/src</span><br><span class="line"><span class="built_in">cd</span> town_ws/src</span><br><span class="line">ros2 pkg create village_wang --build-type ament_cmake --dependencies rclcpp</span><br></pre></td></tr></table></figure>
<p>创建完成的目录结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709953867147-9f288dcf-5e47-4151-9465-e4418685f654.png#averageHue=%23300a24&amp;clientId=u7f35f781-53fd-4&amp;from=drop&amp;id=ua3e86124&amp;originHeight=118&amp;originWidth=212&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=7896&amp;status=done&amp;style=none&amp;taskId=u4fdf03cc-db2e-4232-9a0f-487eae2ca95&amp;title=" alt="image-20210727193256467.png"><br><a name="XZHy1"></a></p>
<h3 id="POP方式编写节点"><a href="#POP方式编写节点" class="headerlink" title="POP方式编写节点"></a>POP方式编写节点</h3><p>在village_wang/src中创建wang2.cpp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    /*初始化rclcpp</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;rclcpp::Node&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    // 打印一句自我介绍</span><br><span class="line">    RCLCPP_INFO(node-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗wang2.&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数中首先初始化rclcpp，然后新建了一个Node节点的对象，命名为wang2，接着使用rclcpp让这个节点暴露在外面，并检测退出信号（Ctrl+C），检测到退出信号后，就会执行rcl.shutdown()关闭节点。<br><a name="FGd6F"></a></p>
<h4 id="添加到cmakelists"><a href="#添加到cmakelists" class="headerlink" title="添加到cmakelists"></a>添加到cmakelists</h4><p>在CmakeLists.txt最后一行加入下面两行代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">add<span class="constructor">_executable(<span class="params">wang2_node</span> <span class="params">src</span><span class="operator">/</span><span class="params">wang2</span>.<span class="params">cpp</span>)</span></span><br><span class="line">ament<span class="constructor">_target_dependencies(<span class="params">wang2_node</span> <span class="params">rclcpp</span>)</span></span><br></pre></td></tr></table></figure>
<p>添加这两行代码的目的是让编译器编译wang2.cpp这个文件，不然不会主动编译。接着在上面两行代码下面添加下面的代码。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  wang2_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个是C++比Python要麻烦的地方，需要手动将编译好的文件安装到install/village_wang/lib/village_wang下.<br><a name="WfmFe"></a></p>
<h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h4><p>打开vscode终端，进入town_ws<br><a name="Z1Ujk"></a></p>
<h3 id="编译节点"><a href="#编译节点" class="headerlink" title="编译节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e7%bc%96%e8%af%91%e8%8a%82%e7%82%b9">编译节点</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build</span><br></pre></td></tr></table></figure>
<p><a name="FFV99"></a></p>
<h3 id="source环境"><a href="#source环境" class="headerlink" title="source环境"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=source%e7%8e%af%e5%a2%83">source环境</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> install/setup.bash</span><br></pre></td></tr></table></figure>
<p><a name="xqzlR"></a></p>
<h3 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e8%bf%90%e8%a1%8c%e8%8a%82%e7%82%b9">运行节点</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 run village_wang wang2_node</span><br></pre></td></tr></table></figure>
<p>不出意外，你可以看到王二的自我介绍。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954465823-94f63561-dbe0-4ac6-90a6-3e3720ef2823.png#averageHue=%231f1d1c&amp;clientId=u7f35f781-53fd-4&amp;from=drop&amp;id=ucbef2116&amp;originHeight=317&amp;originWidth=644&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=105682&amp;status=done&amp;style=none&amp;taskId=u3d85a105-b651-4405-8a1d-378ebd2cea7&amp;title=" alt="a85481a9b56ae5cf6bee46a440140235.png"><br />当节点运行起来后，使用ros2 node list 指令来查看现有的节点。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954606260-0bd6726b-4a2b-4717-bf95-eba0cac67750.png#averageHue=%23363534&amp;clientId=u7f35f781-53fd-4&amp;from=drop&amp;id=u21cafeca&amp;originHeight=68&amp;originWidth=437&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=14564&amp;status=done&amp;style=none&amp;taskId=ubda76a82-e9ab-43e9-943a-dd83f8acea4&amp;title=" alt="972b7669eb967a31c2a0d959b7301ad9.png"><br><a name="MJsrM"></a></p>
<h2 id="OPP方式编写节点"><a href="#OPP方式编写节点" class="headerlink" title="OPP方式编写节点"></a>OPP方式编写节点</h2><p>还是在wang2.cpp输入代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleDogNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">SingleDogNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="mRwWY"></a></p>
<h3 id="修改cmakelists-amp-amp-运行"><a href="#修改cmakelists-amp-amp-运行" class="headerlink" title="修改cmakelists&amp;&amp;运行"></a>修改cmakelists&amp;&amp;运行</h3><p>同上，不多赘述<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709965221810-a121ef27-b3a9-42f7-a674-f23eee0c3e3b.png#averageHue=%231d1d1c&amp;clientId=u488a9513-274b-4&amp;from=drop&amp;id=u35b36f1c&amp;originHeight=1344&amp;originWidth=1108&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=230404&amp;status=done&amp;style=none&amp;taskId=u6451a532-fc8b-4701-8e02-2a8ab5680a6&amp;title=" alt="8014891cb75b9e90255db630b7115fad.png"><br />运行成功。<br><a name="zvknJ"></a></p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>鱼香教程里的举例实在是难以忘却，这里我cv过来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这里的王二和李四两个节点，通过话题来互相通信（传递数据）。</span><br><span class="line"></span><br><span class="line">李四节点会创建一个发布者（Publisher）来发布一个话题（艳娘传奇,小鱼取个英文名叫sexy_girl）。单身汉王二节点，他创建了一个订阅者（Subscriber）来订阅李四发布的话题sexy_girl。</span><br><span class="line"></span><br><span class="line">那艳娘传奇的内容是什么呢？我们暂且规定为由文字组成的字符串（连插图都没的那种）。</span><br><span class="line"></span><br><span class="line">[object Promise]</span><br><span class="line">李四王二通信模型是一个一对一（一个发布者，一个订阅者）的模型，除此之外ROS2中话题通信其实还可以是1对n,n对1,n对n的。</span><br></pre></td></tr></table></figure>
<p><a name="HgXzG"></a></p>
<h3 id="话题通讯"><a href="#话题通讯" class="headerlink" title="话题通讯"></a>话题通讯</h3><p><a name="jWcs8"></a></p>
<h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4></li>
<li><p>话题名字是关键,发布订阅接口类型要相同，发布的是字符串，接受也要用字符串来接收;</p>
</li>
<li>同一个人(节点)可以订阅多个话题，同时也可以发布多个话题，就像一本书的作者也可以是另外一本书的读者;</li>
<li>同一个小说不能有多个作者（版权问题），但跟小说不一样，同一个话题可以有多个发布者。<br><a name="YaREO"></a><h4 id="相关工具："><a href="#相关工具：" class="headerlink" title="相关工具："></a>相关工具：</h4><a name="FnJns"></a><h5 id="rqt-graph"><a href="#rqt-graph" class="headerlink" title="rqt_graph:"></a>rqt_graph:</h5>ROS2作为一个强大的工具，在运行过程中，我们是可以通过命令来看到节点和节点之间的数据关系的。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709972464260-688eb5ba-8779-4843-ad42-7a00609803f8.png#averageHue=%23e9e9e8&amp;clientId=ud645a189-b8aa-4&amp;from=drop&amp;id=ud5918dcf&amp;originHeight=591&amp;originWidth=761&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=53857&amp;status=done&amp;style=none&amp;taskId=u304193b0-36aa-4ccc-9cbe-cdec436b6b7&amp;title=" alt="image-20210803113450234.png"></li>
</ul>
<p><a name="Cm70r"></a></p>
<h5 id="命令行界面——CLI"><a href="#命令行界面——CLI" class="headerlink" title="命令行界面——CLI"></a>命令行界面——CLI</h5><p>返回系统活动所有主题列表<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure><br>增加消息类型<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure><br>打印实时话题内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic <span class="built_in">echo</span> /chatter</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>查看主题信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic info  /chatter</span><br></pre></td></tr></table></figure><br>查看消息类型<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure><br>手动发布命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 topic pub /chatter std_msgs/msg/String <span class="string">&#x27;data: &quot;123&quot;&#x27;</span></span><br></pre></td></tr></table></figure><br><a name="B7agU"></a></p>
<h3 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h3><p>创建话题订阅者的一般流程：</p>
<ol>
<li>导入订阅的话题接口类型</li>
<li>创建订阅回调函数</li>
<li>声明并创建订阅者</li>
<li>编写订阅回调处理逻辑<br><a name="vIZWC"></a><h3 id="王三"><a href="#王三" class="headerlink" title="王三"></a>王三</h3></li>
</ol>
<ul>
<li><p>将wang2.cpp代码修改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/string.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/u_int32.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using std::placeholders::_1;</span><br><span class="line">using std::placeholders::_2;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span><br><span class="line">*/</span><br><span class="line">class SingleDogNode : public rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数,有一个参数为节点名称</span><br><span class="line">    SingleDogNode(std::string name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 打印一句自我介绍</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>, name.c_str());</span><br><span class="line">         // 创建一个订阅者来订阅李四写的小说，通过名字sexy_girl</span><br><span class="line">        sub_novel = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, 10, std::<span class="built_in">bind</span>(&amp;SingleDogNode::topic_callback, this, _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 声明一个订阅者（成员变量）,用于订阅小说</span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_novel;</span><br><span class="line"></span><br><span class="line">    // 收到话题数据的回调函数</span><br><span class="line">    void topic_callback(const std_msgs::msg::String::SharedPtr msg)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;朕已阅：&#x27;%s&#x27;&quot;</span>, msg-&gt;data.c_str());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用C++订阅话题，需要添加对应的消息类型头文件：</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">string.hpp</span>&quot;</span></span><br><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">u_int</span>32.<span class="string">hpp</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>创建订阅者和发布者时依然使用this-&gt;create_subscription和this-&gt;create_publisher方法。<br />C++中创建一个订阅者，需要传入话题类型、话题名称、所要绑定的回调函数，以及通信Qos.<br /><strong>std::bind()</strong><br /><strong>C++的类成员函数不能像普通函数那样用于回调，因为每个成员函数都需要有一个对象实例去调用它。 通常情况下，要实现成员函数作为回调函数：一种过去常用的方法就是把该成员函数设计为静态成员函数（因为类的成员函数需要隐含的this指针 而回调函数没有办法提供），但这样做有一个缺点，就是会破坏类的结构性，因为静态成员函数只能访问该类的静态成员变量和静态成员函数，不能访问非静态的，要解决这个问题，可以把对象实例的指针或引用做为参数传给它。 后面就可以靠这个对象实例的指针或引用访问非静态成员函数。另一种办法就是使用std::bind和std::function结合实现回调技术。(目前还看不太懂)</strong></p>
</li>
<li><p>编译运行</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure>
</li>
<li><p>source运行<br><a name="KES9k"></a></p>
<h3 id="李四"><a href="#李四" class="headerlink" title="李四"></a>李四</h3><p>突然发现李四的源码在教程里没有，自己搓了个试试。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的数组</span></span><br><span class="line">std::string novel[] = &#123;</span><br><span class="line"><span class="string">&quot;第一回：潋滟湖 1 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第二回：潋滟湖 2 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第三回：潋滟湖 3 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第四回：潋滟湖 4 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第五回：潋滟湖 5 次偶遇胡艳娘&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的索引</span></span><br><span class="line"><span class="type">int</span> nb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做WriterNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriterNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">WriterNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是%s,我是一名作家！&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建一个发布者来发布小说内容，通过名字sexy_girl</span></span><br><span class="line">    pub_novel = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 创建一个定时器，每隔五秒发布一章小说内容</span></span><br><span class="line">    timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>), std::<span class="built_in">bind</span>(&amp;WriterNode::timer_callback, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 声明一个发布者（成员变量）,用于发布小说内容</span></span><br><span class="line">rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_novel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个定时器（成员变量）,用于定时发布小说内容</span></span><br><span class="line">rclcpp::TimerBase::SharedPtr timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器触发的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个小说内容的消息</span></span><br><span class="line">    std_msgs::msg::String novel_msg;</span><br><span class="line">    <span class="comment">// 判断小说内容的索引是否超出数组范围</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt; <span class="built_in">sizeof</span>(novel) / <span class="built_in">sizeof</span>(novel[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取小说内容</span></span><br><span class="line">        novel_msg.data = novel[nb];</span><br><span class="line">        <span class="comment">// 发布小说内容</span></span><br><span class="line">        pub_novel-&gt;<span class="built_in">publish</span>(novel_msg);</span><br><span class="line">        <span class="comment">// 打印发布的小说内容</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;发布小说内容：%s&quot;</span>, novel_msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 小说内容的索引加一</span></span><br><span class="line">        nb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 小说内容已经发布完毕，取消定时器</span></span><br><span class="line">        timer-&gt;<span class="built_in">cancel</span>();</span><br><span class="line">        <span class="comment">// 打印结束语</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;小说已经完结，感谢大家的支持！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv); <span class="comment">// 初始化rclcpp</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;WriterNode&gt;(<span class="string">&quot;li4&quot;</span>); <span class="comment">// 新建一个节点</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node); <span class="comment">// 保持节点运行，检测是否收到退出指令（Ctrl+C）</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>(); <span class="comment">// 关闭rclcpp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用Ctrl+Shift+5切分一个终端出来，输入下面命令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 run  village_li  li4_node</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709973381445-1adfa01f-8fab-4b2e-862b-37be052c45b0.png#averageHue=%232e2e2e&amp;clientId=ud645a189-b8aa-4&amp;from=drop&amp;id=u0011d78d&amp;originHeight=243&amp;originWidth=1362&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=120502&amp;status=done&amp;style=none&amp;taskId=u430b4fc9-7dae-41d0-813a-b956f4cda2a&amp;title=" alt="image-20210804074600329.png"><br><a name="ffgNa"></a></p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>C++中创建一个发布者也比较简单，使用this-&gt;create_publisher即可创建一个发布者。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">pub_</span> = this-&gt;create_publisher&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;sexy_girl_money&quot;</span>,<span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这里提供了三个参数，分别是该发布者要发布的话题名称（sexy_girl_money）、发布者要发布的话题类型（std_msgs::msg::UInt32）、Qos（10）<br><a name="hnt3J"></a></p>
<h3 id="服务和接口"><a href="#服务和接口" class="headerlink" title="服务和接口"></a>服务和接口</h3><p><a name="RpsO0"></a></p>
<h3 id="接口：接口其实是一种规范"><a href="#接口：接口其实是一种规范" class="headerlink" title="接口：接口其实是一种规范"></a>接口：接口其实是一种规范</h3><p>当接口类型统一的时候，适配显然就不是问题了，大家的服务和响应都是一致的规范格式<br><a name="MYwEG"></a></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><a name="eTGJG"></a></p>
<h5 id="查看接口列表（当前环境下）"><a href="#查看接口列表（当前环境下）" class="headerlink" title="查看接口列表（当前环境下）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_41%e6%9f%a5%e7%9c%8b%e6%8e%a5%e5%8f%a3%e5%88%97%e8%a1%a8%ef%bc%88%e5%bd%93%e5%89%8d%e7%8e%af%e5%a2%83%e4%b8%8b%ef%bc%89">查看接口列表（当前环境下）</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface list</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811318-9c2e1b9d-119d-4c2d-80ee-8b9effa311de.png#averageHue=%23282828&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=u6b0684ac&amp;originHeight=366&amp;originWidth=700&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueea0a066-269f-4a44-908b-66eff688a8a&amp;title=" alt=""><br><a name="gfepk"></a></p>
<h5 id="查看所有接口包"><a href="#查看所有接口包" class="headerlink" title="查看所有接口包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_42%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3%e5%8c%85">查看所有接口包</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface packages</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811026-b7326182-2b56-499b-bf97-5580abcd8c68.png#averageHue=%23252525&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=uc9cacca0&amp;originHeight=500&amp;originWidth=444&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uba98428e-3d16-4193-926e-7b18b031853&amp;title=" alt=""><br><a name="EDlMf"></a></p>
<h5 id="查看某一个包下的所有接口"><a href="#查看某一个包下的所有接口" class="headerlink" title="查看某一个包下的所有接口"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_43%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e5%8c%85%e4%b8%8b%e7%9a%84%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3">查看某一个包下的所有接口</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface package std_msgs</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811203-ae44eadd-e3cf-41ce-8f6e-17452d028e89.png#averageHue=%23262626&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=u11110c34&amp;originHeight=246&amp;originWidth=669&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue6b53307-54e5-482e-9233-ae6dfa80bfa&amp;title=" alt=""><br><a name="kgaGi"></a></p>
<h5 id="查看某一个接口详细的内容"><a href="#查看某一个接口详细的内容" class="headerlink" title="查看某一个接口详细的内容"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_44%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e8%af%a6%e7%bb%86%e7%9a%84%e5%86%85%e5%ae%b9">查看某一个接口详细的内容</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811860-73d814e9-0ad4-4f3c-8b03-cc84d50b8e00.png#averageHue=%23292929&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=uff812660&amp;originHeight=114&amp;originWidth=764&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufbd1877f-055c-45bb-b469-d1c4c124258&amp;title=" alt=""><br><a name="YVXNq"></a></p>
<h5 id="输出某一个接口所有属性"><a href="#输出某一个接口所有属性" class="headerlink" title="输出某一个接口所有属性"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_45-%e8%be%93%e5%87%ba%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e6%89%80%e6%9c%89%e5%b1%9e%e6%80%a7">输出某一个接口所有属性</a></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 interface proto sensor_msgs/msg/Image</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811870-5f07a163-7673-4f56-a3c5-337c13939d9a.png#averageHue=%23212121&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=u9b08528d&amp;originHeight=208&amp;originWidth=611&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf0315698-41a2-4e5e-b260-a5dff7aa66e&amp;title=" alt=""></p>
</li>
</ul>
<p><a name="PJTRk"></a></p>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>显然，服务和话题的区别在于话题是没有返回的，只是单向的数据传递。而服务是双向的客户端发送，服务端响应。<br><a name="JJ4MV"></a></p>
<h3 id="自定义话题接口"><a href="#自定义话题接口" class="headerlink" title="自定义话题接口"></a>自定义话题接口</h3><ul>
<li>新建工作空间</li>
</ul>
<p>在town_ws的src文件夹下，运行下面的指令，即可完成village_interfaces功能包的创建。    <br />     <strong>注意，这里包的编译类型我们使用ament_cmake方式。</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 pkg create village_interfaces --build-type ament_cmake </span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037304935-3b720491-175f-421f-b8b8-cd410932ca33.png#averageHue=%23212121&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u0e50a9c7&amp;originHeight=179&amp;originWidth=503&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=15650&amp;status=done&amp;style=none&amp;taskId=u951c0305-6102-4c35-885a-e55d3f3c93b&amp;title=" alt="image-20210809151545012.png"></p>
<ul>
<li>新建msg文件和Novel.msg（小说消息）</li>
</ul>
<p><strong>注意:msg文件开头首字母一定要大写，ROS2强制要求，盲猜应该是为了和类名保持一致</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd village_interfaces</span><br><span class="line">mkdir msg</span><br><span class="line">touch Novel.msg </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>编写Novel.msg内容</li>
</ul>
<p>我们的目的是给李四的小说每一章增加一张图片，原来李四写小说是对外发布一个std_msgs/msg/String字符串类型的数据。<br />而发布图片的格式，我们需要采用ros自带的传感器消息接口中的图片sensor_msgs/msg/Image数据类型，所以我们新的消息文件的内容就是将两者合并，在ROS2中可以写做这样：<br /><strong>在msg文件中可以使用#号添加注释。</strong><br><figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="type">#</span> 标准消息接口<span class="type">std_msgs</span>下的<span class="built_in">String</span>类型</span><br><span class="line"><span class="type">std_msgs</span><span class="operator">/</span><span class="built_in">String</span> <span class="variable">content</span></span><br><span class="line"><span class="type">#</span> 图像消息，调用<span class="type">sensor_msgs</span>下的<span class="built_in">Image</span>类型</span><br><span class="line"><span class="type">sensor_msgs</span><span class="operator">/</span><span class="built_in">Image</span> <span class="variable">image</span></span><br></pre></td></tr></table></figure><br>这种组合结构图如下：<br />[object Promise]<br />这个图一共三层，第一层是消息定义层，第二层是ROS2已有的std_msgs,sensor_msgs，其组成关系是由下一层组合成上一层。<br />最下面一层string、uint8、uint32是ROS2中的原始数据类型，原始数据类型有下面几种，ROS2中所有的接口都是由这些原始数据类型组成。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="type">byte</span></span><br><span class="line">char</span><br><span class="line"><span class="type">float32</span>,<span class="type">float64</span></span><br><span class="line"><span class="type">int8</span>,<span class="type">uint8</span></span><br><span class="line"><span class="type">int16</span>,<span class="type">uint16</span></span><br><span class="line"><span class="type">int32</span>,<span class="type">uint32</span></span><br><span class="line"><span class="type">int64</span>,<span class="type">uint64</span></span><br><span class="line"><span class="type">string</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Another way</li>
</ul>
<p>我们不使用std_msgs/String 而是直接使用最下面一层的string。<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure></p>
<ul>
<li>说明</li>
</ul>
<p>如何知道，std_msgs/String是由基础数据类型string组成的，其实可以通过下面的指令来查看<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">show</span> <span class="symbol">std_msgs</span>/<span class="symbol">msg</span>/<span class="symbol">String</span></span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">string</span> <span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>原来std_msgs的String就是包含一个叫变量名为data的string类型变量，这也是在4.2和4.3章节中代码要用.data才能拿到真正的数据的原因：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> <span class="built_in">String</span></span><br><span class="line">msg = <span class="built_in">String</span>()</span><br><span class="line">msg.data = <span class="string">&#x27;第%d回：潋滟湖 %d 次偶遇胡艳娘&#x27;</span> % (self.i,self.i)</span><br><span class="line"><span class="comment"># msg 是 std_msgs.msg.String() 的对象</span></span><br><span class="line"><span class="comment"># msg.data data是string类型的对象，其定义是string data</span></span><br></pre></td></tr></table></figure><br>最终Novel.msg<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure></p>
<ul>
<li>修改Cmakelists.txt</li>
</ul>
<p>完成了代码的编写还不够，我们还需要在CMakeLists.txt中告诉编译器，你要给我把Novel.msg转换成Python库和C++的头文件。<br />直接添加下面的代码到CMakeLists.txt即可。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#添加对sensor_msgs的</span><br><span class="line"><span class="built_in">find_package</span>(sensor_msgs REQUIRED)</span><br><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">#添加消息文件和依赖</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line"><span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">    DEPENDENCIES sensor_msgs</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><br>find_package用于查找rosidl_default_generators位置，下面rosidl_generate_interfaces就是声明msg文件所属的工程名字、文件位置以及依赖DEPENDENCIES。<br /><strong>踩坑报告：</strong></p>
<ul>
<li><strong>重点强调一下依赖部分DEPENDENCIES，我们消息中用到的依赖这里必须写上，即使不写编译器也不会报错，直到运行的时候才会出错。</strong></li>
<li><strong>而且rosidl_generate_interfaces()</strong> 函数必须在 <strong>ament_package()</strong> 函数之前调用。</li>
</ul>
<p>代码大概是这样的<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038380883-6becece5-b4cd-4c3d-bc11-cdcffa9dcf1d.png#averageHue=%23201f1f&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=ua4ec7301&amp;originHeight=843&amp;originWidth=1469&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=471267&amp;status=done&amp;style=none&amp;taskId=u795fc122-a6a1-4427-9f9d-d20f8507983&amp;title=" alt="e3877412c40448c0995ba2884a1ae7c1.png"></p>
<ul>
<li>修改package.xml</li>
</ul>
<p>修改village_interfaces目录下的package.xml，添加下面三行代码，为工程添加一下所需的依赖。<br /><strong>这里其实不添加也可以</strong><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>sensor_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure><br>代码位置：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037769727-982ef5d8-77a3-446a-9035-8861ead0bf4e.png#averageHue=%23201f1f&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u06f1f241&amp;originHeight=492&amp;originWidth=1099&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=105921&amp;status=done&amp;style=none&amp;taskId=u1930cd93-9480-4455-b99b-a9971abac6c&amp;title=" alt="image-20210816145202732.png"></p>
<ul>
<li>编译</li>
</ul>
<p>回到town_ws<br><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_interfaces</span><br></pre></td></tr></table></figure></p>
<ul>
<li>验证</li>
</ul>
<p>过上节课说过的ros2 interface常用的命令来测试。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">package</span> <span class="symbol">village_interfaces</span>  #查看包下所有接口</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">show</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #查看内容</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">proto</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #显示属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><a name="zucuy"></a></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037813556-ec2ce503-73b2-4496-ad09-0d176cf48bdb.png#averageHue=%23242424&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u580048f1&amp;originHeight=367&amp;originWidth=751&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=58470&amp;status=done&amp;style=none&amp;taskId=u39622192-29e6-41b5-9414-a9b8c7ed920&amp;title=" alt="image-20210816145503946.png"></h3><p>我们可以在运行结果中看到，Novel的消息内容是由content数据和传感器数据image共同组成的了。</p>
<p><a name="vtOSp"></a></p>
<h3 id="服务："><a href="#服务：" class="headerlink" title="服务："></a>服务：</h3><ul>
<li>服务：客户端发送请求给服务端，服务端可以根据客户端的请求做一些处理，然后返回结果给客户端。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035790713-136e7676-715a-48d2-92ad-41e569c869f1.gif#averageHue=%23fcf9fd&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=PMpbD&amp;originHeight=480&amp;originWidth=854&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=380270&amp;status=done&amp;style=none&amp;taskId=u365753d7-dbb5-4e03-9548-c451b5f740a&amp;title=" alt="Service-SingleServiceClient.gif"><br /><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035797325-0dfe07bb-99eb-4afc-9625-737c1827a667.gif#averageHue=%2394a2cc&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=mTDBy&amp;originHeight=480&amp;originWidth=854&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=898464&amp;status=done&amp;style=none&amp;taskId=u4ef526f9-0e06-43be-ab48-beff9eb1ad0&amp;title=" alt="Service-MultipleServiceClient.gif"></p>
<p>下面操作一下ros2自带的样例服务：<br><a name="ZLIvy"></a></p>
<h4 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h4><p>运行一个服务节点<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 run examples_rclpy_minimal_service service</span><br><span class="line"><span class="comment">//服务的功能是将两个数字相加，给定a，b两个数，返回sum也就是ab之和</span></span><br></pre></td></tr></table></figure><br><a name="OhYmw"></a></p>
<h5 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service list</span><br></pre></td></tr></table></figure>
<p><a name="ZNyUa"></a></p>
<h5 id="手动调用服务（一定要注意a：-b-的空格）"><a href="#手动调用服务（一定要注意a：-b-的空格）" class="headerlink" title="手动调用服务（一定要注意a：  b: 的空格）"></a>手动调用服务（一定要注意a：  b: 的空格）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts <span class="string">&quot;&#123;a: 5,b: 10&#125;&quot;</span></span><br><span class="line"><span class="comment">//需要再启动一个终端</span></span><br></pre></td></tr></table></figure>
<p><a name="RHF6C"></a></p>
<h5 id="查看服务接口类型"><a href="#查看服务接口类型" class="headerlink" title="查看服务接口类型"></a>查看服务接口类型</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service type /add_two_ints</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="AIADv"></a></p>
<h5 id="查找使用某一接口的服务"><a href="#查找使用某一接口的服务" class="headerlink" title="查找使用某一接口的服务"></a>查找使用某一接口的服务</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ros2 service find example_interfaces/srv/AddTwoInts</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="X9wyU"></a></p>
<h4 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h4><p>我们来看一下服务的消息接口长什么样子？<br />服务接口格式：xxx.srv<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">int64 a</span><br><span class="line"><span class="section">int64 b</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><br>与话题不同的是，srv文件比msg文件中间多出了三个—-这三个杠杠就是分界线，上方的是客户端发送请求的数据结构定义，下方的是服务端响应结果的数据结构定义。<br />参考下面的步骤：</p>
<ul>
<li>新建srv文件夹，并在文件夹下新建xxx.srv</li>
<li>在xxx.srv下编写服务接口内容并保存</li>
<li>在CmakeLists.txt添加依赖和srv文件目录</li>
<li>在package.xml中添加xxx.srv所需的依赖</li>
<li>编译功能包即可生成python与c++头文件</li>
</ul>
<p>当然在做上面的步骤之前，我们还需要做一件很重要的事情。就是根据业务需求，确定好请求的数据结构和返回的数据结构。我们依然是在village_interfaces下创建服务接口。<br />开始之前，我们先根据李四的需求来确定数据结构。<br />上一节中李四对借钱的要求如下：</p>
<ol>
<li>借钱一定要打欠条，收到欠条才能给钱</li>
<li>每次借钱不能超过自己全部资金的10%且一定是整数，也就是说李四假如现在有100块钱，那么最多借出去100x10%=10块钱</li>
</ol>
<p>总结一下就是，李三发送借钱请求的时候一定要有欠条，我们想一下，欠条中应该至少包含两条信息</p>
<ul>
<li>借钱者名字，字符串类型、可以用string表示</li>
<li>金额，整形，可以用uint32表示</li>
</ul>
<p>那请求的数据结构我们就可以确定下来了，接着确定返回的数据的格式。<br />既然是借钱，那李四就有可能拒绝，会有借钱失败的情况，所以返回数据应该有这两条信息：</p>
<ul>
<li>是否出借：只有成功和失败两种情况，布尔类型（bool）可表示</li>
<li><p>出借金额：无符号整形，可以用uint32表示，借钱失败时为0。<br><a name="SOi0x"></a></p>
<h5 id="创建srv文件夹及BorrowMoney-srv消息文件"><a href="#创建srv文件夹及BorrowMoney-srv消息文件" class="headerlink" title="创建srv文件夹及BorrowMoney.srv消息文件"></a>创建srv文件夹及BorrowMoney.srv消息文件</h5><p>在village_interfaces下新建srv文件夹<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038764606-c8035912-d3b5-4a18-8758-978165a7a504.png#averageHue=%23222222&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u87e80afd&amp;originHeight=160&amp;originWidth=471&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=14984&amp;status=done&amp;style=none&amp;taskId=u6fcc9d9a-d569-433f-86c9-0a6ed8b969f&amp;title=" alt="image-20210811162010736.png"><br><a name="yxyCD"></a></p>
<h5 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string name</span><br><span class="line">uint32 money</span><br><span class="line">---</span><br><span class="line"><span class="type">bool</span> success</span><br><span class="line">uint32 money</span><br></pre></td></tr></table></figure>
<p><a name="efh5K"></a></p>
<h5 id="修改Cmakelists-txt"><a href="#修改Cmakelists-txt" class="headerlink" title="修改Cmakelists.txt"></a>修改Cmakelists.txt</h5><p>我们已经添加过依赖DEPENDENCIES和msg文件了，所以这里我们直接添加一个srv即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line">  #---msg---</span><br><span class="line">  <span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">  #---srv---</span><br><span class="line">  <span class="string">&quot;srv/BorrowMoney.srv&quot;</span></span><br><span class="line">  DEPENDENCIES sensor_msgs</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p>需要关注的是这一行”srv/BorrowMoney.srv”,添加了对应的文件位置。</p>
</li>
<li><p>踩坑：在rosidl_generate_interfaces()函数中传递了一个依赖项sensor_msgs，但是在使用find_package()函数之前没有找到它。需要在CMakeLists.txt 文件中添加find_package(sensor_msgs REQUIRED)，以确保 <strong>sensor_msgs</strong> 包被正确地找到和链接。<br><a name="io4wO"></a></p>
<h5 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;build_depend&gt;sensor_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;</span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="Ink82"></a></p>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">colcon build --packages-select village_interfaces</span><br></pre></td></tr></table></figure>
<p><a name="lVN2C"></a></p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>这次测试我们依然使用ros2 interface指令进行测试。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 interface package village_interfaces</span><br><span class="line">ros2 interface show village_interfaces/srv/BorrowMoney</span><br><span class="line">ros2 interface proto village_interfaces/srv/BorrowMoney </span><br></pre></td></tr></table></figure>
<p><a name="uONPm"></a></p>
<h4 id="服务的c-实现"><a href="#服务的c-实现" class="headerlink" title="服务的c++实现"></a>服务的c++实现</h4><p><strong>一句话：张三拿多少钱钱给王二，王二凑够多少个章节的艳娘传奇给他，可参考以下步骤</strong></p>
</li>
</ul>
<ol>
<li>导入服务接口</li>
<li>创建服务端回调函数</li>
<li>声明并创建服务端</li>
<li>编写回调函数逻辑处理请求<br><a name="c7FPU"></a><h5 id="添加接口-amp-amp-依赖"><a href="#添加接口-amp-amp-依赖" class="headerlink" title="添加接口&amp;&amp;依赖"></a>添加接口&amp;&amp;依赖</h5>因为village_wang的包类型是ament_cmake，故需要进行以下两步操作：<br /><strong>第一步修改package.xml</strong><br />加入下面的代码（告诉colcon，编译之前要确保有village_interfaces存在）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;depend&gt;village_interfaces&lt;/depend&gt;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710039585985-a81f2aa8-b41e-461b-bc89-2642cab063a3.png#averageHue=%23222120&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=ud2b27244&amp;originHeight=109&amp;originWidth=542&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=18085&amp;status=done&amp;style=none&amp;taskId=u0cad5214-f47f-4485-a806-092b7a4e5d0&amp;title=" alt="image-20210816153438400.png"><br /><strong>第二步修改和CMakeLists.txt</strong><br />在CMakeLists.txt中加入下面一行代码<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(village_interfaces REQUIRED)</span><br></pre></td></tr></table></figure>
<strong>find_package是cmake的语法，用于查找库。找到后，还需要将其和可执行文件链接起来</strong><br />所以还需要修改ament_target_dependencies，在其中添加village_interfaces。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ament_target_dependencies</span>(wang2_node </span><br><span class="line">  rclcpp </span><br><span class="line">  village_interfaces</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
对于C++来说，添加服务接口只需在程序中引入对应的头文件即可。<br /><strong>这个头文件就是我们SellNovel.srv生成的头文件</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;village_interfaces/srv/sell_novel.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>
<a name="Fhg7q"></a><h5 id="声明回调函数"><a href="#声明回调函数" class="headerlink" title="声明回调函数"></a>声明回调函数</h5>添加完服务接口接着就可以声明一个<strong>卖书请求回调函数</strong>。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell_book_callback</span><span class="params">(<span class="type">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>再创建一个队列，用于存放自己看过的二手书，创建队列需要用到queue容器，所以我们先用#include <queue>在程序开头引入该容器，再在代码中添加下面这句话。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个小说章节队列</span></span><br><span class="line">std::queue&lt;std::string&gt;  novels_queue;</span><br></pre></td></tr></table></figure><br><a name="LaIsk"></a></p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>当张三请求王二买二手书的时候，假如王二手里书的数量不足，王二就等攒够了对应数量的书再返回给张三。<br />等待攒够章节的操作需要在卖书服务函数中阻塞当前线程，阻塞后王二就收不到李四写的小说了，这样一来就会造成一个很尴尬的情景：<br /><strong>在卖书服务回调函数中等着书库（队列）里小说章节数量满足张三需求，接收小说的程序等着这边的卖书回调函数结束，好把书放进书库（队列）里。</strong><br />这种互相等待的情况，我们称之为死锁<br />ROS2默认是单线程的，同时只有一个线程在跑，大家都是顺序执行，你干完我干，一条线下去。<br />所以为了解决这个问题，我们可以使用多线程，即每次收到服务请求后，单独开一个线程来处理，不影响其他部分。<br><a name="aZhlq"></a></p>
<h5 id="回调函数组"><a href="#回调函数组" class="headerlink" title="回调函数组"></a>回调函数组</h5><p>ROS2中要使用多线程执行器和回调组来实现多线程，我们先在SingleDogNode中声明一个回调组成员变量。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务回调组</span></span><br><span class="line">rclcpp::CallbackGroup::SharedPtr callback_group_service_;</span><br></pre></td></tr></table></figure><br>最终结果<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">class SingleDogNode : <span class="keyword">public</span> rclcpp<span class="type">::Node</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    SingleDogNode(std<span class="type">::string</span> name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明一个服务回调组</span></span><br><span class="line">    rclcpp<span class="type">::CallbackGroup</span><span class="type">::SharedPtr</span> callback_group_service_;</span><br><span class="line">    <span class="comment">//创建一个小说章节队列</span></span><br><span class="line">    std<span class="type">::queue</span>&lt;std<span class="type">::string</span>&gt;  novels_queue;</span><br><span class="line">    <span class="comment">// 声明一个服务端</span></span><br><span class="line">    rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br><span class="line">    <span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    <span class="literal">void</span> sell_book_callback(const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Request</span><span class="type">::SharedPtr</span> request,</span><br><span class="line">        const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Response</span><span class="type">::SharedPtr</span> response)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对请求数据进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><a name="rAhK4"></a></p>
<h5 id="实例化服务端-amp-amp-编写回调函数处理请求"><a href="#实例化服务端-amp-amp-编写回调函数处理请求" class="headerlink" title="实例化服务端&amp;&amp;编写回调函数处理请求"></a>实例化服务端&amp;&amp;编写回调函数处理请求</h5><p>在ROS2中，回调函数组也是一个对象，通过实例化create_callback_group类即可创建一个callback_group_service的对象。<br />在SingleDogNode的构造函数中添加下面这行代码，即可完成实例化<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">callback_group_service_</span> = this-&gt;create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br />我们使用成员函数作为回调函数，这里要根据回调函数中参数个数，设置占位符，即告诉编译器，这个函数需要传入的参数个数。<br /><strong>在之前订阅话题的回调函数中，我们已经用到过一次了，因为话题回调只有一个参数，所以只需要一个占位符，这里服务的回调是两个参数，所以要设置两个</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br></pre></td></tr></table></figure><br>在private:下<strong>声明服务端</strong><br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务端</span></span><br><span class="line">rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br></pre></td></tr></table></figure><br>在构造函数中<strong>实例化服务端</strong><br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化卖二手书的服务</span></span><br><span class="line">server_ = this<span class="punctuation">-&gt;</span>create_service&lt;village_interfaces::srv::SellNovel&gt;(<span class="string">&quot;sell_novel&quot;</span>,</span><br><span class="line">                            std::<span class="title function_ invoke__">bind</span>(&amp;SingleDogNode::sell_book_callback,this,_1,_2),</span><br><span class="line">                            rmw_qos_profile_services_default,</span><br><span class="line">                            callback_group_service_);</span><br></pre></td></tr></table></figure><br>实例化服务端可以直接使用create_service函数，该函数是一个模版函数，需要输入要创建的服务类型，这里我们使用的是<village_interfaces::srv::SellNovel>，这个函数有四个参数需要输入,小鱼接下来进行一一介绍</p>
<ul>
<li>“sell_novel”服务名称，没啥好说的，要唯一哦，因为服务只能有一个</li>
<li>std::bind(&amp;SingleDogNode::sell_book_callback,this,_1,_2)回调函数，这里指向了我们2.3.1中我们声明的sell_book_callback</li>
<li>rmw_qos_profile_services_default 通信质量，这里使用服务默认的通信质量</li>
<li>callback<em>group_service</em>，回调组，我们前面创建回调组就是在这里使用的，告诉ROS2，当你要调用回调函数处理请求时，请把它放到单独线程的回调组中<br><a name="q5mnn"></a><h5 id="编写回调函数"><a href="#编写回调函数" class="headerlink" title="编写回调函数"></a>编写回调函数</h5><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    void sell_book_callback(<span class="keyword">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span><br><span class="line">        <span class="keyword">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;收到一个买书请求，一共给了%d钱&quot;</span>,request-&gt;money);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> novelsNum = request-&gt;money*<span class="number">1</span>;  <span class="comment">//应给小说数量，一块钱一章</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前书库里书的数量是否满足张三要买的数量，不够则进入等待函数</span></span><br><span class="line">        <span class="keyword">if</span>(novels_queue.size()&lt;novelsNum)</span><br><span class="line">        &#123;</span><br><span class="line">            RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：不能满足需求,开始等待&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置rate周期为1s，代表1s检查一次</span></span><br><span class="line">            rclcpp::Rate loop_rate(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当书库里小说数量小于请求数量时一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (novels_queue.size()&lt;novelsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断系统是否还在运行</span></span><br><span class="line">                <span class="keyword">if</span>(!rclcpp::ok())</span><br><span class="line">                &#123;</span><br><span class="line">                    RCLCPP_ERROR(this-&gt;get_logger(), <span class="string">&quot;程序被终止了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印一下当前的章节数量和缺少的数量</span></span><br><span class="line">                RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;等待中，目前已有%d章，还差%d章&quot;</span>,novels_queue.size(),novelsNum-novels_queue.size());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//rate.sleep()让整个循环1s运行一次</span></span><br><span class="line">                loop_rate.sleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 章节数量满足需求了</span></span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：已经满足需求&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一本本把书取出来，放进请求响应对象response中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;novelsNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            response-&gt;novels.push_back(novels_queue.front());</span><br><span class="line">            novels_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<br />当收到请求时，先计算一下应该给张三多少书novelsNum，然后判断书库里书的数量够不够，不够则进入攒书程序。如果够或者攒够了就把书放到服务响应对象里，返回给张三。这里我们还需要修改一下话题回调函数，增加了一行代码，将小说放到书库里novels_queue.push(msg-&gt;data);<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到话题数据的回调函数</span></span><br><span class="line"> void <span class="title function_ invoke__">topic_callback</span>(<span class="keyword">const</span> std_msgs::msg::<span class="type">String</span>::SharedPtr msg)&#123;</span><br><span class="line">     <span class="comment">// 新建一张人民币</span></span><br><span class="line">     std_msgs::msg::UInt32 money;</span><br><span class="line">     money.data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送人民币给李四</span></span><br><span class="line">    pub_<span class="punctuation">-&gt;</span><span class="title function_ invoke__">publish</span>(money);</span><br><span class="line">    <span class="title function_ invoke__">RCLCPP_INFO</span>(this<span class="punctuation">-&gt;</span><span class="title function_ invoke__">get_logger</span>(), <span class="string">&quot;王二：我收到了：&#x27;%s&#x27; ，并给了李四：%d 元的稿费&quot;</span>, msg<span class="punctuation">-&gt;</span>data.<span class="title function_ invoke__">c_str</span>(),money.data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小说放入novels_queue中</span></span><br><span class="line">    novels_queue.<span class="title function_ invoke__">push</span>(msg<span class="punctuation">-&gt;</span>data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a name="S7CCg"></a><h5 id="修改main函数"><a href="#修改main函数" class="headerlink" title="修改main函数"></a>修改main函数</h5>因为我们要让整个程序变成多线程的，所以我们要把节点的执行器变成多线程执行器。<br />修改一下main函数，新建一个多线程执行器，添加王二节点并spin,完整代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="https://raw.githubusercontent.com/fishros/ros2_town/af8b29f7b23153d35348ebfcd3b1bc5760c6c5a6/village_wang/src/wang2.cpp">wang2.cpp</a><br><a name="NmoFR"></a><h5 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h5><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure>
<a name="YjbW2"></a><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_wang wang2_node</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2@ubuntu:~/code/town_ws$ ros2 service list -t</span><br><span class="line">/sell_book [village_interfaces/srv/SellNovel]</span><br><span class="line">ros2 service call /sell_book  village_interfaces/srv/SellNovel &quot;&#123;money: 5&#125;&quot;</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_li li4_node</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040232046-33fa90eb-16d0-4459-8907-ec1d53912d34.png#averageHue=%232f2f2f&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=bKVka&amp;originHeight=251&amp;originWidth=1424&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=135885&amp;status=done&amp;style=none&amp;taskId=ud6755017-b9b4-40d3-a3d5-08f505ffa75&amp;title=" alt="image-20210831124712850.png"></li>
</ul>
<p><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.10%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0(C++">客户端实现</a>?id=_3%e5%ae%a2%e6%88%b7%e7%ab%af%ef%bc%88%e5%bc%a0%e4%b8%89%ef%bc%89%e5%ae%9e%e7%8e%b0)<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040911063-ab181be4-89fa-4a05-8da4-a2b5d58c0444.png#averageHue=%23eeebe9&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u4725bfe1&amp;originHeight=430&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=62757&amp;status=done&amp;style=none&amp;taskId=u2b8126d0-3aa8-4cae-b16e-308b2b4d88f&amp;title=" alt="28bff3501425d8b0e5a018fb3f7cfb1b.png"></p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Self-balancing-bycycle</title>
    <url>/2023/10/09/Self-balancing-bycycle/</url>
    <content><![CDATA[<p><em>项目简介：由于这是我负责的项目，仅以此篇博客用于记录项目的研究方向，思路，进度等。</em><br>未完待续。。。<br><span id="more"></span></p>
<p>烂尾了，直接贴代码了<br><a href="https://github.com/zuquanzhi/Self_Balance_Bycicle">https://github.com/zuquanzhi/Self_Balance_Bycicle</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>平衡车</tag>
      </tags>
  </entry>
  <entry>
    <title>yolo初步</title>
    <url>/2024/04/10/yolo%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<p>参考文献：<br /><a href="https://towardsdatascience.com/chess-rolls-or-basketball-lets-create-a-custom-object-detection-model-ef53028eac7d">A simple way of creating a custom object detection model</a>（这个就是卓晴教程的原版）<br /><a href="https://blog.csdn.net/sinat_28371057/article/details/120598220?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=yolo5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-120598220.142^v99^control&amp;spm=1018.2226.3001.4187">YOLOv5的详细使用教程，以及使用yolov5训练自己的数据集_yolo5训练集-CSDN博客</a></p>
<p><a name="Ub0k6"></a></p>
<span id="more"></span>
<h1 id="使用预训练模型"><a href="#使用预训练模型" class="headerlink" title="使用预训练模型"></a>使用预训练模型</h1><p><a name="Ir8Je"></a></p>
<h2 id="安装环境依赖"><a href="#安装环境依赖" class="headerlink" title="安装环境依赖"></a>安装环境依赖</h2><p><a name="ucNeD"></a></p>
<h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure>
<p>镜像</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com.cnpmjs.org<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure>
<p><a name="LHIoW"></a></p>
<h2 id="必要环境"><a href="#必要环境" class="headerlink" title="必要环境"></a>必要环境</h2><p>官方给出的要求是：python&gt;=3.7、PyTorch&gt;=1.5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> yolov5</span><br><span class="line">pip install -U -r requirements.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip install -U -r requirements.txt</span></span><br><span class="line"><span class="attribute">Cython</span></span><br><span class="line"><span class="attribute">numpy</span>==<span class="number">1</span>.<span class="number">17</span></span><br><span class="line"><span class="attribute">opencv</span>-python</span><br><span class="line"><span class="attribute">torch</span>&gt;=<span class="number">1</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">matplotlib</span></span><br><span class="line"><span class="attribute">pillow</span></span><br><span class="line"><span class="attribute">tensorboard</span></span><br><span class="line"><span class="attribute">PyYAML</span>&gt;=<span class="number">5</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">torchvision</span></span><br><span class="line"><span class="attribute">scipy</span></span><br><span class="line"><span class="attribute">tqdm</span></span><br><span class="line"><span class="attribute">git</span>+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Nvidia Apex (optional) for mixed precision training --------------------------</span></span><br><span class="line"><span class="comment"># git clone https://github.com/NVIDIA/apex &amp;&amp; cd apex &amp;&amp; pip install -v --no-cache-dir --global-option=&quot;--cpp_ext&quot; --global-option=&quot;--cuda_ext&quot; . --user &amp;&amp; cd .. &amp;&amp; rm -rf apex</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Conda commands (in place of pip) ---------------------------------------------</span></span><br><span class="line"><span class="comment"># conda update -yn base -c defaults conda</span></span><br><span class="line"><span class="comment"># conda install -yc anaconda numpy opencv matplotlib tqdm pillow ipython</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge scikit-image pycocotools tensorboard</span></span><br><span class="line"><span class="comment"># conda install -yc spyder-ide spyder-line-profiler</span></span><br><span class="line"><span class="comment"># conda install -yc pytorch pytorch torchvision</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge protobuf numpy &amp;&amp; pip install onnx  # https://github.com/onnx/onnx#linux-and-macos</span></span><br></pre></td></tr></table></figure>
<p><a name="Lpb3W"></a></p>
<h2 id="下载预训练模型和标注数据集"><a href="#下载预训练模型和标注数据集" class="headerlink" title="下载预训练模型和标注数据集"></a>下载预训练模型和标注数据集</h2><p><a name="VMqUW"></a></p>
<h3 id="执行脚本下载模型"><a href="#执行脚本下载模型" class="headerlink" title="执行脚本下载模型"></a>执行脚本下载模型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Download common models</span></span><br><span class="line"> </span><br><span class="line">python3 -c <span class="string">&quot;from utils.google_utils import *;</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5s.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5m.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5l.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5x.pt&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
<p>（attempt_download函数在/yolov5/utils/google_utils.py脚本中定义）<br><a name="rFxrZ"></a></p>
<h3 id="下载标注数据集"><a href="#下载标注数据集" class="headerlink" title="下载标注数据集"></a>下载标注数据集</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python3</span> -c <span class="string">&quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span> <span class="comment"># download dataset</span></span><br></pre></td></tr></table></figure>
<p>执行上面的代码，会下载：coco128.zip数据集，该数据是COCO train2017数据的一部分，只取了coco数据集中的128张标注的图片，coco128.zip下载完后解压到/yolov5目录下即可，解压后的coco128文件结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">coco128</span><br><span class="line"><span class="operator">|</span><span class="comment">-- LICENSE</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- README.txt  # 相关说明</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- annotations  # 空目录</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- images   # 128张jpg图片</span></span><br><span class="line">`<span class="comment">-- labels  # 128张标注的txt文件</span></span><br></pre></td></tr></table></figure>
<p>/yolov5/utils/google_utils.py脚本是下载预训练模型和标注的训练数据集，该脚本代码内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># This file <span class="keyword">contains</span> google utils: https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>reference<span class="operator">/</span>libraries</span><br><span class="line"># pip install <span class="comment">--upgrade google-cloud-storage</span></span><br><span class="line"># <span class="keyword">from</span> google.cloud import storage</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line">import <span class="type">time</span></span><br><span class="line"><span class="keyword">from</span> pathlib import Path</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def attempt_download(weights):</span><br><span class="line">    # Attempt <span class="keyword">to</span> download pretrained weights if <span class="keyword">not</span> found locally</span><br><span class="line">    weights <span class="operator">=</span> weights.strip()</span><br><span class="line">    msg <span class="operator">=</span> weights <span class="operator">+</span> <span class="string">&#x27; missing, try downloading from https://drive.google.com/drive/folders/1Drs_Aiu7xx6S-ix95f9kNsA6ueKRpN2J&#x27;</span></span><br><span class="line"> </span><br><span class="line">    r <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    if len(weights) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> os.path.isfile(weights):</span><br><span class="line">        d <span class="operator">=</span> &#123;<span class="string">&#x27;yolov3-spp.pt&#x27;</span>: <span class="string">&#x27;1mM67oNw4fZoIOL1c8M3hHmj66d8e-ni_&#x27;</span>,  # yolov3<span class="operator">-</span>spp.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5s.pt&#x27;</span>: <span class="string">&#x27;1R5T6rIyy3lLwgFXNms8whc-387H0tMQO&#x27;</span>,  # yolov5s.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5m.pt&#x27;</span>: <span class="string">&#x27;1vobuEExpWQVpXExsJ2w-Mbf3HJjWkQJr&#x27;</span>,  # yolov5m.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5l.pt&#x27;</span>: <span class="string">&#x27;1hrlqD1Wdei7UT4OgT785BEk1JwnSvNEV&#x27;</span>,  # yolov5l.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5x.pt&#x27;</span>: <span class="string">&#x27;1mM8aZJlWTxOg7BZJvNUMrTnA2AbeCVzS&#x27;</span>,  # yolov5x.yaml</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">        file <span class="operator">=</span> Path(weights).name</span><br><span class="line">        if file <span class="keyword">in</span> d:</span><br><span class="line">            r <span class="operator">=</span> gdrive_download(id<span class="operator">=</span>d[file], name<span class="operator">=</span>weights)</span><br><span class="line"> </span><br><span class="line">        if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">            os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">            s <span class="operator">=</span> &quot;curl -L -o %s &#x27;https://storage.googleapis.com/ultralytics/yolov5/ckpt/%s&#x27;&quot; <span class="operator">%</span> (weights, file)</span><br><span class="line">            r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line"> </span><br><span class="line">            # Error <span class="keyword">check</span></span><br><span class="line">            if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">                os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">                raise Exception(msg)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def gdrive_download(id<span class="operator">=</span><span class="string">&#x27;1HaXkef9z6y5l4vUnCYgdmEAj61c6bfWO&#x27;</span>, name<span class="operator">=</span><span class="string">&#x27;coco.zip&#x27;</span>):</span><br><span class="line">    # https:<span class="operator">/</span><span class="operator">/</span>gist.github.com<span class="operator">/</span>tanaikech<span class="operator">/</span>f0f2d122e05bf5f971611258c22c110f</span><br><span class="line">    # Downloads a file <span class="keyword">from</span> Google Drive, accepting presented query</span><br><span class="line">    # <span class="keyword">from</span> utils.google_utils import <span class="operator">*</span>; gdrive_download()</span><br><span class="line">    t <span class="operator">=</span> time.time()</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Downloading https://drive.google.com/uc?export=download&amp;id=%s as %s... &#x27;</span> <span class="operator">%</span> (id, name), <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove existing</span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Attempt file download</span><br><span class="line">    os.system(&quot;curl -c ./cookie -s -L \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; &gt; /dev/null&quot; <span class="operator">%</span> id)</span><br><span class="line">    if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>):  # <span class="keyword">large</span> file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -Lb ./cookie \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>confirm<span class="operator">=</span>`awk <span class="string">&#x27;/download/ &#123;print $NF&#125;&#x27;</span> .<span class="operator">/</span>cookie`<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; -o %s&quot; <span class="operator">%</span> (</span><br><span class="line">            id, name)</span><br><span class="line">    <span class="keyword">else</span>:  # small file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -s -L -o %s &#x27;https://drive.google.com/uc?export=download&amp;id=%s&#x27;&quot; <span class="operator">%</span> (name, id)</span><br><span class="line">    r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Error <span class="keyword">check</span></span><br><span class="line">    if r <span class="operator">!=</span> <span class="number">0</span>:</span><br><span class="line">        os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial</span><br><span class="line">        print(<span class="string">&#x27;Download error &#x27;</span>)  # raise Exception(<span class="string">&#x27;Download error&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line">    # Unzip if archive</span><br><span class="line">    if name.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;unzipping... &#x27;</span>, <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        os.system(<span class="string">&#x27;unzip -q %s&#x27;</span> <span class="operator">%</span> name)  # unzip</span><br><span class="line">        os.remove(name)  # remove zip <span class="keyword">to</span> <span class="keyword">free</span> space</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Done (%.1fs)&#x27;</span> <span class="operator">%</span> (time.time() <span class="operator">-</span> t))</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line"># def upload_blob(bucket_name, source_file_name, destination_blob_name):</span><br><span class="line">#     # Uploads a file <span class="keyword">to</span> a bucket</span><br><span class="line">#     # https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>uploading<span class="operator">-</span>objects#storage<span class="operator">-</span>upload<span class="operator">-</span>object<span class="operator">-</span>python</span><br><span class="line">#</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(destination_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.upload_from_filename(source_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;File &#123;&#125; uploaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_file_name,</span><br><span class="line">#         destination_blob_name))</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># def download_blob(bucket_name, source_blob_name, destination_file_name):</span><br><span class="line">#     # Uploads a <span class="type">blob</span> <span class="keyword">from</span> a bucket</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(source_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.download_to_filename(destination_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;Blob &#123;&#125; downloaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_blob_name,</span><br><span class="line">#         destination_file_name))</span><br></pre></td></tr></table></figure>
<p><a name="FqoFo"></a></p>
<h2 id="训练下载的coco128数据集"><a href="#训练下载的coco128数据集" class="headerlink" title="训练下载的coco128数据集"></a>训练下载的coco128数据集</h2><p>创建训练数据集的配置文件Dataset.yaml<br />上面下载好coco128.zip小型数据集之后，这些数据集可以用于训练和验证<br />/content/yolov5/models/yolov5l.yaml。coco128.yaml中定义了：<br />训练图片的路径（或训练图片列表的.txt文件）<br />与验证集相同的图片<br />目标的类别数<br />类名列表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># COCO <span class="number">2017</span> dataset http:<span class="operator">/</span><span class="operator">/</span>cocodataset.org <span class="operator">-</span> <span class="keyword">first</span> <span class="number">128</span> training images</span><br><span class="line"># Download command:  python <span class="operator">-</span>c &quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span><br><span class="line"># Train command: python train.py <span class="comment">--data ./data/coco128.yaml</span></span><br><span class="line"># Dataset should be placed next <span class="keyword">to</span> yolov5 folder:</span><br><span class="line">#   <span class="operator">/</span>parent_folder</span><br><span class="line">#     <span class="operator">/</span>coco128</span><br><span class="line">#     <span class="operator">/</span>yolov5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 训练集和验证集 （图片的目录路径或 <span class="operator">*</span>.txt图片路径）</span><br><span class="line">train: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line">val: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line"> </span><br><span class="line"># 类别数 number <span class="keyword">of</span> classes</span><br><span class="line">nc: <span class="number">80</span></span><br><span class="line"> </span><br><span class="line"># 类别列表 class names</span><br><span class="line">names: [<span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;motorcycle&#x27;</span>, <span class="string">&#x27;airplane&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, <span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;traffic light&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;fire hydrant&#x27;</span>, <span class="string">&#x27;stop sign&#x27;</span>, <span class="string">&#x27;parking meter&#x27;</span>, <span class="string">&#x27;bench&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;elephant&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>, <span class="string">&#x27;giraffe&#x27;</span>, <span class="string">&#x27;backpack&#x27;</span>, <span class="string">&#x27;umbrella&#x27;</span>, <span class="string">&#x27;handbag&#x27;</span>, <span class="string">&#x27;tie&#x27;</span>, <span class="string">&#x27;suitcase&#x27;</span>, <span class="string">&#x27;frisbee&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;skis&#x27;</span>, <span class="string">&#x27;snowboard&#x27;</span>, <span class="string">&#x27;sports ball&#x27;</span>, <span class="string">&#x27;kite&#x27;</span>, <span class="string">&#x27;baseball bat&#x27;</span>, <span class="string">&#x27;baseball glove&#x27;</span>, <span class="string">&#x27;skateboard&#x27;</span>, <span class="string">&#x27;surfboard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;tennis racket&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;wine glass&#x27;</span>, <span class="string">&#x27;cup&#x27;</span>, <span class="string">&#x27;fork&#x27;</span>, <span class="string">&#x27;knife&#x27;</span>, <span class="string">&#x27;spoon&#x27;</span>, <span class="string">&#x27;bowl&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sandwich&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;broccoli&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>, <span class="string">&#x27;hot dog&#x27;</span>, <span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;donut&#x27;</span>, <span class="string">&#x27;cake&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;couch&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;potted plant&#x27;</span>, <span class="string">&#x27;bed&#x27;</span>, <span class="string">&#x27;dining table&#x27;</span>, <span class="string">&#x27;toilet&#x27;</span>, <span class="string">&#x27;tv&#x27;</span>, <span class="string">&#x27;laptop&#x27;</span>, <span class="string">&#x27;mouse&#x27;</span>, <span class="string">&#x27;remote&#x27;</span>, <span class="string">&#x27;keyboard&#x27;</span>, <span class="string">&#x27;cell phone&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;microwave&#x27;</span>, <span class="string">&#x27;oven&#x27;</span>, <span class="string">&#x27;toaster&#x27;</span>, <span class="string">&#x27;sink&#x27;</span>, <span class="string">&#x27;refrigerator&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;clock&#x27;</span>, <span class="string">&#x27;vase&#x27;</span>, <span class="string">&#x27;scissors&#x27;</span>, <span class="string">&#x27;teddy bear&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;hair drier&#x27;</span>, <span class="string">&#x27;toothbrush&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p><a name="cCzV7"></a></p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>对数据集进行打标签，可以选择如下两种打标工具：<br />Labelbox<br />CVAT<br />也可以使用LabelImg，选用ylolo格式进行标注<br />将标签导出为darknet格式，每个标注图像有一个<em>.txt文件（如果图像中没有对象，则不需要</em>.txt文件），*.txt文件格式如下：</p>
<p>每行一个对象<br />每行都是：class x_center y_center width height格式<br />框的坐标格式必须采用归一化格式的xywh（从0到1），如果你框以像素为单位，则将x_center和width除以图像宽度，将y_center和height除以图像的高度<br />类别是从索引0开始的<br />通过在器路径名中将/images/<em>.jpg替换为/label/</em>.txt，可以定位每个图像的标签文件，示例图像和标签对为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">dataset<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>jpg  # image</span><br><span class="line">dataset<span class="operator">/</span>labels<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>txt  # label</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">45</span> <span class="number">0.479492</span> <span class="number">0.688771</span> <span class="number">0.955609</span> <span class="number">0.5955</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.736516</span> <span class="number">0.247188</span> <span class="number">0.498875</span> <span class="number">0.476417</span></span><br><span class="line"><span class="number">50</span> <span class="number">0.637063</span> <span class="number">0.732938</span> <span class="number">0.494125</span> <span class="number">0.510583</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.339438</span> <span class="number">0.418896</span> <span class="number">0.678875</span> <span class="number">0.7815</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.646836</span> <span class="number">0.132552</span> <span class="number">0.118047</span> <span class="number">0.096937</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.773148</span> <span class="number">0.129802</span> <span class="number">0.090734</span> <span class="number">0.097229</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.668297</span> <span class="number">0.226906</span> <span class="number">0.131281</span> <span class="number">0.146896</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.642859</span> <span class="number">0.079219</span> <span class="number">0.148063</span> <span class="number">0.148062</span></span><br></pre></td></tr></table></figure>
<p><a name="Fk4Lk"></a></p>
<h2 id="组织文件结构"><a href="#组织文件结构" class="headerlink" title="组织文件结构"></a>组织文件结构</h2><p><strong><em>/coco128目录应该和yolov5目录同级，同时确保coco128/labels和coco128/images两个目录同级</em></strong><br><img src="4cc9eb4348385e98b15dc0f5db0dc95.png" alt="4cc9eb4348385e98b15dc0f5db0dc95"></p>
<h2 id="选择训练模型"><a href="#选择训练模型" class="headerlink" title="选择训练模型"></a>选择训练模型</h2><p>上面已经修改了自定义数据集的配置文件，同时组织好了数据。下面就可以选择一个模型进行训练了。</p>
<p>从./models目录下选择一个模型的配置文件，这里我们选择yolov5s.ymal，这是一个最小最快的模型。关于其他模型之间的比较下面介绍。选择好模型之后，如果你使用的不是coco数据集进行训练，而是自定义的数据集，此时只需要修改*.yaml配置文件中的nc: 80参数和数据的类别列表</p>
<p>下面是yolo5s.ymal配置文件的内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># parameters</span><br><span class="line">nc: <span class="number">80</span>  # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span>  # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span>  # layer channel multiple</span><br><span class="line"> </span><br><span class="line"># anchors</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line"> </span><br><span class="line"># YOLOv5 backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, Focus, [<span class="number">64</span>, <span class="number">3</span>]],  # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">128</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">256</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">512</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, SPP, [<span class="number">1024</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>]]],</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"># YOLOv5 head</span><br><span class="line">head:</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],  # <span class="number">9</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],  # <span class="number">13</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P3</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">256</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">18</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">22</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P5</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">26</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"> </span><br><span class="line">   [[], <span class="number">1</span>, Detect, [nc, anchors]],  # Detect(P5, P4, P3)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>yolov5s.yaml配置文件中主要定义了：</p>
<ul>
<li>参数（parameters）：类别等</li>
<li>anchor</li>
<li>YOLOv5 backbone</li>
<li>YOLOv5 head</li>
</ul>
<p><a name="tQOKw"></a></p>
<h2 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h2><p>运行下面的命令训练coco128.ymal，训练5epochs。可以有两种训练方式，如下参数：</p>
<p>—cfg yolov5s.yaml —weights ‘’：从头开始训练<br />—cfg yolov5s.yaml —weights yolov5s.pt：从预训练的模型加载开始训练<br />YOLOv5在coco128上训练5epochs的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 16 --epochs 5 --data ./data/coco128.yaml --cfg ./models/yolov5s.yaml --weights &#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>训练的更多可选参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--epochs：训练的epoch，默认值300</span></span><br><span class="line"><span class="comment">--batch-size：默认值16</span></span><br><span class="line"><span class="comment">--cfg：模型的配置文件，默认为yolov5s.yaml</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco128.yaml</span></span><br><span class="line"><span class="comment">--img-size：训练和测试输入大小，默认为[640, 640]</span></span><br><span class="line"><span class="comment">--rect：rectangular training，布尔值</span></span><br><span class="line"><span class="comment">--resume：是否从最新的last.pt中恢复训练，布尔值</span></span><br><span class="line"><span class="comment">--nosave：仅仅保存最后的checkpoint，布尔值</span></span><br><span class="line"><span class="comment">--notest：仅仅在最后的epoch上测试，布尔值</span></span><br><span class="line"><span class="comment">--evolve：进化超参数（evolve hyperparameters），布尔值</span></span><br><span class="line"><span class="comment">--bucket：gsutil bucket，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--cache-images：缓存图片可以更快的开始训练，布尔值</span></span><br><span class="line"><span class="comment">--weights：初始化参数路径，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--name：如果提供，将results.txt重命名为results_name.txt</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--adam：使用adam优化器，布尔值</span></span><br><span class="line"><span class="comment">--multi-scale：改变图片尺寸img-size +/0- 50%，布尔值</span></span><br><span class="line"><span class="comment">--single-cls：训练单个类别的数据集，布尔值</span></span><br></pre></td></tr></table></figure>
<p><a name="ZacJ9"></a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试的更多可选参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--weights ：预训练模型路径，默认值weights/yolov5s.pt</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco.yaml</span></span><br><span class="line"><span class="comment">--batch-size：默认值32</span></span><br><span class="line"><span class="comment">--img-size：推理大小（pixels），默认640</span></span><br><span class="line"><span class="comment">--conf-thres：目标置信度阈值，默认0.001</span></span><br><span class="line"><span class="comment">--iou-thres：NMS的IOU阈值，默认0.65</span></span><br><span class="line"><span class="comment">--save-json：把结果保存为cocoapi-compatible的json文件</span></span><br><span class="line"><span class="comment">--task：默认val，可选其他值：val, test, study</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--half：半精度的FP16推理</span></span><br><span class="line"><span class="comment">--single-cls：将其视为单类别，布尔值</span></span><br><span class="line"><span class="comment">--augment：增强推理，布尔值</span></span><br><span class="line"><span class="comment">--verbose：显示类别的mAP，布尔值</span></span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python test.py <span class="comment">--weights yolov5s.pt --data ./data/coco.yaml --img 640</span></span><br></pre></td></tr></table></figure>
<p><a name="t0dKT"></a></p>
<h1 id="实现yolo自由（自训练模型）"><a href="#实现yolo自由（自训练模型）" class="headerlink" title="实现yolo自由（自训练模型）"></a>实现yolo自由（自训练模型）</h1><p>上面的都是官方给出的训练模型，我也尝试了一下训练自己的。<br><a name="Jqm55"></a></p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>首先是image的手框转换成yolo文件，我使用的是清华小丑（bushi）给的开源工具<a href="https://www.makesense.ai/">https://www.makesense.ai/</a>生成的。（由于小车上的回传节点还没开始写就用手机try一下）<br><a name="Y2qP3"></a></p>
<h2 id="yolo环境配置"><a href="#yolo环境配置" class="headerlink" title="yolo环境配置"></a>yolo环境配置</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="operator">/</span><span class="operator">/</span>github.com<span class="operator">/</span>ultralytics<span class="operator">/</span>yolov5 # clone repo</span><br></pre></td></tr></table></figure>
<p>同上，不过目录结构似乎不太一样(尤其是datasets的部分，差异太多我干脆直接提出来了)<br /></p>
<p><img src="f299a1faae42c3dfa23869900cfc571.png" alt="f299a1faae42c3dfa23869900cfc571"></p>
<p>数据集标注好之后，存放如下目录格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$ tree hat_hair_beard</span><br><span class="line">hat_hair_beard</span><br><span class="line">├── images</span><br><span class="line">│   ├── train2017        # 训练集图片，这里我只列举几张示例</span><br><span class="line">│   │   ├── <span class="number">000050.</span>jpg</span><br><span class="line">│   │   ├── <span class="number">000051.</span>jpg</span><br><span class="line">│   │   └── <span class="number">000052.</span>jpg</span><br><span class="line">│   └── val2017          # 验证集图片</span><br><span class="line">│       ├── <span class="number">001800.</span>jpg</span><br><span class="line">│       ├── <span class="number">001801.</span>jpg</span><br><span class="line">│       └── <span class="number">001802.</span>jpg</span><br><span class="line">└── labels               </span><br><span class="line">    ├── train2017       # 训练集的标签文件</span><br><span class="line">    │   ├── <span class="number">000050.</span>txt</span><br><span class="line">    │   ├── <span class="number">000051.</span>txt</span><br><span class="line">    │   └── <span class="number">000052.</span>txt</span><br><span class="line">    └── val2017         # 验证集的标签文件</span><br><span class="line">        ├── <span class="number">001800.</span>txt</span><br><span class="line">        ├── <span class="number">001801.</span>txt</span><br><span class="line">        └── <span class="number">001802.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">6</span> directories, <span class="number">13</span> files</span><br><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$</span><br></pre></td></tr></table></figure>
<p><a name="UTe92"></a></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><a name="RF2a3"></a></p>
<h3 id="数据配置文件"><a href="#数据配置文件" class="headerlink" title="数据配置文件"></a>数据配置文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"># COCO128 dataset https:<span class="operator">/</span><span class="operator">/</span>www.kaggle.com<span class="operator">/</span>ultralytics<span class="operator">/</span>coco128 (<span class="keyword">first</span> <span class="number">128</span> images <span class="keyword">from</span> COCO train2017) <span class="keyword">by</span> Ultralytics</span><br><span class="line"># Example usage: python train.py <span class="comment">--data coco128.yaml</span></span><br><span class="line"># parent</span><br><span class="line"># ├── yolov5</span><br><span class="line"># └── datasets</span><br><span class="line">#     └── coco128  ← downloads here (<span class="number">7</span> MB)</span><br><span class="line"></span><br><span class="line"># Train<span class="operator">/</span>val<span class="operator">/</span>test sets <span class="keyword">as</span> <span class="number">1</span>) dir: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs, <span class="number">2</span>) file: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs.txt, <span class="keyword">or</span> <span class="number">3</span>) list: [path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs1, path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs2, ..]</span><br><span class="line">path: .<span class="operator">/</span>datasets # dataset root dir</span><br><span class="line">train: images<span class="operator">/</span>train_test # train images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">val: images<span class="operator">/</span>val_test # val images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">test: # test images (optional)</span><br><span class="line"></span><br><span class="line"># Classes</span><br><span class="line">names:</span><br><span class="line">  <span class="number">0</span>: dijia</span><br><span class="line"></span><br><span class="line"># Download script<span class="operator">/</span>URL (optional)</span><br><span class="line">#download: https:<span class="operator">/</span><span class="operator">/</span>ultralytics.com<span class="operator">/</span>assets<span class="operator">/</span>coco128.zip</span><br></pre></td></tr></table></figure>
<p>主要修改了train和val的路径，以及names的数量和名称（用于测试）<br><a name="fMVyi"></a></p>
<h3 id="模型配置文件"><a href="#模型配置文件" class="headerlink" title="模型配置文件"></a>模型配置文件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"></span><br><span class="line"># Parameters</span><br><span class="line">nc: <span class="number">1</span> # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span> # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span> # layer channel multiple</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>] # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>] # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>] # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">64</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>]], # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">128</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">6</span>, C3, [<span class="number">256</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">9</span>, C3, [<span class="number">512</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, SPPF, [<span class="number">1024</span>, <span class="number">5</span>]], # <span class="number">9</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> head</span><br><span class="line">head: [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P3</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">256</span>, <span class="literal">False</span>]], # <span class="number">17</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">20</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P5</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>, <span class="literal">False</span>]], # <span class="number">23</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"></span><br><span class="line">    [[<span class="number">17</span>, <span class="number">20</span>, <span class="number">23</span>], <span class="number">1</span>, Detect, [nc, anchors]], # Detect(P3, P4, P5)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>这里改个nc就行了（数据集的类别数）<br><a name="ShPbp"></a></p>
<h2 id="开始训练-1"><a href="#开始训练-1" class="headerlink" title="开始训练"></a>开始训练</h2><p>在终端输入以下命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 8 --epochs 300 --data ./data/test.yaml --cfg ./models/test.yaml --weights ./weights/yolov5s.pt --device cpu</span></span><br></pre></td></tr></table></figure>
<p>各个参数作用：</p>
<ul>
<li>img：640×640</li>
<li>batch：类别</li>
<li>epochs：训练迭代次数</li>
<li>data：数据配置文件位置</li>
<li>cfg：模型配置文件位置</li>
<li>weights： 训练权重数据，如果本地没有的话应该会自动下载，以开始训练</li>
<li>device： 这个还没搞明白 正常来说是应该调用gpu的，但是我的驱动似乎有点问题，故 cpu，启动！</li>
</ul>
<p><img src="a5aa4e4d73279a6ea804ffc393a818b.png" alt="a5aa4e4d73279a6ea804ffc393a818b"></p>
<p>训练结束后，会生成两个预训练的模型：</p>
<ul>
<li>best.pt：保存的是中间一共比较好模型</li>
<li>last.pt：训练结束后保存的最后模型</li>
</ul>
<p>尽量把最终训练的模型保存拷贝一份，防止下载再训练给覆盖，白玩<br><a name="g8lUK"></a></p>
<h3 id="浅浅展示训练成果"><a href="#浅浅展示训练成果" class="headerlink" title="浅浅展示训练成果"></a>浅浅展示训练成果</h3><p><br /><img src="d3b58a358174697795bb89c1d86d4bb.png" alt="d3b58a358174697795bb89c1d86d4bb"></p>
<p><img src="4edb813049a6da8f7e926d72ebb0357.png" alt="4edb813049a6da8f7e926d72ebb0357"></p>
<p><img src="d164b7d5fd9b273031ec37aca0e9872.png" alt="d164b7d5fd9b273031ec37aca0e9872"></p>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python3 detect.py <span class="comment">--source ./data/images/image_9.png --weights ./weights/best.pt --device cpu</span></span><br></pre></td></tr></table></figure>
<p>由于数据量较小，准确率较低，就不放图了）</p>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>yolo</tag>
      </tags>
  </entry>
  <entry>
    <title>vim从入门到入土</title>
    <url>/2024/10/15/vim%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<p>首先声明我的vscode坚定拥护者身份，奈何十年老古董实在带不动，不得不重新捡起vim开始朴素（装逼）生活。<br><span id="more"></span></p>
<h2 id="1-什么是-Vim？"><a href="#1-什么是-Vim？" class="headerlink" title="1. 什么是 Vim？"></a>1. 什么是 Vim？</h2><p>Vim 是一个强大的文本编辑器，基于经典的 vi 编辑器。它的核心设计理念是高效编辑文本，特别适合程序员和技术用户 <strong>(高逼格用户)</strong>。</p>
<p>与大多数文本编辑器不同，Vim 的操作基于模式切换，它拥有多个操作模式，使你能够在插入、编辑、命令等操作之间快速切换。</p>
<p><strong><em>Vim vs Vi：Vim 是 vi 的增强版，提供了更多的功能，如多级撤销、语法高亮、扩展的脚本支持等。</em></strong></p>
<h2 id="2-Vim-的主要模式"><a href="#2-Vim-的主要模式" class="headerlink" title="2. Vim 的主要模式"></a>2. Vim 的主要模式</h2><p>Vim 的操作基于不同的模式，主要有以下几种模式：<br><strong>1.普通模式 (Normal Mode)：</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">默认进入的模式，用于导航和操作文本。</span><br><span class="line">进入方式：启动 Vim 后默认进入，或按 Esc 回到普通模式。</span><br><span class="line">常用命令：</span><br><span class="line">h：向左移动光标。</span><br><span class="line">j：向下移动光标。</span><br><span class="line">k：向上移动光标。</span><br><span class="line">l：向右移动光标。</span><br><span class="line"><span class="selector-tag">dd</span>：删除当前行。</span><br><span class="line">yy：复制当前行。</span><br><span class="line"><span class="selector-tag">p</span>：在光标之后粘贴。</span><br></pre></td></tr></table></figure><br><strong>2.插入模式 (Insert Mode)：</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">用于编辑文本，类似于普通文本编辑器的输入状态。</span><br><span class="line">进入方式：按 <span class="selector-tag">i</span> 或 <span class="selector-tag">a</span> 进入。</span><br><span class="line">退出方式：按 Esc 退出插入模式，回到普通模式。</span><br></pre></td></tr></table></figure><br><strong>3.可视模式 (Visual Mode)：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">用于选择文本块。</span><br><span class="line">进入方式：按 v 进入。</span><br><span class="line">常用操作：</span><br><span class="line">y：复制选中的文本。</span><br><span class="line">d：删除选中的文本。</span><br><span class="line"><span class="selector-tag">p</span>：粘贴选中的文本。</span><br></pre></td></tr></table></figure>
<p><strong>4.命令行模式 (Command-Line Mode)：</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">用于执行命令，如保存、退出、查找等。</span><br><span class="line">进入方式：按 : 进入。</span><br><span class="line">常用命令：</span><br><span class="line"><span class="symbol">:w</span>：保存文件。</span><br><span class="line"><span class="symbol">:q</span>：退出文件。</span><br><span class="line"><span class="symbol">:wq</span>：保存并退出。</span><br><span class="line"><span class="symbol">:q!</span>：强制退出（不保存修改）。</span><br></pre></td></tr></table></figure>
<h2 id="3-基本操作指南"><a href="#3-基本操作指南" class="headerlink" title="3. 基本操作指南"></a>3. 基本操作指南</h2><h3 id="3-1-移动光标"><a href="#3-1-移动光标" class="headerlink" title="3.1 移动光标"></a>3.1 移动光标</h3><p>Vim 的基本光标移动是基于 h、j、k、l 四个键，可以用来代替方向键。此外，Vim 提供了更多强大的导航功能：</p>
<pre><code>w：跳转到下一个单词的开头。
b：跳转到上一个单词的开头。
gg：跳转到文件开头。
G：跳转到文件末尾。
Ctrl + f：向下翻页。
Ctrl + b：向上翻页。
</code></pre><h3 id="3-2-插入和编辑文本"><a href="#3-2-插入和编辑文本" class="headerlink" title="3.2 插入和编辑文本"></a>3.2 插入和编辑文本</h3><p>在普通模式下，通过按以下键进入插入模式以编辑文本：</p>
<pre><code>i：在光标前插入文本。
I：在当前行的行首插入文本。
a：在光标后插入文本。
A：在当前行的行尾插入文本。
o：在光标下方新建一行并插入。
O：在光标上方新建一行并插入。
</code></pre><h3 id="3-3-删除文本"><a href="#3-3-删除文本" class="headerlink" title="3.3 删除文本"></a>3.3 删除文本</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">x：删除光标所在的字符。</span><br><span class="line"><span class="built_in">dd</span>：删除当前行。</span><br><span class="line">d + 移动命令：根据移动命令删除内容，例如 <span class="built_in">dw</span> 删除到下一个单词开头，d$ 删除到行尾。</span><br></pre></td></tr></table></figure>
<h3 id="3-4-复制和粘贴"><a href="#3-4-复制和粘贴" class="headerlink" title="3.4 复制和粘贴"></a>3.4 复制和粘贴</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">yy：复制当前行。</span><br><span class="line">y + 移动命令：复制指定范围的内容，例如 yw 复制到下一个单词开头。</span><br><span class="line"><span class="selector-tag">p</span>：在光标后粘贴内容。</span><br><span class="line"><span class="selector-tag">P</span>：在光标前粘贴内容。</span><br></pre></td></tr></table></figure>
<h3 id="3-5-撤销和重做"><a href="#3-5-撤销和重做" class="headerlink" title="3.5 撤销和重做"></a>3.5 撤销和重做</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">u：撤销上一步操作。</span><br><span class="line">Ctrl + <span class="built_in">r</span>：重做撤销的操作。</span><br></pre></td></tr></table></figure>
<h2 id="4-Vim-高级操作"><a href="#4-Vim-高级操作" class="headerlink" title="4. Vim 高级操作"></a>4. Vim 高级操作</h2><h3 id="4-1-查找和替换"><a href="#4-1-查找和替换" class="headerlink" title="4.1 查找和替换"></a>4.1 查找和替换</h3><p>Vim 提供了强大的查找和替换功能：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">/pattern：向前查找 pattern。</span><br><span class="line"><span class="string">?p</span>attern：向后查找 pattern。</span><br><span class="line">n：跳转到下一个匹配项。</span><br><span class="line">N：跳转到上一个匹配项。</span><br><span class="line"><span class="symbol">:s/old/new/g</span>：将当前行中的 old 替换为 new。</span><br><span class="line"><span class="symbol">:%s/old/new/g</span>：将整个文件中的 old 替换为 new。</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-多文件和窗口操作"><a href="#4-2-多文件和窗口操作" class="headerlink" title="4.2 多文件和窗口操作"></a>4.2 多文件和窗口操作</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:e</span> filename：打开一个新文件。</span><br><span class="line"><span class="symbol">:vsp</span> filename：垂直分屏打开文件。</span><br><span class="line"><span class="symbol">:sp</span> filename：水平分屏打开文件。</span><br><span class="line"><span class="title class_">Ctrl</span> + w + h/j/k/l：在不同窗口间切换。</span><br></pre></td></tr></table></figure>
<h3 id="4-3-宏录制与回放"><a href="#4-3-宏录制与回放" class="headerlink" title="4.3 宏录制与回放"></a>4.3 宏录制与回放</h3><p>Vim 支持录制操作的宏，可以将常用操作记录下来并反复执行：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">q</span> + 字母：开始录制宏到指定的字母键（如 <span class="selector-tag">q</span> <span class="selector-tag">a</span> 开始录制到 <span class="selector-tag">a</span>）。</span><br><span class="line">执行所需操作。</span><br><span class="line"><span class="selector-tag">q</span>：停止录制。</span><br><span class="line">@<span class="selector-tag">a</span>：回放录制的宏 <span class="selector-tag">a</span>。</span><br></pre></td></tr></table></figure></p>
<h2 id="5-Vim-的配置"><a href="#5-Vim-的配置" class="headerlink" title="5. Vim 的配置"></a>5. Vim 的配置</h2><p>Vim 可以通过编辑 .vimrc 文件进行自定义，这个文件通常位于用户的主目录下。通过编辑 .vimrc，你可以为 Vim 添加一些个性化的配置，以提高编辑效率。以下是一些常用配置选项：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>        <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>     <span class="comment">&quot; 设置 Tab 键宽度为 4 个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>  <span class="comment">&quot; 设置自动缩进为 4 个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab     <span class="comment">&quot; 将 Tab 转换为空格</span></span><br><span class="line"><span class="keyword">set</span> cursorline    <span class="comment">&quot; 高亮当前行</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>         <span class="comment">&quot; 启用语法高亮</span></span><br><span class="line"><span class="keyword">set</span> relativenumber <span class="comment">&quot; 显示相对行号</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-常用-Vim-插件"><a href="#6-常用-Vim-插件" class="headerlink" title="6. 常用 Vim 插件"></a>6. 常用 Vim 插件</h2><p>Vim 的强大之处还在于其插件支持，可以通过插件扩展其功能。以下是一些常用的 Vim 插件：</p>
<ol>
<li>NerdTree：文件浏览器插件，允许你在 Vim 中以树状结构浏览文件。</li>
<li>Vim-Airline：美化状态栏，提供更丰富的状态信息。</li>
<li>Fzf：强大的文件搜索工具，能够快速定位和打开文件。</li>
<li>YouCompleteMe：代码自动补全插件，支持多种编程语言的补全。</li>
<li>Syntastic：语法检查工具，能够帮助你及时发现代码中的错误。</li>
</ol>
<p>可以通过 Vim 的插件管理工具（如 Vundle 或 Pathogen）来安装和管理这些插件。</p>
<h2 id="7-如何退出-Vim"><a href="#7-如何退出-Vim" class="headerlink" title="7. 如何退出 Vim"></a>7. 如何退出 Vim</h2><p>退出 Vim 是初学者经常遇到的问题。以下是几种退出方式：<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:q</span>：退出（无修改时）。</span><br><span class="line"><span class="symbol">:wq</span> 或 <span class="title class_">ZZ</span>：保存并退出。</span><br><span class="line"><span class="symbol">:q!</span>：强制退出（不保存修改）。</span><br><span class="line"><span class="symbol">:wq!</span>：强制保存并退出。</span><br></pre></td></tr></table></figure></p>
<p>掌握了这些内容基本就足够在服务器终端上大展身手了，网上有很多大佬开发了各种各样的vim插件（说实话vim的最终解就是vscode），以后可能会继续更新这些插件配置相关内容</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>句子倒置</title>
    <url>/2023/11/21/%E5%8F%A5%E5%AD%90%E5%80%92%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="句子倒置"><a href="#句子倒置" class="headerlink" title="句子倒置"></a>句子倒置</h1><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个英语的语句，比如”London bridge is falling down”，把它完全倒装过来，”down falling is bridge London”，如何不使用额外的存储空间完成这个倒装过程？<br>常学习计算机算法的人在解决这个问题时，首先会想到把这个句子切割成一个个单词，然后把它们存到一个数组里，把这个数组顺序存入，逆序取出来就可以完成语句倒装的问题。但是，这种算法要额外地使用存储空间，因此不符合题目的要求。</p>
<span id="more"></span>
<p>我们可以考虑这样解决问题：<br>第一步，先将整个句子看成是一个完整的字符串，以字母为单位头尾对调，这样上面的句子就变成了下面这样一个乱七八糟的字符串：<br>“nwod gnillaf si egdirb nodnoL”<br>第二步，把用空格分割的每一个字串以字母为单位，头尾对调。比如第一个字串是nwod，头尾对调后是down，也就是原来句子中的最后一个单词。第二个字串是gnillaf，字母头尾对调后是falling，原来句子中倒数第二个单词。这样一个个地做，直到最后一个字串里的字母对调完毕。这样就得到了下面的倒装句子：<br>“down falling is bridge London.”</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>题目中已经给出了诱导式的方法：需要造两个轮子：<em>句子倒置</em>和<em>单词倒置</em>。</p>
<ul>
<li><p>单词倒置比较容易，可以在首尾各添一个指针逐渐向中间靠拢，每次两个指针各自指向的元素互换，从而达到倒置效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Word</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> temp = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>句子倒置也不算特别复杂，其根本原理是首先把整个句子倒置，再把句子拆分成为单词，以空格为分界，将每个单词再次倒置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sentence</span><span class="params">(<span class="type">char</span>* sentence)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="type">char</span>* start = sentence;</span><br><span class="line">    Word(sentence, sentence + length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentence[i] == <span class="string">&#x27; &#x27;</span> || sentence[i] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            Word(start, sentence + i - <span class="number">1</span>);</span><br><span class="line">            start = sentence + i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Word</span><span class="params">(<span class="type">char</span>* start, <span class="type">char</span>* end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">char</span> temp = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sentence</span><span class="params">(<span class="type">char</span>* sentence)</span> &#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="type">char</span>* start = sentence;</span><br><span class="line">    Word(sentence, sentence + length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentence[i] == <span class="string">&#x27; &#x27;</span> || sentence[i] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            Word(start, sentence + i - <span class="number">1</span>);</span><br><span class="line">            start = sentence + i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="type">char</span>* <span class="built_in">string</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span> || c == EOF) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span>[i] = c;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span>[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> sentence[] = <span class="string">&quot;London bridge is falling down&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original sentence: %s\n&quot;</span>, sentence);</span><br><span class="line">    Sentence(sentence);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reversed sentence: %s\n&quot;</span>, sentence);</span><br><span class="line"><span class="comment">//    char string[100]=&#123;&#125;;</span></span><br><span class="line"><span class="comment">//    input(string);</span></span><br><span class="line"><span class="comment">//    Sentence(string);</span></span><br><span class="line"><span class="comment">//    printf(&quot;%s&quot;,string);</span></span><br><span class="line"><span class="comment">//    这个是可以自己输入字符串的倒置程序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>凯撒密码</title>
    <url>/2023/11/22/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>凯撒加密算法Caesar<br>    在密码学中，凯撒密码（英语：Caesar cipher），或称凯撒加密、凯撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p>
<span id="more"></span>
<p>​    凯撒密码的替换方法是通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。例如，当偏移量是左移3的时候（解密时的密钥就是3）：<br>明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</p>
<p>​    当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。<br>​    使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：<br>明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG<br>密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ<br>​    加密系统使用的秘诀是发送方和接收方需要知道加密用的偏移量，这个加密算法虽然现在看来特别容易破解，但是它刚开始使用的时候还是很安全的。<br>​    未加密的文字称为明文plaintext. 加密后的文字称为密文ciphertext. 偏移的位置称为钥匙 key.<br>例如用钥匙1 加密HELLO 产生密文IFMMP:<br>​    plaintext    H    E    L    L    O</p>
<p>​    key    1    1    1    1    1<br>​    = ciphertext    I    F    M    M    P<br>​    如果p是明文, pi 是p中第 ith 个 字符, k是密码（正整数）,那么密文c中第i个字符 ci,的计算公式如下：<br>ci = (pi + k) % 26<br>​    你可以把A看作一个数组的第一个元素 (下标是0), B 的下标是 1, …, Z 的下标就是25. 假设明文p是Hi ,密钥 k 是 3. p0 是 H (aka 7), 下一个字符 p1, 是 i (aka 8). 密文的第一个字符c0, 是 K, 第二个字符 c1是 L.<br>​    请写程序 Caesar.c 其功能是用 Caesar 加密算法给信息加密.用户输入的钥匙可能不是正整数，这时我们要求要求用户必须输入正整数作为密钥.<br>程序的运行如下例。密钥是1 ，明文是HELLO:<br>​    plaintext:  HELLO<br>​    ciphertext: IFMMP<br>​    明文是 hello, world，密钥是13时运行输入:<br>​    plaintext:  hello, world<br>​    ciphertext: uryyb, jbeyq<br>注意：标点符号和空格不加密，只有文本加密! 小写字母保持小写，大写字母保持大写。<br>部分代码已经给出，请将to-list 中的5的任务完成，就可以实现以上任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">// 清空输入缓冲区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushInputBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取加密密钥</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_key</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入加密密钥（正整数）: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理密钥的非正整数输入</span></span><br><span class="line">    <span class="keyword">while</span> (key &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入正整数作为加密密钥: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密和解密函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> p[], <span class="type">char</span> c[], <span class="type">int</span> len, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; p[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            c[i] = <span class="string">&#x27;A&#x27;</span> + (p[i] - <span class="string">&#x27;A&#x27;</span> + key) % <span class="number">26</span>; <span class="comment">// 加密大写字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">            c[i] = <span class="string">&#x27;a&#x27;</span> + (p[i] - <span class="string">&#x27;a&#x27;</span> + key) % <span class="number">26</span>; <span class="comment">// 加密小写字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[i] = p[i]; <span class="comment">// 保留非字母字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在密文字符串的末尾添加空字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查解密后的文本是否与原始文本匹配</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span> p[], <span class="type">char</span> origin[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p, origin) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加密正确。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加密不正确。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;chcp 65001&quot;</span>);</span><br><span class="line">    <span class="type">int</span> key = get_key();</span><br><span class="line">    <span class="type">char</span> p[<span class="number">100</span>], c[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    flushInputBuffer();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入明文:&quot;</span>);</span><br><span class="line">    fgets(p, <span class="keyword">sizeof</span>(p), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输入的换行符</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">if</span> (p[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        p[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    change(p, c, len, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示加密后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;密文是: %s&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    <span class="type">char</span> origin[<span class="number">100</span>];</span><br><span class="line">    change(c, origin, len, <span class="number">26</span> - key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示解密后的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始文本是:\n%s\n&quot;</span>, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查加密是否正确</span></span><br><span class="line">    check(p, origin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>屎山——不倒就是山，倒了才是屎</strong></p>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>关于过年抢红包的数学模型</title>
    <url>/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="关于过年抢红包的数学模型"><a href="#关于过年抢红包的数学模型" class="headerlink" title="关于过年抢红包的数学模型"></a>关于过年抢红包的数学模型</h1><h2 id="建模初衷"><a href="#建模初衷" class="headerlink" title="建模初衷"></a>建模初衷</h2><p>旧词已去，新春将至，首先祝各位新春快乐，龙年大吉！   </p>
<p>​     最近，我不禁留意到许多朋友在抢红包这一传统活动中屡次受挫，心生疑惑与好奇。在这个新年风俗的背后，究竟隐藏着怎样的数学模型和本源机制呢？于是，我产生了一个突发奇想的想法，希望通过构建一个专注于抢红包的数学模型，深入探讨这一活动的规律、趋势以及可能的变数。</p>
<span id="more"></span>
<p>​     这个数学模型的目标不仅仅是揭示红包金额的分配方式，更是希望通过对抢红包过程的数学建模，挖掘其中的概率学、随机性、和博弈理论等数学原理。通过精心设计模型，我们或许能够理解为何有些人总能赢得更多，而有些人却屡屡受挫的原因。这也为我们提供了一个新的视角，来看待这个看似简单却又蕴含深厚数学内涵的传统文化现象。</p>
<h2 id="模型雏形"><a href="#模型雏形" class="headerlink" title="模型雏形"></a>模型雏形</h2><p>​    在红包数据庞大的情况下，抢红包的机制可以近似看作是随机抽样。我们可以采用蒙特卡洛模拟方法，通过生成大量的随机样本进行统计分析，从而估算红包分配的平均情况。这种方法通过模拟多次独立的红包抢夺过程，得到了一个近似的红包金额分布，</p>
<p>​    这种方法的优势在于，它不仅能够在庞大的数据集上进行模拟，而且还能够灵活地应用于不同的分布类型。我们引入了参数 <code>distribution</code>，使得模拟可以选择均匀分布或正态分布等。此外，为了提高效率，我们使用了 NumPy 库生成正态分布，使模拟更加高效。</p>
<p>   这个模型的局限性在于它仍然是一个概率模型，通过模拟得到的结果是一种期望的近似。在实际应用中，还可以进一步考虑更复杂的因素，例如用户心理、群体行为等，以得到更准确的模拟结果。这个模型的主要目的是为了提供一个直观的近似方法，用于初步理解红包分配的规律。   </p>
<h2 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h2><p>生成的图像是红包金额分配的模拟结果。在这个模型中，我们进行了多次蒙特卡洛模拟，每次模拟都对同一组人数和总金额进行了10000次红包抽取。图像中的 x 轴表示抢红包的人数，y 轴表示每个人抢到的红包平均金额。</p>
<p>通过这个图像，我们可以观察到在给定的总金额和人数下，每个人抢到的红包平均金额的分布情况。在模拟的多次试验中，我们得到了多个平均分布曲线，每条曲线代表一次模拟的结果。这样的可视化展示使我们能够更清晰地了解红包分配的随机性和不确定性。</p>
<p>在图像中，如果某个人数下的平均金额分布较为集中，说明在这种情况下，大多数人抢到的金额差异不大。相反，如果分布较为分散，说明抢到的金额存在较大的差异。</p>
<p><img src="Figure_1.png" alt="Figure_1"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simulate_red_packet</span>(<span class="params">total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span></span>):</span><br><span class="line">    all_results = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):  <span class="comment"># 模拟10000次抢红包</span></span><br><span class="line">            remaining_amount = total_amount</span><br><span class="line">            remaining_people = total_people</span><br><span class="line">            red_packet = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total_people - <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 随机生成一个红包金额</span></span><br><span class="line">                <span class="keyword">if</span> distribution == <span class="string">&#x27;uniform&#x27;</span>:</span><br><span class="line">                    amount = random.uniform(<span class="number">0.01</span>, remaining_amount - remaining_people * <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">elif</span> distribution == <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                    amount = <span class="built_in">max</span>(<span class="number">0.01</span>, np.random.normal(remaining_amount / remaining_people, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid distribution type&quot;</span>)</span><br><span class="line"></span><br><span class="line">                red_packet.append(amount)</span><br><span class="line">                remaining_amount -= amount</span><br><span class="line">                remaining_people -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后一个红包的金额等于剩余的金额</span></span><br><span class="line">            red_packet.append(remaining_amount)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 随机打乱红包顺序</span></span><br><span class="line">            random.shuffle(red_packet)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录每个人抢到的金额</span></span><br><span class="line">            results.append(red_packet)</span><br><span class="line"></span><br><span class="line">        all_results.append(results)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_results</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_results</span>(<span class="params">all_results</span>):</span><br><span class="line">    average_amounts_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> results <span class="keyword">in</span> all_results:</span><br><span class="line">        average_amounts = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(results[<span class="number">0</span>])):</span><br><span class="line">            total_amount = <span class="built_in">sum</span>(result[i] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line">            average_amount = total_amount / <span class="built_in">len</span>(results)</span><br><span class="line">            average_amounts.append(average_amount)</span><br><span class="line"></span><br><span class="line">        average_amounts_list.append(average_amounts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> average_amounts_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">average_amounts_list, num_simulations</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(average_amounts_list[i]) + <span class="number">1</span>), average_amounts_list[i], label=<span class="string">f&#x27;Simulation <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Person&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Average Amount&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Red Packet Distribution with Varying Data Amount&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    total_amount = <span class="number">100</span>  <span class="comment"># 总金额</span></span><br><span class="line">    total_people = <span class="number">10</span>  <span class="comment"># 总人数</span></span><br><span class="line">    num_simulations = <span class="number">5</span>  <span class="comment"># 模拟次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟均匀分布下的抢红包情况</span></span><br><span class="line">    all_results_uniform = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">    average_amounts_uniform = analyze_results(all_results_uniform)</span><br><span class="line">    plot_distribution(average_amounts_uniform, num_simulations)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟正态分布下的抢红包情况</span></span><br><span class="line">    all_results_normal = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">    average_amounts_normal = analyze_results(all_results_normal)</span><br><span class="line">    plot_distribution(average_amounts_normal, num_simulations)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>我们可以建立一个简单的数学模型，其中包含三个变量：引诱红包的金额量（<code>enticing_amount</code>）、引诱的群聊数量（<code>group_count</code>）、和最终净红包的回报率（<code>return_rate</code>）。我们可以假设这些变量之间存在某种线性关系。</p>
<p><strong><em>Net_Red_Packet=enticing_amount×group_count×return_rate+noise</em></strong></p>
<p>其中，<em>noise</em> 表示模型中的随机噪声，可以包含一些不可预测的因素。</p>
<p>为了使用神经网络构建模型，我们可以将其视为一个回归问题。我们的输入特征为引诱红包的金额量、引诱的群聊数量，输出为最终净红包的回报率。</p>
<p><img src="Figure_3.png" alt="Figure_2"></p>
<p>可以看到在epoch接近100时，尽管有一点波动，在之后训练损失值已经趋于稳定。</p>
<p><img src="Figure_2.png" alt="Figure_3"></p>
<p>在以上可视化图像中不难发现，红包金额有以下几个特点：</p>
<ol>
<li><strong>随机性主导分配：</strong> 由于红包的随机性，抢到红包的金额呈现出随机分布的特征。这符合我们对红包抢够的直观认知，即每个人抢到的金额具有不确定性。</li>
<li><strong>平均金额趋向：</strong> 随着模拟次数的增加，我们观察到平均金额有向某个数值趋近的趋势。这可能是由于模型中设置的金额范围和总人数等参数导致的。在实际情况中，红包金额的平均分配可能受到更多因素的影响，例如红包金额设置、群聊人数等。</li>
<li><strong>模型的应用范围：</strong> 这个模型在一定程度上反映了红包随机分配的特性，但并不涵盖所有情况。实际中，红包分配还可能受到人为干预、算法调整等因素的影响，这些因素并未在模型中考虑。</li>
</ol>
<h2 id="模型总结"><a href="#模型总结" class="headerlink" title="模型总结"></a>模型总结</h2><ol>
<li><p><strong>更复杂的模型：</strong> 在实际应用中，可以考虑引入更多的因素，如用户关系、历史抢红包记录等，构建更为复杂的数学模型，以更准确地描述红包分配的机制。</p>
</li>
<li><p><strong>算法优化：</strong> 针对特定场景，可以优化红包分配的算法，以达到更好的用户体验。这可能需要对模型进行细致的参数调整和算法改进。</p>
</li>
<li><p><strong>社会学和心理学因素：</strong> 考虑到红包活动是一种社交行为，未来的研究可以引入社会学和心理学的因素，深入探讨红包背后的社交动机和心理机制。</p>
<p><strong>以及，可以适当考虑人品问题。</strong></p>
<p>（本文章无任何研究意义，仅供娱乐，相关可视化代码已经发布到Github上）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>屎山</tag>
      </tags>
  </entry>
  <entry>
    <title>基于stm32的蓝牙循迹小车思路</title>
    <url>/2023/11/05/%E5%9F%BA%E4%BA%8Estm32%E7%9A%84%E8%93%9D%E7%89%99%E5%BE%AA%E8%BF%B9%E5%B0%8F%E8%BD%A6%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="一-概况："><a href="#一-概况：" class="headerlink" title="一. 概况："></a>一. 概况：</h2><ol>
<li><p>基本思路。</p>
</li>
<li><p>最初代码实现。</p>
</li>
<li><p>最终代码实现。</p>
<span id="more"></span>
</li>
</ol>
<h2 id="二-思路实现-amp-amp-理解："><a href="#二-思路实现-amp-amp-理解：" class="headerlink" title="二. 思路实现&amp;&amp;理解："></a>二. 思路实现&amp;&amp;理解：</h2><h3 id="1-循迹："><a href="#1-循迹：" class="headerlink" title="1. 循迹："></a>1. 循迹：</h3><ul>
<li><p>整体思路：ADC采样—&gt;对ADC采样数据的数学处理—&gt;对得到的数据进行PID算法运算—&gt;赋值给ccr调整pwm波输出占空比驱动电机。循环此过程则可实现速度闭环实现直角弯道除外的赛道。</p>
</li>
<li><p>方案：两灯&amp;三灯及以上。</p>
</li>
</ul>
<p>​       <strong>归根结底，重点在于数学算法处理。</strong></p>
<ul>
<li><p>实操理解：</p>
<p><strong>针对采样：</strong></p>
</li>
</ul>
<p>​      <em>重要参数</em>：单个采样范围及变化趋势&amp;&amp;单个采样值。</p>
<p>​              单个采样范围及变化趋势：非常有限，几乎不触及黑线采样值变化很小，但一接近黑线立即成指数增长。</p>
<p>​              单个采样值：几百（个体差异）~约2300的原始值。但转化为电压值之后仅为0~3.3，大量数据被压缩，损失了很多精度，最终决定采用原始                                        值进行操作。</p>
<p>​              误差来源<em>包括但不限</em>：环境红外线影响  红外对管个体差异  红外对管彼此距离  红外对管对地距离。</p>
<p>​              环境红外线影响：</p>
<p>​                    非常影响红外对管采集数据。最终解决办法有两种：</p>
<p>​                （1）在每个红外对管四周缠上黑胶布，用以反射环境红外线并聚合红外对管发出的红外线；</p>
<p>​                （2）在代码中初始化过程中消除环境误差并不需要测得，但随着小车运动导 致的位置改变，环境误差在变化，而我们只消除了开始的误差，但我们放弃使用动态消除误差，可能会影响正常循迹和路口识别。</p>
<p>​               红外对管个体差异：</p>
<p>​                    不同红外对管的峰值大致相同，但最低值各有千秋。有的一两百，有的却五六百。考虑到对ADC采样数据进行处理时，个体误差的存在会影响很多计算结果造成两个灯调节作用差别很大。故必须消除。最终我们采用个体采样值域大的红外对管，以输出更加灵敏的值，并在代码中在初始化过程中，连同环境误差一起消除。</p>
<p>​               红外对管彼此距离：</p>
<p>​                    主要影响两点，一是识别范围，二是数学处理时产生漏洞。对于第一点，两灯距离太小时，识别范围就太小，小车遇到稍抖一点的弯路时极易偏线，但两灯距离过大时，就相当于允许小车有一定程度的偏线，造成循迹不流畅。对于第二点，若两灯距离过小，此时可以忽略个体误差，但同时ADC数学处理获得值值域很小，调节精度或说范围很小，若两灯距离过大，两灯之间会留出一个处理值为0的空白区允许小车一定程度偏线，这是我们不希望看到的。</p>
<p>​               红外对管对地距离：</p>
<p>​                    主要影响红外对管的采样值域。对地距离过低时红外对管接收不到反射光，采样值很低，对地距离过高时很受环境光干扰，接收红外线很多，采样值很高，通过打印波形图来观察何对地距离红外对管的检测距离最大，以及采样值域最大。</p>
<p>​        <strong>针对数学处理：</strong></p>
<p>​       处理参数：识别范围，输出值。</p>
<p>​                  识别范围：即小车的“视野”，能够允许偏线程度最大的情况下依然可以回归正轨。</p>
<p>​                   输出值：作为偏差，进行PID运算后，改变ccr来改变电机占空比。</p>
<p>​       处理方法与消除误差：</p>
<p>​                   两灯： 缺少能够作为条件的判断，所以只有让两灯采样值相减，同时让两灯在同一环境下初始化，记录两灯差值，然后代入程序中来消除个体误差和环境误差，然后调用ADC数据处理函数，得到曲线。</p>
<p>​      </p>
<p>​    <strong>针对PID：</strong></p>
<p>​        本次任务中采用位置式PID，且用到P与D参与运算。</p>
<p>​        采用PD系统调节原因：通过P进行主导线形控制，通过D来计算未来趋势抑制系统震荡，即通过PD系统获得更快的反应速度。符合循迹需求。</p>
<p>​        输入值：实时计算ADC数学处理获得值与目标值0的差值</p>
<p>​        输出值：除了初始占空比以外的用于控制电机的pwm</p>
<p>​        偏差：ADC数学处理获得值与目标值0的差值，用于P计算</p>
<p>​        二次偏差：前后两次偏差的差值，用于D计算</p>
<p>​        调参注意：P过小调节作用小，P过大造成过冲系统震荡。D过小调节作用小，D过大会放大系统趋势的影响，使系统震荡。</p>
<p>​        调参顺序：先设D=0，调P，从0逐渐增大，直到系统震荡。再调D使其逐渐增大，直到系统震荡。之后进行微调，直到系统稳定。</p>
<p>​      <strong>针对电机控制：</strong></p>
<p>​          调节方式：对两边电机同时附PID运算值，以达到使两测车轮具有相同效果的调节作用。</p>
<p>​          调节精度及限制：</p>
<p>​          考虑到可供调节的ccr范围为0~500( 有点小，占空比的相对调节精度小），但考虑到对循迹小车来讲500的调节范围够用，所以没改，但后来调车发现问题，发现有些曲率较大的弯转不过去，起初认为是P设的过小，但经过数学运算后发现问题是数值溢出，即能转过这个弯路的PID处理值没发挥出它的作用，因为溢出下限即占空比为0，溢出上限即占空比为100，所以最终采用【循迹电机反转函数】的使用，使溢出值得到充分利用。事实上增大ccr的可操作区间亦可。</p>
<p>​           初始值设置：一开始设置为50%占空比，因为考虑到想使PID调节具有对称性。事实效果很好，循迹很丝滑，但后来考虑到走直线速度较慢，故逐渐增大初始占空比，再具体进行调参。</p>
<p>​           置“0”操作：每次赋值给电机后，电机会保持这个数值运动，但在赋新的值之前，若不将之前赋过值的电机置0，两者会发生冲突比如相互抵消。</p>
<h3 id="2-机械结构："><a href="#2-机械结构：" class="headerlink" title="2. 机械结构："></a>2. 机械结构：</h3><ul>
<li>机械臂：</li>
</ul>
<p>​              负责能量块夹放及将普通矿放入盒子内。</p>
<ul>
<li>机械铲：</li>
</ul>
<p>​              负责为机械臂工作铺路。（可根据具体需要调整）</p>
<h2 id="三-最初代码实现："><a href="#三-最初代码实现：" class="headerlink" title="三. 最初代码实现："></a>三. 最初代码实现：</h2><h2 id="1-循迹：-1"><a href="#1-循迹：-1" class="headerlink" title="1. 循迹："></a>1. 循迹：</h2><ul>
<li>两灯：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_caiyang</span><span class="params">(<span class="type">void</span>)</span>    </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> wucha=<span class="number">0</span>;             <span class="comment">//定义两灯远离黑线的个体误差</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> LeftMax=<span class="number">0</span>;     <span class="comment">//定义左灯峰值 </span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> RightMax=<span class="number">0</span>;    <span class="comment">//定义右灯峰值</span></span><br><span class="line"></span><br><span class="line">	Right_AD=ADC_ConvertedValue[<span class="number">4</span>]; 	<span class="comment">//定义左右灯实时采样数据</span></span><br><span class="line">	Left_AD=ADC_ConvertedValue[<span class="number">7</span>];		</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(Left_AD&gt;LeftMax)	       <span class="comment">//确定左灯峰值</span></span><br><span class="line">	&#123;</span><br><span class="line">		LeftMax=Left_AD;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Right_AD&gt;RightMax)       <span class="comment">//确定右灯峰值</span></span><br><span class="line">	&#123;</span><br><span class="line">		RightMax=Right_AD;</span><br><span class="line">	&#125;		</span><br><span class="line">	</span><br><span class="line">	wucha=Right_AD-Left_AD;    <span class="comment">//确定两灯远离黑线的个体误差</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Right_AD:%d Left_AD:%d\r\n&quot;</span>,Right_AD,Left_AD);    <span class="comment">//用rawdate实时打印方便记录</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;wucha:%d LeftMax:%d RightMax:%d \r\n&quot;</span>,wucha,LeftMax,RightMax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">FloatToByte</span>                             //联合体函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">float</span> ADC_ConvertedValueLocal[NOFCHANEL];   <span class="comment">//用于保存转换计算后的电压值</span></span><br><span class="line">	<span class="type">char</span> byte[NOFCHANEL*<span class="number">4</span>+<span class="number">4</span>];                   <span class="comment">//联合体    将1个浮点数为4个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">FloatToByte</span> <span class="title">a</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Data_Out;            <span class="comment">//ADC数学处理获得值</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> Left_AD,Right_AD;    <span class="comment">//左右灯实时采样数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_ADC_PRINTF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	  a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">0</span>]=<span class="number">0x00</span>;</span><br><span class="line">	  a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">1</span>]=<span class="number">0x00</span>;</span><br><span class="line">	  a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">2</span>]=<span class="number">0x80</span>;</span><br><span class="line">    a.byte[NOFCHANEL*<span class="number">4</span>+<span class="number">3</span>]=<span class="number">0x7f</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">0</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">0</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">1</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">1</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">2</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">2</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">3</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">3</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">4</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">4</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">5</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">5</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">6</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">6</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">7</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">7</span>] ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">8</span>] = (<span class="type">float</span>)Right_AD ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">9</span>] = (<span class="type">float</span>)Left_AD ;</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">10</span>] = (<span class="type">float</span>)ADC_ConvertedValue[<span class="number">10</span>];</span><br><span class="line">        a.ADC_ConvertedValueLocal[<span class="number">11</span>] = (<span class="type">float</span>)Data_Out ;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NOFCHANEL*<span class="number">4</span>+<span class="number">4</span>;i++)      <span class="comment">//NOFCHANEL*4+4为数值12*4+4=52</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a.byte[i]);</span><br><span class="line">			&#125;</span><br><span class="line">       </span><br><span class="line">        Delay_MS(<span class="number">5</span>);        <span class="comment">//5ms一采样</span></span><br><span class="line">				</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WUCHA -400 		</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT_MAX 2927   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_MAX 2868  	</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_chuli</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	Left_AD=ADC_ConvertedValue[<span class="number">4</span>];</span><br><span class="line">	Right_AD=ADC_ConvertedValue[<span class="number">7</span>];</span><br><span class="line">	</span><br><span class="line">	Data_Out=(Left_AD-Right_AD+WUCHA);   <span class="comment">//只有两个灯，故只能作差处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	 <span class="type">uint16_t</span> kp;</span><br><span class="line">	 <span class="type">uint16_t</span> ki;</span><br><span class="line">	 <span class="type">uint16_t</span> kd;</span><br><span class="line"></span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line">PID pid;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PositionPID</span><span class="params">(<span class="type">float</span> dev)</span>         <span class="comment">//此为位置式pid（需要两次），可以考虑增量式pid（需要三次）</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> Position_kp=(<span class="type">float</span>)pid.kp,Position_ki=(<span class="type">float</span>)pid.ki,Position_kd=(<span class="type">float</span>)pid.kd;</span><br><span class="line">  <span class="type">static</span> <span class="type">float</span> Bias,Pwm,Integral_Bias,Last_Bias;</span><br><span class="line">	Bias=Data_Out;</span><br><span class="line">	Integral_Bias+=Bias;</span><br><span class="line">	</span><br><span class="line">	Pwm=Position_kp*Bias+Position_ki*Integral_Bias+Position_kd*(Bias-Last_Bias);</span><br><span class="line">	</span><br><span class="line">	Last_Bias=Bias;</span><br><span class="line">	<span class="keyword">return</span> Pwm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">motor_xunji</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Motor_Run(motor_1, <span class="number">200</span>-PositionPID(Data_Out));</span><br><span class="line">  Motor_Run(motor_2, <span class="number">0</span>);</span><br><span class="line">  Motor_Run(motor_3, <span class="number">200</span>-PositionPID(Data_Out));</span><br><span class="line">  Motor_Run(motor_4, <span class="number">0</span>);</span><br><span class="line">  Motor_Run(motor_5, <span class="number">200</span>+PositionPID(Data_Out));</span><br><span class="line">  Motor_Run(motor_6, <span class="number">0</span>);</span><br><span class="line">  Motor_Run(motor_7, <span class="number">200</span>+PositionPID(Data_Out));</span><br><span class="line">	Motor_Run(motor_8, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ADC_chuli</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">ADC_caiyang</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">motor_xunji</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 将 ADC1 转换的电压值通过 DMA 方式传到 SRAM</span></span><br><span class="line"><span class="keyword">extern</span> __IO <span class="type">uint16_t</span> ADC_ConvertedValue[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量，用于保存转换计算后的电压值</span></span><br><span class="line"><span class="type">float</span> ADC_ConvertedValueLocal[NOFCHANEL];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Data_Out;            </span><br><span class="line"><span class="type">int</span> Left_AD,Right_AD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	pid.kp=<span class="number">0</span>;</span><br><span class="line">	pid.kp=<span class="number">0</span>;</span><br><span class="line">	pid.kp=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	USART_Config();</span><br><span class="line">	ADCx_Init();</span><br><span class="line">	Delay_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="comment">//	ADC_caiyang();     //获得adc采样数据</span></span><br><span class="line">    ADC_chuli();    <span class="comment">//只进行adc采样数据处理</span></span><br><span class="line"></span><br><span class="line">		Delay_MS(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//	Test_ADC_PRINTF(); //打印ADC波形</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		void motor_xunji();    //循迹启动</span></span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-机械臂："><a href="#2-机械臂：" class="headerlink" title="2.机械臂："></a>2.机械臂：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">66</span> == i)                         <span class="comment">//上升</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (; rise &gt; <span class="number">500</span>; rise--)</span><br><span class="line">	&#123;</span><br><span class="line">		Servo_Run(servo_1, rise);</span><br><span class="line">		Delay_MS(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">54</span> == i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">65</span> == i)                          <span class="comment">//下降</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (; rise &lt; <span class="number">2500</span>; rise++)</span><br><span class="line">	&#123;</span><br><span class="line">		Servo_Run(servo_1, rise);</span><br><span class="line">		Delay_MS(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">54</span> == i)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">67</span> == i)                        <span class="comment">//夹取</span></span><br><span class="line">&#123;</span><br><span class="line">	Servo_Run(servo_2, <span class="number">1000</span>);</span><br><span class="line">	Servo_Run(servo_3, <span class="number">1400</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">68</span> == i)                        <span class="comment">//松开</span></span><br><span class="line">&#123; </span><br><span class="line">	Servo_Run(servo_2, <span class="number">1200</span>);</span><br><span class="line">	Servo_Run(servo_3, <span class="number">1200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于本次赛制并不是单纯实现循迹功能，而是走迷宫，需要在十字路口，T字路口，环形岛等情况时进行特殊判断，故舍弃原先两灯方案。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>删除数字</title>
    <url>/2023/12/09/%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="删除数字-amp-amp-合并空格"><a href="#删除数字-amp-amp-合并空格" class="headerlink" title="删除数字&amp;&amp;合并空格"></a>删除数字&amp;&amp;合并空格</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>从键盘接收一个字符串，由数字、大小写字母和空格组成。程序功能为去掉字符串中的所有数字，最后输出变更后的字符串。注意，并列的空格需要缩减为1个空格。比如键盘输入如下：</strong></p>
<p><strong>（1）</strong>能够从键盘正确接收字符串；（2分）</p>
<p><strong>（2）</strong>能够去除数字；（4分）</p>
<p><strong>（3）</strong>能够合并并列的空格；（4分）</p>
<p><strong>（4）</strong>能够输出变更后的字符串；（2分）</p>
<p><strong>（5）</strong>程序能够全面正确运行；（3分）</p>
<span id="more"></span>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    fgets(a, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 使用fgets获取一行输入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> spaceFlag = <span class="number">0</span>; <span class="comment">// 标志变量，用于检测空格连续性</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] &lt; <span class="string">&#x27;0&#x27;</span> || a[i] &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; a[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            a[j++] = a[i]; <span class="comment">// 将非数字字符和非空格字符移动到数组前部</span></span><br><span class="line">            spaceFlag = <span class="number">0</span>; <span class="comment">// 非空格字符出现时，重置空格连续性标志</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!spaceFlag) &#123;</span><br><span class="line">                a[j++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">// 保留一个空格</span></span><br><span class="line">                spaceFlag = <span class="number">1</span>; <span class="comment">// 标记已经出现一个空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    fgets(<span class="built_in">array</span>, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 读取输入的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original string: %s\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    delete(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After deleting and merging: %s\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>成绩单</title>
    <url>/2023/12/09/%E6%88%90%E7%BB%A9%E5%8D%95/</url>
    <content><![CDATA[<h1 id="TXT成绩单"><a href="#TXT成绩单" class="headerlink" title="TXT成绩单"></a>TXT成绩单</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>一份班级成绩表存储在一个TXT文件中，每行由学号、姓名、数学成绩、英语成绩、C语言成绩组成，如下：</strong></p>
<p><strong>192000101</strong> <strong>张天天 86 76 85</strong></p>
<p><strong>192000102</strong> <strong>李笑笑 91 88 76</strong></p>
<p><strong>…</strong></p>
<p><strong>192000130</strong> <strong>王维维 88 75 91</strong></p>
<span id="more"></span>
<p><strong>编制一个程序，完成下列任务。</strong></p>
<p>（1）构建一个结构体数组，来存储这个成绩表；（4分）</p>
<p>（2）能够正确的从文件读取数据到该结构体数组；（5分）</p>
<p>（3）能够将成绩表输出到屏幕；（4分）</p>
<p>（4）能输出总成绩进行排序并输出排序后的结果；（7分）</p>
<p>（5）程序架构良好、代码清晰、能够全面正确运行；（5分）</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul>
<li><strong>单文件版</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> en;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> student a)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld &quot;</span>, a.number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, a.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.math);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.en);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a.sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_sum</span><span class="params">(<span class="keyword">struct</span> student *b)</span> &#123;</span><br><span class="line">    b-&gt;sum = b-&gt;math + b-&gt;en + b-&gt;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="keyword">struct</span> student *arr, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j].sum &gt; arr[j + <span class="number">1</span>].sum) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">students</span>[3] =</span> &#123;</span><br><span class="line">        &#123;<span class="number">123</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">85</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">456</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">70</span>, <span class="number">65</span>, <span class="number">75</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">789</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        calculate_sum(&amp;students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before sorting:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        output(students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(students, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nAfter sorting:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        output(students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>多文件版（txt文件读取）</strong> </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> en;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件数据到结构体数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readData</span><span class="params">(<span class="keyword">struct</span> Student students[], <span class="type">int</span> *count)</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;grades.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%ld%s%d%d%d&quot;</span>, &amp;students[*count].number, students[*count].name,</span><br><span class="line">                  &amp;students[*count].math, &amp;students[*count].en, &amp;students[*count].c) != EOF) &#123;</span><br><span class="line">        students[*count].total = students[*count].math + students[*count].en + students[*count].c;</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结构体数组数据到屏幕</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printData</span><span class="params">(<span class="keyword">struct</span> Student students[], <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Student Number\tName\tMath\tEnglish\tC Language\tTotal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld\t%s\t%d\t%d\t%d\t%d\n&quot;</span>, students[i].number, students[i].name,</span><br><span class="line">               students[i].math, students[i].en, students[i].c, students[i].total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数用于排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">studentA</span> =</span> (<span class="keyword">struct</span> Student *)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">studentB</span> =</span> (<span class="keyword">struct</span> Student *)b;</span><br><span class="line">    <span class="keyword">return</span> studentB-&gt;total - studentA-&gt;total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[100];</span> <span class="comment">// 假设最多有100个学生</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readData(students, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Student Records:\n&quot;</span>);</span><br><span class="line">    printData(students, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序并输出排序后的结果</span></span><br><span class="line">    qsort(students, count, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nStudent Records after sorting by total score:\n&quot;</span>);</span><br><span class="line">    printData(students, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>一文教你学会看多目标检测中的指标</title>
    <url>/2025/03/16/%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E6%8C%87%E6%A0%87%E9%80%9F%E9%80%9A/</url>
    <content><![CDATA[<h1 id="目标检测入门：看懂mAP指标的核心要点"><a href="#目标检测入门：看懂mAP指标的核心要点" class="headerlink" title="目标检测入门：看懂mAP指标的核心要点"></a>目标检测入门：看懂mAP指标的核心要点</h1><h2 id="一、从找东西说起——理解检测任务"><a href="#一、从找东西说起——理解检测任务" class="headerlink" title="一、从找东西说起——理解检测任务"></a>一、从找东西说起——理解检测任务</h2><p>想象你在玩一个”找物品”的游戏：房间里藏着10个不同种类的玩具，你需要用手机拍照后圈出每个玩具的位置并说出名称。目标检测任务就类似这个过程，需要完成两个核心目标：</p>
<ol>
<li><strong>找到物品位置</strong>：用矩形框或者各种奇形怪状的圈准确框住物体（定位）</li>
<li><strong>认出物品类别</strong>：正确说出物品名称（分类）</li>
</ol>
<p>评估系统好坏时，既不能漏掉目标（如找到8个但漏了2个），也不能乱标位置（如把猫的框画到狗身上），更不能乱起名字（<strong>如把坤哥说成牢大</strong>）。这就是mAP指标要解决的问题。<br><img src="laoda.png" alt="只因你太美"></p>
<h2 id="二、核心概念拆解"><a href="#二、核心概念拆解" class="headerlink" title="二、核心概念拆解"></a>二、核心概念拆解</h2><h3 id="2-1-IoU"><a href="#2-1-IoU" class="headerlink" title="2.1 IoU"></a>2.1 IoU</h3><p>判断预测框是否正确的标准就像交朋友：</p>
<ul>
<li><strong>IoU（交并比）</strong>：计算预测框与真实框的”亲密指数”</li>
<li>计算方式：重叠面积 ÷ 合并后的总面积</li>
<li>通过阈值判断是否达标（通常0.5为及格线）<script type="math/tex; mode=display">
IoU = \frac{Area(B_{pred} \cap B_{gt})}{Area(B_{pred} \cup B_{gt})}</script></li>
</ul>
<p><img src="iou.png" alt="IoU"></p>
<h3 id="2-2-预测结果分类"><a href="#2-2-预测结果分类" class="headerlink" title="2.2 预测结果分类"></a>2.2 预测结果分类</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>判断标准</th>
<th>现实类比</th>
</tr>
</thead>
<tbody>
<tr>
<td>TP</td>
<td>框的位置正确（IoU≥阈值）且名称正确</td>
<td>正确找到朋友并叫对名字</td>
</tr>
<tr>
<td>FP</td>
<td>框的位置错误 或 名称错误</td>
<td>认错人 或 把路人当朋友</td>
</tr>
<tr>
<td>FN</td>
<td>真实存在但未被检测到</td>
<td>真正的朋友站在面前却没认出来</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-混淆矩阵衍生指标"><a href="#2-3-混淆矩阵衍生指标" class="headerlink" title="2.3 混淆矩阵衍生指标"></a>2.3 混淆矩阵衍生指标</h3><div class="table-container">
<table>
<thead>
<tr>
<th>指标名称</th>
<th>公式</th>
<th>物理意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>精确率 (Precision)</td>
<td>$P=\frac{TP}{TP+FP}$</td>
<td>预测阳性样本的真实阳性率</td>
</tr>
<tr>
<td>召回率 (Recall)</td>
<td>$R=\frac{TP}{TP+FN}$</td>
<td>真实阳性样本的检出率</td>
</tr>
<tr>
<td>F1分数 (F1 Score)</td>
<td>$F1=\frac{2PR}{P+R}$</td>
<td>精确率与召回率的调和平均</td>
</tr>
<tr>
<td>误检率 (False Positive Rate)</td>
<td>$FPR=\frac{FP}{FP+TN}$</td>
<td>负样本被误判为正的比例</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-4-系统效率指标"><a href="#2-4-系统效率指标" class="headerlink" title="2.4 系统效率指标"></a>2.4 系统效率指标</h3><div class="table-container">
<table>
<thead>
<tr>
<th>指标名称</th>
<th>测量方式</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>FPS (Frames Per Second)</td>
<td>每秒处理帧数</td>
<td>实时检测系统</td>
</tr>
<tr>
<td>内存占用 (Memory Usage)</td>
<td>显存/内存消耗量</td>
<td>嵌入式设备部署</td>
</tr>
<tr>
<td>FLOPs (Floating Point Operations)</td>
<td>浮点运算次数</td>
<td>算法复杂度评估</td>
</tr>
</tbody>
</table>
</div>
<h2 id="三、mAP的计算逻辑"><a href="#三、mAP的计算逻辑" class="headerlink" title="三、mAP的计算逻辑"></a>三、mAP的计算逻辑</h2><h3 id="3-1-从单个类别说起（AP计算）"><a href="#3-1-从单个类别说起（AP计算）" class="headerlink" title="3.1 从单个类别说起（AP计算）"></a>3.1 从单个类别说起（AP计算）</h3><p>假设现在只检测”猫”这个类别：</p>
<p><strong>一步步解析</strong>：</p>
<ol>
<li><strong>收集检测结果</strong>：记录所有预测框的置信度（把握程度）</li>
<li><strong>排序</strong>：按置信度从高到低排队</li>
<li><strong>逐级评估</strong>：<ul>
<li>从最有把握的预测开始检查</li>
<li>每个预测点形成一对（召回率，精确率）</li>
</ul>
</li>
<li><strong>绘制PR曲线</strong>：连接所有评估点形成的曲线</li>
<li><strong>计算曲线下面积</strong>：面积越大说明综合表现越好</li>
</ol>
<script type="math/tex; mode=display">
AP = \int_{0}^{1} P(R) dR</script><p><img src="image.png" alt="PR曲线示意图：曲线越凸向右上角越好"></p>
<h3 id="3-2-扩展到多类别（mAP）"><a href="#3-2-扩展到多类别（mAP）" class="headerlink" title="3.2 扩展到多类别（mAP）"></a>3.2 扩展到多类别（mAP）</h3><p>当需要检测多个类别时（如猫、狗、鸟）：</p>
<ol>
<li>对每个类别单独计算AP值</li>
<li>所有AP值的平均就是mAP</li>
<li>优势：平衡各类别的表现差异</li>
</ol>
<script type="math/tex; mode=display">
mAP = \frac{1}{N}\sum_{i=1}^{N} AP_i</script><h2 id="四、置信度"><a href="#四、置信度" class="headerlink" title="四、置信度"></a>四、置信度</h2><h3 id="4-1-置信度的数学本质"><a href="#4-1-置信度的数学本质" class="headerlink" title="4.1 置信度的数学本质"></a>4.1 置信度的数学本质</h3><p>置信度是模型对预测结果的综合信心值，由两个核心因素构成：</p>
<script type="math/tex; mode=display">
\text{置信度} = \underbrace{P(\text{类别})}_{\text{分类置信度}} \times \underbrace{IoU}_{\text{定位准确度}}</script><p>其中：</p>
<ul>
<li>P(类别) 是模型对物体类别的分类置信度，通常是通过softmax或sigmoid等激活函数计算得到的。</li>
<li>IoU 则是检测框与真实框的重叠度，反映了定位的准确性。</li>
</ul>
<p><img src="conf.png" alt="置信度"></p>
<p>置信度反映了模型对预测结果的总体信任程度。高置信度意味着模型不仅准确识别了物体的类别，而且对其位置也有较高的确定性。</p>
<h3 id="4-2-置信度的影响因素"><a href="#4-2-置信度的影响因素" class="headerlink" title="4.2 置信度的影响因素"></a>4.2 置信度的影响因素</h3><p>置信度的高低直接影响目标检测的性能，特别是在多目标检测场景下，如何合理设置置信度阈值是提升模型效果的关键。</p>
<ul>
<li><p><strong>分类置信度</strong>：分类置信度越高，模型越能准确地识别物体的类别。分类置信度通常受到训练数据质量、模型结构以及超参数调整等因素的影响。如果模型在某个类别的预测上过于保守或过于激进，可能会影响最终的检测效果。</p>
</li>
<li><p><strong>定位准确度（IoU）</strong>：定位的准确度直接决定了模型的检测框是否与真实框高度重合。IoU值过低的预测框通常会被认为是错误的，这就需要通过调节IoU的阈值来权衡误报（FP）与漏报（FN）之间的关系。</p>
</li>
</ul>
<h3 id="4-3-置信度与检测结果"><a href="#4-3-置信度与检测结果" class="headerlink" title="4.3 置信度与检测结果"></a>4.3 置信度与检测结果</h3><p>在实际应用中，目标检测模型会输出每个检测框的置信度值。这个置信度值的高低可以用来做进一步的筛选与决策：</p>
<ol>
<li><p><strong>置信度筛选</strong>：设置一个阈值，只有置信度超过该阈值的预测框才会被认为是有效的。这有助于减少错误的检测框（例如将一个非物体框判定为目标）。</p>
</li>
<li><p><strong>多目标检测中的置信度问题</strong>：在多目标检测场景中，可能会存在多个物体的检测框与置信度接近的情况。此时，需要通过后处理算法（如非极大值抑制NMS）来消除冗余框，保留最具代表性的检测框。</p>
</li>
<li><p><strong>多类别的置信度权衡</strong>：在多类别检测中，每个类别的置信度也不同，因此需要综合考虑每个类别的分类置信度与位置准确度，确保模型对所有类别的均衡检测。</p>
</li>
</ol>
<h3 id="4-4-置信度与mAP的关系"><a href="#4-4-置信度与mAP的关系" class="headerlink" title="4.4 置信度与mAP的关系"></a>4.4 置信度与mAP的关系</h3><p>mAP（mean Average Precision）是评估目标检测模型整体表现的重要指标，而置信度直接影响AP的计算。每个类别的AP计算依赖于预测框的置信度，过低的置信度可能导致许多错误的FP（假阳性）或漏报FN（假阴性），从而导致AP和mAP下降。</p>
<ul>
<li><strong>高置信度</strong>：一般能提高TP（真阳性）数量，降低FP和FN数量，从而提高模型的整体精度（AP）。</li>
<li><strong>低置信度</strong>：会使得模型更多地遗漏真实目标（FN），或错误地识别目标（FP），降低AP，从而影响mAP。</li>
</ul>
<p>因此，调整置信度阈值，以平衡检测精度和召回率，是优化目标检测模型性能的重要步骤。</p>
<h3 id="4-5-置信度阈值的选择"><a href="#4-5-置信度阈值的选择" class="headerlink" title="4.5 置信度阈值的选择"></a>4.5 置信度阈值的选择</h3><p>在实际应用中，设置合理的置信度阈值至关重要。过高的阈值可能导致漏检（FN），而过低的阈值则可能导致误检（FP）。通常通过<strong>Precision-Recall曲线</strong>来选择合适的阈值，使得模型在给定的任务和数据集上取得最佳的平衡。</p>
<ul>
<li><strong>高阈值</strong>：减少误报（FP），但可能增加漏检（FN）。</li>
<li><strong>低阈值</strong>：减少漏检（FN），但可能增加误报（FP）。</li>
</ul>
<h2 id="五、给指标检测人的”防杠声明”"><a href="#五、给指标检测人的”防杠声明”" class="headerlink" title="五、给指标检测人的”防杠声明”"></a>五、给指标检测人的”防杠声明”</h2><p>看完这篇博客的你，现在应该：</p>
<p>🕶️ 能对着PR曲线指点江山：”这个曲线不够翘啊，建议回炉重造”<br>📸 看到误检的猫猫狗狗会冷笑：”呵，FP+1”<br>🤖 跟人battle模型性能时：”先看看mAP@0.5:0.95再说话”</p>
<p>不过记住：  </p>
<ul>
<li>当甲方爸爸说”我全都要”时 → 建议ta把IoU阈值设为0.9  </li>
<li>当产品经理催”再提点准确率”时 → 请ta先标注2000张测试集  </li>
<li>当算法同学甩锅”标注有问题”时 → 请ta背诵本文第2.2节  </li>
<li><strong>但是当学长说你模型练的不行，那就是你真的菜还得多练</strong></li>
</ul>
<p>最后送给各位CV人一个灵魂拷问：<br><strong>如果坤坤的篮球被检测成只因，这算TP还是FP？</strong>  </p>
<p>（答案提示：取决于你的训练集有没有加入律师函警告样本 🤫）</p>
<blockquote>
<p>| <em>本文不生产指标，只做指标的搬运工</em><br>| <em>—— 鲁迅（并没有说过）</em></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机视觉</category>
        <category>RoboMaster</category>
      </categories>
      <tags>
        <tag>多目标检测</tag>
        <tag>YOLO</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>快排</title>
    <url>/2024/10/02/%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<h3 id="快速排序（Quick-Sort）的C-实现"><a href="#快速排序（Quick-Sort）的C-实现" class="headerlink" title="快速排序（Quick Sort）的C++实现"></a>快速排序（Quick Sort）的C++实现</h3><h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h4><p>快速排序是一种基于 <strong>分治法</strong> 的高效排序算法。通过选择一个“基准”（pivot），快速排序将序列分成两个子序列，分别递归地进行排序。在平均情况下，时间复杂度为 ( O(n \log n) )，且具有较小的常数因子，在实际中通常比其他排序算法更快。</p>
<h4 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h4><ol>
<li><strong>选择基准值（Pivot）</strong>: 通常选择序列中的第一个元素或中间元素作为基准值。</li>
<li><strong>分区（Partitioning）</strong>: 将序列中的元素按照基准值划分成两部分：左侧部分小于基准值，右侧部分大于基准值。</li>
<li><strong>递归调用</strong>: 对左侧和右侧的子序列分别进行快速排序。</li>
<li><strong>结束条件</strong>: 当子序列的长度为1或0时，不再递归。</li>
</ol>
<h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><h5 id="标准的递归实现："><a href="#标准的递归实现：" class="headerlink" title="标准的递归实现："></a>标准的递归实现：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，返回基准值的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];  <span class="comment">// 基准值</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];  <span class="comment">// 将小于基准值的元素移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左向右找大于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];  <span class="comment">// 将大于基准值的元素移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;  <span class="comment">// 基准值归位</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回基准值的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 划分序列</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pivotIndex - <span class="number">1</span>);  <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, high);  <span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">29</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-细节分析"><a href="#4-细节分析" class="headerlink" title="4. 细节分析"></a>4. 细节分析</h4><ol>
<li><p><strong>选择基准值</strong>: 代码中选择了第一个元素作为基准值 <code>pivot</code>，在某些情况下（如已排序的数组）会导致最坏的时间复杂度 ( O(n^2) )。通过随机选择基准值或选择中间元素，可以提高算法在特定输入下的效率。</p>
</li>
<li><p><strong>分区过程</strong>: </p>
<ul>
<li>从右向左找第一个小于基准值的元素，放在左侧；</li>
<li>从左向右找第一个大于基准值的元素，放在右侧；</li>
<li>这个过程不断交替进行，直到左右两侧交叉，最后将基准值归位。</li>
</ul>
</li>
<li><p><strong>递归调用</strong>: 快速排序通过递归实现对左右两个子序列的排序。由于每次递归调用的数组长度缩小，因此在平均情况下递归深度为 ( \log n )。</p>
</li>
<li><p><strong>时间复杂度</strong>:</p>
<ul>
<li><strong>最优时间复杂度</strong>: 当每次划分都非常均匀时，递归深度为 ( \log n )，每次分区的代价为 ( O(n) )，因此时间复杂度为 ( O(n \log n) )。</li>
<li><strong>最坏时间复杂度</strong>: 当数组已经有序或接近有序时，每次划分都导致极端不平衡的分区，递归深度为 ( O(n) )，时间复杂度为 ( O(n^2) )。</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>: 快速排序是 <strong>原地排序</strong> 算法，因此空间复杂度仅为递归调用时的栈空间，最优情况下为 ( O(\log n) )，最坏情况下为 ( O(n) )。</p>
</li>
</ol>
<h4 id="5-迭代实现"><a href="#5-迭代实现" class="headerlink" title="5. 迭代实现"></a>5. 迭代实现</h4><p>使用递归容易导致栈溢出问题，在此基础上可以使用栈手动模拟递归过程，进行迭代实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> s, <span class="type">int</span> e) : <span class="built_in">start</span>(s), <span class="built_in">end</span>(e) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数与递归版相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) --high;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) ++low;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代实现的快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortIterative</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;Range&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(<span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Range range = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; range.end) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = <span class="built_in">partition</span>(arr, range.start, range.end);</span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(range.start, pivot - <span class="number">1</span>));</span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(pivot + <span class="number">1</span>, range.end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">29</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSortIterative</span>(arr);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2023/11/07/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="一、概念及其介绍"><a href="#一、概念及其介绍" class="headerlink" title="一、概念及其介绍"></a>一、概念及其介绍</h3><p>插入排序(InsertionSort)，一般也被称为直接插入排序。</p>
<p>对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。</p>
<span id="more"></span>
<h3 id="二、适用说明"><a href="#二、适用说明" class="headerlink" title="二、适用说明"></a>二、适用说明</h3><p>插入排序的平均时间复杂度也是 <strong>O(n^2)</strong>，空间复杂度为常数阶 <strong>O(1)</strong>，具体时间复杂度和数组的有序性也是有关联的。</p>
<p>插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 <strong>N-1</strong> 次，时间复杂度为 <strong>O(N)</strong>。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 <strong>O(n^2)</strong>。</p>
<h3 id="三、过程图示"><a href="#三、过程图示" class="headerlink" title="三、过程图示"></a>三、过程图示</h3><p>假设前面 <strong>n-1</strong>(其中 <strong>n&gt;=2</strong>)个数已经是排好顺序的，现将第 <strong>n</strong> 个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。</p>
<p>按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序。</p>
<p>从小到大的插入排序整个过程如图示：</p>
<p><strong>第一轮：</strong>从第二位置的 6 开始比较，比前面 7 小，交换位置。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-01.png" alt="img"></p>
<p><strong>第二轮：</strong>第三位置的 9 比前一位置的 7 大，无需交换位置。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-02.png" alt="img"></p>
<p><strong>第三轮：</strong>第四位置的 3 比前一位置的 9 小交换位置，依次往前比较。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-03.png" alt="img"></p>
<p><strong>第四轮：</strong>第五位置的 1 比前一位置的 9 小，交换位置，再依次往前比较。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/InsertSort-04.png" alt="img"></p>
<p>就这样依次比较到最后一个元素。</p>
<h3 id="四、C语言代码实现"><a href="#四、C语言代码实现" class="headerlink" title="四、C语言代码实现"></a>四、C语言代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">8</span>]=&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">1</span>; <span class="comment">//定义交换中间变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=i;p&gt;<span class="number">0</span>;p--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[p]&lt;num[p<span class="number">-1</span>])&#123;<span class="comment">//判定是否小于前一个数</span></span><br><span class="line">                temp=num[p];</span><br><span class="line">                num[p]=num[p<span class="number">-1</span>];</span><br><span class="line">                num[p<span class="number">-1</span>]=temp;<span class="comment">//若小于，则两数交换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;<span class="number">8</span>;q++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,num[q]);<span class="comment">//输出数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="一、概念及其介绍-1"><a href="#一、概念及其介绍-1" class="headerlink" title="一、概念及其介绍"></a>一、概念及其介绍</h3><p>希尔排序(Shell Sort)是插入排序的一种，它是针对直接插入排序算法的改进。</p>
<p>希尔排序又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。</p>
<p>它通过比较相距一定间隔的元素来进行，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。</p>
<h3 id="二、适用说明-1"><a href="#二、适用说明-1" class="headerlink" title="二、适用说明"></a>二、适用说明</h3><p>希尔排序时间复杂度是 <strong>O(n^(1.3-2))</strong>，空间复杂度为常数阶 <strong>O(1)</strong>。希尔排序没有时间复杂度为 <strong>O(n(logn))</strong> 的快速排序算法快 ，因此对中等大小规模表现良好，但对规模非常大的数据排序不是最优选择，总之比一般 <strong>O(n^2 )</strong> 复杂度的算法快得多。</p>
<h3 id="三、过程图示-1"><a href="#三、过程图示-1" class="headerlink" title="三、过程图示"></a>三、过程图示</h3><p>希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>在此我们选择增量 <strong>gap=length/2</strong>，缩小增量以 <strong>gap = gap/2</strong> 的方式，用序列 <strong>{n/2,(n/2)/2…1}</strong> 来表示。</p>
<p>如图示例：</p>
<p>（1）初始增量第一趟 <strong>gap = length/2 = 4</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-01.png" alt="img"></p>
<p>（2）第二趟，增量缩小为 2</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-02.png" alt="img"></p>
<p>（3）第三趟，增量缩小为 1,得到最终排序结果</p>
<p>​                                                           <img src="https://www.runoob.com/wp-content/uploads/2020/09/ShellSort-03.png" alt="img"></p>
<h3 id="四、C语言代码示例"><a href="#四、C语言代码示例" class="headerlink" title="四、C语言代码示例"></a>四、C语言代码示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lenth 8</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num[lenth]=&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> gap,j;<span class="comment">//定义增量，循环变量</span></span><br><span class="line">    <span class="keyword">for</span>(gap=lenth/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;lenth;i++)&#123;<span class="comment">//外层循环，gap每次缩小1/2</span></span><br><span class="line">            <span class="type">int</span> temp=num[i];<span class="comment">//将数组元素赋值给中间值</span></span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;=gap&amp;&amp;temp&lt;num[j-gap];j-=gap)&#123;</span><br><span class="line">                num[j]=num[j-gap];</span><br><span class="line">            &#125;</span><br><span class="line">            num[j]=temp;<span class="comment">//判定若小于，两元素交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;<span class="number">8</span>;q++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,num[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h3 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
<p>重复第二步，直到所有元素均排序完毕。</p>
<h3 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="img"></p>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = rand() % <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//初始化随机数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//数组输出函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span> <span class="comment">//交换两数</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> temp = *a;</span><br><span class="line">      *a = *b;</span><br><span class="line">      *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">choose</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++)</span><br><span class="line">      &#123;</span><br><span class="line">                <span class="type">int</span> min = i;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)   <span class="comment">//走访未排序的元素</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &lt; arr[min])  <span class="comment">//找到目前最小值</span></span><br><span class="line">                        min = j;  <span class="comment">//记录最小值</span></span><br><span class="line">                swap(&amp;arr[min], &amp;arr[i]);  <span class="comment">//做交換</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    init(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    choose(a,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p>
</li>
<li><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p>
</li>
</ul>
<h3 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h3 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="img"></p>
<h3 id="3-什么时候最快"><a href="#3-什么时候最快" class="headerlink" title="3. 什么时候最快"></a>3. 什么时候最快</h3><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p>
<h3 id="4-什么时候最慢"><a href="#4-什么时候最慢" class="headerlink" title="4. 什么时候最慢"></a>4. 什么时候最慢</h3><p>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用冒泡排序呢，我是闲的吗）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> n 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = rand() % <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//初始化随机数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//数组输出函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gudu</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> swapped; <span class="comment">// 用于标记是否发生交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swapped = <span class="number">0</span>; <span class="comment">// 每轮开始前重置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; i; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[p] &gt; a[p + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = a[p];</span><br><span class="line">                a[p] = a[p + <span class="number">1</span>];</span><br><span class="line">                a[p + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="number">1</span>; <span class="comment">// 发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="comment">// 如果没有发生交换，说明已经排序完成</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    init(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    gudu(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array:\n&quot;</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv3深入学习</title>
    <url>/2025/01/07/YOLOv3%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>鉴于yolov3对于目标识别界的重大开创性，跳过1、2两个版本直接学习yolov3，同时也作为后续版本的基石入门。</p>
<hr>
<h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><h3 id="1-YOLOv3的核心思想"><a href="#1-YOLOv3的核心思想" class="headerlink" title="1. YOLOv3的核心思想"></a>1. YOLOv3的核心思想</h3><p>YOLOv3（You Only Look Once version 3）是一种单阶段目标检测算法，其核心思想是将目标检测问题转化为一个回归问题。与传统的两阶段检测方法（如R-CNN系列）不同，YOLOv3通过单次前向传播直接预测目标的边界框和类别概率，从而实现高效的目标检测。</p>
<p>YOLOv3的主要特点包括：</p>
<ul>
<li><strong>单次前向传播</strong>：输入图像经过一次网络前向传播即可得到检测结果。</li>
<li><strong>多尺度预测</strong>：通过不同尺度的特征图检测不同大小的目标。</li>
<li><strong>锚点机制</strong>：使用预定义的锚点（anchors）来辅助预测边界框。</li>
</ul>
<hr>
<h3 id="2-YOLOv3的网络结构"><a href="#2-YOLOv3的网络结构" class="headerlink" title="2. YOLOv3的网络结构"></a>2. YOLOv3的网络结构</h3><p>YOLOv3的网络结构可以分为三个部分：<strong>Backbone（骨干网络）</strong>、<strong>Neck（特征融合部分）**</strong>和<strong>**Head（检测头）</strong>。</p>
<h4 id="2-1-Backbone：Darknet-53"><a href="#2-1-Backbone：Darknet-53" class="headerlink" title="2.1 Backbone：Darknet-53"></a>2.1 Backbone：Darknet-53</h4><p>YOLOv3的骨干网络是Darknet-53，它是一个包含53个卷积层的深度卷积神经网络。Darknet-53借鉴了ResNet的思想，使用了残差连接（Residual Connections）来缓解深层网络的梯度消失问题。</p>
<p>Darknet-53的主要特点：</p>
<ul>
<li>使用1x1和3x3卷积层提取特征。</li>
<li>使用残差块（Residual Block）来构建深层网络。</li>
<li>输出三个不同尺度的特征图（13x13、26x26、52x52），用于多尺度预测。</li>
</ul>
<h4 id="2-2-Neck：特征金字塔网络（FPN）"><a href="#2-2-Neck：特征金字塔网络（FPN）" class="headerlink" title="2.2 Neck：特征金字塔网络（FPN）"></a>2.2 Neck：特征金字塔网络（FPN）</h4><p>YOLOv3通过特征金字塔网络（Feature Pyramid Network, FPN）实现多尺度特征融合。FPN将深层特征图（包含语义信息）与浅层特征图（包含细节信息）进行融合，从而增强网络对不同尺度目标的检测能力。</p>
<p>FPN的工作流程：</p>
<ul>
<li>从深层特征图开始，逐步上采样并与浅层特征图融合。</li>
<li>最终生成三个不同尺度的特征图（13x13、26x26、52x52），分别用于检测大、中、小目标。</li>
</ul>
<h4 id="2-3-Head：检测头"><a href="#2-3-Head：检测头" class="headerlink" title="2.3 Head：检测头"></a>2.3 Head：检测头</h4><p>检测头是YOLOv3的输出部分，负责预测边界框和类别概率。每个尺度的特征图都会预测固定数量的边界框（通常是3个），每个边界框包含以下信息：</p>
<ul>
<li>边界框的中心坐标（x, y）。</li>
<li>边界框的宽度和高度（w, h）。</li>
<li>目标存在的置信度（confidence）。</li>
<li>类别概率（class probabilities）。</li>
</ul>
<hr>
<h3 id="3-多尺度预测"><a href="#3-多尺度预测" class="headerlink" title="3. 多尺度预测"></a>3. 多尺度预测</h3><p>YOLOv3在三个不同尺度的特征图上进行预测：</p>
<ul>
<li><strong>13x13特征图</strong>：用于检测大目标。</li>
<li><strong>26x26特征图</strong>：用于检测中等目标。</li>
<li><strong>52x52特征图</strong>：用于检测小目标。</li>
</ul>
<p>每个尺度的特征图会被划分为若干网格（grid cell），每个网格负责预测固定数量的边界框。例如，13x13特征图会被划分为13x13个网格，每个网格预测3个边界框。</p>
<hr>
<h3 id="4-锚点机制"><a href="#4-锚点机制" class="headerlink" title="4. 锚点机制"></a>4. 锚点机制</h3><p>YOLOv3使用锚点（anchors）来辅助预测边界框。锚点是一组预定义的边界框尺寸，用于帮助网络更好地预测不同大小和形状的目标。</p>
<p>锚点的作用：</p>
<ul>
<li>每个尺度的特征图使用不同的锚点尺寸。例如，13x13特征图使用较大的锚点，52x52特征图使用较小的锚点。</li>
<li>网络预测的边界框是基于锚点的偏移量，而不是直接预测边界框的绝对坐标。</li>
</ul>
<hr>
<h3 id="5-边界框的编码与解码"><a href="#5-边界框的编码与解码" class="headerlink" title="5. 边界框的编码与解码"></a>5. 边界框的编码与解码</h3><p>YOLOv3通过编码和解码的方式将预测的边界框与真实边界框进行匹配。</p>
<h4 id="5-1-编码（Encoding）"><a href="#5-1-编码（Encoding）" class="headerlink" title="5.1 编码（Encoding）"></a>5.1 编码（Encoding）</h4><p>在训练时，需要将真实的边界框（ground truth）编码为网络输出的格式。</p>
<p>假设我们有一个真实的边界框$ (x, y, w, h) $，对应的锚点为$ (p_w, p_h) $，则编码后的边界框为：</p>
<ul>
<li>$ tx = (x - cx) / stride $</li>
<li>$ ty = (y - cy) / stride $</li>
<li>$ tw = log(w / p_w) $</li>
<li>$ th = log(h / p_h) $</li>
</ul>
<p>其中，$ (cx, cy) $是当前网格的左上角坐标，$ (tx, ty) $是中心偏移量，$ (tw, th) $是缩放比例，$ stride $是特征图的步长。</p>
<h4 id="5-2-解码（Decoding）"><a href="#5-2-解码（Decoding）" class="headerlink" title="5.2 解码（Decoding）"></a>5.2 解码（Decoding）</h4><p>在推理时，需要将网络输出的边界框解码为实际的坐标。假设网络输出为$ (tx, ty, tw, th) $，对应的锚点为$ (p_w, p_h) $，则解码后的边界框为：</p>
<ul>
<li>$ x = (sigmoid(tx) + cx) * stride $</li>
<li>$ y = (sigmoid(ty) + cy) * stride $</li>
<li>$ w = exp(tw) * p_w $</li>
<li>$ h = exp(th) * p_h $</li>
</ul>
<hr>
<h3 id="6-损失函数"><a href="#6-损失函数" class="headerlink" title="6. 损失函数"></a>6. 损失函数</h3><p>YOLOv3的损失函数由三部分组成：</p>
<ul>
<li><strong>定位损失（Localization Loss）</strong>：计算预测边界框与真实边界框之间的误差，通常使用均方误差（MSE）。</li>
<li><strong>置信度损失（Confidence Loss）</strong>：计算预测的置信度与真实值之间的误差，通常使用二元交叉熵（Binary Cross-Entropy）。</li>
<li><strong>分类损失（Classification Loss）</strong>：计算预测的类别概率与真实类别之间的误差，通常使用交叉熵（Cross-Entropy）。</li>
</ul>
<hr>
<h3 id="7-训练与推理"><a href="#7-训练与推理" class="headerlink" title="7. 训练与推理"></a>7. 训练与推理</h3><h4 id="7-1-训练"><a href="#7-1-训练" class="headerlink" title="7.1 训练"></a>7.1 训练</h4><p>在训练时，YOLOv3通过以下步骤进行优化：</p>
<ol>
<li>输入图像经过网络前向传播，得到三个尺度的预测结果。</li>
<li>将预测结果与真实标签进行匹配，计算损失。</li>
<li>使用反向传播更新网络参数。</li>
</ol>
<h4 id="7-2-推理"><a href="#7-2-推理" class="headerlink" title="7.2 推理"></a>7.2 推理</h4><p>在推理时，YOLOv3通过以下步骤生成检测结果：</p>
<ol>
<li>输入图像经过网络前向传播，得到三个尺度的预测结果。</li>
<li>对预测的边界框进行解码，得到实际的坐标。</li>
<li>使用非极大值抑制（NMS）去除重叠的边界框，得到最终的检测结果。</li>
</ol>
<hr>
<h2 id="细节实现"><a href="#细节实现" class="headerlink" title="细节实现"></a>细节实现</h2><h3 id="1-网络输出的结构"><a href="#1-网络输出的结构" class="headerlink" title="1. 网络输出的结构"></a>1. 网络输出的结构</h3><p>YOLOv3的网络输出是三个尺度的特征图（13x13、26x26、52x52），每个尺度的特征图会预测固定数量的边界框（通常是3个）。每个边界框的输出包含以下信息：</p>
<ul>
<li><strong>边界框的中心坐标偏移量（tx, ty）</strong>：相对于当前网格的偏移量。</li>
<li><strong>边界框的宽度和高度缩放量（tw, th）</strong>：相对于锚点的缩放量。</li>
<li><strong>目标存在的置信度（confidence）</strong>：表示当前边界框包含目标的概率。</li>
<li><strong>类别概率（class probabilities）</strong>：表示目标属于每个类别的概率。</li>
</ul>
<p>假设每个尺度预测3个边界框，类别数为C，则每个尺度的输出维度为：</p>
<ul>
<li>13x13尺度的输出维度：<code>13 x 13 x 3 x (5 + C)</code></li>
<li>26x26尺度的输出维度：<code>26 x 26 x 3 x (5 + C)</code></li>
<li>52x52尺度的输出维度：<code>52 x 52 x 3 x (5 + C)</code></li>
</ul>
<p>其中，<code>5</code>表示边界框的4个坐标值（tx, ty, tw, th）和1个置信度，<code>C</code>表示类别数。</p>
<hr>
<h3 id="2-后处理计算"><a href="#2-后处理计算" class="headerlink" title="2. 后处理计算"></a>2. 后处理计算</h3><p>后处理计算的目的是将网络的原始输出转换为实际的边界框坐标和类别信息。具体步骤如下：</p>
<h4 id="2-1-解码边界框坐标"><a href="#2-1-解码边界框坐标" class="headerlink" title="2.1 解码边界框坐标"></a>2.1 解码边界框坐标</h4><p>网络的输出是边界框的偏移量和缩放量，需要通过解码将其转换为实际的边界框坐标。</p>
<p>假设网络的输出为$ (tx, ty, tw, th) $，对应的锚点为$ (a_w, a_h) $，当前网格的左上角坐标为$ (cx, cy) $，特征图的步长为$ stride $，则解码后的边界框坐标为：</p>
<ul>
<li><strong>中心坐标</strong>：<ul>
<li>$   x = (sigmoid(tx) + cx) * stride $</li>
<li>$   y = (sigmoid(ty) + cy) * stride $</li>
</ul>
</li>
<li><strong>宽度和高度</strong>：<ul>
<li>$   w = exp(tw) * p_w $</li>
<li>$   h = exp(th) * p_h $</li>
</ul>
</li>
</ul>
<p>其中，$ sigmoid $函数用于将偏移量限制在0到1之间，确保边界框的中心位于当前网格内。</p>
<h4 id="2-2-计算置信度和类别概率"><a href="#2-2-计算置信度和类别概率" class="headerlink" title="2.2 计算置信度和类别概率"></a>2.2 计算置信度和类别概率</h4><p>网络的输出还包括置信度和类别概率，需要通过以下步骤进行处理：</p>
<ul>
<li><strong>置信度</strong>：直接使用$ sigmoid $函数将输出值转换为概率值，表示当前边界框包含目标的概率。</li>
<li><strong>类别概率</strong>：对每个类别的输出值应用$ sigmoid $函数，得到每个类别的概率值。</li>
</ul>
<h4 id="2-3-过滤低置信度的边界框"><a href="#2-3-过滤低置信度的边界框" class="headerlink" title="2.3 过滤低置信度的边界框"></a>2.3 过滤低置信度的边界框</h4><p>为了减少计算量，通常会过滤掉置信度低于某个阈值（如0.5）的边界框。只有置信度高于阈值的边界框才会进入下一步处理。</p>
<h4 id="2-4-非极大值抑制（NMS）"><a href="#2-4-非极大值抑制（NMS）" class="headerlink" title="2.4 非极大值抑制（NMS）"></a>2.4 非极大值抑制（NMS）</h4><p>非极大值抑制（Non-Maximum Suppression, NMS）用于去除重叠的边界框，保留最优的检测结果。NMS的具体步骤如下：</p>
<ol>
<li>对所有边界框按置信度从高到低排序。</li>
<li>选择置信度最高的边界框，将其加入最终结果列表。</li>
<li>计算该边界框与其余边界框的交并比（IoU）。</li>
<li>删除IoU高于某个阈值（如0.5）的边界框。</li>
<li>重复步骤2-4，直到所有边界框都被处理。</li>
</ol>
<hr>
<h3 id="3-置信度的计算"><a href="#3-置信度的计算" class="headerlink" title="3. 置信度的计算"></a>3. 置信度的计算</h3><p>置信度（confidence）是网络输出的一个重要部分，表示当前边界框包含目标的概率。置信度的计算步骤如下：</p>
<ol>
<li><strong>网络输出</strong>：网络输出的置信度是一个标量值（通常记为$ t_conf $），范围是任意的（未经过激活函数处理）。</li>
<li><strong>Sigmoid激活</strong>：为了将置信度转换为概率值，需要对$ t_conf $应用Sigmoid函数：<br>$ \text{confidence} = \sigma(t_conf) = \frac{1}{1 + e^{-t_conf}} $<br>这样，置信度的值被限制在0到1之间。</li>
<li><strong>置信度的意义</strong>：置信度表示当前边界框内是否存在目标。如果置信度接近1，说明边界框内很可能存在目标；如果接近0，则说明边界框内很可能没有目标。</li>
</ol>
<hr>
<h3 id="3-1-类别概率的计算"><a href="#3-1-类别概率的计算" class="headerlink" title="3.1 类别概率的计算"></a>3.1 类别概率的计算</h3><p>类别概率（class probabilities）表示目标属于每个类别的概率。</p>
<ol>
<li><strong>网络输出</strong>：网络输出的类别概率是一个长度为$ C $的向量（$ C $为类别数），记为$ t_class $。每个值表示对应类别的得分（未经过激活函数处理）。</li>
<li><strong>Sigmoid激活</strong>：对$ t_class $中的每个值应用$ Sigmoid $函数，将其转换为概率值：<br>$ \text{class_prob}_i = \sigma(t_class_i) = \frac{1}{1 + e^{-t_class_i}} $<br>这样，每个类别的概率值被限制在0到1之间。</li>
<li><strong>类别概率的意义</strong>：$ class_prob_i $表示目标属于第$ i $个类别的概率。YOLOv3使用$ Sigmoid $函数而不是$ Softmax $函数，因此每个类别的概率是独立的，可以同时预测多个类别（适用于多标签分类任务）。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736055615050-19591ae5-d726-49fa-9129-d6f5e1fd6af6.png" alt=""></p>
<hr>
<h3 id="3-2-过滤低置信度的边界框"><a href="#3-2-过滤低置信度的边界框" class="headerlink" title="3.2 过滤低置信度的边界框"></a>3.2 过滤低置信度的边界框</h3><p>在得到置信度和类别概率后，通常需要过滤掉低置信度的边界框，以减少计算量并提高检测结果的可靠性。具体步骤如下：</p>
<ol>
<li><strong>设置置信度阈值</strong>：通常设置一个置信度阈值（如0.5），只有置信度高于该阈值的边界框才会被保留。</li>
<li><strong>过滤边界框</strong>：遍历所有边界框，保留置信度高于阈值的边界框，丢弃低于阈值的边界框。</li>
</ol>
<hr>
<h3 id="3-3-非极大值抑制（NMS）"><a href="#3-3-非极大值抑制（NMS）" class="headerlink" title="3.3 非极大值抑制（NMS）"></a>3.3 非极大值抑制（NMS）</h3><p>非极大值抑制（Non-Maximum Suppression, NMS）是目标检测中常用的后处理步骤，用于去除重叠的边界框，保留最优的检测结果。NMS的具体步骤如下：</p>
<ol>
<li><strong>按置信度排序</strong>：将所有边界框按置信度从高到低排序。</li>
<li><strong>选择最高置信度的边界框</strong>：从排序后的列表中选择置信度最高的边界框，将其加入最终结果列表。</li>
<li><strong>计算交并比（IoU）</strong>：计算该边界框与其余所有边界框的交并比（Intersection over Union, IoU）。IoU的计算公式为：<br>$ \text{IoU} = \frac{\text{Area of Intersection}}{\text{Area of Union}} $<br>其中，<code>Area of Intersection</code>是两个边界框的交集面积，<code>Area of Union</code>是两个边界框的并集面积。</li>
<li><strong>去除重叠边界框</strong>：删除与当前边界框IoU高于某个阈值（如0.5）的边界框。</li>
<li><strong>重复步骤2-4</strong>：重复上述过程，直到所有边界框都被处理。</li>
</ol>
<hr>
<h3 id="3-具体示例"><a href="#3-具体示例" class="headerlink" title="3. 具体示例"></a>3. 具体示例</h3><p>假设我们有一个13x13尺度的输出，类别数为80，锚点为<code>(10, 13), (16, 30), (33, 23)</code>，特征图的步长为32。</p>
<h4 id="3-1-网络输出"><a href="#3-1-网络输出" class="headerlink" title="3.1 网络输出"></a>3.1 网络输出</h4><p>网络的输出维度为<code>13 x 13 x 3 x 85</code>，其中<code>85 = 5 + 80</code>（5表示边界框的4个坐标值和1个置信度，80表示类别数）。</p>
<h4 id="3-2-解码边界框"><a href="#3-2-解码边界框" class="headerlink" title="3.2 解码边界框"></a>3.2 解码边界框</h4><p>对于每个网格和每个锚点，解码边界框的步骤如下：</p>
<ol>
<li>提取$ (tx, ty, tw, th) $和置信度、类别概率。</li>
<li>使用$ Sigmoid $函数计算中心坐标偏移量：<ul>
<li>$ x = (\sigma(tx) + cx) \times 32 $</li>
<li>$   y = (\sigma(ty) + cy) \times 32  $</li>
</ul>
</li>
<li>使用指数函数计算宽度和高度：<ul>
<li>$ w = \exp(tw) \times a_w $</li>
<li>$  h = \exp(th) \times a_h  $</li>
</ul>
</li>
<li>将边界框坐标转换为$ (x_min, y_min, x_max, y_max) $格式：<ul>
<li>$    x_{\text{min}} = x - w / 2  $</li>
<li>$    y_{\text{min}} = y - h / 2  $</li>
<li>$    x_{\text{max}} = x + w / 2  $</li>
<li>$ y_{\text{max}} = y + h / 2  $</li>
</ul>
</li>
</ol>
<h4 id="3-3-置信度和类别概率的计算"><a href="#3-3-置信度和类别概率的计算" class="headerlink" title="3.3 置信度和类别概率的计算"></a>3.3 置信度和类别概率的计算</h4><ol>
<li>对置信度$ t_conf $应用$ Sigmoid $函数：<br>$ \text{confidence} = \sigma(t_conf) $</li>
<li>对类别概率$ t_class $应用$ Sigmoid $函数：<br>$ \text{class_prob}_i = \sigma(t_class_i) $</li>
</ol>
<h4 id="3-4-过滤和NMS"><a href="#3-4-过滤和NMS" class="headerlink" title="3.4 过滤和NMS"></a>3.4 过滤和NMS</h4><ol>
<li>过滤掉置信度低于0.5的边界框。</li>
<li>对剩余的边界框按置信度排序。</li>
<li>使用NMS去除重叠的边界框，保留最优的检测结果。</li>
</ol>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><hr>
<h3 id="1-网络架构：Darknet-53"><a href="#1-网络架构：Darknet-53" class="headerlink" title="1. 网络架构：Darknet-53"></a>1. 网络架构：Darknet-53</h3><p>YOLOv3的骨干网络是Darknet-53，这是一个53层的卷积神经网络（CNN），借鉴了ResNet的残差结构，但设计更为轻量化和高效。</p>
<h4 id="1-1-Darknet-53的结构"><a href="#1-1-Darknet-53的结构" class="headerlink" title="1.1 Darknet-53的结构"></a>1.1 Darknet-53的结构</h4><ul>
<li><strong>输入</strong>：YOLOv3的输入图像尺寸通常为416x416（或其他尺寸，如608x608）。</li>
<li><strong>卷积层</strong>：Darknet-53主要由卷积层、批量归一化（Batch Normalization）和Leaky ReLU激活函数组成。<ul>
<li>卷积层：使用3x3和1x1卷积核，3x3卷积用于提取特征，1x1卷积用于调整通道数。</li>
<li>批量归一化：加速训练并提高模型稳定性。</li>
<li>Leaky ReLU：激活函数，公式为 $  f(x) = \max(x, 0.1x)  $，避免梯度消失。</li>
</ul>
</li>
<li><strong>残差块（Residual Block）</strong>：Darknet-53的核心组件是残差块，每个残差块包含两个3x3卷积层和一个跳跃连接（Shortcut Connection）。<ul>
<li>跳跃连接将输入直接加到输出上，缓解梯度消失问题，使网络能够训练得更深。</li>
<li>Darknet-53共有23个残差块。</li>
</ul>
</li>
</ul>
<h4 id="1-2-Darknet-53的特点"><a href="#1-2-Darknet-53的特点" class="headerlink" title="1.2 Darknet-53的特点"></a>1.2 Darknet-53的特点</h4><ul>
<li><strong>深度</strong>：53层网络，比YOLOv2的Darknet-19更深，但比ResNet-152更轻量。</li>
<li><strong>效率</strong>：Darknet-53在ImageNet分类任务上达到了与ResNet-152相当的精度，但速度更快。</li>
<li><strong>多尺度特征提取</strong>：Darknet-53通过不同层提取不同尺度的特征，为后续的多尺度预测提供支持。</li>
</ul>
<hr>
<h3 id="2-多尺度预测"><a href="#2-多尺度预测" class="headerlink" title="2. 多尺度预测"></a>2. 多尺度预测</h3><p>YOLOv3在三个不同尺度的特征图上进行目标检测，分别对应13x13、26x26和52x52的特征图。这种多尺度设计使其能够检测不同大小的目标。</p>
<h4 id="2-1-特征金字塔网络（FPN）"><a href="#2-1-特征金字塔网络（FPN）" class="headerlink" title="2.1 特征金字塔网络（FPN）"></a>2.1 特征金字塔网络（FPN）</h4><p>YOLOv3借鉴了特征金字塔网络（Feature Pyramid Network, FPN）的思想，通过上采样和特征融合实现多尺度预测。</p>
<ul>
<li><strong>上采样（Upsampling）</strong>：将低分辨率的特征图通过插值方法（如双线性插值）放大到高分辨率。</li>
<li><strong>特征融合</strong>：将上采样后的特征图与来自浅层的特征图进行拼接（Concatenation），结合低级特征（细节信息）和高级特征（语义信息）。<ul>
<li>例如，13x13的特征图通过上采样得到26x26的特征图，然后与Darknet-53中间层的26x26特征图拼接。</li>
</ul>
</li>
</ul>
<h4 id="2-2-三个尺度的预测"><a href="#2-2-三个尺度的预测" class="headerlink" title="2.2 三个尺度的预测"></a>2.2 三个尺度的预测</h4><ul>
<li><strong>13x13特征图</strong>：用于检测大目标。</li>
<li><strong>26x26特征图</strong>：用于检测中等目标。</li>
<li><strong>52x52特征图</strong>：用于检测小目标。</li>
</ul>
<p>每个尺度的特征图都会输出预测结果，包括边界框坐标、置信度和类别概率。</p>
<hr>
<h3 id="3-锚框（Anchor-Boxes）机制"><a href="#3-锚框（Anchor-Boxes）机制" class="headerlink" title="3. 锚框（Anchor Boxes）机制"></a>3. 锚框（Anchor Boxes）机制</h3><p>YOLOv3使用锚框（Anchor Boxes）来预测目标的边界框。锚框是预定义的边界框，用于捕捉不同形状和尺寸的目标。</p>
<h4 id="3-1-锚框的选择"><a href="#3-1-锚框的选择" class="headerlink" title="3.1 锚框的选择"></a>3.1 锚框的选择</h4><ul>
<li><strong>K-means聚类</strong>：YOLOv3使用K-means聚类算法从训练数据集中自动学习锚框的尺寸。<ul>
<li>对训练集中所有目标的边界框进行聚类，得到9个聚类中心（即9个锚框）。</li>
<li>这些锚框被分配到三个尺度上，每个尺度分配3个锚框。</li>
</ul>
</li>
<li><strong>锚框的尺寸</strong>：不同尺度的锚框尺寸不同，例如：<ul>
<li>13x13尺度的锚框较大，适合检测大目标。</li>
<li>52x52尺度的锚框较小，适合检测小目标。</li>
</ul>
</li>
</ul>
<h4 id="3-2-锚框的预测"><a href="#3-2-锚框的预测" class="headerlink" title="3.2 锚框的预测"></a>3.2 锚框的预测</h4><ul>
<li>每个网格单元（Grid Cell）预测3个边界框，每个边界框对应一个锚框。</li>
<li>每个边界框预测以下内容：<ul>
<li>边界框坐标（x, y, w, h）：x和y是中心点坐标，w和h是宽度和高度。</li>
<li>置信度（Confidence）：表示边界框内是否包含目标，以及预测框的准确性。</li>
<li>类别概率（Class Probabilities）：表示目标属于每个类别的概率。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4. 损失函数"></a>4. 损失函数</h3><p>以下是YOLOv3中三个损失计算函数的详细公式和解释：</p>
<hr>
<h4 id="1-坐标损失（Coordinate-Loss）"><a href="#1-坐标损失（Coordinate-Loss）" class="headerlink" title="1. 坐标损失（Coordinate Loss）"></a>1. 坐标损失（Coordinate Loss）</h4><p>坐标损失用于衡量预测的边界框坐标（中心点 (x, y) 和宽高 (w, h)）与真实边界框坐标之间的差异。YOLOv3使用均方误差（MSE）来计算坐标损失。</p>
<h5 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736056982107-a76914d6-e67e-4dc2-a3a9-70c511955a5f.png" alt=""></p>
<h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li>$  S^2  $：网格单元的数量（例如，13x13、26x26、52x52）。</li>
<li>$  B  $：每个网格单元预测的边界框数量（YOLOv3中 ( B = 3 )）。</li>
<li>$ \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 ( i ) 个网格单元的第 ( j ) 个边界框是否负责检测目标（如果是则为1，否则为0）。</li>
<li>$  x_i, y_i  $：预测的边界框中心点坐标。</li>
<li>$  \hat{x}_i, \hat{y}_i  $：真实的边界框中心点坐标。</li>
<li>$  w_i, h_i  $：预测的边界框宽度和高度。</li>
<li>$  \hat{w}_i, \hat{h}_i  $：真实的边界框宽度和高度。</li>
<li>$  \lambda_{\text{coord}}  $：坐标损失的权重（通常设置为5）。</li>
</ul>
<hr>
<h4 id="2-置信度损失（Confidence-Loss）"><a href="#2-置信度损失（Confidence-Loss）" class="headerlink" title="2. 置信度损失（Confidence Loss）"></a>2. 置信度损失（Confidence Loss）</h4><p>置信度损失用于衡量预测的置信度（即边界框内是否包含目标）与真实值之间的差异。YOLOv3使用二分类交叉熵损失来计算置信度损失。</p>
<h5 id="公式：-1"><a href="#公式：-1" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736056991829-7210b841-2fa5-4cf0-b402-bc9756a8a691.png" alt=""></p>
<h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li>$  \hat{C}_i  $：预测的置信度（即边界框内包含目标的概率）。</li>
<li>$  \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 ( i ) 个网格单元的第 ( j ) 个边界框是否负责检测目标（如果是则为1，否则为0）。</li>
<li>对于负样本（不包含目标的边界框），置信度损失仅计算 $  \log(1 - \hat{C}_i)  $。</li>
</ul>
<hr>
<h4 id="3-类别损失（Class-Loss）"><a href="#3-类别损失（Class-Loss）" class="headerlink" title="3. 类别损失（Class Loss）"></a>3. 类别损失（Class Loss）</h4><p>类别损失用于衡量预测的类别概率与真实类别之间的差异。YOLOv3使用多分类交叉熵损失来计算类别损失。</p>
<h5 id="公式：-2"><a href="#公式：-2" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736057000321-c51f7efd-2012-429e-8635-d4b10122b037.png" alt=""></p>
<h5 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li>$ p_i(c)  $：真实的类别概率（如果是类别$  c  $则为1，否则为0）。</li>
<li>$ \hat{p}_i(c)  $：预测的类别概率（通过$ Sigmoid $函数输出）。</li>
<li>$ \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 $  i   $个网格单元的第$   j   $个边界框是否负责检测目标（如果是则为1，否则为0）。</li>
<li>$  c  $：类别索引， $ \text{classes}  $是所有类别的集合。</li>
</ul>
<hr>
<h4 id="4-总损失函数"><a href="#4-总损失函数" class="headerlink" title="4. 总损失函数"></a>4. 总损失函数</h4><p>YOLOv3的总损失函数是上述三个损失函数的加权和：<br><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736057096661-f17820de-b536-4b52-b14d-c2b662de9c8d.png" alt=""></p>
<h5 id="参数说明：-3"><a href="#参数说明：-3" class="headerlink" title="参数说明："></a>参数说明：</h5><ul>
<li>总损失函数是坐标损失、置信度损失和类别损失的总和。</li>
<li>每个损失函数的权重可以通过超参数调整（例如，坐标损失的权重 $  \lambda_{\text{coord}}  $ 通常设置为5）。</li>
</ul>
<hr>
<h3 id="5-训练与推理"><a href="#5-训练与推理" class="headerlink" title="5. 训练与推理"></a>5. 训练与推理</h3><h4 id="5-1-训练"><a href="#5-1-训练" class="headerlink" title="5.1 训练"></a>5.1 训练</h4><ul>
<li><strong>数据增强</strong>：使用随机裁剪、翻转、颜色抖动等技术增强数据。</li>
<li><strong>损失优化</strong>：通过反向传播优化损失函数，更新网络参数。</li>
<li><strong>预训练</strong>：Darknet-53通常在ImageNet数据集上进行预训练，然后在目标检测任务上进行微调。</li>
</ul>
<h4 id="5-2-推理"><a href="#5-2-推理" class="headerlink" title="5.2 推理"></a>5.2 推理</h4><ul>
<li><strong>输入图像</strong>：将图像调整为固定尺寸（如416x416）并输入网络。</li>
<li><strong>预测输出</strong>：网络输出三个尺度的预测结果。</li>
<li><strong>非极大值抑制（NMS）</strong>：去除重叠的边界框，保留置信度最高的预测框。</li>
</ul>
<hr>
<h2 id="代码阅读（汉化）"><a href="#代码阅读（汉化）" class="headerlink" title="代码阅读（汉化）"></a>代码阅读（汉化）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ultralytics YOLOv3 🚀, AGPL-3.0 license</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用自定义数据集训练YOLOv3模型。模型和数据集会自动从最新的YOLOv3版本下载。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单GPU训练用法:</span></span><br><span class="line"><span class="string">    $ python train.py --data coco128.yaml --weights yolov5s.pt --img 640  # 从预训练模型开始训练（推荐）</span></span><br><span class="line"><span class="string">    $ python train.py --data coco128.yaml --weights &#x27;&#x27; --cfg yolov5s.yaml --img 640  # 从零开始训练</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多GPU DDP训练用法:</span></span><br><span class="line"><span class="string">    $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 train.py --data coco128.yaml --weights yolov5s.pt --img 640 --device 0,1,2,3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">模型:     https://github.com/ultralytics/yolov5/tree/master/models</span></span><br><span class="line"><span class="string">数据集:   https://github.com/ultralytics/yolov5/tree/master/data</span></span><br><span class="line"><span class="string">教程:   https://docs.ultralytics.com/yolov5/tutorials/train_custom_data</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> comet_ml  <span class="comment"># 必须在torch之前导入（如果已安装）</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    comet_ml = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">FILE = Path(__file__).resolve()</span><br><span class="line">ROOT = FILE.parents[<span class="number">0</span>]  <span class="comment"># YOLOv3根目录</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">str</span>(ROOT) <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.append(<span class="built_in">str</span>(ROOT))  <span class="comment"># 将ROOT添加到PATH</span></span><br><span class="line">ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  <span class="comment"># 相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> val <span class="keyword">as</span> validate  <span class="comment"># 用于epoch结束时的mAP计算</span></span><br><span class="line"><span class="keyword">from</span> models.experimental <span class="keyword">import</span> attempt_load</span><br><span class="line"><span class="keyword">from</span> models.yolo <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> utils.autoanchor <span class="keyword">import</span> check_anchors</span><br><span class="line"><span class="keyword">from</span> utils.autobatch <span class="keyword">import</span> check_train_batch_size</span><br><span class="line"><span class="keyword">from</span> utils.callbacks <span class="keyword">import</span> Callbacks</span><br><span class="line"><span class="keyword">from</span> utils.dataloaders <span class="keyword">import</span> create_dataloader</span><br><span class="line"><span class="keyword">from</span> utils.downloads <span class="keyword">import</span> attempt_download, is_url</span><br><span class="line"><span class="keyword">from</span> utils.general <span class="keyword">import</span> (</span><br><span class="line">    LOGGER,</span><br><span class="line">    TQDM_BAR_FORMAT,</span><br><span class="line">    check_amp,</span><br><span class="line">    check_dataset,</span><br><span class="line">    check_file,</span><br><span class="line">    check_git_info,</span><br><span class="line">    check_git_status,</span><br><span class="line">    check_img_size,</span><br><span class="line">    check_requirements,</span><br><span class="line">    check_suffix,</span><br><span class="line">    check_yaml,</span><br><span class="line">    colorstr,</span><br><span class="line">    get_latest_run,</span><br><span class="line">    increment_path,</span><br><span class="line">    init_seeds,</span><br><span class="line">    intersect_dicts,</span><br><span class="line">    labels_to_class_weights,</span><br><span class="line">    labels_to_image_weights,</span><br><span class="line">    methods,</span><br><span class="line">    one_cycle,</span><br><span class="line">    print_args,</span><br><span class="line">    print_mutation,</span><br><span class="line">    strip_optimizer,</span><br><span class="line">    yaml_save,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> utils.loggers <span class="keyword">import</span> Loggers</span><br><span class="line"><span class="keyword">from</span> utils.loggers.comet.comet_utils <span class="keyword">import</span> check_comet_resume</span><br><span class="line"><span class="keyword">from</span> utils.loss <span class="keyword">import</span> ComputeLoss</span><br><span class="line"><span class="keyword">from</span> utils.metrics <span class="keyword">import</span> fitness</span><br><span class="line"><span class="keyword">from</span> utils.plots <span class="keyword">import</span> plot_evolve</span><br><span class="line"><span class="keyword">from</span> utils.torch_utils <span class="keyword">import</span> (</span><br><span class="line">    EarlyStopping,</span><br><span class="line">    ModelEMA,</span><br><span class="line">    de_parallel,</span><br><span class="line">    select_device,</span><br><span class="line">    smart_DDP,</span><br><span class="line">    smart_optimizer,</span><br><span class="line">    smart_resume,</span><br><span class="line">    torch_distributed_zero_first,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LOCAL_RANK = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;LOCAL_RANK&quot;</span>, -<span class="number">1</span>))  <span class="comment"># https://pytorch.org/docs/stable/elastic/run.html</span></span><br><span class="line">RANK = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;RANK&quot;</span>, -<span class="number">1</span>))</span><br><span class="line">WORLD_SIZE = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;WORLD_SIZE&quot;</span>, <span class="number">1</span>))</span><br><span class="line">GIT_INFO = check_git_info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">hyp, opt, device, callbacks</span>):  <span class="comment"># hyp是路径/to/hyp.yaml或hyp字典</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在自定义数据集上训练YOLOv3模型并管理训练过程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        hyp (str | dict): 超参数yaml文件的路径或超参数字典。</span></span><br><span class="line"><span class="string">        opt (argparse.Namespace): 包含训练选项的解析命令行参数。</span></span><br><span class="line"><span class="string">        device (torch.device): 加载和训练模型的设备。</span></span><br><span class="line"><span class="string">        callbacks (Callbacks): 处理训练生命周期各个阶段的回调函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    单GPU训练用法:</span></span><br><span class="line"><span class="string">        $ python train.py --data coco128.yaml --weights yolov5s.pt --img 640  # 从预训练模型开始训练（推荐）</span></span><br><span class="line"><span class="string">        $ python train.py --data coco128.yaml --weights &#x27;&#x27; --cfg yolov5s.yaml --img 640  # 从零开始训练</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    多GPU DDP训练用法:</span></span><br><span class="line"><span class="string">        $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 train.py --data coco128.yaml --weights</span></span><br><span class="line"><span class="string">            yolov5s.pt --img 640 --device 0,1,2,3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    模型: https://github.com/ultralytics/yolov5/tree/master/models</span></span><br><span class="line"><span class="string">    数据集: https://github.com/ultralytics/yolov5/tree/master/data</span></span><br><span class="line"><span class="string">    教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    示例:</span></span><br><span class="line"><span class="string">        ```python</span></span><br><span class="line"><span class="string">        from ultralytics import train</span></span><br><span class="line"><span class="string">        import argparse</span></span><br><span class="line"><span class="string">        import torch</span></span><br><span class="line"><span class="string">        from utils.callbacks import Callbacks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 示例用法</span></span><br><span class="line"><span class="string">        args = argparse.Namespace(</span></span><br><span class="line"><span class="string">            data=&#x27;coco128.yaml&#x27;,</span></span><br><span class="line"><span class="string">            weights=&#x27;yolov5s.pt&#x27;,</span></span><br><span class="line"><span class="string">            cfg=&#x27;yolov5s.yaml&#x27;,</span></span><br><span class="line"><span class="string">            img_size=640,</span></span><br><span class="line"><span class="string">            epochs=50,</span></span><br><span class="line"><span class="string">            batch_size=16,</span></span><br><span class="line"><span class="string">            device=&#x27;0&#x27;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        device = torch.device(f&#x27;cuda:&#123;args.device&#125;&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)</span></span><br><span class="line"><span class="string">        callbacks = Callbacks()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        train(hyp=&#x27;hyp.scratch.yaml&#x27;, opt=args, device=device, callbacks=callbacks)</span></span><br></pre></td></tr></table></figure>
<pre><code>&quot;&quot;&quot;
save_dir, epochs, batch_size, weights, single_cls, evolve, data, cfg, resume, noval, nosave, workers, freeze = (
    Path(opt.save_dir),
    opt.epochs,
    opt.batch_size,
    opt.weights,
    opt.single_cls,
    opt.evolve,
    opt.data,
    opt.cfg,
    opt.resume,
    opt.noval,
    opt.nosave,
    opt.workers,
    opt.freeze,
)
callbacks.run(&quot;on_pretrain_routine_start&quot;)

# 目录
w = save_dir / &quot;weights&quot;  # 权重目录
(w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # 创建目录
last, best = w / &quot;last.pt&quot;, w / &quot;best.pt&quot;

# 超参数
if isinstance(hyp, str):
    with open(hyp, errors=&quot;ignore&quot;) as f:
        hyp = yaml.safe_load(f)  # 加载超参数字典
LOGGER.info(colorstr(&quot;超参数: &quot;) + &quot;, &quot;.join(f&quot;&#123;k&#125;=&#123;v&#125;&quot; for k, v in hyp.items()))
opt.hyp = hyp.copy()  # 保存超参数到检查点

# 保存运行设置
if not evolve:
    yaml_save(save_dir / &quot;hyp.yaml&quot;, hyp)
    yaml_save(save_dir / &quot;opt.yaml&quot;, vars(opt))

# 日志记录器
data_dict = None
if RANK in &#123;-1, 0&#125;:
    loggers = Loggers(save_dir, weights, opt, hyp, LOGGER)  # 日志记录器实例

    # 注册动作
    for k in methods(loggers):
        callbacks.register_action(k, callback=getattr(loggers, k))

    # 处理自定义数据集工件链接
    data_dict = loggers.remote_dataset
    if resume:  # 如果从远程工件恢复运行
        weights, epochs, hyp, batch_size = opt.weights, opt.epochs, opt.hyp, opt.batch_size

# 配置
plots = not evolve and not opt.noplots  # 创建图表
cuda = device.type != &quot;cpu&quot;
init_seeds(opt.seed + 1 + RANK, deterministic=True)
with torch_distributed_zero_first(LOCAL_RANK):
    data_dict = data_dict or check_dataset(data)  # 检查是否为None
train_path, val_path = data_dict[&quot;train&quot;], data_dict[&quot;val&quot;]
nc = 1 if single_cls else int(data_dict[&quot;nc&quot;])  # 类别数量
names = &#123;0: &quot;item&quot;&#125; if single_cls and len(data_dict[&quot;names&quot;]) != 1 else data_dict[&quot;names&quot;]  # 类别名称
is_coco = isinstance(val_path, str) and val_path.endswith(&quot;coco/val2017.txt&quot;)  # COCO数据集

# 模型
check_suffix(weights, &quot;.pt&quot;)  # 检查权重
pretrained = weights.endswith(&quot;.pt&quot;)
if pretrained:
    with torch_distributed_zero_first(LOCAL_RANK):
        weights = attempt_download(weights)  # 如果本地没有找到则下载
    ckpt = torch.load(weights, map_location=&quot;cpu&quot;)  # 将检查点加载到CPU以避免CUDA内存泄漏
    model = Model(cfg or ckpt[&quot;model&quot;].yaml, ch=3, nc=nc, anchors=hyp.get(&quot;anchors&quot;)).to(device)  # 创建模型
    exclude = [&quot;anchor&quot;] if (cfg or hyp.get(&quot;anchors&quot;)) and not resume else []  # 排除键
    csd = ckpt[&quot;model&quot;].float().state_dict()  # 检查点状态字典为FP32
    csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # 交集
    model.load_state_dict(csd, strict=False)  # 加载
    LOGGER.info(f&quot;从 &#123;weights&#125; 转移了 &#123;len(csd)&#125;/&#123;len(model.state_dict())&#125; 项&quot;)  # 报告
else:
    model = Model(cfg, ch=3, nc=nc, anchors=hyp.get(&quot;anchors&quot;)).to(device)  # 创建模型
amp = check_amp(model)  # 检查AMP

# 冻结
freeze = [f&quot;model.&#123;x&#125;.&quot; for x in (freeze if len(freeze) &gt; 1 else range(freeze[0]))]  # 冻结的层
for k, v in model.named_parameters():
    v.requires_grad = True  # 训练所有层
    # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN转为0（注释掉以避免训练结果不稳定）
    if any(x in k for x in freeze):
        LOGGER.info(f&quot;冻结 &#123;k&#125;&quot;)
        v.requires_grad = False

# 图像大小
gs = max(int(model.stride.max()), 32)  # 网格大小（最大步幅）
imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # 验证imgsz是gs的倍数

# 批量大小
if RANK == -1 and batch_size == -1:  # 仅限单GPU，估计最佳批量大小
    batch_size = check_train_batch_size(model, imgsz, amp)
    loggers.on_params_update(&#123;&quot;batch_size&quot;: batch_size&#125;)

# 优化器
nbs = 64  # 名义批量大小
accumulate = max(round(nbs / batch_size), 1)  # 在优化前累积损失
hyp[&quot;weight_decay&quot;] *= batch_size * accumulate / nbs  # 缩放权重衰减
optimizer = smart_optimizer(model, opt.optimizer, hyp[&quot;lr0&quot;], hyp[&quot;momentum&quot;], hyp[&quot;weight_decay&quot;])

# 学习率调度器
if opt.cos_lr:
    lf = one_cycle(1, hyp[&quot;lrf&quot;], epochs)  # 余弦 1-&gt;hyp[&#39;lrf&#39;]
else:

    def lf(x):
        &quot;&quot;&quot;线性学习率调度器函数，根据epoch比例计算衰减。&quot;&quot;&quot;
        return (1 - x / epochs) * (1.0 - hyp[&quot;lrf&quot;]) + hyp[&quot;lrf&quot;]  # 线性

scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)

# EMA
ema = ModelEMA(model) if RANK in &#123;-1, 0&#125; else None

# 恢复
best_fitness, start_epoch = 0.0, 0
if pretrained:
    if resume:
        best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)
    del ckpt, csd

# DP模式
if cuda and RANK == -1 and torch.cuda.device_count() &gt; 1:
    LOGGER.warning(
        &quot;警告 ⚠️ 不推荐使用DP模式，建议使用torch.distributed.run以获得最佳DDP多GPU结果。\n&quot;
        &quot;请参阅多GPU教程：https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training 以开始使用。&quot;
    )
    model = torch.nn.DataParallel(model)

# SyncBatchNorm
if opt.sync_bn and cuda and RANK != -1:
    model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)
    LOGGER.info(&quot;使用 SyncBatchNorm()&quot;)

# 训练数据加载器
train_loader, dataset = create_dataloader(
    train_path,
    imgsz,
    batch_size // WORLD_SIZE,
    gs,
    single_cls,
    hyp=hyp,
    augment=True,
    cache=None if opt.cache == &quot;val&quot; else opt.cache,
    rect=opt.rect,
    rank=LOCAL_RANK,
    workers=workers,
    image_weights=opt.image_weights,
    quad=opt.quad,
    prefix=colorstr(&quot;训练: &quot;),
    shuffle=True,
    seed=opt.seed,
)
labels = np.concatenate(dataset.labels, 0)
mlc = int(labels[:, 0].max())  # 最大标签类别
assert mlc &lt; nc, f&quot;标签类别 &#123;mlc&#125; 超过了 &#123;data&#125; 中的 nc=&#123;nc&#125;。可能的类别标签是 0-&#123;nc - 1&#125;&quot;

# 进程0
if RANK in &#123;-1, 0&#125;:
    val_loader = create_dataloader(
        val_path,
        imgsz,
        batch_size // WORLD_SIZE * 2,
        gs,
        single_cls,
        hyp=hyp,
        cache=None if noval else opt.cache,
        rect=True,
        rank=-1,
        workers=workers * 2,
        pad=0.5,
        prefix=colorstr(&quot;验证: &quot;),
    )[0]

    if not resume:
        if not opt.noautoanchor:
            check_anchors(dataset, model=model, thr=hyp[&quot;anchor_t&quot;], imgsz=imgsz)  # 运行AutoAnchor
        model.half().float()  # 预降低锚点精度

    callbacks.run(&quot;on_pretrain_routine_end&quot;, labels, names)

# DDP模式
if cuda and RANK != -1:
    model = smart_DDP(model)

# 模型属性
nl = de_parallel(model).model[-1].nl  # 检测层数量（用于缩放超参数）
hyp[&quot;box&quot;] *= 3 / nl  # 按层缩放
hyp[&quot;cls&quot;] *= nc / 80 * 3 / nl  # 按类别和层缩放
hyp[&quot;obj&quot;] *= (imgsz / 640) ** 2 * 3 / nl  # 按图像大小和层缩放
hyp[&quot;label_smoothing&quot;] = opt.label_smoothing
model.nc = nc  # 将类别数量附加到模型
model.hyp = hyp  # 将超参数附加到模型
model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # 将类别权重附加到模型
model.names = names

# 开始训练
t0 = time.time()
nb = len(train_loader)  # 批次数量
nw = max(round(hyp[&quot;warmup_epochs&quot;] * nb), 100)  # 预热迭代次数，最大（3个epoch，100次迭代）
# nw = min(nw, (epochs - start_epoch) / 2 * nb)  # 将预热限制在训练的一半以下
last_opt_step = -1
maps = np.zeros(nc)  # 每个类别的mAP
results = (0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)
scheduler.last_epoch = start_epoch - 1  # 不要移动
scaler = torch.cuda.amp.GradScaler(enabled=amp)
stopper, stop = EarlyStopping(patience=opt.patience), False
compute_loss = ComputeLoss(model)  # 初始化损失类
callbacks.run(&quot;on_train_start&quot;)
LOGGER.info(
    f&#39;图像大小 &#123;imgsz&#125; 训练, &#123;imgsz&#125; 验证\n&#39;
    f&#39;使用 &#123;train_loader.num_workers * WORLD_SIZE&#125; 个数据加载器工作进程\n&#39;
    f&quot;记录结果到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;\n&quot;
    f&#39;开始训练 &#123;epochs&#125; 个epoch...&#39;
)
for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------
    callbacks.run(&quot;on_train_epoch_start&quot;)
    model.train()

    # 更新图像权重（可选，仅限单GPU）
    if opt.image_weights:
        cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # 类别权重
        iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # 图像权重
        dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # 随机加权索引

    # 更新马赛克边框（可选）
    # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)
    # dataset.mosaic_border = [b - imgsz, -b]  # 高度，宽度边框

    mloss = torch.zeros(3, device=device)  # 平均损失
    if RANK != -1:
        train_loader.sampler.set_epoch(epoch)
    pbar = enumerate(train_loader)
    LOGGER.info((&quot;\n&quot; + &quot;%11s&quot; * 7) % (&quot;Epoch&quot;, &quot;GPU_mem&quot;, &quot;box_loss&quot;, &quot;obj_loss&quot;, &quot;cls_loss&quot;, &quot;Instances&quot;, &quot;Size&quot;))
    if RANK in &#123;-1, 0&#125;:
        pbar = tqdm(pbar, total=nb, bar_format=TQDM_BAR_FORMAT)  # 进度条
    optimizer.zero_grad()
    for i, (imgs, targets, paths, _) in pbar:  # batch -------------------------------------------------------------
        callbacks.run(&quot;on_train_batch_start&quot;)
        ni = i + nb * epoch  # 自训练开始以来的集成批次数量
        imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8转为float32，0-255转为0.0-1.0

        # 预热
        if ni &lt;= nw:
            xi = [0, nw]  # x插值
            # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou损失比率（obj_loss = 1.0或iou）
            accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())
            for j, x in enumerate(optimizer.param_groups):
                # bias lr从0.1下降到lr0，其他lr从0.0上升到lr0
                x[&quot;lr&quot;] = np.interp(ni, xi, [hyp[&quot;warmup_bias_lr&quot;] if j == 0 else 0.0, x[&quot;initial_lr&quot;] * lf(epoch)])
                if &quot;momentum&quot; in x:
                    x[&quot;momentum&quot;] = np.interp(ni, xi, [hyp[&quot;warmup_momentum&quot;], hyp[&quot;momentum&quot;]])

        # 多尺度
        if opt.multi_scale:
            sz = random.randrange(int(imgsz * 0.5), int(imgsz * 1.5) + gs) // gs * gs  # 大小
            sf = sz / max(imgs.shape[2:])  # 缩放因子
            if sf != 1:
                ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # 新形状（拉伸到gs倍数）
                imgs = nn.functional.interpolate(imgs, size=ns, mode=&quot;bilinear&quot;, align_corners=False)

        # 前向传播
        with torch.cuda.amp.autocast(amp):
            pred = model(imgs)  # 前向传播
            loss, loss_items = compute_loss(pred, targets.to(device))  # 损失按批量大小缩放
            if RANK != -1:
                loss *= WORLD_SIZE  # 在DDP模式下梯度在设备间平均
            if opt.quad:
                loss *= 4.0

        # 反向传播
        scaler.scale(loss).backward()

        # 优化 - https://pytorch.org/docs/master/notes/amp_examples.html
        if ni - last_opt_step &gt;= accumulate:
            scaler.unscale_(optimizer)  # 取消梯度缩放
            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # 梯度裁剪
            scaler.step(optimizer)  # 优化器步骤
            scaler.update()
            optimizer.zero_grad()
            if ema:
                ema.update(model)
            last_opt_step = ni

        # 日志
        if RANK in &#123;-1, 0&#125;:
            mloss = (mloss * i + loss_items) / (i + 1)  # 更新平均损失
            mem = f&quot;&#123;torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g&#125;G&quot;  # (GB)
            pbar.set_description(
                (&quot;%11s&quot; * 2 + &quot;%11.4g&quot; * 5)
                % (f&quot;&#123;epoch&#125;/&#123;epochs - 1&#125;&quot;, mem, *mloss, targets.shape[0], imgs.shape[-1])
            )
            callbacks.run(&quot;on_train_batch_end&quot;, model, ni, imgs, targets, paths, list(mloss))
            if callbacks.stop_training:
                return
        # 结束批次 ------------------------------------------------------------------------------------------------

    # 学习率调度器
    lr = [x[&quot;lr&quot;] for x in optimizer.param_groups]  # 用于日志记录器
    scheduler.step()

    if RANK in &#123;-1, 0&#125;:
        # mAP
        callbacks.run(&quot;on_train_epoch_end&quot;, epoch=epoch)
        ema.update_attr(model, include=[&quot;yaml&quot;, &quot;nc&quot;, &quot;hyp&quot;, &quot;names&quot;, &quot;stride&quot;, &quot;class_weights&quot;])
        final_epoch = (epoch + 1 == epochs) or stopper.possible_stop
        if not noval or final_epoch:  # 计算mAP
            results, maps, _ = validate.run(
                data_dict,
                batch_size=batch_size // WORLD_SIZE * 2,
                imgsz=imgsz,
                half=amp,
                model=ema.ema,
                single_cls=single_cls,
                dataloader=val_loader,
                save_dir=save_dir,
                plots=False,
                callbacks=callbacks,
                compute_loss=compute_loss,
            )

        # 更新最佳mAP
        fi = fitness(np.array(results).reshape(1, -1))  # [P, R, mAP@.5, mAP@.5-.95]的加权组合
        stop = stopper(epoch=epoch, fitness=fi)  # 早停检查
        if fi &gt; best_fitness:
            best_fitness = fi
        log_vals = list(mloss) + list(results) + lr
        callbacks.run(&quot;on_fit_epoch_end&quot;, log_vals, epoch, best_fitness, fi)

        # 保存模型
        if (not nosave) or (final_epoch and not evolve):  # 如果保存
            ckpt = &#123;
                &quot;epoch&quot;: epoch,
                &quot;best_fitness&quot;: best_fitness,
                &quot;model&quot;: deepcopy(de_parallel(model)).half(),
                &quot;ema&quot;: deepcopy(ema.ema).half(),
                &quot;updates&quot;: ema.updates,
                &quot;optimizer&quot;: optimizer.state_dict(),
                &quot;opt&quot;: vars(opt),
                &quot;git&quot;: GIT_INFO,  # &#123;remote, branch, commit&#125; 如果是git仓库
                &quot;date&quot;: datetime.now().isoformat(),
            &#125;

            # 保存最后、最佳并删除
            torch.save(ckpt, last)
            if best_fitness == fi:
                torch.save(ckpt, best)
            if opt.save_period &gt; 0 and epoch % opt.save_period == 0:
                torch.save(ckpt, w / f&quot;epoch&#123;epoch&#125;.pt&quot;)
            del ckpt
            callbacks.run(&quot;on_model_save&quot;, last, epoch, final_epoch, best_fitness, fi)

    # 早停
    if RANK != -1:  # 如果是DDP训练
        broadcast_list = [stop if RANK == 0 else None]
        dist.broadcast_object_list(broadcast_list, 0)  # 将&#39;stop&#39;广播到所有rank
        if RANK != 0:
            stop = broadcast_list[0]
    if stop:
        break  # 必须中断所有DDP rank

    # 结束epoch ----------------------------------------------------------------------------------------------------
# 结束训练 -----------------------------------------------------------------------------------------------------
if RANK in &#123;-1, 0&#125;:
    LOGGER.info(f&quot;\n&#123;epoch - start_epoch + 1&#125; 个epoch在 &#123;(time.time() - t0) / 3600:.3f&#125; 小时内完成。&quot;)
    for f in last, best:
        if f.exists():
            strip_optimizer(f)  # 去除优化器
            if f is best:
                LOGGER.info(f&quot;\n验证 &#123;f&#125;...&quot;)
                results, _, _ = validate.run(
                    data_dict,
                    batch_size=batch_size // WORLD_SIZE * 2,
                    imgsz=imgsz,
                    model=attempt_load(f, device).half(),
                    iou_thres=0.65 if is_coco else 0.60,  # 最佳pycocotools在iou 0.65
                    single_cls=single_cls,
                    dataloader=val_loader,
                    save_dir=save_dir,
                    save_json=is_coco,
                    verbose=True,
                    plots=plots,
                    callbacks=callbacks,
                    compute_loss=compute_loss,
                )  # 使用图表验证最佳模型
                if is_coco:
                    callbacks.run(&quot;on_fit_epoch_end&quot;, list(mloss) + list(results) + lr, epoch, best_fitness, fi)

    callbacks.run(&quot;on_train_end&quot;, last, best, epoch, results)

torch.cuda.empty_cache()
return results
</code></pre><p>def parse_opt(known=False):<br>    “””<br>    解析命令行参数以配置YOLO模型的训练。</p>
<pre><code>参数:
    known (bool): 仅解析已知参数的标志，默认为False。

返回:
    (argparse.Namespace): 解析后的命令行参数。

示例:
    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">options = parse_opt()</span><br><span class="line"><span class="built_in">print</span>(options.weights)</span><br></pre></td></tr></table></figure>

注意:
    * 默认权重路径为 &#39;yolov3-tiny.pt&#39;。
    * 设置 `known` 为True以仅解析已知参数，适用于部分参数解析。

参考:
    * 模型: https://github.com/ultralytics/yolov5/tree/master/models
    * 数据集: https://github.com/ultralytics/yolov5/tree/master/data
    * 训练教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data
&quot;&quot;&quot;
parser = argparse.ArgumentParser()
parser.add_argument(&quot;--weights&quot;, type=str, default=ROOT / &quot;yolov3-tiny.pt&quot;, help=&quot;初始权重路径&quot;)
parser.add_argument(&quot;--cfg&quot;, type=str, default=&quot;&quot;, help=&quot;模型yaml路径&quot;)
parser.add_argument(&quot;--data&quot;, type=str, default=ROOT / &quot;data/coco128.yaml&quot;, help=&quot;数据集yaml路径&quot;)
parser.add_argument(&quot;--hyp&quot;, type=str, default=ROOT / &quot;data/hyps/hyp.scratch-low.yaml&quot;, help=&quot;超参数路径&quot;)
parser.add_argument(&quot;--epochs&quot;, type=int, default=100, help=&quot;总训练epoch数&quot;)
parser.add_argument(&quot;--batch-size&quot;, type=int, default=16, help=&quot;所有GPU的总批量大小，-1表示自动批量&quot;)
parser.add_argument(&quot;--imgsz&quot;, &quot;--img&quot;, &quot;--img-size&quot;, type=int, default=640, help=&quot;训练、验证图像大小（像素）&quot;)
parser.add_argument(&quot;--rect&quot;, action=&quot;store_true&quot;, help=&quot;矩形训练&quot;)
parser.add_argument(&quot;--resume&quot;, nargs=&quot;?&quot;, const=True, default=False, help=&quot;恢复最近的训练&quot;)
parser.add_argument(&quot;--nosave&quot;, action=&quot;store_true&quot;, help=&quot;仅保存最终检查点&quot;)
parser.add_argument(&quot;--noval&quot;, action=&quot;store_true&quot;, help=&quot;仅在最终epoch验证&quot;)
parser.add_argument(&quot;--noautoanchor&quot;, action=&quot;store_true&quot;, help=&quot;禁用AutoAnchor&quot;)
parser.add_argument(&quot;--noplots&quot;, action=&quot;store_true&quot;, help=&quot;不保存任何图表文件&quot;)
parser.add_argument(&quot;--evolve&quot;, type=int, nargs=&quot;?&quot;, const=300, help=&quot;超参数进化x代&quot;)
parser.add_argument(&quot;--bucket&quot;, type=str, default=&quot;&quot;, help=&quot;gsutil存储桶&quot;)
parser.add_argument(&quot;--cache&quot;, type=str, nargs=&quot;?&quot;, const=&quot;ram&quot;, help=&quot;图像缓存 ram/disk&quot;)
parser.add_argument(&quot;--image-weights&quot;, action=&quot;store_true&quot;, help=&quot;使用加权图像选择进行训练&quot;)
parser.add_argument(&quot;--device&quot;, default=&quot;&quot;, help=&quot;cuda设备，例如 0 或 0,1,2,3 或 cpu&quot;)
parser.add_argument(&quot;--multi-scale&quot;, action=&quot;store_true&quot;, help=&quot;图像大小变化 +/- 50%%&quot;)
parser.add_argument(&quot;--single-cls&quot;, action=&quot;store_true&quot;, help=&quot;将多类数据训练为单类&quot;)
parser.add_argument(&quot;--optimizer&quot;, type=str, choices=[&quot;SGD&quot;, &quot;Adam&quot;, &quot;AdamW&quot;], default=&quot;SGD&quot;, help=&quot;优化器&quot;)
parser.add_argument(&quot;--sync-bn&quot;, action=&quot;store_true&quot;, help=&quot;使用SyncBatchNorm，仅在DDP模式下可用&quot;)
parser.add_argument(&quot;--workers&quot;, type=int, default=8, help=&quot;最大数据加载器工作进程数（DDP模式下每rank）&quot;)
parser.add_argument(&quot;--project&quot;, default=ROOT / &quot;runs/train&quot;, help=&quot;保存到project/name&quot;)
parser.add_argument(&quot;--name&quot;, default=&quot;exp&quot;, help=&quot;保存到project/name&quot;)
parser.add_argument(&quot;--exist-ok&quot;, action=&quot;store_true&quot;, help=&quot;允许现有project/name，不递增&quot;)
parser.add_argument(&quot;--quad&quot;, action=&quot;store_true&quot;, help=&quot;四倍数据加载器&quot;)
parser.add_argument(&quot;--cos-lr&quot;, action=&quot;store_true&quot;, help=&quot;余弦学习率调度器&quot;)
parser.add_argument(&quot;--label-smoothing&quot;, type=float, default=0.0, help=&quot;标签平滑epsilon&quot;)
parser.add_argument(&quot;--patience&quot;, type=int, default=100, help=&quot;早停耐心（无改进的epoch数）&quot;)
parser.add_argument(&quot;--freeze&quot;, nargs=&quot;+&quot;, type=int, default=[0], help=&quot;冻结层：backbone=10, first3=0 1 2&quot;)
parser.add_argument(&quot;--save-period&quot;, type=int, default=-1, help=&quot;每x个epoch保存检查点（如果小于1则禁用）&quot;)
parser.add_argument(&quot;--seed&quot;, type=int, default=0, help=&quot;全局训练种子&quot;)
parser.add_argument(&quot;--local_rank&quot;, type=int, default=-1, help=&quot;自动DDP多GPU参数，不要修改&quot;)

# 日志记录器参数
parser.add_argument(&quot;--entity&quot;, default=None, help=&quot;实体&quot;)
parser.add_argument(&quot;--upload_dataset&quot;, nargs=&quot;?&quot;, const=True, default=False, help=&#39;上传数据，&quot;val&quot;选项&#39;)
parser.add_argument(&quot;--bbox_interval&quot;, type=int, default=-1, help=&quot;设置边界框图像记录间隔&quot;)
parser.add_argument(&quot;--artifact_alias&quot;, type=str, default=&quot;latest&quot;, help=&quot;数据集工件的版本&quot;)

return parser.parse_known_args()[0] if known else parser.parse_args()
</code></pre><p>def main(opt, callbacks=Callbacks()):<br>    “””<br>    主训练/进化脚本，处理模型检查、DDP设置、训练和超参数进化。</p>
<pre><code>参数:
    opt (argparse.Namespace): 解析后的命令行选项。
    callbacks (Callbacks, 可选): 处理训练事件的回调对象。默认为Callbacks()。

返回:
    None

异常:
    AssertionError: 如果某些约束被违反（例如，当特定选项与DDP训练不兼容时）。

注意:
   - 有关使用DDP进行多GPU训练的教程：https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training

示例:
    单GPU训练:
    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python train.py --data coco128.yaml --weights yolov5s.pt --img <span class="number">640</span>  <span class="comment"># 从预训练模型开始训练（推荐）</span></span><br><span class="line">$ python train.py --data coco128.yaml --weights <span class="string">&#x27;&#x27;</span> --cfg yolov5s.yaml --img <span class="number">640</span>  <span class="comment"># 从零开始训练</span></span><br></pre></td></tr></table></figure>

    多GPU DDP训练:
    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m torch.distributed.run --nproc_per_node <span class="number">4</span> --master_port <span class="number">1</span> train.py --data coco128.yaml \</span><br><span class="line">--weights yolov5s.pt --img <span class="number">640</span> --device <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>

    模型: https://github.com/ultralytics/yolov5/tree/master/models
    数据集: https://github.com/ultralytics/yolov5/tree/master/data
    教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data
&quot;&quot;&quot;
if RANK in &#123;-1, 0&#125;:
    print_args(vars(opt))
    check_git_status()
    check_requirements(ROOT / &quot;requirements.txt&quot;)

# 恢复（从指定或最近的last.pt）
if opt.resume and not check_comet_resume(opt) and not opt.evolve:
    last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())
    opt_yaml = last.parent.parent / &quot;opt.yaml&quot;  # 训练选项yaml
    opt_data = opt.data  # 原始数据集
    if opt_yaml.is_file():
        with open(opt_yaml, errors=&quot;ignore&quot;) as f:
            d = yaml.safe_load(f)
    else:
        d = torch.load(last, map_location=&quot;cpu&quot;)[&quot;opt&quot;]
    opt = argparse.Namespace(**d)  # 替换
    opt.cfg, opt.weights, opt.resume = &quot;&quot;, str(last), True  # 恢复
    if is_url(opt_data):
        opt.data = check_file(opt_data)  # 避免HUB恢复认证超时
else:
    opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = (
        check_file(opt.data),
        check_yaml(opt.cfg),
        check_yaml(opt.hyp),
        str(opt.weights),
        str(opt.project),
    )  # 检查
    assert len(opt.cfg) or len(opt.weights), &quot;必须指定 --cfg 或 --weights&quot;
    if opt.evolve:
        if opt.project == str(ROOT / &quot;runs/train&quot;):  # 如果默认项目名称，重命名为runs/evolve
            opt.project = str(ROOT / &quot;runs/evolve&quot;)
        opt.exist_ok, opt.resume = opt.resume, False  # 将resume传递给exist_ok并禁用resume
    if opt.name == &quot;cfg&quot;:
        opt.name = Path(opt.cfg).stem  # 使用model.yaml作为名称
    opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))

# DDP模式
device = select_device(opt.device, batch_size=opt.batch_size)
if LOCAL_RANK != -1:
    msg = &quot;与YOLOv3多GPU DDP训练不兼容&quot;
    assert not opt.image_weights, f&quot;--image-weights &#123;msg&#125;&quot;
    assert not opt.evolve, f&quot;--evolve &#123;msg&#125;&quot;
    assert opt.batch_size != -1, f&quot;自动批量 --batch-size -1 &#123;msg&#125;, 请传递有效的 --batch-size&quot;
    assert opt.batch_size % WORLD_SIZE == 0, f&quot;--batch-size &#123;opt.batch_size&#125; 必须是 WORLD_SIZE 的倍数&quot;
    assert torch.cuda.device_count() &gt; LOCAL_RANK, &quot;DDP命令的CUDA设备不足&quot;
    torch.cuda.set_device(LOCAL_RANK)
    device = torch.device(&quot;cuda&quot;, LOCAL_RANK)
    dist.init_process_group(backend=&quot;nccl&quot; if dist.is_nccl_available() else &quot;gloo&quot;)

# 训练
if not opt.evolve:
    train(opt.hyp, opt, device, callbacks)

# 超参数进化（可选）
else:
    # 超参数进化元数据（突变比例0-1，下限，上限）
    meta = &#123;
        &quot;lr0&quot;: (1, 1e-5, 1e-1),  # 初始学习率（SGD=1E-2, Adam=1E-3）
        &quot;lrf&quot;: (1, 0.01, 1.0),  # 最终OneCycleLR学习率（lr0 * lrf）
        &quot;momentum&quot;: (0.3, 0.6, 0.98),  # SGD动量/Adam beta1
        &quot;weight_decay&quot;: (1, 0.0, 0.001),  # 优化器权重衰减
        &quot;warmup_epochs&quot;: (1, 0.0, 5.0),  # 预热epoch数（可以是小数）
        &quot;warmup_momentum&quot;: (1, 0.0, 0.95),  # 预热初始动量
        &quot;warmup_bias_lr&quot;: (1, 0.0, 0.2),  # 预热初始偏差学习率
        &quot;box&quot;: (1, 0.02, 0.2),  # 框损失增益
        &quot;cls&quot;: (1, 0.2, 4.0),  # 类别损失增益
        &quot;cls_pw&quot;: (1, 0.5, 2.0),  # 类别BCELoss正样本权重
        &quot;obj&quot;: (1, 0.2, 4.0),  # 目标损失增益（按像素缩放）
        &quot;obj_pw&quot;: (1, 0.5, 2.0),  # 目标BCELoss正样本权重
        &quot;iou_t&quot;: (0, 0.1, 0.7),  # IoU训练阈值
        &quot;anchor_t&quot;: (1, 2.0, 8.0),  # 锚点倍数阈值
        &quot;anchors&quot;: (2, 2.0, 10.0),  # 每个输出网格的锚点数量（0表示忽略）
        &quot;fl_gamma&quot;: (0, 0.0, 2.0),  # 焦点损失gamma（efficientDet默认gamma=1.5）
        &quot;hsv_h&quot;: (1, 0.0, 0.1),  # 图像HSV-Hue增强（比例）
        &quot;hsv_s&quot;: (1, 0.0, 0.9),  # 图像HSV-Saturation增强（比例）
        &quot;hsv_v&quot;: (1, 0.0, 0.9),  # 图像HSV-Value增强（比例）
        &quot;degrees&quot;: (1, 0.0, 45.0),  # 图像旋转（+/- 度）
        &quot;translate&quot;: (1, 0.0, 0.9),  # 图像平移（+/- 比例）
        &quot;scale&quot;: (1, 0.0, 0.9),  # 图像缩放（+/- 增益）
        &quot;shear&quot;: (1, 0.0, 10.0),  # 图像剪切（+/- 度）
        &quot;perspective&quot;: (0, 0.0, 0.001),  # 图像透视（+/- 比例），范围0-0.001
        &quot;flipud&quot;: (1, 0.0, 1.0),  # 图像上下翻转（概率）
        &quot;fliplr&quot;: (0, 0.0, 1.0),  # 图像左右翻转（概率）
        &quot;mosaic&quot;: (1, 0.0, 1.0),  # 图像马赛克（概率）
        &quot;mixup&quot;: (1, 0.0, 1.0),  # 图像混合（概率）
        &quot;copy_paste&quot;: (1, 0.0, 1.0),
    &#125;  # 分段复制粘贴（概率）

    with open(opt.hyp, errors=&quot;ignore&quot;) as f:
        hyp = yaml.safe_load(f)  # 加载超参数字典
        if &quot;anchors&quot; not in hyp:  # 如果hyp.yaml中注释了anchors
            hyp[&quot;anchors&quot;] = 3
    if opt.noautoanchor:
        del hyp[&quot;anchors&quot;], meta[&quot;anchors&quot;]
    opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # 仅在最终epoch验证/保存
    # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # 可进化的索引
    evolve_yaml, evolve_csv = save_dir / &quot;hyp_evolve.yaml&quot;, save_dir / &quot;evolve.csv&quot;
    if opt.bucket:
        # 如果存在则下载evolve.csv
        subprocess.run(
            [
                &quot;gsutil&quot;,
                &quot;cp&quot;,
                f&quot;gs://&#123;opt.bucket&#125;/evolve.csv&quot;,
                str(evolve_csv),
            ]
        )

    for _ in range(opt.evolve):  # 进化代数
        if evolve_csv.exists():  # 如果evolve.csv存在：选择最佳超参数并突变
            # 选择父代
            parent = &quot;single&quot;  # 父代选择方法：&#39;single&#39; 或 &#39;weighted&#39;
            x = np.loadtxt(evolve_csv, ndmin=2, delimiter=&quot;,&quot;, skiprows=1)
            n = min(5, len(x))  # 考虑的前n个结果
            x = x[np.argsort(-fitness(x))][:n]  # 前n个突变
            w = fitness(x) - fitness(x).min() + 1e-6  # 权重（总和 &gt; 0）
            if parent == &quot;single&quot; or len(x) == 1:
                # x = x[random.randint(0, n - 1)]  # 随机选择
                x = x[random.choices(range(n), weights=w)[0]]  # 加权选择
            elif parent == &quot;weighted&quot;:
                x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # 加权组合

            # 突变
            mp, s = 0.8, 0.2  # 突变概率，sigma
            npr = np.random
            npr.seed(int(time.time()))
            g = np.array([meta[k][0] for k in hyp.keys()])  # 增益 0-1
            ng = len(meta)
            v = np.ones(ng)
            while all(v == 1):  # 突变直到发生变化（防止重复）
                v = (g * (npr.random(ng) &lt; mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)
            for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)
                hyp[k] = float(x[i + 7] * v[i])  # 突变

        # 限制在范围内
        for k, v in meta.items():
            hyp[k] = max(hyp[k], v[1])  # 下限
            hyp[k] = min(hyp[k], v[2])  # 上限
            hyp[k] = round(hyp[k], 5)  # 有效数字

        # 训练突变
        results = train(hyp.copy(), opt, device, callbacks)
        callbacks = Callbacks()
        # 写入突变结果
        keys = (
            &quot;metrics/precision&quot;,
            &quot;metrics/recall&quot;,
            &quot;metrics/mAP_0.5&quot;,
            &quot;metrics/mAP_0.5:0.95&quot;,
            &quot;val/box_loss&quot;,
            &quot;val/obj_loss&quot;,
            &quot;val/cls_loss&quot;,
        )
        print_mutation(keys, results, hyp.copy(), save_dir, opt.bucket)

    # 绘制结果
    plot_evolve(evolve_csv)
    LOGGER.info(
        f&#39;超参数进化完成 &#123;opt.evolve&#125; 代\n&#39;
        f&quot;结果保存到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;\n&quot;
        f&#39;使用示例: $ python train.py --hyp &#123;evolve_yaml&#125;&#39;
    )
</code></pre><p>def run(**kwargs):<br>    “””<br>    使用指定配置运行YOLOv3模型的训练过程。</p>
<pre><code>参数:
    data (str): 数据集YAML文件的路径。
    weights (str): 预训练权重文件的路径或 &#39;&#39; 表示从零开始训练。
    cfg (str): 模型配置文件的路径。
    hyp (str): 超参数YAML文件的路径。
    epochs (int): 总训练epoch数。
    batch_size (int): 所有GPU的总批量大小。
    imgsz (int): 训练和验证的图像大小（像素）。
    rect (bool): 使用矩形训练以更好地保留宽高比。
    resume (bool | str): 如果为True，则恢复最近的训练，如果为字符串，则从特定检查点恢复训练。
    nosave (bool): 仅保存最终检查点，不保存中间检查点。
    noval (bool): 仅在最终epoch验证模型性能。
    noautoanchor (bool): 禁用自动锚点生成。
    noplots (bool): 不保存任何图表。
    evolve (int): 超参数进化的代数。
    bucket (str): 用于保存运行工件的Google Cloud Storage存储桶名称。
    cache (str | None): 缓存图像以加快训练速度（&#39;ram&#39; 或 &#39;disk&#39;）。
    image_weights (bool): 使用加权图像选择进行训练。
    device (str): 用于训练的设备，例如 &#39;0&#39; 表示第一个GPU或 &#39;cpu&#39; 表示CPU。
    multi_scale (bool): 使用多尺度训练。
    single_cls (bool): 将多类数据集训练为单类。
    optimizer (str): 使用的优化器（&#39;SGD&#39;, &#39;Adam&#39;, 或 &#39;AdamW&#39;）。
    sync_bn (bool): 使用同步批归一化（仅在DDP模式下可用）。
    workers (int): 最大数据加载器工作进程数（DDP模式下每rank）。
    project (str): 输出目录的位置。
    name (str): 运行的唯一名称。
    exist_ok (bool): 允许现有输出目录。
    quad (bool): 使用四倍数据加载器。
    cos_lr (bool): 使用余弦学习率调度器。
    label_smoothing (float): 标签平滑epsilon。
    patience (int): 早停耐心（无改进的epoch数）。
    freeze (list[int]): 冻结的层列表，例如 [0] 表示仅冻结第一层。
    save_period (int): 每 &#39;save_period&#39; 个epoch保存检查点（如果小于1则禁用）。
    seed (int): 全局训练种子以确保可重复性。
    local_rank (int): 用于自动DDP多GPU参数解析，不要修改。

返回:
    None

示例:
    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> run</span><br><span class="line">run(data=<span class="string">&#x27;coco128.yaml&#x27;</span>, weights=<span class="string">&#x27;yolov5m.pt&#x27;</span>, imgsz=<span class="number">320</span>, epochs=<span class="number">100</span>, batch_size=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

注意:
    - 确保数据集YAML文件和初始权重可访问。
    - 参考 [Ultralytics YOLOv5 仓库](https://github.com/ultralytics/yolov5) 获取模型和数据配置。
    - 使用 [训练教程](https://docs.ultralytics.com/yolov5/tutorials/train_custom_data) 进行自定义数据集训练。
&quot;&quot;&quot;
opt = parse_opt(True)
for k, v in kwargs.items():
    setattr(opt, k, v)
main(opt)
return opt
</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    opt = parse_opt()<br>    main(opt)<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta"># Ultralytics YOLOv3 🚀, AGPL-3.0 license</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">在图像、视频、目录、通配符、YouTube、网络摄像头、流媒体等上运行 YOLOv3 检测推理。</span><br><span class="line"></span><br><span class="line">用法 - 来源:</span><br><span class="line">    $ python detect.py --weights yolov5s.pt --source <span class="number">0</span>                               <span class="meta"># 网络摄像头</span></span><br><span class="line">                                                     img.jpg                         <span class="meta"># 图像</span></span><br><span class="line">                                                     vid.mp4                         <span class="meta"># 视频</span></span><br><span class="line">                                                     screen                          <span class="meta"># 截图</span></span><br><span class="line">                                                     path/                           <span class="meta"># 目录</span></span><br><span class="line">                                                     list.txt                        <span class="meta"># 图像列表</span></span><br><span class="line">                                                     list.streams                    <span class="meta"># 流媒体列表</span></span><br><span class="line">                                                     &#x27;path/*.jpg&#x27;                    <span class="meta"># 通配符</span></span><br><span class="line">                                                     &#x27;https://youtu.be/LNwODJXcvt4&#x27;  <span class="meta"># YouTube</span></span><br><span class="line">                                                     &#x27;rtsp://example.com/media.mp4&#x27;  <span class="meta"># RTSP, RTMP, HTTP 流</span></span><br><span class="line"></span><br><span class="line">用法 - 格式:</span><br><span class="line">    $ python detect.py --weights yolov5s.pt                 <span class="meta"># PyTorch</span></span><br><span class="line">                                 yolov5s.torchscript        <span class="meta"># TorchScript</span></span><br><span class="line">                                 yolov5s.onnx               <span class="meta"># ONNX Runtime 或 OpenCV DNN with --dnn</span></span><br><span class="line">                                 yolov5s_openvino_model     <span class="meta"># OpenVINO</span></span><br><span class="line">                                 yolov5s.engine             <span class="meta"># TensorRT</span></span><br><span class="line">                                 yolov5s.mlmodel            <span class="meta"># CoreML (macOS-only)</span></span><br><span class="line">                                 yolov5s_saved_model        <span class="meta"># TensorFlow SavedModel</span></span><br><span class="line">                                 yolov5s.pb                 <span class="meta"># TensorFlow GraphDef</span></span><br><span class="line">                                 yolov5s.tflite             <span class="meta"># TensorFlow Lite</span></span><br><span class="line">                                 yolov5s_edgetpu.tflite     <span class="meta"># TensorFlow Edge TPU</span></span><br><span class="line">                                 yolov5s_paddle_model       <span class="meta"># PaddlePaddle</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">import argparse</span><br><span class="line">import os</span><br><span class="line">import platform</span><br><span class="line">import sys</span><br><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line">FILE = Path(__file__).resolve()</span><br><span class="line">ROOT = FILE.parents[<span class="number">0</span>]  <span class="meta"># YOLOv3 根目录</span></span><br><span class="line">if str(ROOT) not in sys.path:</span><br><span class="line">    sys.path.append(str(ROOT))  <span class="meta"># 将 ROOT 添加到 PATH</span></span><br><span class="line">ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  <span class="meta"># 相对路径</span></span><br><span class="line"></span><br><span class="line">from ultralytics.utils.plotting import Annotator, colors, save_one_box</span><br><span class="line"></span><br><span class="line">from models.common import DetectMultiBackend</span><br><span class="line">from utils.dataloaders import IMG_FORMATS, VID_FORMATS, LoadImages, LoadScreenshots, LoadStreams</span><br><span class="line">from utils.general import (</span><br><span class="line">    LOGGER,</span><br><span class="line">    Profile,</span><br><span class="line">    check_file,</span><br><span class="line">    check_img_size,</span><br><span class="line">    check_imshow,</span><br><span class="line">    check_requirements,</span><br><span class="line">    colorstr,</span><br><span class="line">    cv2,</span><br><span class="line">    increment_path,</span><br><span class="line">    non_max_suppression,</span><br><span class="line">    print_args,</span><br><span class="line">    scale_boxes,</span><br><span class="line">    strip_optimizer,</span><br><span class="line">    xyxy2xywh,</span><br><span class="line">)</span><br><span class="line">from utils.torch_utils import select_device, smart_inference_mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@smart_inference_mode()</span><br><span class="line">def run(</span><br><span class="line">    weights=ROOT / <span class="string">&quot;yolov5s.pt&quot;</span>,  <span class="meta"># 模型路径或 Triton URL</span></span><br><span class="line">    source=ROOT / <span class="string">&quot;data/images&quot;</span>,  <span class="meta"># 文件/目录/URL/通配符/截图/0(网络摄像头)</span></span><br><span class="line">    data=ROOT / <span class="string">&quot;data/coco128.yaml&quot;</span>,  <span class="meta"># 数据集.yaml 路径</span></span><br><span class="line">    imgsz=(<span class="number">640</span>, <span class="number">640</span>),  <span class="meta"># 推理尺寸 (高度, 宽度)</span></span><br><span class="line">    conf_thres=<span class="number">0.25</span>,  <span class="meta"># 置信度阈值</span></span><br><span class="line">    iou_thres=<span class="number">0.45</span>,  <span class="meta"># NMS IOU 阈值</span></span><br><span class="line">    max_det=<span class="number">1000</span>,  <span class="meta"># 每张图像的最大检测数</span></span><br><span class="line">    device=<span class="string">&quot;&quot;</span>,  <span class="meta"># CUDA 设备，例如 0 或 0,1,2,3 或 cpu</span></span><br><span class="line">    view_img=False,  <span class="meta"># 显示结果</span></span><br><span class="line">    save_txt=False,  <span class="meta"># 将结果保存到 *.txt</span></span><br><span class="line">    save_conf=False,  <span class="meta"># 在 --save-txt 标签中保存置信度</span></span><br><span class="line">    save_crop=False,  <span class="meta"># 保存裁剪的预测框</span></span><br><span class="line">    nosave=False,  <span class="meta"># 不保存图像/视频</span></span><br><span class="line">    classes=None,  <span class="meta"># 按类别过滤：--class 0 或 --class 0 2 3</span></span><br><span class="line">    agnostic_nms=False,  <span class="meta"># 类别无关的 NMS</span></span><br><span class="line">    augment=False,  <span class="meta"># 增强推理</span></span><br><span class="line">    visualize=False,  <span class="meta"># 可视化特征</span></span><br><span class="line">    update=False,  <span class="meta"># 更新所有模型</span></span><br><span class="line">    project=ROOT / <span class="string">&quot;runs/detect&quot;</span>,  <span class="meta"># 将结果保存到 project/name</span></span><br><span class="line">    name=<span class="string">&quot;exp&quot;</span>,  <span class="meta"># 将结果保存到 project/name</span></span><br><span class="line">    exist_ok=False,  <span class="meta"># 允许现有 project/name，不递增</span></span><br><span class="line">    line_thickness=<span class="number">3</span>,  <span class="meta"># 边界框厚度 (像素)</span></span><br><span class="line">    hide_labels=False,  <span class="meta"># 隐藏标签</span></span><br><span class="line">    hide_conf=False,  <span class="meta"># 隐藏置信度</span></span><br><span class="line">    half=False,  <span class="meta"># 使用 FP16 半精度推理</span></span><br><span class="line">    dnn=False,  <span class="meta"># 使用 OpenCV DNN 进行 ONNX 推理</span></span><br><span class="line">    vid_stride=<span class="number">1</span>,  <span class="meta"># 视频帧率步长</span></span><br><span class="line">):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    在各种输入源（如图像、视频、流媒体、YouTube URL）上运行 YOLOv3 检测推理。</span><br><span class="line"></span><br><span class="line">    参数:</span><br><span class="line">        weights (str <span class="string">| Path): 模型权重文件路径或 Triton URL (默认: &#x27;yolov5s.pt&#x27;)。</span></span><br><span class="line">        source (str <span class="string">| Path): 输入数据源，如文件、目录、URL、通配符模式或设备标识符 (默认: &#x27;data/images&#x27;)。</span></span><br><span class="line">        data (str <span class="string">| Path): 数据集 YAML 文件路径 (默认: &#x27;data/coco128.yaml&#x27;)。</span></span><br><span class="line">        imgsz (tuple[int, int]): 推理尺寸，格式为 (高度, 宽度) (默认: (<span class="number">640</span>, <span class="number">640</span>))。</span><br><span class="line">        conf_thres (float): 检测的置信度阈值 (默认: <span class="number">0.25</span>)。</span><br><span class="line">        iou_thres (float): 非最大抑制 (NMS) 的交并比 (IOU) 阈值 (默认: <span class="number">0.45</span>)。</span><br><span class="line">        max_det (int): 每张图像的最大检测数 (默认: <span class="number">1000</span>)。</span><br><span class="line">        device (str): CUDA 设备标识符，例如 &#x27;0&#x27;, &#x27;0,1,2,3&#x27;, 或 &#x27;cpu&#x27; (默认: &#x27;&#x27;)。</span><br><span class="line">        view_img (bool): 是否在推理过程中显示结果 (默认: False)。</span><br><span class="line">        save_txt (bool): 是否将检测结果保存到文本文件 (默认: False)。</span><br><span class="line">        save_conf (bool): 是否在文本标签中保存检测置信度 (默认: False)。</span><br><span class="line">        save_crop (bool): 是否保存裁剪的检测框 (默认: False)。</span><br><span class="line">        nosave (bool): 是否防止保存带有检测结果的图像或视频 (默认: False)。</span><br><span class="line">        classes (list[int] <span class="string">| None): 按类别索引过滤，例如 [0, 2, 3] (默认: None)。</span></span><br><span class="line">        agnostic_nms (bool): 是否执行类别无关的 NMS (默认: False)。</span><br><span class="line">        augment (bool): 是否应用增强推理 (默认: False)。</span><br><span class="line">        visualize (bool): 是否可视化特征图 (默认: False)。</span><br><span class="line">        update (bool): 是否更新所有模型 (默认: False)。</span><br><span class="line">        project (str <span class="string">| Path): 结果保存的项目目录路径 (默认: &#x27;runs/detect&#x27;)。</span></span><br><span class="line">        name (str): 项目目录中的特定运行名称 (默认: &#x27;exp&#x27;)。</span><br><span class="line">        exist_ok (bool): 是否允许现有 project/name 目录而不递增运行索引 (默认: False)。</span><br><span class="line">        line_thickness (int): 边界框线条的厚度 (像素) (默认: <span class="number">3</span>)。</span><br><span class="line">        hide_labels (bool): 是否在结果中隐藏标签 (默认: False)。</span><br><span class="line">        hide_conf (bool): 是否在结果中隐藏置信度 (默认: False)。</span><br><span class="line">        half (bool): 是否使用半精度 (FP16) 进行推理 (默认: False)。</span><br><span class="line">        dnn (bool): 是否使用 OpenCV DNN 进行 ONNX 推理 (默认: False)。</span><br><span class="line">        vid_stride (int): 视频帧率的步长 (默认: <span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line">    返回:</span><br><span class="line">        None</span><br><span class="line"></span><br><span class="line">    注意:</span><br><span class="line">        该函数支持多种输入源，如图像文件、视频文件、目录、URL 模式、网络摄像头流和 YouTube 链接。它还支持多种模型格式，包括 PyTorch、ONNX、OpenVINO、TensorRT、CoreML、TensorFlow、PaddlePaddle 等。结果可以实时显示或保存到指定目录。使用命令行参数修改函数的行为。</span><br><span class="line"></span><br><span class="line">    示例:</span><br><span class="line">        ```python</span><br><span class="line">        <span class="meta"># 在图像上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;data/images/bus.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># 在视频上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;data/videos/video.mp4&#x27;, view_img=True)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># 在网络摄像头上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;0&#x27;, view_img=True)</span><br></pre></td></tr></table></figure><br>    “””<br>    source = str(source)<br>    save_img = not nosave and not source.endswith(“.txt”)  # 保存推理图像<br>    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)<br>    is_url = source.lower().startswith((“rtsp://“, “rtmp://“, “http://“, “https://“))<br>    webcam = source.isnumeric() or source.endswith(“.streams”) or (is_url and not is_file)<br>    screenshot = source.lower().startswith(“screen”)<br>    if is_url and is_file:<br>        source = check_file(source)  # 下载</p>
<pre><code># 目录
save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # 递增运行
(save_dir / &quot;labels&quot; if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # 创建目录

# 加载模型
device = select_device(device)
model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)
stride, names, pt = model.stride, model.names, model.pt
imgsz = check_img_size(imgsz, s=stride)  # 检查图像尺寸

# 数据加载器
bs = 1  # 批量大小
if webcam:
    view_img = check_imshow(warn=True)
    dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)
    bs = len(dataset)
elif screenshot:
    dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)
else:
    dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)
vid_path, vid_writer = [None] * bs, [None] * bs

# 运行推理
model.warmup(imgsz=(1 if pt or model.triton else bs, 3, *imgsz))  # 预热
seen, windows, dt = 0, [], (Profile(), Profile(), Profile())
for path, im, im0s, vid_cap, s in dataset:
    with dt[0]:
        im = torch.from_numpy(im).to(model.device)
        im = im.half() if model.fp16 else im.float()  # uint8 转换为 fp16/32
        im /= 255  # 0 - 255 转换为 0.0 - 1.0
        if len(im.shape) == 3:
            im = im[None]  # 扩展为批量维度

    # 推理
    with dt[1]:
        visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False
        pred = model(im, augment=augment, visualize=visualize)

    # NMS
    with dt[2]:
        pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det)

    # 第二阶段分类器 (可选)
    # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)

    # 处理预测结果
    for i, det in enumerate(pred):  # 每张图像
        seen += 1
        if webcam:  # 批量大小 &gt;= 1
            p, im0, frame = path[i], im0s[i].copy(), dataset.count
            s += f&quot;&#123;i&#125;: &quot;
        else:
            p, im0, frame = path, im0s.copy(), getattr(dataset, &quot;frame&quot;, 0)

        p = Path(p)  # 转换为 Path
        save_path = str(save_dir / p.name)  # im.jpg
        txt_path = str(save_dir / &quot;labels&quot; / p.stem) + (&quot;&quot; if dataset.mode == &quot;image&quot; else f&quot;_&#123;frame&#125;&quot;)  # im.txt
        s += &quot;&#123;:g&#125;x&#123;:g&#125; &quot;.format(*im.shape[2:])  # 打印字符串
        gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # 归一化增益 whwh
        imc = im0.copy() if save_crop else im0  # 用于保存裁剪
        annotator = Annotator(im0, line_width=line_thickness, example=str(names))
        if len(det):
            # 将框从 img_size 缩放到 im0 尺寸
            det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()

            # 打印结果
            for c in det[:, 5].unique():
                n = (det[:, 5] == c).sum()  # 每个类别的检测数
                s += f&quot;&#123;n&#125; &#123;names[int(c)]&#125;&#123;&#39;s&#39; * (n &gt; 1)&#125;, &quot;  # 添加到字符串

            # 写入结果
            for *xyxy, conf, cls in reversed(det):
                if save_txt:  # 写入文件
                    xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # 归一化 xywh
                    line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # 标签格式
                    with open(f&quot;&#123;txt_path&#125;.txt&quot;, &quot;a&quot;) as f:
                        f.write((&quot;%g &quot; * len(line)).rstrip() % line + &quot;\n&quot;)

                if save_img or save_crop or view_img:  # 添加边界框到图像
                    c = int(cls)  # 整数类别
                    label = None if hide_labels else (names[c] if hide_conf else f&quot;&#123;names[c]&#125; &#123;conf:.2f&#125;&quot;)
                    annotator.box_label(xyxy, label, color=colors(c, True))
                if save_crop:
                    save_one_box(xyxy, imc, file=save_dir / &quot;crops&quot; / names[c] / f&quot;&#123;p.stem&#125;.jpg&quot;, BGR=True)

        # 流式结果
        im0 = annotator.result()
        if view_img:
            if platform.system() == &quot;Linux&quot; and p not in windows:
                windows.append(p)
                cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # 允许窗口调整大小 (Linux)
                cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])
            cv2.imshow(str(p), im0)
            cv2.waitKey(1)  # 1 毫秒

        # 保存结果 (带检测的图像)
        if save_img:
            if dataset.mode == &quot;image&quot;:
                cv2.imwrite(save_path, im0)
            else:  # &#39;video&#39; 或 &#39;stream&#39;
                if vid_path[i] != save_path:  # 新视频
                    vid_path[i] = save_path
                    if isinstance(vid_writer[i], cv2.VideoWriter):
                        vid_writer[i].release()  # 释放之前的视频写入器
                    if vid_cap:  # 视频
                        fps = vid_cap.get(cv2.CAP_PROP_FPS)
                        w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                        h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                    else:  # 流
                        fps, w, h = 30, im0.shape[1], im0.shape[0]
                    save_path = str(Path(save_path).with_suffix(&quot;.mp4&quot;))  # 强制结果视频为 *.mp4 后缀
                    vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*&quot;mp4v&quot;), fps, (w, h))
                vid_writer[i].write(im0)

    # 打印时间 (仅推理)
    LOGGER.info(f&quot;&#123;s&#125;&#123;&#39;&#39; if len(det) else &#39;(no detections), &#39;&#125;&#123;dt[1].dt * 1E3:.1f&#125;ms&quot;)

# 打印结果
t = tuple(x.t / seen * 1e3 for x in dt)  # 每张图像的速度
LOGGER.info(f&quot;Speed: %.1fms 预处理, %.1fms 推理, %.1fms NMS 每张图像 at shape &#123;(1, 3, *imgsz)&#125;&quot; % t)
if save_txt or save_img:
    s = f&quot;\n&#123;len(list(save_dir.glob(&#39;labels/*.txt&#39;)))&#125; 标签保存到 &#123;save_dir / &#39;labels&#39;&#125;&quot; if save_txt else &quot;&quot;
    LOGGER.info(f&quot;结果保存到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;&#123;s&#125;&quot;)
if update:
    strip_optimizer(weights[0])  # 更新模型 (修复 SourceChangeWarning)
</code></pre><p>def parse_opt():<br>    “””<br>    解析并返回用于运行 YOLOv3 模型检测的命令行选项。</p>
<pre><code>参数:
    --weights (list[str]): 模型路径或 Triton URL。默认: ROOT / &quot;yolov3-tiny.pt&quot;。
    --source (str): 输入数据源，如文件/目录/URL/通配符/截图/0(网络摄像头)。默认: ROOT / &quot;data/images&quot;。
    --data (str): 可选的数据集.yaml 路径。默认: ROOT / &quot;data/coco128.yaml&quot;。
    --imgsz (list[int]): 推理尺寸，格式为高度, 宽度。接受多个值。默认: [640]。
    --conf-thres (float): 预测的置信度阈值。默认: 0.25。
    --iou-thres (float): 非最大抑制 (NMS) 的交并比 (IoU) 阈值。默认: 0.45。
    --max-det (int): 每张图像的最大检测数。默认: 1000。
    --device (str): CUDA 设备标识符，例如 &quot;0&quot; 或 &quot;0,1,2,3&quot; 或 &quot;cpu&quot;。默认: &quot;&quot; (自动选择)。
    --view-img (bool): 显示结果。默认: False。
    --save-txt (bool): 将结果保存到 *.txt 文件。默认: False。
    --save-conf (bool): 在文本标签中保存置信度分数。默认: False。
    --save-crop (bool): 保存裁剪的预测框。默认: False。
    --nosave (bool): 不保存带有检测结果的图像/视频。默认: False。
    --classes (list[int] | None): 按类别过滤结果，例如 [0, 2, 3]。默认: None。
    --agnostic-nms (bool): 执行类别无关的 NMS。默认: False。
    --augment (bool): 应用增强推理。默认: False。
    --visualize (bool): 可视化特征图。默认: False。
    --update (bool): 更新所有模型。默认: False。
    --project (str): 保存结果的目录；结果保存到 &quot;project/name&quot;。默认: ROOT / &quot;runs/detect&quot;。
    --name (str): 特定运行的名称；结果保存到 &quot;project/name&quot;。默认: &quot;exp&quot;。
    --exist-ok (bool): 允许结果保存到现有目录而不递增。默认: False。
    --line-thickness (int): 边界框线条的厚度 (像素)。默认: 3。
    --hide-labels (bool): 隐藏检测结果中的标签。默认: False。
    --hide-conf (bool): 隐藏标签中的置信度分数。默认: False。
    --half (bool): 使用 FP16 半精度推理。默认: False。
    --dnn (bool): 使用 OpenCV DNN 后端进行 ONNX 推理。默认: False。
    --vid-stride (int): 视频输入的帧率步长。默认: 1。

返回:
    argparse.Namespace: 解析的命令行参数，用于 YOLOv3 推理配置。

示例:
    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">options = parse_opt()</span><br><span class="line">run(**<span class="built_in">vars</span>(options))</span><br></pre></td></tr></table></figure>
&quot;&quot;&quot;
parser = argparse.ArgumentParser()
parser.add_argument(
    &quot;--weights&quot;, nargs=&quot;+&quot;, type=str, default=ROOT / &quot;yolov3-tiny.pt&quot;, help=&quot;模型路径或 triton URL&quot;
)
parser.add_argument(&quot;--source&quot;, type=str, default=ROOT / &quot;data/images&quot;, help=&quot;文件/目录/URL/通配符/截图/0(网络摄像头)&quot;)
parser.add_argument(&quot;--data&quot;, type=str, default=ROOT / &quot;data/coco128.yaml&quot;, help=&quot;(可选) 数据集.yaml 路径&quot;)
parser.add_argument(&quot;--imgsz&quot;, &quot;--img&quot;, &quot;--img-size&quot;, nargs=&quot;+&quot;, type=int, default=[640], help=&quot;推理尺寸 h,w&quot;)
parser.add_argument(&quot;--conf-thres&quot;, type=float, default=0.25, help=&quot;置信度阈值&quot;)
parser.add_argument(&quot;--iou-thres&quot;, type=float, default=0.45, help=&quot;NMS IoU 阈值&quot;)
parser.add_argument(&quot;--max-det&quot;, type=int, default=1000, help=&quot;每张图像的最大检测数&quot;)
parser.add_argument(&quot;--device&quot;, default=&quot;&quot;, help=&quot;cuda 设备，例如 0 或 0,1,2,3 或 cpu&quot;)
parser.add_argument(&quot;--view-img&quot;, action=&quot;store_true&quot;, help=&quot;显示结果&quot;)
parser.add_argument(&quot;--save-txt&quot;, action=&quot;store_true&quot;, help=&quot;将结果保存到 *.txt&quot;)
parser.add_argument(&quot;--save-conf&quot;, action=&quot;store_true&quot;, help=&quot;在 --save-txt 标签中保存置信度&quot;)
parser.add_argument(&quot;--save-crop&quot;, action=&quot;store_true&quot;, help=&quot;保存裁剪的预测框&quot;)
parser.add_argument(&quot;--nosave&quot;, action=&quot;store_true&quot;, help=&quot;不保存图像/视频&quot;)
parser.add_argument(&quot;--classes&quot;, nargs=&quot;+&quot;, type=int, help=&quot;按类别过滤：--classes 0 或 --classes 0 2 3&quot;)
parser.add_argument(&quot;--agnostic-nms&quot;, action=&quot;store_true&quot;, help=&quot;类别无关的 NMS&quot;)
parser.add_argument(&quot;--augment&quot;, action=&quot;store_true&quot;, help=&quot;增强推理&quot;)
parser.add_argument(&quot;--visualize&quot;, action=&quot;store_true&quot;, help=&quot;可视化特征&quot;)
parser.add_argument(&quot;--update&quot;, action=&quot;store_true&quot;, help=&quot;更新所有模型&quot;)
parser.add_argument(&quot;--project&quot;, default=ROOT / &quot;runs/detect&quot;, help=&quot;将结果保存到 project/name&quot;)
parser.add_argument(&quot;--name&quot;, default=&quot;exp&quot;, help=&quot;将结果保存到 project/name&quot;)
parser.add_argument(&quot;--exist-ok&quot;, action=&quot;store_true&quot;, help=&quot;允许现有 project/name 目录而不递增&quot;)
parser.add_argument(&quot;--line-thickness&quot;, default=3, type=int, help=&quot;边界框厚度 (像素)&quot;)
parser.add_argument(&quot;--hide-labels&quot;, default=False, action=&quot;store_true&quot;, help=&quot;隐藏标签&quot;)
parser.add_argument(&quot;--hide-conf&quot;, default=False, action=&quot;store_true&quot;, help=&quot;隐藏置信度&quot;)
parser.add_argument(&quot;--half&quot;, action=&quot;store_true&quot;, help=&quot;使用 FP16 半精度推理&quot;)
parser.add_argument(&quot;--dnn&quot;, action=&quot;store_true&quot;, help=&quot;使用 OpenCV DNN 进行 ONNX 推理&quot;)
parser.add_argument(&quot;--vid-stride&quot;, type=int, default=1, help=&quot;视频帧率步长&quot;)
opt = parser.parse_args()
opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # 扩展
print_args(vars(opt))
return opt
</code></pre><p>def main(opt):<br>    “””<br>    运行 YOLO 模型的入口点；检查需求并使用解析的选项调用 <code>run</code>。</p>
<pre><code>参数:
    opt (argparse.Namespace): 解析的命令行选项，包括：
        - weights (str | list of str): 模型权重路径或 Triton 服务器 URL。
        - source (str): 输入源，可以是文件、目录、URL、通配符、截图或网络摄像头索引。
        - data (str): 数据集配置文件路径 (.yaml)。
        - imgsz (tuple of int): 推理图像尺寸，格式为 (高度, 宽度)。
        - conf_thres (float): 检测的置信度阈值。
        - iou_thres (float): 非最大抑制 (NMS) 的交并比 (IoU) 阈值。
        - max_det (int): 每张图像的最大检测数。
        - device (str): 运行推理的设备；选项为 CUDA 设备 id(s) 或 &#39;cpu&#39;。
        - view_img (bool): 显示推理结果的标志。
        - save_txt (bool): 将检测结果保存为 .txt 格式。
        - save_conf (bool): 在 .txt 标签中保存检测置信度。
        - save_crop (bool): 保存裁剪的边界框预测。
        - nosave (bool): 不保存带有检测结果的图像/视频。
        - classes (list of int): 按类别过滤结果，例如 --class 0 2 3。
        - agnostic_nms (bool): 使用类别无关的 NMS。
        - augment (bool): 启用增强推理。
        - visualize (bool): 可视化特征图。
        - update (bool): 在推理过程中更新模型。
        - project (str): 保存结果的目录。
        - name (str): 结果目录的名称。
        - exist_ok (bool): 允许现有 project/name 目录而不递增。
        - line_thickness (int): 边界框线条的厚度。
        - hide_labels (bool): 在边界框上隐藏类别标签。
        - hide_conf (bool): 在边界框上隐藏置信度分数。
        - half (bool): 使用 FP16 半精度推理。
        - dnn (bool): 使用 OpenCV DNN 后端进行 ONNX 推理。
        - vid_stride (int): 视频帧率步长。

返回:
    None

示例:
    <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    opt = parse_opt()</span><br><span class="line">    main(opt)</span><br></pre></td></tr></table></figure>

注意:
    将此函数作为使用 YOLO 进行对象检测的入口点，支持多种输入源，如图像、视频、目录、网络摄像头、流媒体等。该函数确保检查所有需求，并通过调用 `run` 函数启动检测过程。
&quot;&quot;&quot;
check_requirements(ROOT / &quot;requirements.txt&quot;, exclude=(&quot;tensorboard&quot;, &quot;thop&quot;))
run(**vars(opt))
</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    opt = parse_opt()<br>    main(opt)<br>```</p>
]]></content>
      <categories>
        <category>RoboMaster</category>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>YOLO 目标识别</tag>
      </tags>
  </entry>
  <entry>
    <title>堆栈</title>
    <url>/2024/09/20/%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<h2 id="C-堆栈笔记"><a href="#C-堆栈笔记" class="headerlink" title="C++ 堆栈笔记"></a>C++ 堆栈笔记</h2><h3 id="1-什么是堆栈？"><a href="#1-什么是堆栈？" class="headerlink" title="1. 什么是堆栈？"></a>1. 什么是堆栈？</h3><p>堆栈（Stack）是一种基础的数据结构，遵循<strong>后进先出</strong>（LIFO, Last In First Out）原则，意味着最后插入堆栈的元素最先被弹出。堆栈的使用场景非常广泛，如处理递归、括号匹配、表达式求值、回溯算法等。它通常用于管理程序的运行状态。</p>
<h3 id="2-堆栈的特点与应用场景"><a href="#2-堆栈的特点与应用场景" class="headerlink" title="2. 堆栈的特点与应用场景"></a>2. 堆栈的特点与应用场景</h3><h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><ul>
<li><strong>线性数据结构</strong>：堆栈通过一个线性方式组织元素，只有栈顶（顶部）元素可以被访问。</li>
<li><strong>操作受限</strong>：仅允许在栈的顶部进行插入（push）和删除（pop）操作，无法直接访问或修改栈中的其他元素。</li>
<li><strong>动态增长</strong>：堆栈可以动态调整大小，尤其是在使用标准库的实现时（如 C++ 中的 <code>std::stack</code>）。</li>
</ul>
<h4 id="2-2-典型应用场景"><a href="#2-2-典型应用场景" class="headerlink" title="2.2 典型应用场景"></a>2.2 典型应用场景</h4><ul>
<li><strong>递归调用管理</strong>：函数递归时，每次函数调用都会在堆栈中保存局部变量和返回地址，直到递归结束，再从堆栈中逐步恢复状态。</li>
<li><strong>表达式求值</strong>：在表达式求值过程中，特别是中缀转后缀表达式和逆波兰表达式的计算，堆栈是核心工具。</li>
<li><strong>括号匹配</strong>：用于检查表达式中括号是否配对，堆栈可以方便地追踪最近遇到的左括号，并在遇到右括号时进行匹配。</li>
<li><strong>浏览器前进/后退操作</strong>：用户在浏览网页时，前进和后退操作是典型的堆栈应用。前进操作和后退操作分别模拟两种不同的堆栈。</li>
</ul>
<h3 id="3-堆栈的操作"><a href="#3-堆栈的操作" class="headerlink" title="3. 堆栈的操作"></a>3. 堆栈的操作</h3><h4 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h4><p>堆栈的主要操作包括：</p>
<ul>
<li><strong>push</strong>：将元素插入堆栈的顶部。</li>
<li><strong>pop</strong>：移除堆栈顶部的元素。</li>
<li><strong>top（peek）</strong>：返回栈顶元素但不移除它。</li>
<li><strong>isEmpty</strong>：检查堆栈是否为空。</li>
<li><strong>size</strong>：返回堆栈中元素的数量。</li>
</ul>
<h4 id="3-2-C-标准库实现"><a href="#3-2-C-标准库实现" class="headerlink" title="3.2 C++ 标准库实现"></a>3.2 C++ 标准库实现</h4><p>C++ 提供了标准的 <code>std::stack</code> 容器来实现堆栈。以下是一个简单的例子，演示如何使用 C++ 实现堆栈的基本操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈操作</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element after pop: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断堆栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is not empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出堆栈大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-C-手动实现堆栈"><a href="#4-C-手动实现堆栈" class="headerlink" title="4. C++ 手动实现堆栈"></a>4. C++ 手动实现堆栈</h3><p>除了使用标准库的堆栈，我们也可以通过数组或者链表手动实现堆栈。以下是基于数组的实现：</p>
<h4 id="4-1-使用数组实现堆栈"><a href="#4-1-使用数组实现堆栈" class="headerlink" title="4.1 使用数组实现堆栈"></a>4.1 使用数组实现堆栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> arr[MAX]; <span class="comment">// 堆栈数组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Stack</span>() &#123; top = <span class="number">-1</span>; &#125; <span class="comment">// 初始化栈顶</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt;= MAX - <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack Overflow&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[++top] = x;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; pushed into stack&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack Underflow&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> x = arr[top--];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// peek 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is Empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (top &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; s.<span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot; Popped from stack&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element is &quot;</span> &lt;&lt; s.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack empty: &quot;</span> &lt;&lt; s.<span class="built_in">isEmpty</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-链表实现堆栈"><a href="#4-2-链表实现堆栈" class="headerlink" title="4.2 链表实现堆栈"></a>4.2 链表实现堆栈</h4><p>链表实现堆栈可以避免数组的固定大小限制，它具有动态扩展的能力。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    StackNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">StackNode* <span class="title">newNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    StackNode* stackNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>();</span><br><span class="line">    stackNode-&gt;data = data;</span><br><span class="line">    stackNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> stackNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(StackNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(StackNode** root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    StackNode* stackNode = <span class="built_in">newNode</span>(data);</span><br><span class="line">    stackNode-&gt;next = *root;</span><br><span class="line">    *root = stackNode;</span><br><span class="line">    std::cout &lt;&lt; data &lt;&lt; <span class="string">&quot; pushed to stack\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(StackNode** root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(*root))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    StackNode* temp = *root;</span><br><span class="line">    *root = (*root)-&gt;next;</span><br><span class="line">    <span class="type">int</span> popped = temp-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> popped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(StackNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(root))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StackNode* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pop</span>(&amp;root) &lt;&lt; <span class="string">&quot; popped from stack\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element is &quot;</span> &lt;&lt; <span class="built_in">peek</span>(root) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-常见堆栈应用"><a href="#5-常见堆栈应用" class="headerlink" title="5. 常见堆栈应用"></a>5. 常见堆栈应用</h3><h4 id="5-1-括号匹配问题"><a href="#5-1-括号匹配问题" class="headerlink" title="5.1 括号匹配问题"></a>5.1 括号匹配问题</h4><p>堆栈可以用于括号匹配的检测，以下是一个简单的实现，用于检查括号是否匹配：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">areBracketsBalanced</span><span class="params">(<span class="type">const</span> std::string&amp; expr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : expr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> top = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> ((ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                (ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string expr = <span class="string">&quot;&#123;[()]&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">areBracketsBalanced</span>(expr))</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Balanced\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not Balanced\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-表达式求值"><a href="#5-2-表达式求值" class="headerlink" title="5.2 表达式求值"></a>5.2 表达式求值</h4><p>堆栈在后缀表达式（逆波兰表达式）计算中非常有用。以下是基于堆栈的后缀表达式求值实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evaluatePostfix</span><span class="params">(<span class="type">const</span> std::string&amp; expr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : expr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> val1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> val2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: s.<span class="built_in">push</span>(val2 + val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: s.<span class="built_in">push</span>(val2 - val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: s.<span class="built_in">push</span>(val2 * val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: s.<span class="built_in">push</span>(val2 / val1); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string expr = <span class="string">&quot;231*+9-&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">evaluatePostfix</span>(expr) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-堆栈的时间与空间复杂度"><a href="#6-堆栈的时间与空间复杂度" class="headerlink" title="6. 堆栈的时间与空间复杂度"></a>6. 堆栈的时间与空间复杂度</h3><ul>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><code>push</code> 操作：O(1)</li>
<li><code>pop</code> 操作：O(1)</li>
<li><code>peek</code> 操作：O(1)</li>
</ul>
</li>
<li><p><strong>空间复杂度</strong>：O(n)，其中 n 是堆栈中的元素个数。对于链表实现，额外的空间复杂度还包括链表节点的指针存储。</p>
</li>
</ul>
<h3 id="7-堆栈的局限性"><a href="#7-堆栈的局限性" class="headerlink" title="7. 堆栈的局限性"></a>7. 堆栈的局限性</h3><p>虽然堆栈是一种非常高效的结构，但它的局限性包括：</p>
<ul>
<li><strong>只能访问栈顶元素</strong>：堆栈限制了只能访问最顶部的元素，无法直接随机访问任何位置的元素。</li>
<li><strong>溢出风险</strong>：对于基于数组的实现，如果栈超过预设大小，会产生溢出问题。</li>
<li><strong>应用受限</strong>：对于需要随机访问或双向遍历的应用场景，堆栈并不适用。</li>
</ul>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>堆栈是一种重要的数据结构，广泛应用于程序运行管理和算法设计中。C++ 提供了 <code>std::stack</code> 方便我们使用堆栈，同时我们也可以基于数组或链表手动实现堆栈，来适应不同的应用场景。理解和掌握堆栈的实现和应用，有助于编写高效的算法和程序。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>欧几里得算法</title>
    <url>/2023/10/25/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最近发现了这样一种求最大公约数的算法，因此写此篇博客记录一下</p>
<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>欧几里德算法，也称为辗转相除法，是一种用于计算两个整数的最大公约数（GCD，Greatest Common Divisor）的经典算法。这个算法的名字来源于古希腊数学家欧几里德（Euclid），他在公元前300年左右的《几何原本》一书中首次描述了这一算法。<br><span id="more"></span></p>
<p>欧几里德算法的核心思想是通过不断取两个整数的余数，将问题规模不断减小，直到找到它们的公约数。算法的步骤如下：</p>
<ol>
<li><p>假设有两个整数 a 和 b，其中 a &gt; b。</p>
</li>
<li><p>计算 a 除以 b 的余数，记为 r（r = a % b）。</p>
</li>
<li><p>如果 r 等于 0，则 b 即为最大公约数，算法结束。否则，将 a 的值更新为 b，将 b 的值更新为 r，然后回到步骤 2。</p>
</li>
<li><p>重复步骤 2 和 3 直到余数 r 等于 0。此时，b 的值即为最大公约数。</p>
</li>
</ol>
<p>欧几里德算法的关键观察是，两个整数的最大公约数等于其中较小的整数和这两个整数相除的余数的最大公约数。这个观察使得算法能够快速而有效地找到最大公约数，而且不需要枚举所有可能的因子。</p>
<p>欧几里德算法在计算机科学和数学领域中具有广泛的应用，包括：</p>
<ul>
<li>求解整数的最大公约数。</li>
<li>判断两个整数是否互质（最大公约数为1）。</li>
<li>求解不定方程的整数解，如贝祖等式。</li>
<li>在密码学中用于生成加密密钥。</li>
</ul>
<p>欧几里德算法是一种高效的算法，其时间复杂度是 O(log(min(a, b)))，其中 a 和 b 是输入的两个整数。这使得它成为解决大整数问题的首选方法。</p>
<p>代码实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> (b,a%b);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构的深度思考和总结</title>
    <url>/2024/10/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1-数据结构的本质"><a href="#1-数据结构的本质" class="headerlink" title="1.数据结构的本质"></a>1.数据结构的本质</h4><p>数据结构的本质其实就是<strong>链表和数组</strong>，其他复杂的数据结构不过是这些基本结构的高级抽象。无论是树、栈、队列，还是更高级的图结构，归根结底都是基于数组或链表构建的。它们通过底层的实现细节和不同的逻辑组织方式，提供了更易用的API接口。</p>
<span id="more"></span>
<p><img src="DataStructure.png" alt="DataStructure"></p>
<p>比如，<strong>树</strong>这种数据结构，既可以用数组来实现，也可以用链表构建。数组的优势在于可以通过索引快速访问，节省空间，而链表的优势则在于高效的插入和删除操作。但链表由于使用指针，会占用更多的空间。</p>
<p>我们可以从<strong>Redis</strong>的实现上看到这一点，它内部有字符串、集合等数据结构，每一种数据类型都有不同的实现方式。其实，我们自己也可以根据具体的业务场景，设计并实现出个性化的数据结构，并定义一些适合当前业务需求的API接口。</p>
<p>语言层面也为我们提供了丰富的数据结构工具。比如在<strong>Python</strong>中，除了常用的字典和列表外，还可以通过<code>collections</code>模块找到一些更灵活和高效的数据类型，如<code>defaultdict</code>、双端队列<code>deque</code>、计数器<code>Counter</code>等。<strong>Java</strong>的<code>java.util</code>包中也包含了大量用于扩展基础数据结构的工具类。</p>
<p>综上所述，数据结构的底层其实就是<strong>数组和链表</strong>。无论是集合还是字典，都是通过哈希函数来将元素映射到具体的存储位置上。</p>
<h4 id="那么，算法的本质是什么？"><a href="#那么，算法的本质是什么？" class="headerlink" title="那么，算法的本质是什么？"></a>那么，算法的本质是什么？</h4><p>算法的本质其实就是<strong>穷举</strong>。但穷举并不是那么简单的，它需要做到两点：<strong>不漏</strong>和<strong>聪明的穷举</strong>。</p>
<p>计算机与人类解决问题的思维方式完全不同。人类可能通过一个公式就能解决问题，而计算机则依赖<strong>计算能力</strong>不断进行尝试，直到得到结果。计算机最大的优点就是速度快、不怕累。因此，算法就是用<strong>计算机语言</strong>把人的问题转化为机器能够执行的程序，通过不断的尝试来解决。</p>
<h5 id="1-不漏"><a href="#1-不漏" class="headerlink" title="1. 不漏"></a>1. <strong>不漏</strong></h5><p>“不漏”指的是算法给出的解答必须是完整的。比如很多组合问题常用<strong>回溯算法</strong>来解决，算法需要确保所有可能的解都被考虑到，没有遗漏。</p>
<h5 id="2-聪明的穷举"><a href="#2-聪明的穷举" class="headerlink" title="2. 聪明的穷举"></a>2. <strong>聪明的穷举</strong></h5><p>“聪明的穷举”就是通过优化策略来提高效率。最简单的算法可能是暴力破解，但它通常效率低下。为了提高效率，我们需要进行优化，而所有的优化手段，归根结底都是为了<strong>更聪明地穷举</strong>。</p>
<p>举个例子，<strong>双指针</strong>和<strong>滑动窗口</strong>技巧就是为了在穷举过程中减少不必要的时间消耗。相比于传统的双重循环，它们能显著提高时间效率。同样的，有时可以选择更合适的数据结构来减少穷举，比如使用双链表代替单链表，可以节省一定的操作步骤。</p>
<p>在算法设计中，还有一些优化技巧，比如<strong>剪枝</strong>，即在遍历树时提早终止不必要的分支；又比如<strong>记忆化搜索</strong>，通过缓存中间结果来避免重复计算。</p>
<h2 id="综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同"><a href="#综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同" class="headerlink" title="综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同"></a><strong>综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同</strong></h2><h4 id="2-线性数据结构"><a href="#2-线性数据结构" class="headerlink" title="2. 线性数据结构"></a>2. <strong>线性数据结构</strong></h4><h5 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a><strong>数组 (Array)</strong></h5><ul>
<li><strong>定义与特性</strong><br>数组是内存中连续分配的元素集合，支持常数时间的随机访问。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 定义一个包含5个整数的数组</span></span><br><span class="line"><span class="type">int</span> element = arr[<span class="number">2</span>];  <span class="comment">// 访问索引为2的元素</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">10</span>;  <span class="comment">// 修改索引为1的元素</span></span><br></pre></td></tr></table></figure></li>
<li><strong>优缺点分析</strong>  <ul>
<li>优点：支持常数时间的随机访问，适合查找场景。</li>
<li>缺点：插入和删除操作需要移动大量元素，效率较低。</li>
</ul>
</li>
<li><strong>典型应用场景与变体</strong>  <ul>
<li><strong>动态数组</strong>：大小可动态变化的数组，如C++中的<code>std::vector</code>。  </li>
<li><strong>稀疏矩阵</strong>：存储少量非零元素的矩阵，节省内存。</li>
</ul>
</li>
</ul>
<h5 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 (Linked List)"></a><strong>链表 (Linked List)</strong></h5><ul>
<li><strong>定义与特性</strong><br>链表是由一系列节点组成的，每个节点包含数据和指向下一个节点的指针。支持高效的插入和删除操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* head = <span class="literal">nullptr</span>;  <span class="comment">// 创建一个空链表</span></span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node&#123;<span class="number">10</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 创建一个新节点</span></span><br><span class="line">head = newNode;  <span class="comment">// 将新节点作为链表头部</span></span><br></pre></td></tr></table></figure></li>
<li><strong>单链表与双链表</strong>  <ul>
<li><strong>单链表</strong>：每个节点仅指向下一个节点。</li>
<li><strong>双链表</strong>：每个节点同时指向前一个和后一个节点，便于双向遍历。</li>
</ul>
</li>
<li><strong>优缺点分析</strong>  <ul>
<li>优点：插入和删除操作的时间复杂度为O(1)。</li>
<li>缺点：不能随机访问，查找某个元素需要遍历链表。</li>
</ul>
</li>
<li><strong>典型应用</strong>  <ul>
<li><strong>LRU缓存</strong>：使用双向链表和哈希表实现最近最少使用（Least Recently Used）缓存策略。</li>
<li><strong>队列</strong>：使用链表实现的队列，支持高效的入队和出队操作。</li>
</ul>
</li>
</ul>
<h5 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a><strong>栈与队列</strong></h5><ul>
<li><p><strong>栈 (Stack)</strong></p>
<ul>
<li><strong>定义与特性</strong><br>栈是一种后进先出（LIFO, Last In First Out）数据结构，只有栈顶元素可以被访问。常用于递归问题的处理。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> stack[MAX];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stack[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack[top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>实际应用</strong>  <ul>
<li><strong>递归求解</strong>：如深度优先搜索（DFS）中使用栈模拟递归。</li>
<li><strong>表达式求值</strong>：后缀表达式求值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>队列 (Queue)</strong></p>
<ul>
<li><strong>定义与特性</strong><br>队列是一种先进先出（FIFO, First In First Out）数据结构，常用于任务调度、广度优先搜索（BFS）等场景。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> queue[MAX];</span><br><span class="line"><span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    queue[rear++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue[front++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>实际应用</strong>  <ul>
<li><strong>任务调度</strong>：常用于处理操作系统中的任务调度、打印队列等。</li>
<li><strong>广度优先搜索 (BFS)</strong>：通过队列实现层序遍历。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-树结构"><a href="#3-树结构" class="headerlink" title="3. 树结构"></a>3. <strong>树结构</strong></h4><h5 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 (Binary Tree)"></a><strong>二叉树 (Binary Tree)</strong></h5><ul>
<li><strong>定义与特性</strong><br>二叉树是每个节点最多有两个子节点的树结构，子节点分别称为左子节点和右子节点。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode&#123;<span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 创建根节点</span></span><br><span class="line">root-&gt;left = <span class="keyword">new</span> TreeNode&#123;<span class="number">2</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 添加左子节点</span></span><br><span class="line">root-&gt;right = <span class="keyword">new</span> TreeNode&#123;<span class="number">3</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 添加右子节点</span></span><br></pre></td></tr></table></figure></li>
<li><strong>遍历方式</strong><ul>
<li><strong>前序遍历</strong>：根节点 -&gt; 左子树 -&gt; 右子树</li>
<li><strong>中序遍历</strong>：左子树 -&gt; 根节点 -&gt; 右子树</li>
<li><strong>后序遍历</strong>：左子树 -&gt; 右子树 -&gt; 根节点</li>
<li><strong>层序遍历</strong>：按层访问，常用队列实现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="二叉搜索树-Binary-Search-Tree-BST"><a href="#二叉搜索树-Binary-Search-Tree-BST" class="headerlink" title="二叉搜索树 (Binary Search Tree, BST)"></a><strong>二叉搜索树 (Binary Search Tree, BST)</strong></h5><ul>
<li><strong>定义与特性</strong><br>二叉搜索树是一种有序二叉树，对于每个节点，其左子树的所有节点值小于该节点值，右子树的所有节点值大于该节点值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&#123;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>操作</strong>  <ul>
<li><strong>插入</strong>：新元素按照顺序插入到合适位置。</li>
<li><strong>查找</strong>：从根节点开始，根据大小关系查找节点。</li>
<li><strong>删除</strong>：删除节点时需要考虑其子节点的调整。</li>
</ul>
</li>
<li><strong>平衡性问题与优化</strong>  <ul>
<li><strong>AVL树</strong>：通过旋转保持树的平衡，确保插入、删除、查找操作时间复杂度为O(log n)。</li>
<li><strong>红黑树</strong>：类似AVL树，但平衡条件稍弱，插入和删除更高效。</li>
</ul>
</li>
</ul>
<h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 (Heap)"></a><strong>堆 (Heap)</strong></h5><ul>
<li><strong>定义与特性</strong><br>堆是一棵完全二叉树，分为最大堆和最小堆。最大堆中每个节点的值都大于或等于其子节点，最小堆则相反。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2024/09/20/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="学习笔记：顺序表（SQList）的理解与实现"><a href="#学习笔记：顺序表（SQList）的理解与实现" class="headerlink" title="学习笔记：顺序表（SQList）的理解与实现"></a>学习笔记：顺序表（SQList）的理解与实现</h1><h2 id="1-什么是顺序表（SQList）-s"><a href="#1-什么是顺序表（SQList）-s" class="headerlink" title="1. 什么是顺序表（SQList） ß"></a>1. 什么是顺序表（SQList） ß</h2><p>顺序表是一种常见的线性数据结构，其特点是通过一组连续的内存空间来存储数据元素。在顺序表中，每个元素都有一个直接的前驱和后继（除了第一个元素没有前驱，最后一个元素没有后继）。顺序表的操作主要包括插入、删除、查找等。</p>
<h2 id="2-顺序表的特点"><a href="#2-顺序表的特点" class="headerlink" title="2. 顺序表的特点"></a>2. 顺序表的特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>访问速度快</strong>：由于元素在内存中是连续存储的，因此可以通过索引直接访问，时间复杂度为 O(1)。</li>
<li><strong>易于实现</strong>：使用数组或容器如 <code>std::vector</code> 可以轻松实现顺序表。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><strong>插入和删除效率低</strong>：当在表中间插入或删除元素时，需要移动后续的所有元素，最坏情况下的时间复杂度为 O(n)。</li>
<li><strong>空间预分配</strong>：需要提前知道表的最大容量，否则可能会导致内存不足。</li>
</ul>
<h2 id="3-顺序表的实现"><a href="#3-顺序表的实现" class="headerlink" title="3. 顺序表的实现"></a>3. 顺序表的实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 当前顺序表的实际大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQList</span>() : <span class="built_in">size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向顺序表中添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> elem)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(elem);</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据索引获取元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Index out of bounds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定索引处的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Index out of bounds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elements.<span class="built_in">erase</span>(elements.<span class="built_in">begin</span>() + index);</span><br><span class="line">        --size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印顺序表的内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顺序表的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SQList list;</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line">    list.<span class="built_in">print</span>(); <span class="comment">// 输出: 1 2 3</span></span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">remove</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">print</span>(); <span class="comment">// 输出: 1 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4. 时间复杂度分析"></a>4. 时间复杂度分析</h2><ul>
<li><strong>访问</strong>: O(1)，直接通过索引访问。</li>
<li><strong>插入</strong>: 最坏情况下为 O(n)，当插入位置位于表的开头或中间时。</li>
<li><strong>删除</strong>: 最坏情况下为 O(n)，当删除位置位于表的开头或中间时。</li>
<li><strong>查找</strong>: O(n)，需要遍历整个表。</li>
</ul>
<h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><p>顺序表适合用于需要频繁访问但插入和删除较少的情况，例如缓存数据、静态数据集合等。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>文件基本操作</title>
    <url>/2023/12/10/%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><p>（临时抱佛脚，捞捞）</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file; <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="type">char</span> filename[] = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件以进行读写操作（如果文件不存在，则创建新文件）</span></span><br><span class="line">    file = fopen(filename, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;这是一个文件操作示例。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;欢迎使用 C 语言进行文件操作！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件指针移到文件开头</span></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取内容并输出到屏幕上</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派配合公网服务器frp转发实现内网穿透</title>
    <url>/2025/02/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E5%90%88%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8frp%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>相信不少的同学都遇到过一个很麻烦的事情——实验室用的服务器只有连上实验室的内网后才能使用，一旦外出开impart或者回家后，就不能进入实验室的服务器继续玩耍（卷）了。这个时候怎么办呢？<br>如果你没有一个公网服务器又不想花钱，cpolar是你的最佳选择，但是如果你有事情就变得完全不一样了——<strong>frp的优雅永不过时</strong>。</p>
<ul>
<li><a href="https://gofrp.org/">FRP 项目官网</a></li>
<li><a href="https://github.com/fatedier/frp">GitHub 仓库</a></li>
<li><a href="https://gofrp.org/docs/">项目文档</a></li>
</ul>
<h3 id="frp是什么？"><a href="#frp是什么？" class="headerlink" title="frp是什么？"></a>frp是什么？</h3><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p>
<h3 id="为什么使用-frp-？"><a href="#为什么使用-frp-？" class="headerlink" title="为什么使用 frp ？"></a>为什么使用 frp ？</h3><p>通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p>
<ul>
<li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li>
<li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li>
<li>代理组间的负载均衡。</li>
<li>端口复用，多个服务通过同一个服务端端口暴露。</li>
<li>多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。</li>
<li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li>
<li>服务端和客户端 UI 页面。<h2 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h2>为了达到这个目的，在硬件上，我们的读者需要准备如下三件东西：</li>
</ul>
<p>一台公网服务器，它的 IP 可以在任何能上网的机器上被 ping 到。<br>一台实验室服务器，它只能在实验室内网被访问。<br>一台你自己的电脑，它能 ping 到公网服务器，但是当你带着它出去玩时，它无法 ping 到实验室服务器。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们记我们的公网服务器为 <code>pub</code> (public server)，实验室服务器为 <code>loc</code> (local server)。我们在 pub 和 loc 上同时下载对应操作系统和芯片指令集的<a href="https://github.com/fatedier/frp/releases">编译版本</a>：</p>
<p>不过考虑到大部分的服务器都是 x86 芯片的 linux，所以可以直接下载解压如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget -c https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.55.1/</span>frp_0.<span class="number">55.1</span>_linux_amd64.tar.gz</span><br><span class="line">tar -xvf frp_0.<span class="number">55.1</span>_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>进入 frp_0.55.1_linux_amd64 后，我们会看到如下几个文件：</p>
<ul>
<li>frpc： frp 客户端执行程序</li>
<li>frpc.toml：frp 客户端配置文件</li>
<li>frps：frp 服务端执行程序</li>
<li>frps.toml：frp 服务端配置文件</li>
<li>LICENSE：frp 软件开源协议，不用管<br><img src="image.png" alt="从锦恢大佬那里偷的图"></li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为了让我们可以在外部能够访问 <code>loc</code>，我们先来实现 SSH 协议的内网穿透。<br>首先在 <code>pub</code> 上，进入解压后的 <code>frp</code> 文件夹。修改 <code>frps.toml</code> 如下：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bindPort</span> <span class="operator">=</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure><br>bindPort 用于和 frpc 进行绑定。<br>在后台执行如下指令：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/frps -c ./</span>frps.toml</span><br></pre></td></tr></table></figure><br>输出如下日志，代表 frps 启动成功：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">58.972</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[frps/root.go:105]</span> frps uses config file: ./frps<span class="selector-class">.toml</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:225]</span> frps tcp listen on <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:292]</span> http service listen on <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[frps/root.go:114]</span> frps started successfully</span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.775</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:563]</span> <span class="selector-attr">[11abba605bc7fe77]</span> client login info: ip <span class="selector-attr">[58.211.218.74:64089]</span> version <span class="selector-attr">[0.55.1]</span> hostname <span class="selector-attr">[]</span> os <span class="selector-attr">[linux]</span> arch <span class="selector-attr">[amd64]</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.806</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[proxy/tcp.go:82]</span> <span class="selector-attr">[11abba605bc7fe77]</span> <span class="selector-attr">[ssh]</span> tcp proxy listen port <span class="selector-attr">[7001]</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.806</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/control.go:401]</span> <span class="selector-attr">[11abba605bc7fe77]</span> new proxy <span class="selector-attr">[ssh]</span> type <span class="selector-attr">[tcp]</span> success</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>下载适用于树莓派的arm64架构的frp文件包：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.35.1/</span>frp_0.<span class="number">35.1</span>_linux_arm64.tar.gz</span><br><span class="line">sudo tar -zxvf frp_0.<span class="number">35.1</span>_linux_arm64.tar.gz</span><br><span class="line"><span class="comment"># 文件名可能会有不同，用ls -a命令查看</span></span><br></pre></td></tr></table></figure><br>编辑其中的frpc.ini文件：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><br>按如下参数说明修改配置文件：</p>
<ul>
<li><p>server_addr：服务器的IP地址；</p>
</li>
<li><p>server_port：服务器端的端口，与服务端配置文件的bind_port端口相同；</p>
</li>
<li><p>local_ip：要在公网访问的本地设备的地址，这里指客户端本机，填127.0.0.1即可；</p>
</li>
<li><p>local_port：本地设备要暴露的端口，即理解为提供服务的端口</p>
</li>
<li><p>remote_port：在外网的访问端口，此端口上的流量会被转发到本地设备对应的local_port端口上</p>
</li>
</ul>
<p><strong>还有别忘了在服务器防火墙上放行remote_port端口</strong></p>
<p>配置文件中默认有一个ssh的访问配置，如果我们还想让其他的端口在外网访问到，那就可以照猫画虎来添加一个配置。比如在外网用公网ip的8888端口访问本地设备的80端口，就可以这样写：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[http]</span>                  <span class="comment"># 名字自定，写在方括号里面</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span></span><br></pre></td></tr></table></figure><br>然后启动服务<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/frps -c ./</span>frps.ini</span><br></pre></td></tr></table></figure><br>大功告成。</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>以上配置完成，就可以在外网访问本地的服务了，访问方式是：服务器的IP地址/域名:端口。此处端口为客户端配置文件中的remote_port端口。<br>（如果想挂在后台或者开机自启动可以写个小脚本或者挂在终端工具上（如sceen），这里就不细说了。）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://kirigaya.cn/blog/article?seq=192">https://kirigaya.cn/blog/article?seq=192</a></li>
<li><a href="https://www.wlplove.com/archives/33/#1.%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2frp">https://www.wlplove.com/archives/33/#1.%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2frp</a></li>
</ul>
]]></content>
      <categories>
        <category>树莓派项目</category>
      </categories>
      <tags>
        <tag>frp转发</tag>
        <tag>树莓派</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络初识</title>
    <url>/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/qq_22583741/article/details/129444508?ops_request_misc=%7B%22request%5Fid%22%3A%22170486960516800197010429%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170486960516800197010429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129444508-null-null.142^v99^pc_search_result_base6&amp;utm_term=python神经网络&amp;spm=1018.2226.3001.4187">新手入门python实现神经网络，超级简单!_py 神经网络-CSDN博客</a></p>
<p><a href="https://hitwhlc.yuque.com/attachments/yuque/0/2024/pdf/39221021/1704869715414-7f00ccda-2452-42d9-a816-4a09a794e0ad.pdf">📎Python神经网络编程.pdf</a></p>
<p><a href="https://blog.csdn.net/weixin_40221426/article/details/132255702?ops_request_misc=%7B%22request%5Fid%22%3A%22170486960516800197010429%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170486960516800197010429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-132255702-null-null.142^v99^pc_search_result_base6&amp;utm_term=python神经网络&amp;spm=1018.2226.3001.4187">Python学习篇30-神经网络_python神经网络-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691?ops_request_misc=%7B%22request%5Fid%22%3A%22170487093716800192217002%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170487093716800192217002&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90221691-null-null.142^v99^pc_search_result_base6&amp;utm_term=反向传播算法&amp;spm=1018.2226.3001.4187">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/baidu_41774120/article/details/125764136?ops_request_misc=%7B%22request%5Fid%22%3A%22170487093716800192217002%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170487093716800192217002&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125764136-null-null.142^v99^pc_search_result_base6&amp;utm_term=反向传播算法&amp;spm=1018.2226.3001.4187">反向传播算法推导过程（看一篇就够了）_神经网络反向传播算法推导-CSDN博客</a></p>
<span id="more"></span>
<h2 id="1-发展历史"><a href="#1-发展历史" class="headerlink" title="1.发展历史"></a>1.发展历史</h2><p>神经网络的发展历史可以追溯到20世纪中叶。</p>
<ol>
<li><strong>McCulloch和Pitts的神经元模型（1943）：</strong></li>
</ol>
<p>​        Warren McCulloch和Walter Pitts提出了神经元模型，将神经元抽象为二进制开关，形成了后来神经网络的基础。</p>
<ol>
<li><strong>感知器的提出（1957）：</strong></li>
</ol>
<p>​        Frank Rosenblatt提出了感知器，这是一种基于神经元模型的学习算法。感知器可以实现简单的二分类任务。</p>
<ol>
<li><strong>早期神经网络的研究（1960s-1970s）：</strong></li>
</ol>
<p>在这一时期，神经网络受到了关注，但受到了硬件和理论上的限制。神经网络的训练和应用遇到了困难。</p>
<ol>
<li><strong>反向传播算法的提出（1986）：</strong></li>
</ol>
<ul>
<li>David Rumelhart、Geoffrey Hinton和Ronald Williams提出了反向传播算法，为多层神经网络的训练提供了有效的方法。这一突破重新激发了对神经网络的研究兴趣。</li>
</ul>
<ol>
<li><strong>计算能力的提升（1990s）：</strong></li>
</ol>
<p>随着计算能力的提高，研究者们开始更深入地研究神经网络的理论和应用。但由于数据集和计算资源的限制，发展相对较慢。</p>
<ol>
<li><strong>深度学习的崛起（2000年后）：</strong></li>
</ol>
<ul>
<li>随着大规模数据集和强大的计算能力的可用性，深度学习（深度神经网络）再次引起了广泛关注。</li>
</ul>
<ul>
<li>图像分类、语音识别、自然语言处理等领域的成功应用推动了神经网络的发展。</li>
</ul>
<ol>
<li><strong>卷积神经网络（CNN）和循环神经网络（RNN）的出现：</strong><ul>
<li>2012年，AlexNet的成功标志着卷积神经网络（CNN）的兴起，对图像处理任务取得了巨大成功。</li>
<li>循环神经网络（RNN）在处理序列数据（如自然语言）方面表现出色，为更多领域的应用提供了解决方案。</li>
</ul>
</li>
</ol>
<ol>
<li><strong>深度学习在各领域的广泛应用：</strong></li>
</ol>
<ul>
<li>深度学习技术在计算机视觉、自然语言处理、语音识别、医学影像等领域取得了显著的进展，推动了人工智能的发展。</li>
</ul>
<h2 id="2-主体流程"><a href="#2-主体流程" class="headerlink" title="2.主体流程"></a>2.主体流程</h2><p><img src="1.png" alt="1"></p>
<p><strong>输入层（Input Layer）：</strong></p>
<ul>
<li>神经网络的第一层，负责接收输入数据。每个输入节点对应输入数据的一个特征。</li>
</ul>
<p><strong>权重和偏差（Weights and Biases）：</strong></p>
<ul>
<li>每个连接（神经元之间的连接）都有一个权重，用于调整输入的影响力。每个神经元还有一个偏差，用于调整整体激活的阈值。</li>
</ul>
<p><strong>线性组合（Linear Combination）：</strong></p>
<ul>
<li>输入层的每个神经元将其输入与相应的权重相乘，然后将所有乘积相加，再加上偏差。这形成了线性组合。</li>
</ul>
<p><strong>激活函数（Activation Function）：</strong></p>
<ul>
<li>线性组合的结果通常通过激活函数，如Sigmoid、ReLU等，以引入非线性特性。这使得神经网络能够学习非线性关系。这个函数有点像高中学过的神经元阈值（神经网络似乎就是模拟人脑结构），当输入信号或信号组合以某种方式达到一定阈值，才会激活这个节点。</li>
</ul>
<p><strong>隐藏层（Hidden Layers）：</strong></p>
<ul>
<li>在输入层和输出层之间的层称为隐藏层。神经网络的深度取决于隐藏层的数量。每个隐藏层的神经元接收前一层的输出，并重复之前的步骤。</li>
</ul>
<p><strong>输出层（Output Layer）：</strong></p>
<ul>
<li>最后一个隐藏层的输出作为神经网络的最终输出。输出的数量通常取决于任务类型，如二分类问题有一个输出节点，多分类问题有多个输出节点。</li>
</ul>
<p><strong>损失函数（Loss Function）：</strong></p>
<ul>
<li>损失函数度量神经网络输出与真实标签之间的差异。训练过程的目标是最小化损失函数。</li>
</ul>
<p><strong>优化算法（Optimization Algorithm）：</strong></p>
<ul>
<li>优化算法，如梯度下降，用于调整权重和偏差，以降低损失函数。通过计算损失函数关于权重和偏差的梯度，优化算法更新参数。</li>
</ul>
<p><strong>反向传播（Backpropagation）：</strong></p>
<ul>
<li>反向传播算法是训练神经网络的关键步骤。通过计算梯度，反向传播从输出层到输入层反向传播误差，并更新权重和偏差。</li>
</ul>
<p><strong>训练和预测（Training and Prediction）：</strong></p>
<ul>
<li>神经网络通过多次迭代训练数据来学习权重和偏差。在训练后，神经网络可以用于对新数据的预测。</li>
</ul>
<p><strong>正则化和调参（Regularization and Hyperparameter Tuning）：</strong></p>
<ul>
<li>为了提高泛化能力，可以使用正则化技术，并调整超参数（如学习率、隐藏层节点数）。</li>
</ul>
<h2 id="3-矩阵的应用"><a href="#3-矩阵的应用" class="headerlink" title="3.矩阵的应用"></a>3.矩阵的应用</h2><h5 id="学习资料与平台"><a href="#学习资料与平台" class="headerlink" title="学习资料与平台"></a>学习资料与平台</h5><p><a href="https://www.bilibili.com/video/BV1bx411M7Zx/?t=6&amp;spm_id_from=333.1350.jump_directly&amp;vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之神经网络的结构 Part 1 ver 2.0_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ux411j7ri/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之梯度下降法 Part 2 ver 0.9 beta_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV16x411V7Qg/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之反向传播算法 上/下 Part 3 ver 0.9 beta_哔哩哔哩_bilibili</a></p>
<p>（作为计算机专业小白常常听说线性代数在计算机领域尤其重要，今天才真正理解）。</p>
<p><img src="2.png" alt="2"></p>
<p>​      在神经网络的构建中，存在着巨量的参数权重，每一层的数据都代表着运算量进一步飙升。矩阵作为一种数据间关系表达的优良方式（其实就是数表），可以极大程度的简化运算，并能非常简易地表示出结果。下例：</p>
<p><img src="3.png" alt="3"></p>
<h2 id="4-梯度下降"><a href="#4-梯度下降" class="headerlink" title="4.梯度下降"></a>4.梯度下降</h2><h4 id="梯度："><a href="#梯度：" class="headerlink" title="梯度："></a>梯度：</h4><ul>
<li><strong>梯度</strong>表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（梯度的方向）变化最快，变化率（梯度的模）最大，<strong>可理解为导数</strong>。</li>
<li>梯度上升和梯度下降是优化算法中常用的两种方法，主要目的是通过迭代找到目标函数的最大值和最小值。</li>
<li><p>例如：</p>
</li>
<li><ul>
<li>想象我们在一座很高的山上，怎么才能以最快的速度下山？我们可以先选择坡度最倾斜的方向走一段距离，然后再重新选择坡度最倾斜的方向，再走一段距离。以此类推，我们就可以以最快的速度到达山底。<strong>（梯度的方向，就是我们要选择的方向）</strong></li>
</ul>
</li>
</ul>
<h4 id="梯度下降法："><a href="#梯度下降法：" class="headerlink" title="梯度下降法："></a>梯度下降法：</h4><p><strong>梯度下降算法</strong>针对的是最小优化问题(即求最小值问题)，目的是使目标函数沿最快路径下降到最小值。</p>
<p>通俗的解释，是模拟下山，每次沿着当前位置最陡峭最易下山的方向前进一小步，然后继续沿下一个位置最陡方向前进一小步。这样一步一步走下去，一直走到觉得我们已经到了山脚。</p>
<p>算法作用于损失函数(也称目标函数、代价函数、误差函数)，是为了找到使损失函数取最小值的权重(w)和偏置(b)。</p>
<p>梯度下降运行步骤：</p>
<ol>
<li>用随机值初始化权重和偏差</li>
<li>把输入传入网络，得到输出值(预测值)</li>
<li>计算预测值和真实值(标签值)之间的误差</li>
<li><strong>对每一个产生误差的神经元，调整相应的（权重和偏差）值以减小误差</strong></li>
<li>重复迭代，直至得到网络权重和偏差的最佳值</li>
</ol>
<p><strong>批量梯度下降法(BGD)</strong>：每次迭代计算梯度，使用整个数据集。每次更新都会朝着正确的方向进行，最后能够保证收敛于极值点，凸函数收敛于全局极值点，非凸函数可能会收敛于局部极值点，缺陷就是学习时间太长，消耗大量内存。</p>
<p><strong>随机梯度下降法(SGD)</strong>：每次迭代计算梯度，从整个数据集中随机选取一个数据，所以每次迭代的时间非常快。但收敛时震荡，不稳定，在最优解附近波动，难以判断是否已经收敛。</p>
<p><strong>小批量梯度下降法(MBGD)</strong>：这个是 <strong>BGD</strong> 和 <strong>SGD</strong> 的折中方法， <strong>BGD</strong> 每次使用整体数据，收敛太慢， <strong>SGD</strong> 每次只使用一条数据，虽然收敛快但震荡厉害，所以出现了折中的 <strong>MBGD</strong>，每次使用 <strong>n</strong> 条数据，如果 <strong>n(batch size)</strong> 选择的合适，不仅收敛速度比SGD更快、更稳定，而且在最优解附近的震荡也不会很大，甚至得到比 <strong>BGD</strong> 更好的解。</p>
<p><strong>batch size</strong> 的选择，一般取2的幂次时能充分利用矩阵运算操作，因此可以在2的幂次中挑选最优取值。例如16、32、64、128、256等等。</p>
<h2 id="5-反向传播"><a href="#5-反向传播" class="headerlink" title="5.反向传播"></a>5.反向传播</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先来一个<strong>反向传播算法</strong>的定义（转自维基百科）：<strong>反向传播</strong>（英语：<strong>Backpropagation</strong>，缩写为<strong>BP</strong>）是“<strong>误差反向传播</strong>”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。 该方法对网络中<strong>所有权重</strong>计算损失函数的梯度。 这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。（<strong>误差</strong>的反向传播）</p>
<p>首先拿一个简单的三层神经网络来举例，如下：<br><img src="20190515095532783.png" alt="20190515095532783"></p>
<h5 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h5><p>每个神经元由两部分组成，第一部分（e）是<strong>输入值</strong>和<strong>权重系数</strong>乘积的<strong>和</strong>，第二部分（f(e)）是一个<strong>激活函数</strong>（非线性函数）的输出， y=f(e)即为某个神经元的输出，如下：<br><img src="20190515100159284.png" alt="20190515100159284"></p>
<p>下面是<strong>前向传播</strong>过程：<br><img src="20190515100805671.png" alt="20190515100805671"><br>—————-手动分割—————-<br><img src="20190515100845442.png" alt="20190515100845442"><br>—————-手动分割—————-<br><img src="20190515101005589.png" alt="20190515101005589"></p>
<p>到这里为止，神经网络的前向传播已经完成，最后输出的y就是本次前向传播神经网络计算出来的结果（预测结果），但这个预测结果不一定是正确的，要和真实的标签（z）相比较，计算预测结果和真实标签的误差（δ \deltaδ），如下：<br><img src="20190515101232916.png" alt="20190515101232916"></p>
<p>下面开始计算每个神经元的误差（δ \deltaδ）：<br><img src="20190515101334960.png" alt="20190515101334960"></p>
<h5 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h5><p>下面开始利用反向传播的误差，计算各个神经元（权重）的导数，开始反向传播修改权重。</p>
<p><img src="20190515103014208.png" alt="20190515103014208"></p>
<p><img src="20190515103033715.png" alt="20190515103033715"></p>
<p><img src="20190515103116521.png" alt="20190515103116521"></p>
<h4 id="“正向传播”求损失，“反向传播”回传误差。"><a href="#“正向传播”求损失，“反向传播”回传误差。" class="headerlink" title="“正向传播”求损失，“反向传播”回传误差。"></a><strong>“正向传播”求损失，“反向传播”回传误差</strong>。</h4><p><strong>BP算法，也叫**</strong>δ \delta<strong><strong>δ</strong></strong>算法**，下面以3层的感知机为例进行举例讲解。<br><img src="20190515104858190.png" alt="20190515104858190"></p>
<p>上图的前向传播（网络输出计算）过程如下：（此处为网络的整个误差的计算，误差E计算方法为mse）</p>
<p><img src="20200331121115812.png" alt="20200331121115812"></p>
<p>上面的计算过程并不难，只要耐心一步步的拆开式子，逐渐分解即可。现在还有两个问题需要解决：</p>
<ol>
<li>误差E有了，怎么调整权重让误差不断减小？</li>
<li>E是权重w的函数，何如找到使得函数值最小的w。</li>
</ol>
<h4 id="（其实这些稀奇古怪的公式已经看不懂了）"><a href="#（其实这些稀奇古怪的公式已经看不懂了）" class="headerlink" title="（其实这些稀奇古怪的公式已经看不懂了）"></a>（其实这些稀奇古怪的公式已经看不懂了）</h4><p>通俗来讲，反向传播就是根据计算结果的误差修改权重信号，俗称打哪指哪，像极了我强行凑答案的样子。通过这种方法可以优化神经网络的整体权重布局，从而使训练结果更上一层楼（也可能中间层的黑箱子照着无法预测的方向走远但是结果准确率超高）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上所述感觉神经网络就是人们用计算机模拟人脑神经元链接构建出来的玩意（果然生物结构才是顶级码农的创造）。对于深度学习，神经网络属于机器学习的一部分，更具体地说是深度学习的一种。机器学习是一种让计算机从数据中学习的方法，而深度学习则是机器学习中的一个分支，强调使用深层次的神经网络结构。</p>
<p>对于神经网络是否智能这件事，我也说不好，感觉相对人脑来说这种结构实在是太简单了。（比如说计算机永远无法理解我怎么眼睁睁地看着自己把7x8算成45）。目前神经网络似乎缺少了较高程度的自我学习能力，例如发现个什么定律啥的，（照《终结者》一比还是差着层次），但是chatgpt确实很香，看起来AI方面的发展还是很大的，贾维斯指日可待（乐）。</p>
<h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><p>直接上代码吧，内容都写在注释里了</p>
<h5 id="神经网络类："><a href="#神经网络类：" class="headerlink" title="神经网络类："></a>神经网络类：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 神经网络类定义</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> scipy.special</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">neuralNetwork</span>:</span><br><span class="line">    <span class="comment"># 初始化神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inputnodes, hiddennodes, outputnodes, learningrate</span>):</span><br><span class="line">        <span class="comment"># 设置每个层中的节点数</span></span><br><span class="line">        self.inodes = inputnodes</span><br><span class="line">        self.hnodes = hiddennodes</span><br><span class="line">        self.onodes = outputnodes</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用随机值初始化权重</span></span><br><span class="line">        self.wih = numpy.random.normal(<span class="number">0.0</span>, <span class="built_in">pow</span>(self.hnodes, -<span class="number">0.5</span>), (self.hnodes, self.inodes))</span><br><span class="line">        self.who = numpy.random.normal(<span class="number">0.0</span>, <span class="built_in">pow</span>(self.onodes, -<span class="number">0.5</span>), (self.onodes, self.hnodes))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置学习率</span></span><br><span class="line">        self.lr = learningrate</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义激活函数为sigmoid函数</span></span><br><span class="line">        self.activation_function = <span class="keyword">lambda</span> x: scipy.special.expit(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, inputs_list, targets_list</span>):</span><br><span class="line">        <span class="comment"># 将输入和目标转换为2维数组</span></span><br><span class="line">        inputs = numpy.array(inputs_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">        targets = numpy.array(targets_list, ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的输入和输出信号</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的输入和输出信号</span></span><br><span class="line">        final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的误差</span></span><br><span class="line">        output_errors = targets - final_outputs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的误差</span></span><br><span class="line">        hidden_errors = numpy.dot(self.who.T, output_errors)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用学习率和梯度更新权重</span></span><br><span class="line">        self.who += self.lr * numpy.dot((output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)), numpy.transpose(hidden_outputs))</span><br><span class="line">        self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)), numpy.transpose(inputs))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, input_list</span>):</span><br><span class="line">        <span class="comment"># 将输入转换为2维数组</span></span><br><span class="line">        inputs = numpy.array(input_list, ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的输入和输出信号</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的输入和输出信号</span></span><br><span class="line">        final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回网络的输出</span></span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_train.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>data_file=…</strong>：打开 MNIST 训练数据集文件，并将其内容读取到 <strong>data_list</strong> 列表中。</li>
<li><strong>data_list=data_file.readlines()</strong>：读取文件的所有行，并存储在 <strong>data_list</strong> 列表中。</li>
<li><strong>all_values=data_list[0].split(‘,’)</strong>：将第一行数据按逗号分隔，存储到 <strong>all_values</strong> 列表中。</li>
<li><strong>image_array=numpy.asfarray(all_values[1:]).reshape((28,28))</strong>：将 <strong>all_values</strong> 中的像素值转换为浮点数，并重新形状为 28x28 的数组，表示图像的像素矩阵。</li>
<li><strong>matplotlib.pyplot.imshow(image_array,cmap=’Greys’,interpolation=’None’)</strong>：使用 Matplotlib 的 <strong>imshow</strong> 函数将图像以灰度的形式显示在图像窗口中。</li>
</ol>
<p>这段代码读取 MNIST 数据集中的第一张图像数据，并显示在图像窗口中。</p>
<p><img src="a350e116ec9ac187600f639bb8574216.png" alt="a350e116ec9ac187600f639bb8574216"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_train.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">5</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>data_list[5]</strong> 表示第6行数据，<strong>all_values=data_list[5].split(‘,’)</strong> 将这一行数据根据逗号分割成一个值的列表。然后，将列表中除第一个值外的其余值转换为浮点数数组，并reshape为28x28的图像矩阵，最后使用<strong>matplotlib</strong>库将图像显示在灰度色图上。</p>
<p>(其实就是根据数据显示原图)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scaled_input=(numpy.asfarray(all_values[<span class="number">1</span>:]) /<span class="number">255.0</span>*<span class="number">0.99</span>)+<span class="number">0.01</span></span><br><span class="line"><span class="built_in">print</span>(scaled_input)</span><br></pre></td></tr></table></figure>
<p>这段代码对MNIST数据集中第6行的像素值进行了预处理。首先，<strong>numpy.asfarray(all_values[1:])</strong> 将第6行除第一个值外的其余值转换为浮点数数组。然后，通过除以255.0将像素值缩放到0到1之间，接着将数据范围缩放到0.01到1之间，而不是0到1。这是因为在神经网络中，为了避免输入值为0的情况（可能会影响权重的更新），将数据范围设置为稍微偏离0的范围。</p>
<p>最后，通过<strong>print(scaled_input)</strong> 将缩放后的输入值打印出来，以便查看处理后的数值范围和数据。</p>
<p>这段代码可以帮助确保在使用神经网络之前对输入数据进行了适当的预处理，以提高神经网络的训练效果。</p>
<p><img src="416a55bcc508c87e6a28fb7d848dcec6_720.png" alt="416a55bcc508c87e6a28fb7d848dcec6_720"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">onodes=<span class="number">10</span></span><br><span class="line">targets=numpy.zeros(onodes)+<span class="number">0.01</span></span><br><span class="line">targets[<span class="built_in">int</span>(all_values[<span class="number">0</span>])]=<span class="number">0.99</span></span><br></pre></td></tr></table></figure>
<p>这段代码是为了准备目标输出。它创建了一个长度为<strong>onodes</strong>的零数组（全零数组），然后将第<strong>int(all_values[0])</strong>个位置设置为0.99。这个位置对应于<strong>all_values[0]</strong>中的值，通常表示图像中显示的数字。<strong>int(all_values[0])</strong>的值被用作索引，用于将目标输出数组中对应的位置值设置为0.99。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_test.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">all_values=test_data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(all_values[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><img src="1014148cd6ee8d823f12ab6de2c2ea0b_720.png" alt="1014148cd6ee8d823f12ab6de2c2ea0b_720"></p>
<ol>
<li><strong>data_file=open(“/home/zuquanzhi/pythonProject/mnist_dataset/mnist_test.csv”,’r’)</strong>: 打开了一个名为<strong>mnist_test.csv</strong>的CSV文件来读取测试数据。</li>
<li><strong>data_list=data_file.readlines()</strong>: 读取CSV文件的内容，并将每一行数据存储在<strong>data_list</strong>列表中。</li>
<li><strong>all_values=data_list[0].split(‘,’)</strong>: 从第一行提取数据，使用逗号作为分隔符将数据拆分为一个值的列表<strong>all_values</strong>。</li>
<li><strong>image_array=numpy.asfarray(all_values[1:]).reshape((28,28))</strong>: 将<strong>all_values</strong>列表中的字符串转换为浮点数，并根据这些值创建一个28x28的二维数组 <strong>image_array</strong>，用于表示图像的像素值。</li>
<li><strong>matplotlib.pyplot.imshow(image_array,cmap=’Greys’,interpolation=’None’)</strong>: 使用Matplotlib库中的<strong>imshow</strong>函数将<strong>image_array</strong>作为灰度图像显示出来。</li>
<li><strong>all_values=test_data_list[0].split(‘,’)</strong>: 这里应该更正为<strong>data_list</strong>而不是<strong>test_data_list</strong>，以便使用刚刚加载的测试集数据。这行代码意图是重新读取<strong>data_list</strong>的第一行数据并将其拆分。</li>
<li><strong>print(all_values[0])</strong>: 打印 <strong>all_values</strong> 列表的第一个值，这可能是与图像相关联的标签或类别。</li>
</ol>
]]></content>
      <categories>
        <category>718</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>筛去重复元素</title>
    <url>/2023/12/14/%E7%AD%9B%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="筛去重复元素"><a href="#筛去重复元素" class="headerlink" title="筛去重复元素"></a>筛去重复元素</h1><p>最近发现这样一道题，大致意思是给定一个数组，其中元素仅有一个只出现一次，其余元素均出现两次，编写程序以找出这个数。</p>
<p>这里可以用到异或运算。</p>
<span id="more"></span>
<p>异或运算法则如下：</p>
<ol>
<li><p>交换律：A ^ B = B ^ A</p>
</li>
<li><p>结合律：A ^ (B ^ C) = (A ^ B) ^ C</p>
</li>
<li><p><strong>恒等律：X ^ 0 = X</strong></p>
</li>
<li><p><strong>归零律：X ^ X = 0</strong></p>
</li>
<li><p>自反：A ^ B ^ B = A ^ 0 = A</p>
<p>这里主要用到后三条性质，可以定义变量key，不断与数组元素进行异或运算，某种意义上达到对于数组的压缩储存。</p>
</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        key^=<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,func(<span class="built_in">array</span>,<span class="number">13</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>近世代数</title>
    <url>/2024/11/16/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<p><img src="第 1 页.png" alt=""><br><img src="第 2 页.png" alt=""><br><img src="第 3 页.png" alt=""><br><img src="第 4 页.png" alt=""><br><img src="第 5 页.png" alt=""><br><img src="第 6 页.png" alt=""><br><img src="第 7 页.png" alt=""><br><img src="第 8 页.png" alt=""><br><img src="第 9 页.png" alt=""></p>
]]></content>
      <categories>
        <category>数学基础</category>
      </categories>
      <tags>
        <tag>近世代数</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2023/10/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一点关于贪心算法的思考"><a href="#一点关于贪心算法的思考" class="headerlink" title="一点关于贪心算法的思考"></a>一点关于贪心算法的思考</h1><h4 id="关于贪心算法，ChatGPT是这么定义的："><a href="#关于贪心算法，ChatGPT是这么定义的：" class="headerlink" title="关于贪心算法，ChatGPT是这么定义的："></a>关于贪心算法，ChatGPT是这么定义的：</h4><p>贪心算法（Greedy Algorithm）是一种求解最优化问题的算法范式，它在每一步选择当前状态下的最优解，最终期望通过一系列的最优选择达到全局最优解。贪心算法通常适用于那些具有最优子结构性质的问题，其中整体问题的最优解可以通过局部子问题的最优解得到。</p>
<p>贪心算法的一般思想是按照某种规则，从问题的初始状态开始，通过一系列局部最优的选择，逐步逼近问题的全局最优解。每一步的选择不依赖于前面的选择，也不会影响以后的选择。因此，贪心算法通常是一个非常高效的算法，因为它不需要考虑所有可能的解决方案，只需关注当前的最优选择。<br><span id="more"></span><br><strong>显然，此算法是通过局部运算达到计算整体最优解的效果。</strong></p>
<h4 id="举个生活中常见的实例："><a href="#举个生活中常见的实例：" class="headerlink" title="举个生活中常见的实例："></a>举个生活中常见的实例：</h4><p>假设有1元、2元、5元、10元、20元、50元、100元的纸币。现在要用这些钱来支付，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m[<span class="number">7</span>]= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>&#125;; <span class="comment">//先有纸币的数额</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">//所找的金额</span></span><br><span class="line">	<span class="type">int</span> num;          <span class="comment">//所需纸币的张数</span></span><br><span class="line">    <span class="keyword">while</span>((	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ret))!=EOF) &#123;</span><br><span class="line">		<span class="keyword">while</span>(ret&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(ret&gt;=<span class="number">100</span>) &#123;</span><br><span class="line">                ret-=<span class="number">100</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">50</span>&amp;&amp;ret&lt;<span class="number">100</span>) &#123;</span><br><span class="line">                ret-=<span class="number">50</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">20</span>&amp;&amp;ret&lt;<span class="number">50</span>) &#123;</span><br><span class="line">                ret-=<span class="number">20</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">5</span>&amp;&amp;ret&lt;<span class="number">20</span>) &#123;</span><br><span class="line">                ret-=<span class="number">5</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">2</span>&amp;&amp;ret&lt;<span class="number">5</span>) &#123;</span><br><span class="line">                ret-=<span class="number">2</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;=<span class="number">1</span>&amp;&amp;ret&lt;<span class="number">2</span>) &#123;</span><br><span class="line">                ret-=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="贪心算法的基本思路"><a href="#贪心算法的基本思路" class="headerlink" title="贪心算法的基本思路"></a>贪心算法的基本思路</h4><ol>
<li>候选集合S<br>为了构造问题的解决方案，有一个候选集合C作为问题的可能解，问题的最终解均取自于候选集合C。</li>
<li>解集合S<br>随着贪心选择的进行，解集合不断扩展，直到构成一个满足问题的完整解。</li>
<li>解决函数solution<br>检查解集合是否构成问题的完整解。</li>
<li>选择函数select<br>即贪心策略，这是贪心算法的关键，它指出哪个候选对象有希望构成成问题的解。</li>
<li>可行函数feasible<br>检查解集合中加入一个候选对象是否可行，即解集合扩展后是否满足约束条件。</li>
</ol>
<p>对应的，</p>
<h4 id="该算法存在的问题"><a href="#该算法存在的问题" class="headerlink" title="该算法存在的问题"></a>该算法存在的问题</h4><ul>
<li><p>不能保证求得的最后解是最佳的</p>
</li>
<li><p>不能用来求最大值或最小值的问题</p>
</li>
<li><p>只能求满足某些约束条件的可行解的范围   </p>
</li>
</ul>
<p>要选出最优解不是一件容易的事，要证明局部最优为全局最优，要进行数学证明，否则就不能说明为全局最优。</p>
<p>很多问题表面上看来用贪心算法可以找到最优解，实际上却把最优解给漏掉了。这就像现实生活中的“贪小便宜吃大亏”。所以在解决问题的时候，一定要谨慎使用此算法，一定要注意这个问题适不适合采用贪心算法。</p>
<p>但是在很多大规模问题中，寻找最优解是一件相当费时耗力的事情，有时候付出大量人力物力财力后，回报并不与投入成正比。在这个时候选择相对最优的贪心算法就比较经济可行了。有的问题对最优的要求不是很高，在充分衡量付出和回报后，选择贪心算法未尝不是一种不错的选择。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体编程</title>
    <url>/2023/11/27/%E7%BB%93%E6%9E%84%E4%BD%93%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>屎山测试第二趴</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">某校的惯例是在每学期的期末考试之后发放奖学金。发 放</span><br><span class="line">的奖学金共有五种，每项奖学金获取的条件分别如下：</span><br><span class="line"><span class="number">1</span>) 院士奖学金：期末平均成绩高于 <span class="number">80</span> 分（&gt;<span class="number">80</span>），并且在本学期内发表 <span class="number">1</span> 篇或</span><br><span class="line"><span class="number">1</span> 篇以上论文的学生每人均可获得 <span class="number">8000</span> 元；</span><br><span class="line"><span class="number">2</span>) 五四奖学金：期末平均成绩高于 <span class="number">85</span> 分（&gt;<span class="number">85</span>），并且班级评议成绩高于 <span class="number">80</span> 分</span><br><span class="line">（&gt;<span class="number">80</span>）的学生每人均可获得 <span class="number">4000</span> 元；</span><br><span class="line"><span class="number">3</span>) 成绩优秀奖：期末平均成绩高于 <span class="number">90</span> 分（&gt;<span class="number">90</span>）的学生每人均可获得 <span class="number">2000</span> 元；</span><br><span class="line"><span class="number">4</span>) 西部奖学金：期末平均成绩高于 <span class="number">85</span> 分（&gt;<span class="number">85</span>）的西部省份学生每人均可获得</span><br><span class="line"><span class="number">1000</span> 元；</span><br><span class="line"><span class="number">5</span>) 班级贡献奖：班级评议成绩高于 <span class="number">80</span> 分（&gt;<span class="number">80</span>）的学生干部每人均可获得 <span class="number">850</span></span><br><span class="line">元；</span><br><span class="line">只要符合上述条件就可获得相应的奖项，每项奖学金的获奖人数没有限制，每</span><br><span class="line">名学生也可以同时获得多项奖学金。例如姚明的期末平均成绩是 <span class="number">87</span> 分，班级</span><br><span class="line">评议成绩 <span class="number">82</span> 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金</span><br><span class="line">和班级贡献奖，奖金总数是 <span class="number">4850</span> 元。</span><br><span class="line">现在给出若干学生的相关数据（假设总有同学能满足获得奖学金的条件），</span><br><span class="line">程序运行时，要先输入学生人数。提示：<span class="string">&quot;Input n:&quot;</span>，然后逐个输入学生信息：</span><br><span class="line">输入学生姓名提示：<span class="string">&quot;Input name:&quot;</span></span><br><span class="line">输入学生期末平均成绩提示：<span class="string">&quot;Input final score:&quot;</span></span><br><span class="line">输入学生班级评议成绩提示：<span class="string">&quot;Input class score:&quot;</span></span><br><span class="line">输入是否为学生干部提示：<span class="string">&quot;Class cadre or not?(Y/N):&quot;</span></span><br><span class="line">输入是否为西部学生提示：<span class="string">&quot;Students from the West or not?(Y/N):&quot;</span></span><br><span class="line">输入发表文章数量提示：<span class="string">&quot;Input the number of published papers:&quot;</span></span><br><span class="line"><span class="number">1.</span>请定义结构体类型 S</span><br><span class="line"><span class="number">2.</span> 编程输入所有学生的数据（定义 input 函数 ）</span><br><span class="line"><span class="number">3.</span>将所有的学生按照姓名进行排序（定义 sort 函数 <span class="number">10</span> 分）</span><br><span class="line"><span class="number">4.</span>后输出每个人的信息（print 函数）</span><br><span class="line"><span class="number">5.</span>计算每个同学获得的奖金总数（定义 addup 函数）</span><br><span class="line"><span class="number">6.</span>并找到奖金最高者（定义 findMax 函数 <span class="number">5</span> 分），打印出他的名字和奖金数额。</span><br><span class="line"><span class="number">7.</span>主函数。注意请不要使用全局变量。</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">float</span> final_score;</span><br><span class="line">    <span class="type">float</span> class_score;</span><br><span class="line">    <span class="type">char</span> is_cadre; <span class="comment">// &#x27;Y&#x27;表示是学生干部，&#x27;N&#x27;表示不是</span></span><br><span class="line">    <span class="type">char</span> is_west; <span class="comment">// &#x27;Y&#x27;表示来自西部省份，&#x27;N&#x27;表示不是</span></span><br><span class="line">    <span class="type">int</span> published_papers;</span><br><span class="line">    <span class="type">int</span> scholarship;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义输入函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="keyword">struct</span> S *s)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input name: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input final score: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;(s-&gt;final_score));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input class score: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;(s-&gt;class_score));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Class cadre or not? (Y/N): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;(s-&gt;is_cadre));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Students from the West or not? (Y/N): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;(s-&gt;is_west));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input the number of published papers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(s-&gt;published_papers));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义排序函数（造个小轮子方便引用qsort）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sort</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> S *)a)-&gt;name, ((<span class="keyword">struct</span> S *)b)-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> S *s)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, s-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final score: %.2f\n&quot;</span>, s-&gt;final_score);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Class score: %.2f\n&quot;</span>, s-&gt;class_score);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Class cadre: %c\n&quot;</span>, s-&gt;is_cadre);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Students from the West: %c\n&quot;</span>, s-&gt;is_west);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Published papers: %d\n&quot;</span>, s-&gt;published_papers);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Scholarship: %d\n&quot;</span>, s-&gt;scholarship);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addup</span><span class="params">(<span class="keyword">struct</span> S *s)</span> &#123;</span><br><span class="line">    s-&gt;scholarship = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">80</span> &amp;&amp; s-&gt;published_papers &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">8000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">85</span> &amp;&amp; s-&gt;class_score &gt; <span class="number">80</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">4000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">90</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;final_score &gt; <span class="number">85</span> &amp;&amp; s-&gt;is_west == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;class_score &gt; <span class="number">80</span> &amp;&amp; s-&gt;is_cadre == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">        s-&gt;scholarship += <span class="number">850</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> S <span class="title function_">findMax</span><span class="params">(<span class="keyword">struct</span> S *students, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">maxStudent</span> =</span> students[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (students[i].scholarship &gt; maxStudent.scholarship) &#123;</span><br><span class="line">            maxStudent = students[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxStudent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input n: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">students</span> =</span> (<span class="keyword">struct</span> S *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nEnter data for student %d:\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        input(&amp;students[i]);</span><br><span class="line">        addup(&amp;students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qsort(students, n, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S), sort);<span class="comment">//按名字排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nStudent information:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        print(&amp;students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">maxStudent</span> =</span> findMax(students, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nStudent with the highest scholarship:\n&quot;</span>);</span><br><span class="line">    print(&amp;maxStudent);</span><br><span class="line">    <span class="built_in">free</span>(students);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>链表基本操作</title>
    <url>/2023/12/10/%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="链表基本操作"><a href="#链表基本操作" class="headerlink" title="链表基本操作"></a>链表基本操作</h3><p>（临时抱佛脚的笔记）</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头部插入节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">insertAtBeginning</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾部插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAtEnd</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个值为 data 的节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找要删除的节点并记录其前一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != data) &#123;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若找到要删除的节点，则删除它</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = current-&gt;next; <span class="comment">// 删除头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = current-&gt;next; <span class="comment">// 删除中间或尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(<span class="keyword">struct</span> Node *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 初始化链表头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部插入节点</span></span><br><span class="line">    head = insertAtBeginning(head, <span class="number">10</span>);</span><br><span class="line">    head = insertAtBeginning(head, <span class="number">20</span>);</span><br><span class="line">    head = insertAtBeginning(head, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">    insertAtEnd(head, <span class="number">40</span>);</span><br><span class="line">    insertAtEnd(head, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容：\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    head = deleteNode(head, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后的链表内容：\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表节点内存</span></span><br><span class="line">    freeList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>屎山</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度算法</title>
    <url>/2024/04/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h1><p>在处理数据的时候经常需要用到一些无比巨大的数，比如41856410684191645611这种的，或者是十进制的二进制转化，显然cpp里不能直接用int存放这些数据，然而long类型也是有上限的，这时就需要引入一个新的算法，叫做高精度算法<br><span id="more"></span></p>
<h2 id="算法本质思想"><a href="#算法本质思想" class="headerlink" title="算法本质思想"></a>算法本质思想</h2><p>感觉多数思路就是用数组之类的容器存放数据，采用最原始的方式一点点进位计算之类的。（果然高端的食材往往采用最朴素的烹饪方式）。</p>
<h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><p>高精度计算中有几个细节需要注意：</p>
<ul>
<li><p>数据接受和储存： 当输入的数很长时，可以使用字符串方式输入和储存，再用字符串函数进行操作运算，将每一位去取出，存入数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">void init(<span class="type">int</span> a[]) &#123; <span class="comment">// 传入数组</span></span><br><span class="line">    <span class="type">string</span> s;</span><br><span class="line">    cin &gt;&gt; s; </span><br><span class="line">    <span class="built_in">len</span> = s.length(); <span class="comment">// s.length --&gt; 计算字符串位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">len</span>; i++)     </span><br><span class="line">        a[i] = s[<span class="built_in">len</span> -i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//将字符串s转换为数组a, 倒序存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进位错位处理：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">// 加法进位: c[i] = a[i] + b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i] <span class="comment">%= 10;</span></span><br><span class="line">            ++c[i++];</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">//减法借位: c[i] = a[i] - b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(a[i] &lt; b[i]) &#123;</span><br><span class="line">             --a[i+<span class="number">1</span>];</span><br><span class="line">             a[i] += <span class="number">10</span>;   </span><br><span class="line">         &#125; </span><br><span class="line"> </span><br><span class="line">//乘法进位: c[i + j - <span class="number">1</span>] = a[i] * b[j] + x + c[i + j - <span class="number">1</span>];</span><br><span class="line">          x = c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">          c[i + j - <span class="number">1</span>] <span class="comment">% 10;</span></span><br></pre></td></tr></table></figure>
<h3 id="高精度加法："><a href="#高精度加法：" class="headerlink" title="高精度加法："></a>高精度加法：</h3><p>输入两个数到变量中，然后用赋值语句求它们的和后输出 . But，我们知道，在 C++ 语言中任何数据类型都有一定表示范围. 当两个加数很大时，以前的算法显然不能求出精确解，因此我们需要寻求另一种方法 .在读小学时，我们做加法都采用竖式方法 . 这样我们方便写出两个整数相加的算法 .</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度加法</span></span><br><span class="line"><span class="keyword">string</span> add(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = digit1 + digit2 + carry;</span><br><span class="line">        carry = s / <span class="number">10</span>;</span><br><span class="line">        sum = to_string(s % <span class="number">10</span>) + sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度减法</span></span><br><span class="line"><span class="keyword">string</span> subtract(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> borrow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> diff = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d = digit1 - digit2 - borrow;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d += <span class="number">10</span>;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        diff = to_string(d) + diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除前导零</span></span><br><span class="line">    diff.erase(<span class="number">0</span>, diff.find_first_not_of(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> (diff == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度乘法</span></span><br><span class="line"><span class="keyword">string</span> multiply(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; result(n1 + n2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = mul + result[i + j + <span class="number">1</span>];</span><br><span class="line">            result[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">            result[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换为字符串</span></span><br><span class="line">    <span class="keyword">string</span> product = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(product.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123;  <span class="comment">// 忽略前导零</span></span><br><span class="line">            product += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (product == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">// 高精度除法（除以低精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, int&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, int divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    int <span class="built_in">remainder</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (char digit : dividend) &#123;</span><br><span class="line">        int <span class="built_in">num</span> = digit - &#x27;<span class="number">0</span>&#x27; + <span class="built_in">remainder</span> * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">quotient</span> += to_string(<span class="built_in">num</span> / divisor);</span><br><span class="line">        <span class="built_in">remainder</span> = <span class="built_in">num</span> <span class="symbol">%</span> divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="高精度除以高精度"><a href="#高精度除以高精度" class="headerlink" title="高精度除以高精度"></a>高精度除以高精度</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">// 高精度除法（除以高精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, <span class="built_in">string</span> divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;0&quot;</span>, <span class="built_in">remainder</span> = dividend;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">remainder</span>.size() &gt;= divisor.size() &amp;&amp; <span class="built_in">remainder</span> &gt;= divisor) &#123;</span><br><span class="line">        int n = <span class="built_in">remainder</span>.size() - divisor.size();</span><br><span class="line">        <span class="built_in">string</span> temp = divisor;</span><br><span class="line">        temp.<span class="built_in">append</span>(n, &#x27;<span class="number">0</span>&#x27;); // 补零</span><br><span class="line">        int count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">remainder</span> &gt;= temp) &#123;</span><br><span class="line">            <span class="built_in">remainder</span> = subtract(<span class="built_in">remainder</span>, temp);</span><br><span class="line">            <span class="built_in">quotient</span> = add(<span class="built_in">quotient</span>, <span class="string">&quot;1&quot;</span> + <span class="built_in">string</span>(n, &#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">remainder</span>.erase(<span class="number">0</span>, <span class="built_in">remainder</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, (<span class="built_in">remainder</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压位技巧"><a href="#压位技巧" class="headerlink" title="压位技巧"></a>压位技巧</h3><p>谁说数组每个元素只能是一位数？显然这会造成巨大的浪费。<br>这时我们就可以使用压位的技巧来节省运行时间。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压位技巧高精度加法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span>(<span class="params"><span class="built_in">string</span> num1, <span class="built_in">string</span> num2</span>)</span> &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">result</span>(<span class="params">max(num1.size(</span>), num2.<span class="title">size</span>()) + 1, 0)</span>; <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="built_in">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="built_in">int</span> i = num1.size() - <span class="number">1</span>, j = num2.size() - <span class="number">1</span>, k = result.size() - <span class="number">1</span>; <span class="comment">// 从个位开始相加</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="built_in">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num1的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num2的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> sum = digit1 + digit2 + carry; <span class="comment">// 当前位的和</span></span><br><span class="line">        result[k--] = sum % <span class="number">10</span>; <span class="comment">// 将当前位的和放入结果数组</span></span><br><span class="line">        carry = sum / <span class="number">10</span>; <span class="comment">// 更新进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换结果数组为字符串</span></span><br><span class="line">    <span class="built_in">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(sum.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123; <span class="comment">// 忽略前导零</span></span><br><span class="line">            sum += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : sum; <span class="comment">// 如果结果为空字符串，则返回&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> num1 = <span class="string">&quot;123456789012345678901234567890&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> num2 = <span class="string">&quot;987654321098765432109876543210&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;高精度加法结果：&quot;</span> &lt;&lt; <span class="keyword">add</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>总之大多数需要根据现实情况变通。。。。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>Agent时代基础设施--MCP协议介绍</title>
    <url>/2025/04/11/Agent%E6%97%B6%E4%BB%A3%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-MCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="What-is-MCP"><a href="#What-is-MCP" class="headerlink" title="What is MCP"></a>What is MCP</h2><p>MCP (Model Context Protocol)是一种开放协议，用于标准化应用程序如何向大型语言模型（LLMs）提供上下文。可以将 MCP 想象为 AI 应用的 typec 接口。正如 typec 提供了一种标准化的方式将您的设备连接到各种外设和配件，MCP 也提供了一种标准化的方式，将 AI 模型连接到不同的数据源和工具。</p>
<p>MCP 协议由 Anthropic 在 2024 年 11 月底推出：</p>
<ul>
<li>官方文档：<a href="https://modelcontextprotocol.io/introduction">Introduction</a></li>
<li>GitHub 仓库：<a href="https://github.com/modelcontextprotocol">https://github.com/modelcontextprotocol</a></li>
</ul>
<p>MCP 集成教学：</p>
<ul>
<li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/git">Git</a> - Git 读取、操作、搜索。</li>
<li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/github">Github</a> - Repo 管理、文件操作和 GitHub API 集成。</li>
<li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/google-maps">Google Maps</a> - 集成 Google Map 获取位置信息。</li>
<li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/postgres">PostgreSQL</a> - 只读数据库查询。</li>
<li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/slack">Slack</a> - Slack 消息发送和查询。</li>
</ul>
<p><strong><a href="https://mcp.so/">MCP导航站</a></strong></p>
<h2 id="Why-is-MCP"><a href="#Why-is-MCP" class="headerlink" title="Why is MCP"></a>Why is MCP</h2><p>举个栗子，在过去，为了让大模型等 AI 应用使用我们的数据，要么复制粘贴，要么上传下载，非常麻烦。</p>
<p>即使是最强大模型也会受到数据隔离的限制，形成信息孤岛，要做出更强大的模型，每个新数据源都需要自己重新定制实现，使真正互联的系统难以扩展，存在很多的局限性。</p>
<p>从最初的 chatgpt，到后来的 cursor，copilot chatroom，再到现在耳熟能详的 agent，实际上，从用户交互的角度去观察，你会发现目前的大模型产品经历了如下的变化：</p>
<p><img src="image.png" alt=""></p>
<ul>
<li>chatbot<ul>
<li>只会聊天的程序。</li>
<li>工作流程：你输入问题，它给你这个问题的解决方案，但是具体执行还需要你自己去。</li>
<li>代表工作：deepseek，chatgpt</li>
</ul>
</li>
<li>composer<ul>
<li>稍微会帮你干活的实习生，仅限于写代码。</li>
<li>工作流程：你输入问题，它会给你帮你生成解决问题的代码，并且自动填入代码编辑器的编译区，你只需要审核确认即可。</li>
<li>代表工作：cursor，copilot</li>
</ul>
</li>
<li>agent<ul>
<li>私人秘书。</li>
<li>工作流程：你输入问题，它生成这个问题的解决方案，并在征询了你的同意后全自动执行。</li>
<li>代表工作：AutoGPT，Manus，Open Manus</li>
</ul>
</li>
</ul>
<p>为了实现 agent，也就需要让 LLM 可以自如灵活地操作所有软件甚至物理世界的机器人，于是需要定义统一的上下文协议与之上统一工作流。MCP(model context protocol) 就是解决这套方案的应运而生的基础协议。</p>
<p>而 MCP 服务器就是为了实现 AI Agent 的自动化而存在的。它是一个中间层，告诉 AI Agent 当前有哪些可用的服务、API 和数据源。AI Agent 根据服务器提供的信息决定是否调用某个服务，并通过 Function Calling 执行相应的函数。</p>
<p>现在，MCP 可以直接在 AI 与数据（包括本地数据和互联网数据）之间架起一座桥梁，通过 MCP 服务器和 MCP 客户端，大家只要都遵循这套协议，就能实现“万物互联”。</p>
<p>有了MCP，可以和数据和文件系统、开发工具、Web 和浏览器自动化、生产力和通信、各种社区生态能力全部集成，实现强大的协作工作能力，它的价值远不可估量。</p>
<blockquote>
<p>Anthropic 对于 MCP 的必要性给出的解释：MCP 帮助您在 LLMs 之上构建 agent 和复杂的工作流程。LLMs 经常需要与数据和工具集成，而 MCP 提供了以下支持：</p>
<ul>
<li>一系列不断增长的预构建集成，您的 LLM 可以直接接入这些集成。</li>
<li>在 LLM 提供商和供应商之间灵活切换。</li>
<li>在基础设施内保护数据的最佳实践。</li>
</ul>
</blockquote>
<p>看到这里你可能有一个问题，在 23 年 OpenAI 发布 GPT function calling 的时候，不是也是可以实现类似的功能吗？我们之前博客介绍的 AI Agent，不就是用来集成不同的服务吗？为什么又出现了 MCP。</p>
<h3 id="Function-Calling、AI-Agent-和-MCP-的区别"><a href="#Function-Calling、AI-Agent-和-MCP-的区别" class="headerlink" title="Function Calling、AI Agent 和 MCP 的区别"></a>Function Calling、AI Agent 和 MCP 的区别</h3><h4 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h4><p>Function Calling 是指 AI 模型根据上下文自动调用函数的机制。它充当了 AI 模型与外部系统之间的桥梁。不同模型的 Function Calling 实现方式各异，代码集成方式也各不相同，由不同的 AI 模型平台定义和实现。  </p>
<p>如果使用 Function Calling，需要通过代码为 LLM 提供一组函数，并明确描述函数的输入和输出。这样，LLM 就可以根据清晰的结构化数据进行推理并执行函数。  </p>
<p>Function Calling 的缺点在于难以处理多轮对话和复杂需求，更适合边界清晰、描述明确的任务。如果任务繁多，Function Calling 的代码会变得难以维护。  </p>
<h4 id="Model-Context-Protocol-MCP"><a href="#Model-Context-Protocol-MCP" class="headerlink" title="Model Context Protocol (MCP)"></a>Model Context Protocol (MCP)</h4><p>MCP 是一种标准化协议，类似于电子设备中的 Type-C 接口（既能充电又能传输数据），使 AI 模型能够与不同的 API 和数据源无缝交互。  </p>
<p>MCP 的目标是取代碎片化的 Agent 代码集成，从而让 AI 系统更加可靠和高效。通过建立通用标准，服务商可以基于协议推出自己的 AI 能力，帮助开发者更快地构建更强大的 AI 应用。开发者无需重复造轮子，通过开源项目即可构建强大的 AI Agent 生态。  </p>
<p>MCP 能够在不同应用和服务之间保持上下文，从而增强整体自主执行任务的能力。可以理解为，MCP 将不同任务分层处理，每一层都提供特定的能力、描述和限制。MCP 客户端根据任务需求判断是否调用某项能力，并通过每层的输入和输出，构建出一个能够处理复杂、多步对话和统一上下文的 Agent。  </p>
<h4 id="AI-Agent"><a href="#AI-Agent" class="headerlink" title="AI Agent"></a>AI Agent</h4><p>AI Agent 是一个智能系统，能够自主运行以实现特定目标。传统的 AI 聊天仅提供建议或需要手动执行任务，而 AI Agent 则可以分析具体情况、做出决策并自行采取行动。  </p>
<p>AI Agent 可以利用 MCP 提供的功能描述来理解更多上下文，并在不同平台和服务上自动执行任务。  </p>
<hr>
<h2 id="MCP-的工作原理"><a href="#MCP-的工作原理" class="headerlink" title="MCP 的工作原理"></a>MCP 的工作原理</h2><p>先来看一下 MCP 的整体架构：<br><img src="image-1.png" alt="">  </p>
<ul>
<li><p><strong>MCP 主机（MCP Hosts）</strong><br>指希望通过 MCP 访问数据的程序，例如 Claude Desktop、集成开发环境（IDE）或其他 AI 工具。  </p>
</li>
<li><p><strong>MCP 客户端（MCP Clients）</strong><br>是与服务器保持 1:1 连接的协议客户端，负责与 MCP 服务器通信。  </p>
</li>
<li><p><strong>MCP 服务器（MCP Servers）</strong><br>是轻量级程序，每个服务器通过标准化的 Model Context Protocol 暴露特定功能。  </p>
</li>
<li><p><strong>本地数据源（Local Data Sources）</strong><br>指 MCP 服务器可以安全访问的计算机文件、数据库和服务。  </p>
</li>
<li><p><strong>远程服务（Remote Services）</strong><br>指 MCP 服务器可以通过互联网连接的外部系统（例如通过 API 访问的服务）。  </p>
</li>
</ul>
<p>整个 MCP 协议的核心在于服务器（Server）。对于熟悉计算机网络的人来说，主机（Host）和客户端（Client）的概念并不陌生，易于理解。</p>
<h2 id="MCP的工作流程"><a href="#MCP的工作流程" class="headerlink" title="MCP的工作流程"></a>MCP的工作流程</h2><p>从工作流程上看，MCP 确实与 LSP（Language Server Protocol）非常相似。实际上，目前的 MCP 和 LSP 一样，也是基于 JSON-RPC 2.0 进行数据传输的（可以通过 Stdio 或基于 SSE 实现）。这种设计选择并非偶然，而是为了充分利用 JSON-RPC 的灵活性和高效性，同时借鉴了 LSP 在开发工具领域的成功经验。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这里引用一下锦恢大佬的图：<br>假设我们的软件已经支持了 MCP 客户端，那么当我们的软件启动时，它会经历如下的步骤：<br><img src="image-2.png" alt="">  </p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>假设，你是一位 C语言工程师，你现在想要让 agent 自动完成一个项目的编译，那么执行流程如下：<br><img src="image-3.png" alt="">  </p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://kirigaya.cn/blog/article?seq=299">锦恢的博客</a></li>
<li><a href="https://guangzhengli.com/blog/zh/model-context-protocol#mcp-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%BA%90">MCP终极指南</a></li>
</ul>
]]></content>
      <categories>
        <category>大模型</category>
      </categories>
      <tags>
        <tag>大模型</tag>
        <tag>Agent</tag>
      </tags>
  </entry>
</search>
