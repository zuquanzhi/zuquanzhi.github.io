<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全之の博客</title>
  
  <subtitle>ME = Ctrl C + Ctrl V</subtitle>
  <link href="http://zuweicun.top/atom.xml" rel="self"/>
  
  <link href="http://zuweicun.top/"/>
  <updated>2024-09-16T14:17:11.075Z</updated>
  <id>http://zuweicun.top/</id>
  
  <author>
    <name>ZU Weicun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>yolo初步</title>
    <link href="http://zuweicun.top/2024/04/10/yolo%E5%88%9D%E6%AD%A5/"/>
    <id>http://zuweicun.top/2024/04/10/yolo%E5%88%9D%E6%AD%A5/</id>
    <published>2024-04-10T13:48:36.000Z</published>
    <updated>2024-09-16T14:17:11.075Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<br /><a href="https://towardsdatascience.com/chess-rolls-or-basketball-lets-create-a-custom-object-detection-model-ef53028eac7d">A simple way of creating a custom object detection model</a>（这个就是卓晴教程的原版）<br /><a href="https://blog.csdn.net/sinat_28371057/article/details/120598220?ops_request_misc=&request_id=&biz_id=102&utm_term=yolo5&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-120598220.142%5Ev99%5Econtrol&spm=1018.2226.3001.4187">YOLOv5的详细使用教程，以及使用yolov5训练自己的数据集_yolo5训练集-CSDN博客</a></p><p><a name="Ub0k6"></a></p><span id="more"></span><h1 id="使用预训练模型"><a href="#使用预训练模型" class="headerlink" title="使用预训练模型"></a>使用预训练模型</h1><p><a name="Ir8Je"></a></p><h2 id="安装环境依赖"><a href="#安装环境依赖" class="headerlink" title="安装环境依赖"></a>安装环境依赖</h2><p><a name="ucNeD"></a></p><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure><p>镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com.cnpmjs.org<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure><p><a name="LHIoW"></a></p><h2 id="必要环境"><a href="#必要环境" class="headerlink" title="必要环境"></a>必要环境</h2><p>官方给出的要求是：python&gt;&#x3D;3.7、PyTorch&gt;&#x3D;1.5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> yolov5</span><br><span class="line">pip install -U -r requirements.txt</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install -U -r requirements.txt</span></span><br><span class="line"><span class="attribute">Cython</span></span><br><span class="line"><span class="attribute">numpy</span>==<span class="number">1</span>.<span class="number">17</span></span><br><span class="line"><span class="attribute">opencv</span>-python</span><br><span class="line"><span class="attribute">torch</span>&gt;=<span class="number">1</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">matplotlib</span></span><br><span class="line"><span class="attribute">pillow</span></span><br><span class="line"><span class="attribute">tensorboard</span></span><br><span class="line"><span class="attribute">PyYAML</span>&gt;=<span class="number">5</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">torchvision</span></span><br><span class="line"><span class="attribute">scipy</span></span><br><span class="line"><span class="attribute">tqdm</span></span><br><span class="line"><span class="attribute">git</span>+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Nvidia Apex (optional) for mixed precision training --------------------------</span></span><br><span class="line"><span class="comment"># git clone https://github.com/NVIDIA/apex &amp;&amp; cd apex &amp;&amp; pip install -v --no-cache-dir --global-option=&quot;--cpp_ext&quot; --global-option=&quot;--cuda_ext&quot; . --user &amp;&amp; cd .. &amp;&amp; rm -rf apex</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Conda commands (in place of pip) ---------------------------------------------</span></span><br><span class="line"><span class="comment"># conda update -yn base -c defaults conda</span></span><br><span class="line"><span class="comment"># conda install -yc anaconda numpy opencv matplotlib tqdm pillow ipython</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge scikit-image pycocotools tensorboard</span></span><br><span class="line"><span class="comment"># conda install -yc spyder-ide spyder-line-profiler</span></span><br><span class="line"><span class="comment"># conda install -yc pytorch pytorch torchvision</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge protobuf numpy &amp;&amp; pip install onnx  # https://github.com/onnx/onnx#linux-and-macos</span></span><br></pre></td></tr></table></figure><p><a name="Lpb3W"></a></p><h2 id="下载预训练模型和标注数据集"><a href="#下载预训练模型和标注数据集" class="headerlink" title="下载预训练模型和标注数据集"></a>下载预训练模型和标注数据集</h2><p><a name="VMqUW"></a></p><h3 id="执行脚本下载模型"><a href="#执行脚本下载模型" class="headerlink" title="执行脚本下载模型"></a>执行脚本下载模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Download common models</span></span><br><span class="line"> </span><br><span class="line">python3 -c <span class="string">&quot;from utils.google_utils import *;</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5s.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5m.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5l.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5x.pt&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p>（attempt_download函数在&#x2F;yolov5&#x2F;utils&#x2F;google_utils.py脚本中定义）<br><a name="rFxrZ"></a></p><h3 id="下载标注数据集"><a href="#下载标注数据集" class="headerlink" title="下载标注数据集"></a>下载标注数据集</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">python3</span> -c <span class="string">&quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span> <span class="comment"># download dataset</span></span><br></pre></td></tr></table></figure><p>执行上面的代码，会下载：coco128.zip数据集，该数据是COCO train2017数据的一部分，只取了coco数据集中的128张标注的图片，coco128.zip下载完后解压到&#x2F;yolov5目录下即可，解压后的coco128文件结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coco128</span><br><span class="line"><span class="operator">|</span><span class="comment">-- LICENSE</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- README.txt  # 相关说明</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- annotations  # 空目录</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- images   # 128张jpg图片</span></span><br><span class="line">`<span class="comment">-- labels  # 128张标注的txt文件</span></span><br></pre></td></tr></table></figure><p>&#x2F;yolov5&#x2F;utils&#x2F;google_utils.py脚本是下载预训练模型和标注的训练数据集，该脚本代码内容如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"># This file <span class="keyword">contains</span> google utils: https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>reference<span class="operator">/</span>libraries</span><br><span class="line"># pip install <span class="comment">--upgrade google-cloud-storage</span></span><br><span class="line"># <span class="keyword">from</span> google.cloud import storage</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line">import <span class="type">time</span></span><br><span class="line"><span class="keyword">from</span> pathlib import Path</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def attempt_download(weights):</span><br><span class="line">    # Attempt <span class="keyword">to</span> download pretrained weights if <span class="keyword">not</span> found locally</span><br><span class="line">    weights <span class="operator">=</span> weights.strip()</span><br><span class="line">    msg <span class="operator">=</span> weights <span class="operator">+</span> <span class="string">&#x27; missing, try downloading from https://drive.google.com/drive/folders/1Drs_Aiu7xx6S-ix95f9kNsA6ueKRpN2J&#x27;</span></span><br><span class="line"> </span><br><span class="line">    r <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    if len(weights) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> os.path.isfile(weights):</span><br><span class="line">        d <span class="operator">=</span> &#123;<span class="string">&#x27;yolov3-spp.pt&#x27;</span>: <span class="string">&#x27;1mM67oNw4fZoIOL1c8M3hHmj66d8e-ni_&#x27;</span>,  # yolov3<span class="operator">-</span>spp.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5s.pt&#x27;</span>: <span class="string">&#x27;1R5T6rIyy3lLwgFXNms8whc-387H0tMQO&#x27;</span>,  # yolov5s.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5m.pt&#x27;</span>: <span class="string">&#x27;1vobuEExpWQVpXExsJ2w-Mbf3HJjWkQJr&#x27;</span>,  # yolov5m.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5l.pt&#x27;</span>: <span class="string">&#x27;1hrlqD1Wdei7UT4OgT785BEk1JwnSvNEV&#x27;</span>,  # yolov5l.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5x.pt&#x27;</span>: <span class="string">&#x27;1mM8aZJlWTxOg7BZJvNUMrTnA2AbeCVzS&#x27;</span>,  # yolov5x.yaml</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">        file <span class="operator">=</span> Path(weights).name</span><br><span class="line">        if file <span class="keyword">in</span> d:</span><br><span class="line">            r <span class="operator">=</span> gdrive_download(id<span class="operator">=</span>d[file], name<span class="operator">=</span>weights)</span><br><span class="line"> </span><br><span class="line">        if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">            os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">            s <span class="operator">=</span> &quot;curl -L -o %s &#x27;https://storage.googleapis.com/ultralytics/yolov5/ckpt/%s&#x27;&quot; <span class="operator">%</span> (weights, file)</span><br><span class="line">            r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line"> </span><br><span class="line">            # Error <span class="keyword">check</span></span><br><span class="line">            if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">                os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">                raise Exception(msg)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def gdrive_download(id<span class="operator">=</span><span class="string">&#x27;1HaXkef9z6y5l4vUnCYgdmEAj61c6bfWO&#x27;</span>, name<span class="operator">=</span><span class="string">&#x27;coco.zip&#x27;</span>):</span><br><span class="line">    # https:<span class="operator">/</span><span class="operator">/</span>gist.github.com<span class="operator">/</span>tanaikech<span class="operator">/</span>f0f2d122e05bf5f971611258c22c110f</span><br><span class="line">    # Downloads a file <span class="keyword">from</span> Google Drive, accepting presented query</span><br><span class="line">    # <span class="keyword">from</span> utils.google_utils import <span class="operator">*</span>; gdrive_download()</span><br><span class="line">    t <span class="operator">=</span> time.time()</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Downloading https://drive.google.com/uc?export=download&amp;id=%s as %s... &#x27;</span> <span class="operator">%</span> (id, name), <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove existing</span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Attempt file download</span><br><span class="line">    os.system(&quot;curl -c ./cookie -s -L \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; &gt; /dev/null&quot; <span class="operator">%</span> id)</span><br><span class="line">    if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>):  # <span class="keyword">large</span> file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -Lb ./cookie \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>confirm<span class="operator">=</span>`awk <span class="string">&#x27;/download/ &#123;print $NF&#125;&#x27;</span> .<span class="operator">/</span>cookie`<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; -o %s&quot; <span class="operator">%</span> (</span><br><span class="line">            id, name)</span><br><span class="line">    <span class="keyword">else</span>:  # small file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -s -L -o %s &#x27;https://drive.google.com/uc?export=download&amp;id=%s&#x27;&quot; <span class="operator">%</span> (name, id)</span><br><span class="line">    r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Error <span class="keyword">check</span></span><br><span class="line">    if r <span class="operator">!=</span> <span class="number">0</span>:</span><br><span class="line">        os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial</span><br><span class="line">        print(<span class="string">&#x27;Download error &#x27;</span>)  # raise Exception(<span class="string">&#x27;Download error&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line">    # Unzip if archive</span><br><span class="line">    if name.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;unzipping... &#x27;</span>, <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        os.system(<span class="string">&#x27;unzip -q %s&#x27;</span> <span class="operator">%</span> name)  # unzip</span><br><span class="line">        os.remove(name)  # remove zip <span class="keyword">to</span> <span class="keyword">free</span> space</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Done (%.1fs)&#x27;</span> <span class="operator">%</span> (time.time() <span class="operator">-</span> t))</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line"># def upload_blob(bucket_name, source_file_name, destination_blob_name):</span><br><span class="line">#     # Uploads a file <span class="keyword">to</span> a bucket</span><br><span class="line">#     # https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>uploading<span class="operator">-</span>objects#storage<span class="operator">-</span>upload<span class="operator">-</span>object<span class="operator">-</span>python</span><br><span class="line">#</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(destination_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.upload_from_filename(source_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;File &#123;&#125; uploaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_file_name,</span><br><span class="line">#         destination_blob_name))</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># def download_blob(bucket_name, source_blob_name, destination_file_name):</span><br><span class="line">#     # Uploads a <span class="type">blob</span> <span class="keyword">from</span> a bucket</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(source_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.download_to_filename(destination_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;Blob &#123;&#125; downloaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_blob_name,</span><br><span class="line">#         destination_file_name))</span><br></pre></td></tr></table></figure><p><a name="FqoFo"></a></p><h2 id="训练下载的coco128数据集"><a href="#训练下载的coco128数据集" class="headerlink" title="训练下载的coco128数据集"></a>训练下载的coco128数据集</h2><p>创建训练数据集的配置文件Dataset.yaml<br />上面下载好coco128.zip小型数据集之后，这些数据集可以用于训练和验证<br />&#x2F;content&#x2F;yolov5&#x2F;models&#x2F;yolov5l.yaml。coco128.yaml中定义了：<br />训练图片的路径（或训练图片列表的.txt文件）<br />与验证集相同的图片<br />目标的类别数<br />类名列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># COCO <span class="number">2017</span> dataset http:<span class="operator">/</span><span class="operator">/</span>cocodataset.org <span class="operator">-</span> <span class="keyword">first</span> <span class="number">128</span> training images</span><br><span class="line"># Download command:  python <span class="operator">-</span>c &quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span><br><span class="line"># Train command: python train.py <span class="comment">--data ./data/coco128.yaml</span></span><br><span class="line"># Dataset should be placed next <span class="keyword">to</span> yolov5 folder:</span><br><span class="line">#   <span class="operator">/</span>parent_folder</span><br><span class="line">#     <span class="operator">/</span>coco128</span><br><span class="line">#     <span class="operator">/</span>yolov5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 训练集和验证集 （图片的目录路径或 <span class="operator">*</span>.txt图片路径）</span><br><span class="line">train: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line">val: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line"> </span><br><span class="line"># 类别数 number <span class="keyword">of</span> classes</span><br><span class="line">nc: <span class="number">80</span></span><br><span class="line"> </span><br><span class="line"># 类别列表 class names</span><br><span class="line">names: [<span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;motorcycle&#x27;</span>, <span class="string">&#x27;airplane&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, <span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;traffic light&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;fire hydrant&#x27;</span>, <span class="string">&#x27;stop sign&#x27;</span>, <span class="string">&#x27;parking meter&#x27;</span>, <span class="string">&#x27;bench&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;elephant&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>, <span class="string">&#x27;giraffe&#x27;</span>, <span class="string">&#x27;backpack&#x27;</span>, <span class="string">&#x27;umbrella&#x27;</span>, <span class="string">&#x27;handbag&#x27;</span>, <span class="string">&#x27;tie&#x27;</span>, <span class="string">&#x27;suitcase&#x27;</span>, <span class="string">&#x27;frisbee&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;skis&#x27;</span>, <span class="string">&#x27;snowboard&#x27;</span>, <span class="string">&#x27;sports ball&#x27;</span>, <span class="string">&#x27;kite&#x27;</span>, <span class="string">&#x27;baseball bat&#x27;</span>, <span class="string">&#x27;baseball glove&#x27;</span>, <span class="string">&#x27;skateboard&#x27;</span>, <span class="string">&#x27;surfboard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;tennis racket&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;wine glass&#x27;</span>, <span class="string">&#x27;cup&#x27;</span>, <span class="string">&#x27;fork&#x27;</span>, <span class="string">&#x27;knife&#x27;</span>, <span class="string">&#x27;spoon&#x27;</span>, <span class="string">&#x27;bowl&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sandwich&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;broccoli&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>, <span class="string">&#x27;hot dog&#x27;</span>, <span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;donut&#x27;</span>, <span class="string">&#x27;cake&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;couch&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;potted plant&#x27;</span>, <span class="string">&#x27;bed&#x27;</span>, <span class="string">&#x27;dining table&#x27;</span>, <span class="string">&#x27;toilet&#x27;</span>, <span class="string">&#x27;tv&#x27;</span>, <span class="string">&#x27;laptop&#x27;</span>, <span class="string">&#x27;mouse&#x27;</span>, <span class="string">&#x27;remote&#x27;</span>, <span class="string">&#x27;keyboard&#x27;</span>, <span class="string">&#x27;cell phone&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;microwave&#x27;</span>, <span class="string">&#x27;oven&#x27;</span>, <span class="string">&#x27;toaster&#x27;</span>, <span class="string">&#x27;sink&#x27;</span>, <span class="string">&#x27;refrigerator&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;clock&#x27;</span>, <span class="string">&#x27;vase&#x27;</span>, <span class="string">&#x27;scissors&#x27;</span>, <span class="string">&#x27;teddy bear&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;hair drier&#x27;</span>, <span class="string">&#x27;toothbrush&#x27;</span>]</span><br></pre></td></tr></table></figure><p><a name="cCzV7"></a></p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>对数据集进行打标签，可以选择如下两种打标工具：<br />Labelbox<br />CVAT<br />也可以使用LabelImg，选用ylolo格式进行标注<br />将标签导出为darknet格式，每个标注图像有一个*.txt文件（如果图像中没有对象，则不需要*.txt文件），*.txt文件格式如下：</p><p>每行一个对象<br />每行都是：class x_center y_center width height格式<br />框的坐标格式必须采用归一化格式的xywh（从0到1），如果你框以像素为单位，则将x_center和width除以图像宽度，将y_center和height除以图像的高度<br />类别是从索引0开始的<br />通过在器路径名中将&#x2F;images&#x2F;<em>.jpg替换为&#x2F;label&#x2F;</em>.txt，可以定位每个图像的标签文件，示例图像和标签对为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>jpg  # image</span><br><span class="line">dataset<span class="operator">/</span>labels<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>txt  # label</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">45</span> <span class="number">0.479492</span> <span class="number">0.688771</span> <span class="number">0.955609</span> <span class="number">0.5955</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.736516</span> <span class="number">0.247188</span> <span class="number">0.498875</span> <span class="number">0.476417</span></span><br><span class="line"><span class="number">50</span> <span class="number">0.637063</span> <span class="number">0.732938</span> <span class="number">0.494125</span> <span class="number">0.510583</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.339438</span> <span class="number">0.418896</span> <span class="number">0.678875</span> <span class="number">0.7815</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.646836</span> <span class="number">0.132552</span> <span class="number">0.118047</span> <span class="number">0.096937</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.773148</span> <span class="number">0.129802</span> <span class="number">0.090734</span> <span class="number">0.097229</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.668297</span> <span class="number">0.226906</span> <span class="number">0.131281</span> <span class="number">0.146896</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.642859</span> <span class="number">0.079219</span> <span class="number">0.148063</span> <span class="number">0.148062</span></span><br></pre></td></tr></table></figure><p><a name="Fk4Lk"></a></p><h2 id="组织文件结构"><a href="#组织文件结构" class="headerlink" title="组织文件结构"></a>组织文件结构</h2><p><strong><em>&#x2F;coco128目录应该和yolov5目录同级，同时确保coco128&#x2F;labels和coco128&#x2F;images两个目录同级</em></strong><br><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/4cc9eb4348385e98b15dc0f5db0dc95.png" alt="4cc9eb4348385e98b15dc0f5db0dc95"></p><h2 id="选择训练模型"><a href="#选择训练模型" class="headerlink" title="选择训练模型"></a>选择训练模型</h2><p>上面已经修改了自定义数据集的配置文件，同时组织好了数据。下面就可以选择一个模型进行训练了。</p><p>从.&#x2F;models目录下选择一个模型的配置文件，这里我们选择yolov5s.ymal，这是一个最小最快的模型。关于其他模型之间的比较下面介绍。选择好模型之后，如果你使用的不是coco数据集进行训练，而是自定义的数据集，此时只需要修改*.yaml配置文件中的nc: 80参数和数据的类别列表</p><p>下面是yolo5s.ymal配置文件的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># parameters</span><br><span class="line">nc: <span class="number">80</span>  # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span>  # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span>  # layer channel multiple</span><br><span class="line"> </span><br><span class="line"># anchors</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line"> </span><br><span class="line"># YOLOv5 backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, Focus, [<span class="number">64</span>, <span class="number">3</span>]],  # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">128</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">256</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">512</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, SPP, [<span class="number">1024</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>]]],</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"># YOLOv5 head</span><br><span class="line">head:</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],  # <span class="number">9</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],  # <span class="number">13</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P3</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">256</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">18</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">22</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P5</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">26</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"> </span><br><span class="line">   [[], <span class="number">1</span>, Detect, [nc, anchors]],  # Detect(P5, P4, P3)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>yolov5s.yaml配置文件中主要定义了：</p><ul><li>参数（parameters）：类别等</li><li>anchor</li><li>YOLOv5 backbone</li><li>YOLOv5 head</li></ul><p><a name="tQOKw"></a></p><h2 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h2><p>运行下面的命令训练coco128.ymal，训练5epochs。可以有两种训练方式，如下参数：</p><p>–cfg yolov5s.yaml –weights ‘’：从头开始训练<br />–cfg yolov5s.yaml –weights yolov5s.pt：从预训练的模型加载开始训练<br />YOLOv5在coco128上训练5epochs的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 16 --epochs 5 --data ./data/coco128.yaml --cfg ./models/yolov5s.yaml --weights &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>训练的更多可选参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--epochs：训练的epoch，默认值300</span></span><br><span class="line"><span class="comment">--batch-size：默认值16</span></span><br><span class="line"><span class="comment">--cfg：模型的配置文件，默认为yolov5s.yaml</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco128.yaml</span></span><br><span class="line"><span class="comment">--img-size：训练和测试输入大小，默认为[640, 640]</span></span><br><span class="line"><span class="comment">--rect：rectangular training，布尔值</span></span><br><span class="line"><span class="comment">--resume：是否从最新的last.pt中恢复训练，布尔值</span></span><br><span class="line"><span class="comment">--nosave：仅仅保存最后的checkpoint，布尔值</span></span><br><span class="line"><span class="comment">--notest：仅仅在最后的epoch上测试，布尔值</span></span><br><span class="line"><span class="comment">--evolve：进化超参数（evolve hyperparameters），布尔值</span></span><br><span class="line"><span class="comment">--bucket：gsutil bucket，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--cache-images：缓存图片可以更快的开始训练，布尔值</span></span><br><span class="line"><span class="comment">--weights：初始化参数路径，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--name：如果提供，将results.txt重命名为results_name.txt</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--adam：使用adam优化器，布尔值</span></span><br><span class="line"><span class="comment">--multi-scale：改变图片尺寸img-size +/0- 50%，布尔值</span></span><br><span class="line"><span class="comment">--single-cls：训练单个类别的数据集，布尔值</span></span><br></pre></td></tr></table></figure><p><a name="ZacJ9"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试的更多可选参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--weights ：预训练模型路径，默认值weights/yolov5s.pt</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco.yaml</span></span><br><span class="line"><span class="comment">--batch-size：默认值32</span></span><br><span class="line"><span class="comment">--img-size：推理大小（pixels），默认640</span></span><br><span class="line"><span class="comment">--conf-thres：目标置信度阈值，默认0.001</span></span><br><span class="line"><span class="comment">--iou-thres：NMS的IOU阈值，默认0.65</span></span><br><span class="line"><span class="comment">--save-json：把结果保存为cocoapi-compatible的json文件</span></span><br><span class="line"><span class="comment">--task：默认val，可选其他值：val, test, study</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--half：半精度的FP16推理</span></span><br><span class="line"><span class="comment">--single-cls：将其视为单类别，布尔值</span></span><br><span class="line"><span class="comment">--augment：增强推理，布尔值</span></span><br><span class="line"><span class="comment">--verbose：显示类别的mAP，布尔值</span></span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py <span class="comment">--weights yolov5s.pt --data ./data/coco.yaml --img 640</span></span><br></pre></td></tr></table></figure><p><a name="t0dKT"></a></p><h1 id="实现yolo自由（自训练模型）"><a href="#实现yolo自由（自训练模型）" class="headerlink" title="实现yolo自由（自训练模型）"></a>实现yolo自由（自训练模型）</h1><p>上面的都是官方给出的训练模型，我也尝试了一下训练自己的。<br><a name="Jqm55"></a></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>首先是image的手框转换成yolo文件，我使用的是清华小丑（bushi）给的开源工具<a href="https://www.makesense.ai/">https://www.makesense.ai/</a>生成的。（由于小车上的回传节点还没开始写就用手机try一下）<br><a name="Y2qP3"></a></p><h2 id="yolo环境配置"><a href="#yolo环境配置" class="headerlink" title="yolo环境配置"></a>yolo环境配置</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="operator">/</span><span class="operator">/</span>github.com<span class="operator">/</span>ultralytics<span class="operator">/</span>yolov5 # clone repo</span><br></pre></td></tr></table></figure><p>同上，不过目录结构似乎不太一样(尤其是datasets的部分，差异太多我干脆直接提出来了)<br /></p><p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/f299a1faae42c3dfa23869900cfc571.png" alt="f299a1faae42c3dfa23869900cfc571"></p><p>数据集标注好之后，存放如下目录格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$ tree hat_hair_beard</span><br><span class="line">hat_hair_beard</span><br><span class="line">├── images</span><br><span class="line">│   ├── train2017        # 训练集图片，这里我只列举几张示例</span><br><span class="line">│   │   ├── <span class="number">000050.</span>jpg</span><br><span class="line">│   │   ├── <span class="number">000051.</span>jpg</span><br><span class="line">│   │   └── <span class="number">000052.</span>jpg</span><br><span class="line">│   └── val2017          # 验证集图片</span><br><span class="line">│       ├── <span class="number">001800.</span>jpg</span><br><span class="line">│       ├── <span class="number">001801.</span>jpg</span><br><span class="line">│       └── <span class="number">001802.</span>jpg</span><br><span class="line">└── labels               </span><br><span class="line">    ├── train2017       # 训练集的标签文件</span><br><span class="line">    │   ├── <span class="number">000050.</span>txt</span><br><span class="line">    │   ├── <span class="number">000051.</span>txt</span><br><span class="line">    │   └── <span class="number">000052.</span>txt</span><br><span class="line">    └── val2017         # 验证集的标签文件</span><br><span class="line">        ├── <span class="number">001800.</span>txt</span><br><span class="line">        ├── <span class="number">001801.</span>txt</span><br><span class="line">        └── <span class="number">001802.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">6</span> directories, <span class="number">13</span> files</span><br><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$</span><br></pre></td></tr></table></figure><p><a name="UTe92"></a></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><a name="RF2a3"></a></p><h3 id="数据配置文件"><a href="#数据配置文件" class="headerlink" title="数据配置文件"></a>数据配置文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"># COCO128 dataset https:<span class="operator">/</span><span class="operator">/</span>www.kaggle.com<span class="operator">/</span>ultralytics<span class="operator">/</span>coco128 (<span class="keyword">first</span> <span class="number">128</span> images <span class="keyword">from</span> COCO train2017) <span class="keyword">by</span> Ultralytics</span><br><span class="line"># Example usage: python train.py <span class="comment">--data coco128.yaml</span></span><br><span class="line"># parent</span><br><span class="line"># ├── yolov5</span><br><span class="line"># └── datasets</span><br><span class="line">#     └── coco128  ← downloads here (<span class="number">7</span> MB)</span><br><span class="line"></span><br><span class="line"># Train<span class="operator">/</span>val<span class="operator">/</span>test sets <span class="keyword">as</span> <span class="number">1</span>) dir: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs, <span class="number">2</span>) file: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs.txt, <span class="keyword">or</span> <span class="number">3</span>) list: [path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs1, path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs2, ..]</span><br><span class="line">path: .<span class="operator">/</span>datasets # dataset root dir</span><br><span class="line">train: images<span class="operator">/</span>train_test # train images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">val: images<span class="operator">/</span>val_test # val images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">test: # test images (optional)</span><br><span class="line"></span><br><span class="line"># Classes</span><br><span class="line">names:</span><br><span class="line">  <span class="number">0</span>: dijia</span><br><span class="line"></span><br><span class="line"># Download script<span class="operator">/</span>URL (optional)</span><br><span class="line">#download: https:<span class="operator">/</span><span class="operator">/</span>ultralytics.com<span class="operator">/</span>assets<span class="operator">/</span>coco128.zip</span><br></pre></td></tr></table></figure><p>主要修改了train和val的路径，以及names的数量和名称（用于测试）<br><a name="fMVyi"></a></p><h3 id="模型配置文件"><a href="#模型配置文件" class="headerlink" title="模型配置文件"></a>模型配置文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"></span><br><span class="line"># Parameters</span><br><span class="line">nc: <span class="number">1</span> # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span> # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span> # layer channel multiple</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>] # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>] # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>] # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">64</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>]], # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">128</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">6</span>, C3, [<span class="number">256</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">9</span>, C3, [<span class="number">512</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, SPPF, [<span class="number">1024</span>, <span class="number">5</span>]], # <span class="number">9</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> head</span><br><span class="line">head: [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P3</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">256</span>, <span class="literal">False</span>]], # <span class="number">17</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">20</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P5</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>, <span class="literal">False</span>]], # <span class="number">23</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"></span><br><span class="line">    [[<span class="number">17</span>, <span class="number">20</span>, <span class="number">23</span>], <span class="number">1</span>, Detect, [nc, anchors]], # Detect(P3, P4, P5)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>这里改个nc就行了（数据集的类别数）<br><a name="ShPbp"></a></p><h2 id="开始训练-1"><a href="#开始训练-1" class="headerlink" title="开始训练"></a>开始训练</h2><p>在终端输入以下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 8 --epochs 300 --data ./data/test.yaml --cfg ./models/test.yaml --weights ./weights/yolov5s.pt --device cpu</span></span><br></pre></td></tr></table></figure><p>各个参数作用：</p><ul><li>img：640×640</li><li>batch：类别</li><li>epochs：训练迭代次数</li><li>data：数据配置文件位置</li><li>cfg：模型配置文件位置</li><li>weights： 训练权重数据，如果本地没有的话应该会自动下载，以开始训练</li><li>device： 这个还没搞明白 正常来说是应该调用gpu的，但是我的驱动似乎有点问题，故 cpu，启动！</li></ul><p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/a5aa4e4d73279a6ea804ffc393a818b.png" alt="a5aa4e4d73279a6ea804ffc393a818b"></p><p>训练结束后，会生成两个预训练的模型：</p><ul><li>best.pt：保存的是中间一共比较好模型</li><li>last.pt：训练结束后保存的最后模型</li></ul><p>尽量把最终训练的模型保存拷贝一份，防止下载再训练给覆盖，白玩<br><a name="g8lUK"></a></p><h3 id="浅浅展示训练成果"><a href="#浅浅展示训练成果" class="headerlink" title="浅浅展示训练成果"></a>浅浅展示训练成果</h3><p><br /><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/d3b58a358174697795bb89c1d86d4bb.png" alt="d3b58a358174697795bb89c1d86d4bb"></p><p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/4edb813049a6da8f7e926d72ebb0357.png" alt="4edb813049a6da8f7e926d72ebb0357"></p><p><img src="/2024/04/10/yolo%E5%88%9D%E6%AD%A5/d164b7d5fd9b273031ec37aca0e9872.png" alt="d164b7d5fd9b273031ec37aca0e9872"></p><h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 detect.py <span class="comment">--source ./data/images/image_9.png --weights ./weights/best.pt --device cpu</span></span><br></pre></td></tr></table></figure><p>由于数据量较小，准确率较低，就不放图了）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考文献：&lt;br /&gt;&lt;a href=&quot;https://towardsdatascience.com/chess-rolls-or-basketball-lets-create-a-custom-object-detection-model-ef53028eac7d&quot;&gt;A simple way of creating a custom object detection model&lt;/a&gt;（这个就是卓晴教程的原版）&lt;br /&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_28371057/article/details/120598220?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=yolo5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-120598220.142%5Ev99%5Econtrol&amp;spm=1018.2226.3001.4187&quot;&gt;YOLOv5的详细使用教程，以及使用yolov5训练自己的数据集_yolo5训练集-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;Ub0k6&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="yolo" scheme="http://zuweicun.top/tags/yolo/"/>
    
  </entry>
  
  <entry>
    <title>高精度算法</title>
    <link href="http://zuweicun.top/2024/04/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>http://zuweicun.top/2024/04/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/</id>
    <published>2024-04-02T02:55:06.000Z</published>
    <updated>2024-09-16T14:17:29.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h1><p>在处理数据的时候经常需要用到一些无比巨大的数，比如41856410684191645611这种的，或者是十进制的二进制转化，显然cpp里不能直接用int存放这些数据，然而long类型也是有上限的，这时就需要引入一个新的算法，叫做高精度算法</p><span id="more"></span><h2 id="算法本质思想"><a href="#算法本质思想" class="headerlink" title="算法本质思想"></a>算法本质思想</h2><p>感觉多数思路就是用数组之类的容器存放数据，采用最原始的方式一点点进位计算之类的。（果然高端的食材往往采用最朴素的烹饪方式）。</p><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><p>高精度计算中有几个细节需要注意：</p><ul><li><p>数据接受和储存： 当输入的数很长时，可以使用字符串方式输入和储存，再用字符串函数进行操作运算，将每一位去取出，存入数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init(<span class="type">int</span> a[]) &#123; <span class="comment">// 传入数组</span></span><br><span class="line">    <span class="type">string</span> s;</span><br><span class="line">    cin &gt;&gt; s; </span><br><span class="line">    <span class="built_in">len</span> = s.length(); <span class="comment">// s.length --&gt; 计算字符串位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">len</span>; i++)     </span><br><span class="line">        a[i] = s[<span class="built_in">len</span> -i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//将字符串s转换为数组a, 倒序存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进位错位处理：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 加法进位: c[i] = a[i] + b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i] <span class="comment">%= 10;</span></span><br><span class="line">            ++c[i++];</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">//减法借位: c[i] = a[i] - b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(a[i] &lt; b[i]) &#123;</span><br><span class="line">             --a[i+<span class="number">1</span>];</span><br><span class="line">             a[i] += <span class="number">10</span>;   </span><br><span class="line">         &#125; </span><br><span class="line"> </span><br><span class="line">//乘法进位: c[i + j - <span class="number">1</span>] = a[i] * b[j] + x + c[i + j - <span class="number">1</span>];</span><br><span class="line">          x = c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">          c[i + j - <span class="number">1</span>] <span class="comment">% 10;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="高精度加法："><a href="#高精度加法：" class="headerlink" title="高精度加法："></a>高精度加法：</h3><p>输入两个数到变量中，然后用赋值语句求它们的和后输出 . But，我们知道，在 C++ 语言中任何数据类型都有一定表示范围. 当两个加数很大时，以前的算法显然不能求出精确解，因此我们需要寻求另一种方法 .在读小学时，我们做加法都采用竖式方法 . 这样我们方便写出两个整数相加的算法 .</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度加法</span></span><br><span class="line"><span class="keyword">string</span> add(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = digit1 + digit2 + carry;</span><br><span class="line">        carry = s / <span class="number">10</span>;</span><br><span class="line">        sum = to_string(s % <span class="number">10</span>) + sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度减法</span></span><br><span class="line"><span class="keyword">string</span> subtract(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> borrow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> diff = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d = digit1 - digit2 - borrow;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d += <span class="number">10</span>;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        diff = to_string(d) + diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除前导零</span></span><br><span class="line">    diff.erase(<span class="number">0</span>, diff.find_first_not_of(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> (diff == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度乘法</span></span><br><span class="line"><span class="keyword">string</span> multiply(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; result(n1 + n2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = mul + result[i + j + <span class="number">1</span>];</span><br><span class="line">            result[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">            result[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换为字符串</span></span><br><span class="line">    <span class="keyword">string</span> product = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(product.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123;  <span class="comment">// 忽略前导零</span></span><br><span class="line">            product += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (product == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 高精度除法（除以低精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, int&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, int divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    int <span class="built_in">remainder</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (char digit : dividend) &#123;</span><br><span class="line">        int <span class="built_in">num</span> = digit - &#x27;<span class="number">0</span>&#x27; + <span class="built_in">remainder</span> * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">quotient</span> += to_string(<span class="built_in">num</span> / divisor);</span><br><span class="line">        <span class="built_in">remainder</span> = <span class="built_in">num</span> <span class="symbol">%</span> divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="高精度除以高精度"><a href="#高精度除以高精度" class="headerlink" title="高精度除以高精度"></a>高精度除以高精度</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 高精度除法（除以高精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, <span class="built_in">string</span> divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;0&quot;</span>, <span class="built_in">remainder</span> = dividend;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">remainder</span>.size() &gt;= divisor.size() &amp;&amp; <span class="built_in">remainder</span> &gt;= divisor) &#123;</span><br><span class="line">        int n = <span class="built_in">remainder</span>.size() - divisor.size();</span><br><span class="line">        <span class="built_in">string</span> temp = divisor;</span><br><span class="line">        temp.<span class="built_in">append</span>(n, &#x27;<span class="number">0</span>&#x27;); // 补零</span><br><span class="line">        int count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">remainder</span> &gt;= temp) &#123;</span><br><span class="line">            <span class="built_in">remainder</span> = subtract(<span class="built_in">remainder</span>, temp);</span><br><span class="line">            <span class="built_in">quotient</span> = add(<span class="built_in">quotient</span>, <span class="string">&quot;1&quot;</span> + <span class="built_in">string</span>(n, &#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">remainder</span>.erase(<span class="number">0</span>, <span class="built_in">remainder</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, (<span class="built_in">remainder</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位技巧"><a href="#压位技巧" class="headerlink" title="压位技巧"></a>压位技巧</h3><p>谁说数组每个元素只能是一位数？显然这会造成巨大的浪费。<br>这时我们就可以使用压位的技巧来节省运行时间。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压位技巧高精度加法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span>(<span class="params"><span class="built_in">string</span> num1, <span class="built_in">string</span> num2</span>)</span> &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">result</span>(<span class="params">max(num1.size(</span>), num2.<span class="title">size</span>()) + 1, 0)</span>; <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="built_in">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="built_in">int</span> i = num1.size() - <span class="number">1</span>, j = num2.size() - <span class="number">1</span>, k = result.size() - <span class="number">1</span>; <span class="comment">// 从个位开始相加</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="built_in">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num1的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num2的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> sum = digit1 + digit2 + carry; <span class="comment">// 当前位的和</span></span><br><span class="line">        result[k--] = sum % <span class="number">10</span>; <span class="comment">// 将当前位的和放入结果数组</span></span><br><span class="line">        carry = sum / <span class="number">10</span>; <span class="comment">// 更新进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换结果数组为字符串</span></span><br><span class="line">    <span class="built_in">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(sum.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123; <span class="comment">// 忽略前导零</span></span><br><span class="line">            sum += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : sum; <span class="comment">// 如果结果为空字符串，则返回&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> num1 = <span class="string">&quot;123456789012345678901234567890&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> num2 = <span class="string">&quot;987654321098765432109876543210&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;高精度加法结果：&quot;</span> &lt;&lt; <span class="keyword">add</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总之大多数需要根据现实情况变通。。。。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高精度算法&quot;&gt;&lt;a href=&quot;#高精度算法&quot; class=&quot;headerlink&quot; title=&quot;高精度算法&quot;&gt;&lt;/a&gt;高精度算法&lt;/h1&gt;&lt;p&gt;在处理数据的时候经常需要用到一些无比巨大的数，比如41856410684191645611这种的，或者是十进制的二进制转化，显然cpp里不能直接用int存放这些数据，然而long类型也是有上限的，这时就需要引入一个新的算法，叫做高精度算法&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://zuweicun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高精度" scheme="http://zuweicun.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>离散数学（2）</title>
    <link href="http://zuweicun.top/2024/03/30/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%882%EF%BC%89/"/>
    <id>http://zuweicun.top/2024/03/30/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%882%EF%BC%89/</id>
    <published>2024-03-30T03:34:30.000Z</published>
    <updated>2024-09-16T14:17:43.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="离散数学基础（2）"><a href="#离散数学基础（2）" class="headerlink" title="离散数学基础（2）"></a>离散数学基础（2）</h2><p>本篇博客简单理解一下各种映射的本质</p><span id="more"></span><p>对于一个映射A→B：</p><ul><li><p>单射：</p><ul><li>类似于函数的一一对应性质，不包括多对一的情况。限制于A集合，即B集合可以有元未被映射</li><li><img src="https://pic3.zhimg.com/80/v2-070562850aaee357be93a2a67c794a36_1440w.webp" alt="img"></li></ul></li><li><p>满射：</p><ul><li>即把B中的所有元都用上，主要限制于B集合，即A集合可以不指向B的元</li><li><img src="https://pic4.zhimg.com/80/v2-a7d76ec834eee4adb7df74857a3b8a07_1440w.webp" alt="img"></li></ul></li><li><p>双射：</p><ul><li>既是单射又是满射，严格的一一对应关系。</li><li><img src="https://pic2.zhimg.com/80/v2-c13f789dab192de9ca2ed763995a956d_1440w.webp" alt="img"></li></ul></li></ul><p>接着是逆映射的概念：</p><p>只有双射才可以定义逆映射。类比于函数的可逆函数。</p><p>复合映射：</p><p>类比于复合函数。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;离散数学基础（2）&quot;&gt;&lt;a href=&quot;#离散数学基础（2）&quot; class=&quot;headerlink&quot; title=&quot;离散数学基础（2）&quot;&gt;&lt;/a&gt;离散数学基础（2）&lt;/h2&gt;&lt;p&gt;本篇博客简单理解一下各种映射的本质&lt;/p&gt;</summary>
    
    
    
    <category term="数学基础" scheme="http://zuweicun.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="离散数学" scheme="http://zuweicun.top/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>离散数学（1）</title>
    <link href="http://zuweicun.top/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/"/>
    <id>http://zuweicun.top/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/</id>
    <published>2024-03-28T10:44:06.000Z</published>
    <updated>2024-09-16T14:18:04.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离散数学基础"><a href="#离散数学基础" class="headerlink" title="离散数学基础"></a>离散数学基础</h1><p>本来是打算一点点肝的，谁知道讲这么快，干脆就一晚上肝完吧</p><span id="more"></span><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><h3 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h3><p>看了下定义：大抵是说一个集合到自身的一一对应，<br>这句简单的话透露出一个信息：置换这种运算应该是自闭的，也就是说没有每个元素必然被一个元素指向，自身也指向一个元素（或自身）。<img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711624643658.png" alt="1711624643658"><br>按照我目前的理解，大概就是说r是使γ置换成自身的最小次数，在此之前咋换都不行。<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711625730481.png" alt="1711625730481"><br>这个定理大概是说反正没有重复数字，可以瞎jb换，也不会影响什么。<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711625796751.png" alt="1711625796751"><br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711625891397.png" alt="1711625891397"><br>PS：这里的个数指置换中元素的个数</p><h3 id="二元和n元运算"><a href="#二元和n元运算" class="headerlink" title="二元和n元运算"></a>二元和n元运算</h3><p><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711626677152.png" alt="1711626677152"><br>本来这个二元运算的概念没太理解，知道看到了这张图<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711627084928.png" alt="1711627084928"><br>忽然间理解了奥义：两个加数（乘数）分别是二进制数域，运算之后的结过依然属于二进制数，这就是二元运算；相似地一一对应的那种函数就是一元运算了，以此类推。<br><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711627187999.png" alt="1711627187999"><br>值得注意的是二元运算并不都符合结合律，交换律，分配率那些。。。</p><p><img src="/2024/03/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%881%EF%BC%89/1711627256797.png" alt="1711627256797"><br>其实同构的代数系本质上是一样的，元素对象的命名不同而已。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;离散数学基础&quot;&gt;&lt;a href=&quot;#离散数学基础&quot; class=&quot;headerlink&quot; title=&quot;离散数学基础&quot;&gt;&lt;/a&gt;离散数学基础&lt;/h1&gt;&lt;p&gt;本来是打算一点点肝的，谁知道讲这么快，干脆就一晚上肝完吧&lt;/p&gt;</summary>
    
    
    
    <category term="数学基础" scheme="http://zuweicun.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="离散数学" scheme="http://zuweicun.top/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ROS2初步</title>
    <link href="http://zuweicun.top/2024/03/11/ROS2%E5%88%9D%E6%AD%A5/"/>
    <id>http://zuweicun.top/2024/03/11/ROS2%E5%88%9D%E6%AD%A5/</id>
    <published>2024-03-11T12:16:00.000Z</published>
    <updated>2024-09-16T14:18:13.195Z</updated>
    
    <content type="html"><![CDATA[<p><a name="w3PS4"></a></p><h1 id="安装ROS2"><a href="#安装ROS2" class="headerlink" title="安装ROS2"></a>安装ROS2</h1><p>鱼香yyds</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; bash fishros</span><br></pre></td></tr></table></figure><p>卸载ROS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove ros-foxy-* &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure><p><a name="hoy3W"></a></p><span id="more"></span><h1 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h1><p>与ROS1类似，ROS中同样具有节点，工作空间，功能包等概念<br><a name="ALm4g"></a></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><a name="RgFga"></a></p><h3 id="每一个节点都负责一个单独的模块。"><a href="#每一个节点都负责一个单独的模块。" class="headerlink" title="每一个节点都负责一个单独的模块。"></a>每一个节点都负责一个单独的模块。</h3><p>举个不太恰当的例子：外卖员小哥外卖给主播小姐姐吃，送累了就刷小姐姐直播跳舞，这里外卖小哥和小姐姐都是一个节点，大家共同构成了一个整体，营造出lianghao社会（bushi）<br />ROS2中的节点也是如此，每一个节点也是只负责一个单独的模块化的功能（比如一个节点负责控制车轮转动，一个节点负责从激光雷达获取数据、一个节点负责处理激光雷达的数据、一个节点负责定位等等）</p><blockquote><p><a name="sQg5i"></a></p></blockquote><h3 id="节点通信（详见）"><a href="#节点通信（详见）" class="headerlink" title="节点通信（详见）"></a>节点通信（详见）</h3><p>ROS2中主要有以下四种通信方式：</p><ul><li>话题-topics</li><li>服务-services</li><li>动作-Action</li><li>参数-parameters</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1709952196063-33689e90-6391-444f-b3f8-054f02b98e34.gif#averageHue=%23faf7fb&clientId=uc1f625e0-63bc-4&from=drop&id=u42629f68&originHeight=480&originWidth=854&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=2993370&status=done&style=none&taskId=u5f22b082-1278-4c51-a0b8-8d390e71c3e&title=" alt="Nodes-TopicandService.gif"></p><p><a name="SasOs"></a></p><h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>需要使用指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;</span><br></pre></td></tr></table></figure><p><a name="qUDBx"></a></p><h3 id="命令行查看节点信息"><a href="#命令行查看节点信息" class="headerlink" title="命令行查看节点信息"></a>命令行查看节点信息</h3><p>这里涉及以下两个概念：</p><ul><li>GUI（Graphical User Interface）就是平常我们说的图形用户界面，大家用的Windows是就是可视化的，我们可以通过鼠标点击按钮等图形化交互完成任务。</li><li>CLI（Command-Line Interface）就是命令行界面了，我们所用的终端，黑框框就是命令行界面，没有图形化。<br><a name="JdGKJ"></a></li></ul><h3 id="节点相关CLI："><a href="#节点相关CLI：" class="headerlink" title="节点相关CLI："></a>节点相关CLI：</h3><p>列举几个常用的：<br />运行节点(</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>查看节点列表(常用)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>查看节点信息(常用)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>重映射节点名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</span><br></pre></td></tr></table></figure><p><a name="qg3CI"></a></p><h2 id="工作空间-功能包："><a href="#工作空间-功能包：" class="headerlink" title="工作空间&amp;&amp;功能包："></a>工作空间&amp;&amp;功能包：</h2><p>想要找到一个可执行文件（节点）必须依赖于一个功能包，这些包可以统一放在某个工作空间里。<br />创建工作空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p turtle_ws/src</span><br><span class="line"><span class="built_in">cd</span> turtle_ws/src</span><br></pre></td></tr></table></figure><p>功能包：<br />可以理解为存放节点的容器。<br />ROS2中功能包根据编译方式的不同分为三种类型。</p><ul><li>ament_python，适用于python程序</li><li>cmake，适用于C++</li><li>ament_cmake，适用于C++程序,是cmake的增强版<br><a name="YUrMN"></a></li></ul><h3 id="功能包获取"><a href="#功能包获取" class="headerlink" title="功能包获取"></a>功能包获取</h3><ul><li><p>安装一般使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-&lt;version&gt;-package_name</span><br></pre></td></tr></table></figure></li><li><p>手动编译：有点麻烦，一般都是需要对包进行修改的时候shiytong<br><a name="mddWh"></a></p></li></ul><h3 id="相关指令——ros2pkg"><a href="#相关指令——ros2pkg" class="headerlink" title="相关指令——ros2pkg"></a>相关指令——ros2pkg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create       Create a new ROS2 package</span><br><span class="line">executables  Output a list of package specific executables</span><br><span class="line">list         Output a list of available packages</span><br><span class="line">prefix       Output the prefix path of a package</span><br><span class="line">xml          Output the XML of the package manifest or a specific tag</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   <strong>1.创建功能包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create &lt;package-name&gt;  --build-type  &#123;cmake,ament_cmake,ament_python&#125;  --dependencies &lt;依赖名字&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>2.列出可执行文件</strong><br />列出所有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg executablesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>列出某个功能包的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg executables turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709952853767-34253709-40e1-445a-9df0-99407cbf16e4.png#averageHue=%23262321&clientId=uc1f625e0-63bc-4&from=paste&id=u29043447&originHeight=82&originWidth=430&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u5ab1ac60-bfbc-4ace-97a5-3a014d2af0f&title="><br /><strong>3.列出所有的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>4.输出某个包所在路径的前缀</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg prefix  &lt;package-name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>比如小乌龟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg prefix turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>5.列出包的清单描述文件</strong><br /><strong>每一个功能包都有一个标配的manifest.xml文件，用于记录这个包的名字，构建工具，编译信息，拥有者，干啥用的等信息。</strong><br /><strong>通过这个信息，就可以自动为该功能包安装依赖，构建时确定编译顺序等</strong><br />查看小乌龟模拟器功能包的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg xml turtlesim</span><br></pre></td></tr></table></figure><p><a name="WrcLt"></a></p><h2 id="colcon"><a href="#colcon" class="headerlink" title="colcon:"></a>colcon:</h2><p>colcon其是就是个功能包的构建工具，说白了就是编译器。<br />ros2默认死没有colcon的，所以需要安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-colcon-common-extensions</span><br></pre></td></tr></table></figure><p><a name="BzyYh"></a></p><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p><a name="moZ8W"></a></p><h3 id="5-1-只编译一个包"><a href="#5-1-只编译一个包" class="headerlink" title="5.1 只编译一个包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_51-%e5%8f%aa%e7%bc%96%e8%af%91%e4%b8%80%e4%b8%aa%e5%8c%85">5.1 只编译一个包</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><a name="Mb0AY"></a></p><h3 id="5-2-不编译测试单元"><a href="#5-2-不编译测试单元" class="headerlink" title="5.2 不编译测试单元"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_52-%e4%b8%8d%e7%bc%96%e8%af%91%e6%b5%8b%e8%af%95%e5%8d%95%e5%85%83">5.2 不编译测试单元</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME  --cmake-args -DBUILD_TESTING=0Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><a name="Dt5J5"></a></p><h3 id="5-3-运行编译的包的测试"><a href="#5-3-运行编译的包的测试" class="headerlink" title="5.3 运行编译的包的测试"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_53-%e8%bf%90%e8%a1%8c%e7%bc%96%e8%af%91%e7%9a%84%e5%8c%85%e7%9a%84%e6%b5%8b%e8%af%95">5.3 运行编译的包的测试</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon testCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><a name="Gacar"></a></p><h3 id="5-4-允许通过更改src下的部分文件来改变install（重要）"><a href="#5-4-允许通过更改src下的部分文件来改变install（重要）" class="headerlink" title="5.4 允许通过更改src下的部分文件来改变install（重要）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_54-%e5%85%81%e8%ae%b8%e9%80%9a%e8%bf%87%e6%9b%b4%e6%94%b9src%e4%b8%8b%e7%9a%84%e9%83%a8%e5%88%86%e6%96%87%e4%bb%b6%e6%9d%a5%e6%94%b9%e5%8f%98install%ef%bc%88%e9%87%8d%e8%a6%81%ef%bc%89">5.4 允许通过更改src下的部分文件来改变install（重要）</a></h3><p>（每次调整 python 脚本时都不必重新build了）</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build <span class="comment">--symlink-install</span></span><br></pre></td></tr></table></figure><p><a name="DEwTp"></a></p><h2 id="手撸节点test（c-）"><a href="#手撸节点test（c-）" class="headerlink" title="手撸节点test（c++）"></a>手撸节点test（c++）</h2><p>由于python的运行效率实在是一言难尽，我们只学习C++_的版本<br><a name="b6gfN"></a></p><h3 id="创建工作空间-功能包"><a href="#创建工作空间-功能包" class="headerlink" title="创建工作空间&amp;&amp; 功能包"></a>创建工作空间&amp;&amp; 功能包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p town_ws/src</span><br><span class="line"><span class="built_in">cd</span> town_ws/src</span><br><span class="line">ros2 pkg create village_wang --build-type ament_cmake --dependencies rclcpp</span><br></pre></td></tr></table></figure><p>创建完成的目录结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709953867147-9f288dcf-5e47-4151-9465-e4418685f654.png#averageHue=%23300a24&clientId=u7f35f781-53fd-4&from=drop&id=ua3e86124&originHeight=118&originWidth=212&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=7896&status=done&style=none&taskId=u4fdf03cc-db2e-4232-9a0f-487eae2ca95&title=" alt="image-20210727193256467.png"><br><a name="XZHy1"></a></p><h3 id="POP方式编写节点"><a href="#POP方式编写节点" class="headerlink" title="POP方式编写节点"></a>POP方式编写节点</h3><p>在village_wang&#x2F;src中创建wang2.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    /*初始化rclcpp</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;rclcpp::Node&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    // 打印一句自我介绍</span><br><span class="line">    RCLCPP_INFO(node-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗wang2.&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数中首先初始化rclcpp，然后新建了一个Node节点的对象，命名为wang2，接着使用rclcpp让这个节点暴露在外面，并检测退出信号（Ctrl+C），检测到退出信号后，就会执行rcl.shutdown()关闭节点。<br><a name="FGd6F"></a></p><h4 id="添加到cmakelists"><a href="#添加到cmakelists" class="headerlink" title="添加到cmakelists"></a>添加到cmakelists</h4><p>在CmakeLists.txt最后一行加入下面两行代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add<span class="constructor">_executable(<span class="params">wang2_node</span> <span class="params">src</span><span class="operator">/</span><span class="params">wang2</span>.<span class="params">cpp</span>)</span></span><br><span class="line">ament<span class="constructor">_target_dependencies(<span class="params">wang2_node</span> <span class="params">rclcpp</span>)</span></span><br></pre></td></tr></table></figure><p>添加这两行代码的目的是让编译器编译wang2.cpp这个文件，不然不会主动编译。接着在上面两行代码下面添加下面的代码。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  wang2_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个是C++比Python要麻烦的地方，需要手动将编译好的文件安装到install&#x2F;village_wang&#x2F;lib&#x2F;village_wang下.<br><a name="WfmFe"></a></p><h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h4><p>打开vscode终端，进入town_ws<br><a name="Z1Ujk"></a></p><h3 id="编译节点"><a href="#编译节点" class="headerlink" title="编译节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e7%bc%96%e8%af%91%e8%8a%82%e7%82%b9">编译节点</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br></pre></td></tr></table></figure><p><a name="FFV99"></a></p><h3 id="source环境"><a href="#source环境" class="headerlink" title="source环境"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=source%e7%8e%af%e5%a2%83">source环境</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> install/setup.bash</span><br></pre></td></tr></table></figure><p><a name="xqzlR"></a></p><h3 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e8%bf%90%e8%a1%8c%e8%8a%82%e7%82%b9">运行节点</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run village_wang wang2_node</span><br></pre></td></tr></table></figure><p>不出意外，你可以看到王二的自我介绍。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954465823-94f63561-dbe0-4ac6-90a6-3e3720ef2823.png#averageHue=%231f1d1c&clientId=u7f35f781-53fd-4&from=drop&id=ucbef2116&originHeight=317&originWidth=644&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=105682&status=done&style=none&taskId=u3d85a105-b651-4405-8a1d-378ebd2cea7&title=" alt="a85481a9b56ae5cf6bee46a440140235.png"><br />当节点运行起来后，使用ros2 node list 指令来查看现有的节点。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954606260-0bd6726b-4a2b-4717-bf95-eba0cac67750.png#averageHue=%23363534&clientId=u7f35f781-53fd-4&from=drop&id=u21cafeca&originHeight=68&originWidth=437&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=14564&status=done&style=none&taskId=ubda76a82-e9ab-43e9-943a-dd83f8acea4&title=" alt="972b7669eb967a31c2a0d959b7301ad9.png"><br><a name="MJsrM"></a></p><h2 id="OPP方式编写节点"><a href="#OPP方式编写节点" class="headerlink" title="OPP方式编写节点"></a>OPP方式编写节点</h2><p>还是在wang2.cpp输入代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleDogNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">SingleDogNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="mRwWY"></a></p><h3 id="修改cmakelists-运行"><a href="#修改cmakelists-运行" class="headerlink" title="修改cmakelists&amp;&amp;运行"></a>修改cmakelists&amp;&amp;运行</h3><p>同上，不多赘述<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709965221810-a121ef27-b3a9-42f7-a674-f23eee0c3e3b.png#averageHue=%231d1d1c&clientId=u488a9513-274b-4&from=drop&id=u35b36f1c&originHeight=1344&originWidth=1108&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=230404&status=done&style=none&taskId=u6451a532-fc8b-4701-8e02-2a8ab5680a6&title=" alt="8014891cb75b9e90255db630b7115fad.png"><br />运行成功。<br><a name="zvknJ"></a></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>鱼香教程里的举例实在是难以忘却，这里我cv过来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这里的王二和李四两个节点，通过话题来互相通信（传递数据）。</span><br><span class="line"></span><br><span class="line">李四节点会创建一个发布者（Publisher）来发布一个话题（艳娘传奇,小鱼取个英文名叫sexy_girl）。单身汉王二节点，他创建了一个订阅者（Subscriber）来订阅李四发布的话题sexy_girl。</span><br><span class="line"></span><br><span class="line">那艳娘传奇的内容是什么呢？我们暂且规定为由文字组成的字符串（连插图都没的那种）。</span><br><span class="line"></span><br><span class="line">[object Promise]</span><br><span class="line">李四王二通信模型是一个一对一（一个发布者，一个订阅者）的模型，除此之外ROS2中话题通信其实还可以是1对n,n对1,n对n的。</span><br></pre></td></tr></table></figure><p><a name="HgXzG"></a></p><h3 id="话题通讯"><a href="#话题通讯" class="headerlink" title="话题通讯"></a>话题通讯</h3><p><a name="jWcs8"></a></p><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ul><li>话题名字是关键,发布订阅接口类型要相同，发布的是字符串，接受也要用字符串来接收;</li><li>同一个人(节点)可以订阅多个话题，同时也可以发布多个话题，就像一本书的作者也可以是另外一本书的读者;</li><li>同一个小说不能有多个作者（版权问题），但跟小说不一样，同一个话题可以有多个发布者。<br><a name="YaREO"></a></li></ul><h4 id="相关工具："><a href="#相关工具：" class="headerlink" title="相关工具："></a>相关工具：</h4><p><a name="FnJns"></a></p><h5 id="rqt-graph"><a href="#rqt-graph" class="headerlink" title="rqt_graph:"></a>rqt_graph:</h5><p>ROS2作为一个强大的工具，在运行过程中，我们是可以通过命令来看到节点和节点之间的数据关系的。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709972464260-688eb5ba-8779-4843-ad42-7a00609803f8.png#averageHue=%23e9e9e8&clientId=ud645a189-b8aa-4&from=drop&id=ud5918dcf&originHeight=591&originWidth=761&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=53857&status=done&style=none&taskId=u304193b0-36aa-4ccc-9cbe-cdec436b6b7&title=" alt="image-20210803113450234.png"></p><p><a name="Cm70r"></a></p><h5 id="命令行界面——CLI"><a href="#命令行界面——CLI" class="headerlink" title="命令行界面——CLI"></a>命令行界面——CLI</h5><p>返回系统活动所有主题列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure><p>增加消息类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure><p>打印实时话题内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic <span class="built_in">echo</span> /chatter</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看主题信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic info  /chatter</span><br></pre></td></tr></table></figure><p>查看消息类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure><p>手动发布命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub /chatter std_msgs/msg/String <span class="string">&#x27;data: &quot;123&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="B7agU"></a></p><h3 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h3><p>创建话题订阅者的一般流程：</p><ol><li>导入订阅的话题接口类型</li><li>创建订阅回调函数</li><li>声明并创建订阅者</li><li>编写订阅回调处理逻辑<br><a name="vIZWC"></a></li></ol><h3 id="王三"><a href="#王三" class="headerlink" title="王三"></a>王三</h3><ul><li><p>将wang2.cpp代码修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/string.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/u_int32.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using std::placeholders::_1;</span><br><span class="line">using std::placeholders::_2;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span><br><span class="line">*/</span><br><span class="line">class SingleDogNode : public rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数,有一个参数为节点名称</span><br><span class="line">    SingleDogNode(std::string name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 打印一句自我介绍</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>, name.c_str());</span><br><span class="line">         // 创建一个订阅者来订阅李四写的小说，通过名字sexy_girl</span><br><span class="line">        sub_novel = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, 10, std::<span class="built_in">bind</span>(&amp;SingleDogNode::topic_callback, this, _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 声明一个订阅者（成员变量）,用于订阅小说</span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_novel;</span><br><span class="line"></span><br><span class="line">    // 收到话题数据的回调函数</span><br><span class="line">    void topic_callback(const std_msgs::msg::String::SharedPtr msg)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;朕已阅：&#x27;%s&#x27;&quot;</span>, msg-&gt;data.c_str());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用C++订阅话题，需要添加对应的消息类型头文件：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">string.hpp</span>&quot;</span></span><br><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">u_int</span>32.<span class="string">hpp</span>&quot;</span></span><br></pre></td></tr></table></figure><p>创建订阅者和发布者时依然使用this-&gt;create_subscription和this-&gt;create_publisher方法。<br />C++中创建一个订阅者，需要传入话题类型、话题名称、所要绑定的回调函数，以及通信Qos.<br /><strong>std::bind()</strong><br /><strong>C++的类成员函数不能像普通函数那样用于回调，因为每个成员函数都需要有一个对象实例去调用它。 通常情况下，要实现成员函数作为回调函数：一种过去常用的方法就是把该成员函数设计为静态成员函数（因为类的成员函数需要隐含的this指针 而回调函数没有办法提供），但这样做有一个缺点，就是会破坏类的结构性，因为静态成员函数只能访问该类的静态成员变量和静态成员函数，不能访问非静态的，要解决这个问题，可以把对象实例的指针或引用做为参数传给它。 后面就可以靠这个对象实例的指针或引用访问非静态成员函数。另一种办法就是使用std::bind和std::function结合实现回调技术。(目前还看不太懂)</strong></p></li><li><p>编译运行</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure></li><li><p>source运行<br><a name="KES9k"></a></p></li></ul><h3 id="李四"><a href="#李四" class="headerlink" title="李四"></a>李四</h3><p>突然发现李四的源码在教程里没有，自己搓了个试试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的数组</span></span><br><span class="line">std::string novel[] = &#123;</span><br><span class="line"><span class="string">&quot;第一回：潋滟湖 1 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第二回：潋滟湖 2 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第三回：潋滟湖 3 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第四回：潋滟湖 4 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第五回：潋滟湖 5 次偶遇胡艳娘&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的索引</span></span><br><span class="line"><span class="type">int</span> nb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做WriterNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriterNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">WriterNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是%s,我是一名作家！&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建一个发布者来发布小说内容，通过名字sexy_girl</span></span><br><span class="line">    pub_novel = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 创建一个定时器，每隔五秒发布一章小说内容</span></span><br><span class="line">    timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>), std::<span class="built_in">bind</span>(&amp;WriterNode::timer_callback, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 声明一个发布者（成员变量）,用于发布小说内容</span></span><br><span class="line">rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_novel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个定时器（成员变量）,用于定时发布小说内容</span></span><br><span class="line">rclcpp::TimerBase::SharedPtr timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器触发的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个小说内容的消息</span></span><br><span class="line">    std_msgs::msg::String novel_msg;</span><br><span class="line">    <span class="comment">// 判断小说内容的索引是否超出数组范围</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt; <span class="built_in">sizeof</span>(novel) / <span class="built_in">sizeof</span>(novel[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取小说内容</span></span><br><span class="line">        novel_msg.data = novel[nb];</span><br><span class="line">        <span class="comment">// 发布小说内容</span></span><br><span class="line">        pub_novel-&gt;<span class="built_in">publish</span>(novel_msg);</span><br><span class="line">        <span class="comment">// 打印发布的小说内容</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;发布小说内容：%s&quot;</span>, novel_msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 小说内容的索引加一</span></span><br><span class="line">        nb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 小说内容已经发布完毕，取消定时器</span></span><br><span class="line">        timer-&gt;<span class="built_in">cancel</span>();</span><br><span class="line">        <span class="comment">// 打印结束语</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;小说已经完结，感谢大家的支持！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv); <span class="comment">// 初始化rclcpp</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;WriterNode&gt;(<span class="string">&quot;li4&quot;</span>); <span class="comment">// 新建一个节点</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node); <span class="comment">// 保持节点运行，检测是否收到退出指令（Ctrl+C）</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>(); <span class="comment">// 关闭rclcpp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Ctrl+Shift+5切分一个终端出来，输入下面命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 run  village_li  li4_node</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709973381445-1adfa01f-8fab-4b2e-862b-37be052c45b0.png#averageHue=%232e2e2e&clientId=ud645a189-b8aa-4&from=drop&id=u0011d78d&originHeight=243&originWidth=1362&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=120502&status=done&style=none&taskId=u430b4fc9-7dae-41d0-813a-b956f4cda2a&title=" alt="image-20210804074600329.png"><br><a name="ffgNa"></a></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>C++中创建一个发布者也比较简单，使用this-&gt;create_publisher即可创建一个发布者。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pub_</span> = this-&gt;create_publisher&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;sexy_girl_money&quot;</span>,<span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这里提供了三个参数，分别是该发布者要发布的话题名称（sexy_girl_money）、发布者要发布的话题类型（std_msgs::msg::UInt32）、Qos（10）<br><a name="hnt3J"></a></p><h3 id="服务和接口"><a href="#服务和接口" class="headerlink" title="服务和接口"></a>服务和接口</h3><p><a name="RpsO0"></a></p><h3 id="接口：接口其实是一种规范"><a href="#接口：接口其实是一种规范" class="headerlink" title="接口：接口其实是一种规范"></a>接口：接口其实是一种规范</h3><p>当接口类型统一的时候，适配显然就不是问题了，大家的服务和响应都是一致的规范格式<br><a name="MYwEG"></a></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><a name="eTGJG"></a></p><h5 id="查看接口列表（当前环境下）"><a href="#查看接口列表（当前环境下）" class="headerlink" title="查看接口列表（当前环境下）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_41%e6%9f%a5%e7%9c%8b%e6%8e%a5%e5%8f%a3%e5%88%97%e8%a1%a8%ef%bc%88%e5%bd%93%e5%89%8d%e7%8e%af%e5%a2%83%e4%b8%8b%ef%bc%89">查看接口列表（当前环境下）</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface list</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811318-9c2e1b9d-119d-4c2d-80ee-8b9effa311de.png#averageHue=%23282828&clientId=ud3f5d7d5-6e8f-4&from=paste&id=u6b0684ac&originHeight=366&originWidth=700&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=ueea0a066-269f-4a44-908b-66eff688a8a&title="><br><a name="gfepk"></a></p><h5 id="查看所有接口包"><a href="#查看所有接口包" class="headerlink" title="查看所有接口包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_42%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3%e5%8c%85">查看所有接口包</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface packages</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811026-b7326182-2b56-499b-bf97-5580abcd8c68.png#averageHue=%23252525&clientId=ud3f5d7d5-6e8f-4&from=paste&id=uc9cacca0&originHeight=500&originWidth=444&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=uba98428e-3d16-4193-926e-7b18b031853&title="><br><a name="EDlMf"></a></p><h5 id="查看某一个包下的所有接口"><a href="#查看某一个包下的所有接口" class="headerlink" title="查看某一个包下的所有接口"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_43%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e5%8c%85%e4%b8%8b%e7%9a%84%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3">查看某一个包下的所有接口</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface package std_msgs</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811203-ae44eadd-e3cf-41ce-8f6e-17452d028e89.png#averageHue=%23262626&clientId=ud3f5d7d5-6e8f-4&from=paste&id=u11110c34&originHeight=246&originWidth=669&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=ue6b53307-54e5-482e-9233-ae6dfa80bfa&title="><br><a name="kgaGi"></a></p><h5 id="查看某一个接口详细的内容"><a href="#查看某一个接口详细的内容" class="headerlink" title="查看某一个接口详细的内容"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_44%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e8%af%a6%e7%bb%86%e7%9a%84%e5%86%85%e5%ae%b9">查看某一个接口详细的内容</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811860-73d814e9-0ad4-4f3c-8b03-cc84d50b8e00.png#averageHue=%23292929&clientId=ud3f5d7d5-6e8f-4&from=paste&id=uff812660&originHeight=114&originWidth=764&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=ufbd1877f-055c-45bb-b469-d1c4c124258&title="><br><a name="YVXNq"></a></p><h5 id="输出某一个接口所有属性"><a href="#输出某一个接口所有属性" class="headerlink" title="输出某一个接口所有属性"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_45-%e8%be%93%e5%87%ba%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e6%89%80%e6%9c%89%e5%b1%9e%e6%80%a7">输出某一个接口所有属性</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface proto sensor_msgs/msg/Image</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811870-5f07a163-7673-4f56-a3c5-337c13939d9a.png#averageHue=%23212121&clientId=ud3f5d7d5-6e8f-4&from=paste&id=u9b08528d&originHeight=208&originWidth=611&originalType=url&ratio=1.5625&rotation=0&showTitle=false&status=done&style=none&taskId=uf0315698-41a2-4e5e-b260-a5dff7aa66e&title="></p><p><a name="PJTRk"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>显然，服务和话题的区别在于话题是没有返回的，只是单向的数据传递。而服务是双向的客户端发送，服务端响应。<br><a name="JJ4MV"></a></p><h3 id="自定义话题接口"><a href="#自定义话题接口" class="headerlink" title="自定义话题接口"></a>自定义话题接口</h3><ul><li>新建工作空间</li></ul><p>在town_ws的src文件夹下，运行下面的指令，即可完成village_interfaces功能包的创建。    <br /> <strong>注意，这里包的编译类型我们使用ament_cmake方式。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create village_interfaces --build-type ament_cmake </span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037304935-3b720491-175f-421f-b8b8-cd410932ca33.png#averageHue=%23212121&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u0e50a9c7&originHeight=179&originWidth=503&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=15650&status=done&style=none&taskId=u951c0305-6102-4c35-885a-e55d3f3c93b&title=" alt="image-20210809151545012.png"></p><ul><li>新建msg文件和Novel.msg（小说消息）</li></ul><p><strong>注意:msg文件开头首字母一定要大写，ROS2强制要求，盲猜应该是为了和类名保持一致</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd village_interfaces</span><br><span class="line">mkdir msg</span><br><span class="line">touch Novel.msg </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>编写Novel.msg内容</li></ul><p>我们的目的是给李四的小说每一章增加一张图片，原来李四写小说是对外发布一个std_msgs&#x2F;msg&#x2F;String字符串类型的数据。<br />而发布图片的格式，我们需要采用ros自带的传感器消息接口中的图片sensor_msgs&#x2F;msg&#x2F;Image数据类型，所以我们新的消息文件的内容就是将两者合并，在ROS2中可以写做这样：<br /><strong>在msg文件中可以使用#号添加注释。</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">#</span> 标准消息接口<span class="type">std_msgs</span>下的<span class="built_in">String</span>类型</span><br><span class="line"><span class="type">std_msgs</span><span class="operator">/</span><span class="built_in">String</span> <span class="variable">content</span></span><br><span class="line"><span class="type">#</span> 图像消息，调用<span class="type">sensor_msgs</span>下的<span class="built_in">Image</span>类型</span><br><span class="line"><span class="type">sensor_msgs</span><span class="operator">/</span><span class="built_in">Image</span> <span class="variable">image</span></span><br></pre></td></tr></table></figure><p>这种组合结构图如下：<br />[object Promise]<br />这个图一共三层，第一层是消息定义层，第二层是ROS2已有的std_msgs,sensor_msgs，其组成关系是由下一层组合成上一层。<br />最下面一层string、uint8、uint32是ROS2中的原始数据类型，原始数据类型有下面几种，ROS2中所有的接口都是由这些原始数据类型组成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="type">byte</span></span><br><span class="line">char</span><br><span class="line"><span class="type">float32</span>,<span class="type">float64</span></span><br><span class="line"><span class="type">int8</span>,<span class="type">uint8</span></span><br><span class="line"><span class="type">int16</span>,<span class="type">uint16</span></span><br><span class="line"><span class="type">int32</span>,<span class="type">uint32</span></span><br><span class="line"><span class="type">int64</span>,<span class="type">uint64</span></span><br><span class="line"><span class="type">string</span></span><br></pre></td></tr></table></figure><ul><li>Another way</li></ul><p>我们不使用std_msgs&#x2F;String 而是直接使用最下面一层的string。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure><ul><li>说明</li></ul><p>如何知道，std_msgs&#x2F;String是由基础数据类型string组成的，其实可以通过下面的指令来查看</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">show</span> <span class="symbol">std_msgs</span>/<span class="symbol">msg</span>/<span class="symbol">String</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">string</span> <span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原来std_msgs的String就是包含一个叫变量名为data的string类型变量，这也是在4.2和4.3章节中代码要用.data才能拿到真正的数据的原因：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> <span class="built_in">String</span></span><br><span class="line">msg = <span class="built_in">String</span>()</span><br><span class="line">msg.data = <span class="string">&#x27;第%d回：潋滟湖 %d 次偶遇胡艳娘&#x27;</span> % (self.i,self.i)</span><br><span class="line"><span class="comment"># msg 是 std_msgs.msg.String() 的对象</span></span><br><span class="line"><span class="comment"># msg.data data是string类型的对象，其定义是string data</span></span><br></pre></td></tr></table></figure><p>最终Novel.msg</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure><ul><li>修改Cmakelists.txt</li></ul><p>完成了代码的编写还不够，我们还需要在CMakeLists.txt中告诉编译器，你要给我把Novel.msg转换成Python库和C++的头文件。<br />直接添加下面的代码到CMakeLists.txt即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#添加对sensor_msgs的</span><br><span class="line"><span class="built_in">find_package</span>(sensor_msgs REQUIRED)</span><br><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">#添加消息文件和依赖</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line"><span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">    DEPENDENCIES sensor_msgs</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>find_package用于查找rosidl_default_generators位置，下面rosidl_generate_interfaces就是声明msg文件所属的工程名字、文件位置以及依赖DEPENDENCIES。<br /><strong>踩坑报告：</strong></p><ul><li><strong>重点强调一下依赖部分DEPENDENCIES，我们消息中用到的依赖这里必须写上，即使不写编译器也不会报错，直到运行的时候才会出错。</strong></li><li><strong>而且rosidl_generate_interfaces()</strong> 函数必须在 <strong>ament_package()</strong> 函数之前调用。</li></ul><p>代码大概是这样的<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038380883-6becece5-b4cd-4c3d-bc11-cdcffa9dcf1d.png#averageHue=%23201f1f&clientId=ud3f5d7d5-6e8f-4&from=drop&id=ua4ec7301&originHeight=843&originWidth=1469&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=471267&status=done&style=none&taskId=u795fc122-a6a1-4427-9f9d-d20f8507983&title=" alt="e3877412c40448c0995ba2884a1ae7c1.png"></p><ul><li>修改package.xml</li></ul><p>修改village_interfaces目录下的package.xml，添加下面三行代码，为工程添加一下所需的依赖。<br /><strong>这里其实不添加也可以</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>sensor_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码位置：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037769727-982ef5d8-77a3-446a-9035-8861ead0bf4e.png#averageHue=%23201f1f&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u06f1f241&originHeight=492&originWidth=1099&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=105921&status=done&style=none&taskId=u1930cd93-9480-4455-b99b-a9971abac6c&title=" alt="image-20210816145202732.png"></p><ul><li>编译</li></ul><p>回到town_ws</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_interfaces</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><p>过上节课说过的ros2 interface常用的命令来测试。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">package</span> <span class="symbol">village_interfaces</span>  #查看包下所有接口</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">show</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #查看内容</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">proto</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #显示属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="zucuy"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037813556-ec2ce503-73b2-4496-ad09-0d176cf48bdb.png#averageHue=%23242424&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u580048f1&originHeight=367&originWidth=751&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=58470&status=done&style=none&taskId=u39622192-29e6-41b5-9414-a9b8c7ed920&title=" alt="image-20210816145503946.png"></h3><p>我们可以在运行结果中看到，Novel的消息内容是由content数据和传感器数据image共同组成的了。</p><p><a name="vtOSp"></a></p><h3 id="服务："><a href="#服务：" class="headerlink" title="服务："></a>服务：</h3><ul><li>服务：客户端发送请求给服务端，服务端可以根据客户端的请求做一些处理，然后返回结果给客户端。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035790713-136e7676-715a-48d2-92ad-41e569c869f1.gif#averageHue=%23fcf9fd&clientId=ud3f5d7d5-6e8f-4&from=drop&id=PMpbD&originHeight=480&originWidth=854&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=380270&status=done&style=none&taskId=u365753d7-dbb5-4e03-9548-c451b5f740a&title=" alt="Service-SingleServiceClient.gif"><br /><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035797325-0dfe07bb-99eb-4afc-9625-737c1827a667.gif#averageHue=%2394a2cc&clientId=ud3f5d7d5-6e8f-4&from=drop&id=mTDBy&originHeight=480&originWidth=854&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=898464&status=done&style=none&taskId=u4ef526f9-0e06-43be-ab48-beff9eb1ad0&title=" alt="Service-MultipleServiceClient.gif"></p><p>下面操作一下ros2自带的样例服务：<br><a name="ZLIvy"></a></p><h4 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h4><p>运行一个服务节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 run examples_rclpy_minimal_service service</span><br><span class="line"><span class="comment">//服务的功能是将两个数字相加，给定a，b两个数，返回sum也就是ab之和</span></span><br></pre></td></tr></table></figure><p><a name="OhYmw"></a></p><h5 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 service list</span><br></pre></td></tr></table></figure><p><a name="ZNyUa"></a></p><h5 id="手动调用服务（一定要注意a：-b-的空格）"><a href="#手动调用服务（一定要注意a：-b-的空格）" class="headerlink" title="手动调用服务（一定要注意a：  b: 的空格）"></a>手动调用服务（一定要注意a：  b: 的空格）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts <span class="string">&quot;&#123;a: 5,b: 10&#125;&quot;</span></span><br><span class="line"><span class="comment">//需要再启动一个终端</span></span><br></pre></td></tr></table></figure><p><a name="RHF6C"></a></p><h5 id="查看服务接口类型"><a href="#查看服务接口类型" class="headerlink" title="查看服务接口类型"></a>查看服务接口类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 service type /add_two_ints</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="AIADv"></a></p><h5 id="查找使用某一接口的服务"><a href="#查找使用某一接口的服务" class="headerlink" title="查找使用某一接口的服务"></a>查找使用某一接口的服务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 service find example_interfaces/srv/AddTwoInts</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="X9wyU"></a></p><h4 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h4><p>我们来看一下服务的消息接口长什么样子？<br />服务接口格式：xxx.srv</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line"><span class="section">int64 b</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><p>与话题不同的是，srv文件比msg文件中间多出了三个—这三个杠杠就是分界线，上方的是客户端发送请求的数据结构定义，下方的是服务端响应结果的数据结构定义。<br />参考下面的步骤：</p><ul><li>新建srv文件夹，并在文件夹下新建xxx.srv</li><li>在xxx.srv下编写服务接口内容并保存</li><li>在CmakeLists.txt添加依赖和srv文件目录</li><li>在package.xml中添加xxx.srv所需的依赖</li><li>编译功能包即可生成python与c++头文件</li></ul><p>当然在做上面的步骤之前，我们还需要做一件很重要的事情。就是根据业务需求，确定好请求的数据结构和返回的数据结构。我们依然是在village_interfaces下创建服务接口。<br />开始之前，我们先根据李四的需求来确定数据结构。<br />上一节中李四对借钱的要求如下：</p><ol><li>借钱一定要打欠条，收到欠条才能给钱</li><li>每次借钱不能超过自己全部资金的10%且一定是整数，也就是说李四假如现在有100块钱，那么最多借出去100x10%&#x3D;10块钱</li></ol><p>总结一下就是，李三发送借钱请求的时候一定要有欠条，我们想一下，欠条中应该至少包含两条信息</p><ul><li>借钱者名字，字符串类型、可以用string表示</li><li>金额，整形，可以用uint32表示</li></ul><p>那请求的数据结构我们就可以确定下来了，接着确定返回的数据的格式。<br />既然是借钱，那李四就有可能拒绝，会有借钱失败的情况，所以返回数据应该有这两条信息：</p><ul><li>是否出借：只有成功和失败两种情况，布尔类型（bool）可表示</li><li>出借金额：无符号整形，可以用uint32表示，借钱失败时为0。<br><a name="SOi0x"></a></li></ul><h5 id="创建srv文件夹及BorrowMoney-srv消息文件"><a href="#创建srv文件夹及BorrowMoney-srv消息文件" class="headerlink" title="创建srv文件夹及BorrowMoney.srv消息文件"></a>创建srv文件夹及BorrowMoney.srv消息文件</h5><p>在village_interfaces下新建srv文件夹<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038764606-c8035912-d3b5-4a18-8758-978165a7a504.png#averageHue=%23222222&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u87e80afd&originHeight=160&originWidth=471&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=14984&status=done&style=none&taskId=u6fcc9d9a-d569-433f-86c9-0a6ed8b969f&title=" alt="image-20210811162010736.png"><br><a name="yxyCD"></a></p><h5 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint32 money</span><br><span class="line">---</span><br><span class="line"><span class="type">bool</span> success</span><br><span class="line">uint32 money</span><br></pre></td></tr></table></figure><p><a name="efh5K"></a></p><h5 id="修改Cmakelists-txt"><a href="#修改Cmakelists-txt" class="headerlink" title="修改Cmakelists.txt"></a>修改Cmakelists.txt</h5><p>我们已经添加过依赖DEPENDENCIES和msg文件了，所以这里我们直接添加一个srv即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line">  #---msg---</span><br><span class="line">  <span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">  #---srv---</span><br><span class="line">  <span class="string">&quot;srv/BorrowMoney.srv&quot;</span></span><br><span class="line">  DEPENDENCIES sensor_msgs</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>需要关注的是这一行”srv&#x2F;BorrowMoney.srv”,添加了对应的文件位置。</p><ul><li>踩坑：在rosidl_generate_interfaces()函数中传递了一个依赖项sensor_msgs，但是在使用find_package()函数之前没有找到它。需要在CMakeLists.txt 文件中添加find_package(sensor_msgs REQUIRED)，以确保 <strong>sensor_msgs</strong> 包被正确地找到和链接。<br><a name="io4wO"></a></li></ul><h5 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;sensor_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;</span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="Ink82"></a></p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select village_interfaces</span><br></pre></td></tr></table></figure><p><a name="lVN2C"></a></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>这次测试我们依然使用ros2 interface指令进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 interface package village_interfaces</span><br><span class="line">ros2 interface show village_interfaces/srv/BorrowMoney</span><br><span class="line">ros2 interface proto village_interfaces/srv/BorrowMoney </span><br></pre></td></tr></table></figure><p><a name="uONPm"></a></p><h4 id="服务的c-实现"><a href="#服务的c-实现" class="headerlink" title="服务的c++实现"></a>服务的c++实现</h4><p><strong>一句话：张三拿多少钱钱给王二，王二凑够多少个章节的艳娘传奇给他，可参考以下步骤</strong></p><ol><li>导入服务接口</li><li>创建服务端回调函数</li><li>声明并创建服务端</li><li>编写回调函数逻辑处理请求<br><a name="c7FPU"></a></li></ol><h5 id="添加接口-依赖"><a href="#添加接口-依赖" class="headerlink" title="添加接口&amp;&amp;依赖"></a>添加接口&amp;&amp;依赖</h5><p>因为village_wang的包类型是ament_cmake，故需要进行以下两步操作：<br /><strong>第一步修改package.xml</strong><br />加入下面的代码（告诉colcon，编译之前要确保有village_interfaces存在）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;depend&gt;village_interfaces&lt;/depend&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710039585985-a81f2aa8-b41e-461b-bc89-2642cab063a3.png#averageHue=%23222120&clientId=ud3f5d7d5-6e8f-4&from=drop&id=ud2b27244&originHeight=109&originWidth=542&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=18085&status=done&style=none&taskId=u0cad5214-f47f-4485-a806-092b7a4e5d0&title=" alt="image-20210816153438400.png"><br /><strong>第二步修改和CMakeLists.txt</strong><br />在CMakeLists.txt中加入下面一行代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(village_interfaces REQUIRED)</span><br></pre></td></tr></table></figure><p><strong>find_package是cmake的语法，用于查找库。找到后，还需要将其和可执行文件链接起来</strong><br />所以还需要修改ament_target_dependencies，在其中添加village_interfaces。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ament_target_dependencies</span>(wang2_node </span><br><span class="line">  rclcpp </span><br><span class="line">  village_interfaces</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于C++来说，添加服务接口只需在程序中引入对应的头文件即可。<br /><strong>这个头文件就是我们SellNovel.srv生成的头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;village_interfaces/srv/sell_novel.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><p><a name="Fhg7q"></a></p><h5 id="声明回调函数"><a href="#声明回调函数" class="headerlink" title="声明回调函数"></a>声明回调函数</h5><p>添加完服务接口接着就可以声明一个<strong>卖书请求回调函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell_book_callback</span><span class="params">(<span class="type">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再创建一个队列，用于存放自己看过的二手书，创建队列需要用到queue容器，所以我们先用#include <queue>在程序开头引入该容器，再在代码中添加下面这句话。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个小说章节队列</span></span><br><span class="line">std::queue&lt;std::string&gt;  novels_queue;</span><br></pre></td></tr></table></figure><p><a name="LaIsk"></a></p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>当张三请求王二买二手书的时候，假如王二手里书的数量不足，王二就等攒够了对应数量的书再返回给张三。<br />等待攒够章节的操作需要在卖书服务函数中阻塞当前线程，阻塞后王二就收不到李四写的小说了，这样一来就会造成一个很尴尬的情景：<br /><strong>在卖书服务回调函数中等着书库（队列）里小说章节数量满足张三需求，接收小说的程序等着这边的卖书回调函数结束，好把书放进书库（队列）里。</strong><br />这种互相等待的情况，我们称之为死锁<br />ROS2默认是单线程的，同时只有一个线程在跑，大家都是顺序执行，你干完我干，一条线下去。<br />所以为了解决这个问题，我们可以使用多线程，即每次收到服务请求后，单独开一个线程来处理，不影响其他部分。<br><a name="aZhlq"></a></p><h5 id="回调函数组"><a href="#回调函数组" class="headerlink" title="回调函数组"></a>回调函数组</h5><p>ROS2中要使用多线程执行器和回调组来实现多线程，我们先在SingleDogNode中声明一个回调组成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务回调组</span></span><br><span class="line">rclcpp::CallbackGroup::SharedPtr callback_group_service_;</span><br></pre></td></tr></table></figure><p>最终结果</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class SingleDogNode : <span class="keyword">public</span> rclcpp<span class="type">::Node</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    SingleDogNode(std<span class="type">::string</span> name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明一个服务回调组</span></span><br><span class="line">    rclcpp<span class="type">::CallbackGroup</span><span class="type">::SharedPtr</span> callback_group_service_;</span><br><span class="line">    <span class="comment">//创建一个小说章节队列</span></span><br><span class="line">    std<span class="type">::queue</span>&lt;std<span class="type">::string</span>&gt;  novels_queue;</span><br><span class="line">    <span class="comment">// 声明一个服务端</span></span><br><span class="line">    rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br><span class="line">    <span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    <span class="literal">void</span> sell_book_callback(const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Request</span><span class="type">::SharedPtr</span> request,</span><br><span class="line">        const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Response</span><span class="type">::SharedPtr</span> response)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对请求数据进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="rAhK4"></a></p><h5 id="实例化服务端-编写回调函数处理请求"><a href="#实例化服务端-编写回调函数处理请求" class="headerlink" title="实例化服务端&amp;&amp;编写回调函数处理请求"></a>实例化服务端&amp;&amp;编写回调函数处理请求</h5><p>在ROS2中，回调函数组也是一个对象，通过实例化create_callback_group类即可创建一个callback_group_service的对象。<br />在SingleDogNode的构造函数中添加下面这行代码，即可完成实例化 </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">callback_group_service_</span> = this-&gt;create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><br />我们使用成员函数作为回调函数，这里要根据回调函数中参数个数，设置占位符，即告诉编译器，这个函数需要传入的参数个数。<br /><strong>在之前订阅话题的回调函数中，我们已经用到过一次了，因为话题回调只有一个参数，所以只需要一个占位符，这里服务的回调是两个参数，所以要设置两个</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br></pre></td></tr></table></figure><p>在private:下<strong>声明服务端</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务端</span></span><br><span class="line">rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br></pre></td></tr></table></figure><p>在构造函数中<strong>实例化服务端</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化卖二手书的服务</span></span><br><span class="line">server_ = this<span class="punctuation">-&gt;</span>create_service&lt;village_interfaces::srv::SellNovel&gt;(<span class="string">&quot;sell_novel&quot;</span>,</span><br><span class="line">                            std::<span class="title function_ invoke__">bind</span>(&amp;SingleDogNode::sell_book_callback,this,_1,_2),</span><br><span class="line">                            rmw_qos_profile_services_default,</span><br><span class="line">                            callback_group_service_);</span><br></pre></td></tr></table></figure><p>实例化服务端可以直接使用create_service函数，该函数是一个模版函数，需要输入要创建的服务类型，这里我们使用的是&lt;village_interfaces::srv::SellNovel&gt;，这个函数有四个参数需要输入,小鱼接下来进行一一介绍</p><ul><li>“sell_novel”服务名称，没啥好说的，要唯一哦，因为服务只能有一个</li><li>std::bind(&amp;SingleDogNode::sell_book_callback,this,_1,_2)回调函数，这里指向了我们2.3.1中我们声明的sell_book_callback</li><li>rmw_qos_profile_services_default 通信质量，这里使用服务默认的通信质量</li><li>callback_group_service_，回调组，我们前面创建回调组就是在这里使用的，告诉ROS2，当你要调用回调函数处理请求时，请把它放到单独线程的回调组中<br><a name="q5mnn"></a></li></ul><h5 id="编写回调函数"><a href="#编写回调函数" class="headerlink" title="编写回调函数"></a>编写回调函数</h5><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    void sell_book_callback(<span class="keyword">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span><br><span class="line">        <span class="keyword">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;收到一个买书请求，一共给了%d钱&quot;</span>,request-&gt;money);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> novelsNum = request-&gt;money*<span class="number">1</span>;  <span class="comment">//应给小说数量，一块钱一章</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前书库里书的数量是否满足张三要买的数量，不够则进入等待函数</span></span><br><span class="line">        <span class="keyword">if</span>(novels_queue.size()&lt;novelsNum)</span><br><span class="line">        &#123;</span><br><span class="line">            RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：不能满足需求,开始等待&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置rate周期为1s，代表1s检查一次</span></span><br><span class="line">            rclcpp::Rate loop_rate(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当书库里小说数量小于请求数量时一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (novels_queue.size()&lt;novelsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断系统是否还在运行</span></span><br><span class="line">                <span class="keyword">if</span>(!rclcpp::ok())</span><br><span class="line">                &#123;</span><br><span class="line">                    RCLCPP_ERROR(this-&gt;get_logger(), <span class="string">&quot;程序被终止了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印一下当前的章节数量和缺少的数量</span></span><br><span class="line">                RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;等待中，目前已有%d章，还差%d章&quot;</span>,novels_queue.size(),novelsNum-novels_queue.size());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//rate.sleep()让整个循环1s运行一次</span></span><br><span class="line">                loop_rate.sleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 章节数量满足需求了</span></span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：已经满足需求&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一本本把书取出来，放进请求响应对象response中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;novelsNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            response-&gt;novels.push_back(novels_queue.front());</span><br><span class="line">            novels_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br />当收到请求时，先计算一下应该给张三多少书novelsNum，然后判断书库里书的数量够不够，不够则进入攒书程序。如果够或者攒够了就把书放到服务响应对象里，返回给张三。这里我们还需要修改一下话题回调函数，增加了一行代码，将小说放到书库里novels_queue.push(msg-&gt;data);</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到话题数据的回调函数</span></span><br><span class="line"> void <span class="title function_ invoke__">topic_callback</span>(<span class="keyword">const</span> std_msgs::msg::<span class="type">String</span>::SharedPtr msg)&#123;</span><br><span class="line">     <span class="comment">// 新建一张人民币</span></span><br><span class="line">     std_msgs::msg::UInt32 money;</span><br><span class="line">     money.data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送人民币给李四</span></span><br><span class="line">    pub_<span class="punctuation">-&gt;</span><span class="title function_ invoke__">publish</span>(money);</span><br><span class="line">    <span class="title function_ invoke__">RCLCPP_INFO</span>(this<span class="punctuation">-&gt;</span><span class="title function_ invoke__">get_logger</span>(), <span class="string">&quot;王二：我收到了：&#x27;%s&#x27; ，并给了李四：%d 元的稿费&quot;</span>, msg<span class="punctuation">-&gt;</span>data.<span class="title function_ invoke__">c_str</span>(),money.data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小说放入novels_queue中</span></span><br><span class="line">    novels_queue.<span class="title function_ invoke__">push</span>(msg<span class="punctuation">-&gt;</span>data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="S7CCg"></a></p><h5 id="修改main函数"><a href="#修改main函数" class="headerlink" title="修改main函数"></a>修改main函数</h5><p>因为我们要让整个程序变成多线程的，所以我们要把节点的执行器变成多线程执行器。<br />修改一下main函数，新建一个多线程执行器，添加王二节点并spin,完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <a href="https://raw.githubusercontent.com/fishros/ros2_town/af8b29f7b23153d35348ebfcd3b1bc5760c6c5a6/village_wang/src/wang2.cpp">wang2.cpp</a><br><a name="NmoFR"></a></p><h5 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure><p><a name="YjbW2"></a></p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_wang wang2_node</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2@ubuntu:~/code/town_ws$ ros2 service list -t</span><br><span class="line">/sell_book [village_interfaces/srv/SellNovel]</span><br><span class="line">ros2 service call /sell_book  village_interfaces/srv/SellNovel &quot;&#123;money: 5&#125;&quot;</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_li li4_node</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040232046-33fa90eb-16d0-4459-8907-ec1d53912d34.png#averageHue=%232f2f2f&clientId=ud3f5d7d5-6e8f-4&from=drop&id=bKVka&originHeight=251&originWidth=1424&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=135885&status=done&style=none&taskId=ud6755017-b9b4-40d3-a3d5-08f505ffa75&title=" alt="image-20210831124712850.png"></p><p><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.10%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0(C++)?id=_3%e5%ae%a2%e6%88%b7%e7%ab%af%ef%bc%88%e5%bc%a0%e4%b8%89%ef%bc%89%e5%ae%9e%e7%8e%b0">客户端实现</a><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040911063-ab181be4-89fa-4a05-8da4-a2b5d58c0444.png#averageHue=%23eeebe9&clientId=ud3f5d7d5-6e8f-4&from=drop&id=u4725bfe1&originHeight=430&originWidth=380&originalType=binary&ratio=1.5625&rotation=0&showTitle=false&size=62757&status=done&style=none&taskId=u2b8126d0-3aa8-4cae-b16e-308b2b4d88f&title=" alt="28bff3501425d8b0e5a018fb3f7cfb1b.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a name=&quot;w3PS4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装ROS2&quot;&gt;&lt;a href=&quot;#安装ROS2&quot; class=&quot;headerlink&quot; title=&quot;安装ROS2&quot;&gt;&lt;/a&gt;安装ROS2&lt;/h1&gt;&lt;p&gt;鱼香yyds&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http://fishros.com/install -O fishros &amp;amp;&amp;amp; bash fishros&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;卸载ROS&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt remove ros-foxy-* &amp;amp;&amp;amp; sudo apt autoremove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a name=&quot;hoy3W&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="ROS" scheme="http://zuweicun.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS1初步</title>
    <link href="http://zuweicun.top/2024/03/11/ROS1%E5%88%9D%E6%AD%A5/"/>
    <id>http://zuweicun.top/2024/03/11/ROS1%E5%88%9D%E6%AD%A5/</id>
    <published>2024-03-11T12:12:21.000Z</published>
    <updated>2024-09-16T14:18:29.665Z</updated>
    
    <content type="html"><![CDATA[<p><a name="J4y9t"></a></p><h1 id="Topic与Message"><a href="#Topic与Message" class="headerlink" title="Topic与Message"></a>Topic与Message</h1><span id="more"></span><p>基础概念：<br />1.话题Topic是节点间进行持续通讯的一种形式<br />2.话题通讯的两个节点通过话题的名称建立起话题通讯连接。<br />3.话题中通讯的数据，叫做消息Message<br />4.消息Message通常会按照一定的频率持续不断的发送，以保证消息数据的实时性。<br />5.消息的发送方叫做话题的发布者Publisher<br />6.消息的接收方叫做话题的订阅者Subsciber<br />更多有：<br />1.一个ROS节点网络中，可以同时存在多个话题<br />2.一个话题可以有多个发布者，也可以有多个订阅者<br />3.一个节点可以对多个话题进行订阅，也可以发布多个话题<br />4.不痛得传感器消息通常会拥有各自独立话题名称，每个话题只有一个发布者<br />5.机器人速度指令话题通常会有多个发布者，但是同一时间只能有一个发言人。<br><a name="v1QhS"></a></p><h2 id="Topic的C-实现"><a href="#Topic的C-实现" class="headerlink" title="Topic的C++实现"></a>Topic的C++实现</h2><p>发布者的具体步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家发布一个话题并得到消息发送对象<br />4.生成要发送的消息包并进行发送数据的赋值。<br />5.调用消息发送对象的publish()函数将消息包发送到话题当中。<br />为了查看有关的Topic我们可以使用以下的常用工具：<br />rostopic list<br />列出当前系统汇总所有活跃着的话题<br />rostopic echo 主体名称<br />显示指定话题中发送的消息包内容<br />rostopic hz 主体名称<br />统计指定话题中消息包的发送频率<br />而话题的订阅需要满足以下的步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include&lt;ros.h&gt;和消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家订阅一个话题并设置消息接收回调函数<br />4.定义一个回调函数，对接收到的消息包进行处理。<br />5.main函数中需要执行ros::spinOnce()，让回调函数能够响应接受到的消息包<br><a name="JxKTI"></a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;chao_node&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;node_chao is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//这里第二个参数表示缓存空间</span></span><br><span class="line">  <span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chao is sending\n&quot;</span>);</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    msg.data = <span class="string">&quot;chao is sending message&quot;</span>;</span><br><span class="line">    pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_WARN</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;ma_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>, chao_callback);</span><br><span class="line"><span class="comment">//这里第三个参数类似于单片机里的中断函数</span></span><br><span class="line">  Subscriber sub_yao = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_yao&quot;</span>, <span class="number">10</span>, yao_callback);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">spinOnce</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="L26MD"></a></p><h3 id="图形化界面rqt-graph"><a href="#图形化界面rqt-graph" class="headerlink" title="图形化界面rqt_graph"></a>图形化界面rqt_graph</h3><p>运行三个节点和roscore，然后在一个新的终端中输入rqt_graph可以得到一个用来观察当前消息链路的图形化界面<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705307614453-48eb5146-7ae3-40e1-b12c-6cc0a99ed5cb.png#averageHue=%23817243&clientId=ued9d9fb6-a67b-4&from=paste&height=586&id=u8f7c53f5&originHeight=1172&originWidth=2532&originalType=binary&ratio=2&rotation=0&showTitle=false&size=466221&status=done&style=none&taskId=u54a4f49e-81fd-4e78-bf60-cd6d364613b&title=&width=1266" alt="image.png"><br><a name="DLwhc"></a></p><h3 id="launch文件同时启动多个节点"><a href="#launch文件同时启动多个节点" class="headerlink" title="launch文件同时启动多个节点"></a>launch文件同时启动多个节点</h3><p>launch文件是一种遵循XML语法的描述文件，这里启动多个节点只是launch文件的功能之一。 <br />对应到启动节点，我们可以使用这个流程：<br />1.使用launch文件，可以通过roslaunch指令一次启动多个节点。<br />2.在launch文件中，为节点添加output&#x3D;”screen”属性，可以容纳个节点信息输出在终端中。（ROS_WARN不受该属性控制）<br />3.在launch文件中，为节点添加launch-prefix&#x3D;”gnome-terminal -e”属性，可以让节点单独运行在一个独立终端中。<br />具体的，我们使用这个代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而我们使用时只需要在终端中使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch 包名 launch文件名</span><br></pre></td></tr></table></figure><p>就可以运行了<br><a name="Xp45g"></a></p><h2 id="Topic的python实现"><a href="#Topic的python实现" class="headerlink" title="Topic的python实现"></a>Topic的python实现</h2><p>python实现基本上和c++实现差不多，无非就是c++中的NodeHandler变成了python中的rospy<br />看看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment">#说明解释器和编码</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: <span class="comment">#主函数</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;chao_node&quot;</span>)<span class="comment">#申明节点</span></span><br><span class="line">    rospy.logwarn(<span class="string">&quot;node chao is running&quot;</span>)<span class="comment">#启动标签，打个warn让你吓一跳（</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;node_chao&quot;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)<span class="comment">#控制频率</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;node chao is sending message&quot;</span>)</span><br><span class="line">        msg = String()</span><br><span class="line">        msg.data = <span class="string">&quot;this is node chao&#x27;s message&quot;</span></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><p>和c++的程序实现十分相似<br />值得说明的是，在launch中c++直接是一个可执行文件，而python则是要加入后缀py</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="Wz45W"></a></p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>service是ros中另一种通讯方式，类似于服务器和终端之间请求式的关系。<br />主要操作步骤分为：<br />1.服务端Server注册<br />2.客户端Client注册<br />3.节点管理器进行话题匹配<br />4.服务端请求服务<br />5.服务端提供服务<br><a name="OQdRg"></a></p><h2 id="终端指令的实现"><a href="#终端指令的实现" class="headerlink" title="终端指令的实现"></a>终端指令的实现</h2><p>我们使用ros自带的小乌龟来手动模拟一下一个service实现的过程<br />首先启动ros核心并召唤出小乌龟<br />然后使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rqt_service_caller rqt_service_caller</span><br></pre></td></tr></table></figure><p>召唤出图形化的service界面<br />按照<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388668505-d518fb03-f941-4f5c-b0f6-7f08d92ac516.png#averageHue=%23ede7e5&clientId=u36e31b96-9ee5-4&from=paste&height=435&id=uc21508a1&originHeight=956&originWidth=940&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=271004&status=done&style=none&taskId=uda7225e4-f750-48cd-b154-967e9ec5ca3&title=&width=427.27271801184054" alt="image.png"><br />来配置<br />就能看到图上出现了一只新的小乌龟<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388704513-fa622c00-39a1-498e-85e3-d908b340bc3e.png#averageHue=%234556fe&clientId=u36e31b96-9ee5-4&from=paste&height=255&id=u07d8973e&originHeight=562&originWidth=504&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=20276&status=done&style=none&taskId=u4f0b890d-9656-4f8d-9ad6-8a5d36bee53&title=&width=229.09090412549747" alt="image.png"></p><p><a name="zoD2G"></a></p><h2 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h2><p><a name="T27RX"></a></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_client</span>();</span><br><span class="line">  ~<span class="built_in">service_client</span>();</span><br><span class="line">  ros::ServiceClient client;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_client::<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">  client = nh.<span class="built_in">serviceClient</span>&lt;service_test::service_test::Request&gt;(<span class="string">&quot;a_b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">service_client::request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;request&quot;</span> &lt;&lt; endl;</span><br><span class="line">  service_test::service_test req;</span><br><span class="line">  req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  <span class="keyword">if</span> (client.<span class="built_in">call</span>(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;request falied&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  a++;</span><br><span class="line">  b += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">service_client::~<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_client&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_client is started&quot;</span>);</span><br><span class="line">  service_client service_client;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    service_client.<span class="built_in">request</span>();</span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里用一个类写了一下这个东西，实现了一个a+b的不断请求<br />注意一下里面的核心语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceClient&lt;service_test::service_test::Request&gt;(&quot;a+b&quot;);</span><br></pre></td></tr></table></figure><p>这里定义了最重要的服务名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  if (client.call(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;=&quot; &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里以req为媒介去询问并获得数据<br><a name="rS9TQ"></a></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_server</span>(<span class="comment">/* args */</span>);</span><br><span class="line">  ~<span class="built_in">service_server</span>();</span><br><span class="line">  ros::ServiceServer server;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_server::<span class="built_in">service_server</span>(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">  server = nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">service_server::requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a request is handled&quot;</span> &lt;&lt; endl;</span><br><span class="line">  response.sum = request.numb1 + request.numb2;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service_server::~<span class="built_in">service_server</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_server&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_server is started&quot;</span>);</span><br><span class="line">  service_server server;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里核心为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>这里前面是名字，后面有返回参数，不过这个this我看了半天也没明白是什么，我看如果没有写类的话这里好像只有两个参数，所以我大胆猜测这个是用来指向类的一个东西？<br><a name="RRsNw"></a></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>再cmakelists中加入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(service_client src/service_client.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_client</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_client $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(service_server src/service_server.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_server</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_server $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br></pre></td></tr></table></figure><p>然后编译运行<br />效果：<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705392274716-e9b41739-0415-4df2-964b-0a2a2bb01b27.png#averageHue=%231e1a1a&clientId=ue763d424-91f3-4&from=paste&height=440&id=u37dec1cb&originHeight=968&originWidth=1456&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=257893&status=done&style=none&taskId=uf53eabec-6008-468b-a83f-f7a4cd72232&title=&width=661.8181674736594" alt="image.png"><br><a name="OpNbK"></a></p><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><p><a name="sOxSw"></a></p><h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> service_test, service_testResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addCallback</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="built_in">sum</span> = req.numb1 + req.numb2</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;a request is being handled&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> service_testResponse(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建一个名为add_server的server，注册回调函数addCallback,返回类型为service_test</span></span><br><span class="line">    server = rospy.Service(<span class="string">&quot;add_server&quot;</span>, service_test, addCallback)</span><br><span class="line"></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;server is Ready.&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实具体思路和c++很相似，就有个坑，第五行那两个，我本来以为只要自定义两个当作输入输出就行了，后来发现好像不大行，必须严格按照他这个格式。<br><a name="Mphok"></a></p><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    rospy.wait_for_service(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    add_two_ints = rospy.ServiceProxy(<span class="string">&quot;add_server&quot;</span>, service_test)</span><br><span class="line">    resp = add_two_ints(x, y)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;sum:%lf&quot;</span>, resp.<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_client&quot;</span>)</span><br><span class="line">    x = <span class="number">0.1585</span></span><br><span class="line">    y = <span class="number">15.21</span></span><br><span class="line">    add_two_ints_client(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这位更是十分简洁，没啥问题。记得和srv里文件一定就行了。<br />说起来为啥C语言要搞成.h而python只要srv呢（<br><a name="DPKCw"></a></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705478826907-6a743179-d0cd-490d-be0c-760eb509f9b5.png#averageHue=%231e1b1a&clientId=ubbf6ae85-b225-4&from=paste&height=492&id=u874c5b1f&originHeight=984&originWidth=1476&originalType=binary&ratio=2.200000047683716&rotation=0&showTitle=false&size=191244&status=done&style=none&taskId=ufb54405b-e108-494f-a287-1060d7db19b&title=&width=738" alt="image.png"></h3><p><a name="gMt1l"></a></p><h1 id="param"><a href="#param" class="headerlink" title="param"></a>param</h1><p><a name="QUW9p"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>举个栗子，我现在手里有一组数据，现在很多个节点都在想要得到我这个数据，如果使用前面的两种通讯方式，我开个topic在里面公麦喊数据显然不太合理，或者再开一个服务器呢？看起来好像不错，但是我们要维持这个端口一方面得一直开着这个节点，另一方面要不断的对外输出数据还得自己手写，而且各种数据类型还都不好处理。这个时候就需要我们的参数服务器登场了。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705485702889-26424fa6-e2ba-4130-ae19-545ad789e272.png#averageHue=%23f5f5f5&clientId=u670af268-3edf-4&from=paste&height=280&id=u95f2ebc6&originHeight=559&originWidth=1024&originalType=binary&ratio=2&rotation=0&showTitle=false&size=43576&status=done&style=none&taskId=ufb874013-3788-41b9-8c63-bc7cf6c85c4&title=&width=512" alt="image.png"><br />在这里总计有三个角色，但是实际操作起来的时候，我们并不需要向之前一样像master注册身份，而是只要连接到master之后就可以进行全部的操作。<br />当然了为了书写的方便我们在实现中依旧将get和set分开写。值得注意的是，参数服务器不随着set的关闭而关闭，而是随着roscore的启动一直存在。<br><a name="aKczn"></a></p><h2 id="c-的实现"><a href="#c-的实现" class="headerlink" title="c++的实现"></a>c++的实现</h2><p><a name="UUER6"></a></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_set&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    string name = <span class="string">&quot;vbot&quot;</span>;</span><br><span class="line">    string geometry = <span class="string">&quot;rectangle&quot;</span>;</span><br><span class="line">    <span class="type">double</span> wheel_radius = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">int</span> wheel_num = <span class="number">4</span>;</span><br><span class="line">    <span class="type">bool</span> vision = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>&#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;vbot&#x27;</span>);               <span class="comment">// 字符串, 机器人的名字，char*</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);         <span class="comment">// 字符串, 形状，string</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius); <span class="comment">// 车轮半径double</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);        <span class="comment">// 车轮数量int</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;vision&quot;</span>, vision);              <span class="comment">// 是否具有视觉bool</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;base_size&quot;</span>, base_size);        <span class="comment">// 三维体积vector</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);        <span class="comment">// 传感器的id，map</span></span><br><span class="line">    <span class="comment">// 验证是否设置成功</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get name&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get geometry&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_radius&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_num&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get base_size&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get sensor_id&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们描述了一个机器人，将这个机器人的各个参数传入了参数服务器<br />值得说明的是，这里用了两种写法来写入数据，一种是用NodeHandle，一种直接调用了param里的函数<br />另外system这里不知道为什么会给个warning，无视就行了<br><a name="OjksJ"></a></p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_get&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  <span class="comment">// 修改参数</span></span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;mybot&quot;</span>); <span class="comment">// 字符串, char*</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.2</span>, <span class="number">0.04</span>&#125;;</span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size); <span class="comment">// vector</span></span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">  sensor_id.<span class="built_in">insert</span>(&#123;<span class="string">&quot;ultrasonic&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line">  param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id); <span class="comment">// map</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line"></span><br><span class="line">  string name;</span><br><span class="line">  string geometry;</span><br><span class="line">  <span class="type">double</span> wheel_radius;</span><br><span class="line">  <span class="type">int</span> wheel_num;</span><br><span class="line">  <span class="type">bool</span> vision;</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;vision&quot;</span>, vision);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, name: %s, geometry: %s, wheel_radius: %lf, wheel: %d, vision: %s, base_size: (%lf, %lf)&quot;</span>,</span><br><span class="line">           name.<span class="built_in">c_str</span>(), geometry.<span class="built_in">c_str</span>(), wheel_radius, wheel_num, vision ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>,</span><br><span class="line">           base_size[<span class="number">0</span>], base_size[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> sensor : sensor_id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, %s_id: %d&quot;</span>, sensor.first.<span class="built_in">c_str</span>(), sensor.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除参数</span></span><br><span class="line"></span><br><span class="line">  nh.<span class="built_in">deleteParam</span>(<span class="string">&quot;vision&quot;</span>);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里好像也没有什么要说明的了，大家看看就行了<br><a name="PVfKq"></a></p><h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(param_set src/param_set.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(param_get src/param_get.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_set</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_get</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="X1725"></a></p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>param函数直接返回值，不存在则返回default_val，getparamcached函数好象是getparam的进阶版，加了个记搜？getparamnames返回所有值，以vector形式给出。<br><a name="EWhdA"></a></p><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705486990088-41376b0a-9140-4996-8f12-a6679c204d01.png#averageHue=%231f1b1b&clientId=u670af268-3edf-4&from=paste&height=506&id=uf0ed96e3&originHeight=1012&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=247069&status=done&style=none&taskId=u607c6b38-a903-4ac5-ab4b-8f6db920f4c&title=&width=754" alt="image.png"><br><a name="dsWxB"></a></p><h2 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h2><p><a name="mnReF"></a></p><h3 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure><p><a name="pLckx"></a></p><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个实在是没啥好讲的，看代码就行了（<br><a name="OTwIA"></a></p><h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p><a name="JC3y8"></a></p><h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><p>在实际中，有的时候通讯的时间是非常长的，而在通讯过程中，我们需要掌握中间值，比如我们要下载一个东西，我们可能时不时就要看一看下载进度，这个时候进度就是所需要的反馈feedback值<br />Action在结构上几乎和服务service相似，所以我暂时将其理解为service with feedback(?)<br><a name="yurY8"></a></p><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>说实话这个实现有点阴间，我也只是把教程里的那个东西实现了一下，要自己纯手搓感觉不好实现（<br><a name="fAysR"></a></p><h3 id="文件分层："><a href="#文件分层：" class="headerlink" title="文件分层："></a>文件分层：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559399543-95ef64ac-bbf9-47a2-a75d-de38c50c3d9c.png#averageHue=%23060504&clientId=ucf2197ff-0c36-4&from=paste&height=74&id=ub74f1fe7&originHeight=370&originWidth=468&originalType=binary&ratio=2&rotation=0&showTitle=false&size=41409&status=done&style=none&taskId=u7efe1ed1-fea5-401f-9729-b13df614435&title=&width=93.6" alt="image.png"><br><a name="CiRbu"></a></p><h3 id="laundry-action"><a href="#laundry-action" class="headerlink" title="laundry.action"></a>laundry.action</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># goal，洗衣类型 1:开始快洗;2:开始高温洗;3:开始浸泡洗</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_type</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># result，洗涤结果</span></span><br><span class="line"><span class="string">string</span> <span class="string">wash_result</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># feedback，洗涤的进度</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_percent</span></span><br></pre></td></tr></table></figure><p><a name="YMVMz"></a></p><h3 id="cmake-1"><a href="#cmake-1" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(action_test)</span><br><span class="line"><span class="comment"># catkin构建时依赖的组件包</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line"><span class="comment"># include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 配置action源文件，FILES将引用当前功能包目录的action目录中的*.action文件，自动生成一个头文件（*.h）</span></span><br><span class="line">add_action_files(</span><br><span class="line">  FILES</span><br><span class="line">  Laundry.action</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成消息时依赖于std_msgs、actionlib_msgs</span></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时依赖，描述了库、catkin构建依赖项和系统依赖的功能包</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES action_test</span></span><br><span class="line"> CATKIN_DEPENDS roscpp rospy std_msgs actionlib actionlib_msgs </span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(action_client src/action_client.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(action_server src/action_server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建库和可执行文件之前，预先生成依赖消息</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(action_client <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(action_server <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置目标链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_client</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_server</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="mf7uX"></a></p><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/client/simple_action_client.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionClient&lt;action_test::LaundryAction&gt; ActionClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doneCb</span><span class="params">(<span class="type">const</span> actionlib::SimpleClientGoalState &amp;state, <span class="type">const</span> action_test::LaundryResultConstPtr &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state.state_ == state.SUCCEEDED)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;反馈结果:%s&quot;</span>, result-&gt;wash_result.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;任务失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">activeCb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;动作已经被激活....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feedbackCb</span><span class="params">(<span class="type">const</span> action_test::LaundryFeedbackConstPtr &amp;feedback)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;洗涤进度为:%d%s&quot;</span>, feedback-&gt;wash_percent, <span class="string">&quot;%&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.实例化action客户端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作的名称，参数3默认为true，无需再调用ros::spin()，设置为false时需手动调用</span></span><br><span class="line">  <span class="function">ActionClient <span class="title">client</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 等待服务端启动</span></span><br><span class="line">  client.<span class="built_in">waitForServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.定义动作目标数据</span></span><br><span class="line">  action_test::LaundryGoal goal;</span><br><span class="line">  goal.wash_type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.发送目标，同时注册回调，处理反馈以及最终结果</span></span><br><span class="line">  <span class="comment">// 参数1是转换为Done时处理的回调函数，参数2为转换为Active时处理的回调函数，参数3为每当收到此目标的反馈时就调用的回调函数</span></span><br><span class="line">  client.<span class="built_in">sendGoal</span>(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="s4uDJ"></a></p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/server/simple_action_server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionServer&lt;action_test::LaundryAction&gt; ActionServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.收到action的goal后调用的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeCb</span><span class="params">(<span class="type">const</span> action_test::LaundryGoalConstPtr &amp;goal, ActionServer *server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取目标值</span></span><br><span class="line">  <span class="type">uint8_t</span> wash_type = goal-&gt;wash_type;</span><br><span class="line">  std::string wash_mode;</span><br><span class="line">  <span class="keyword">switch</span> (wash_type)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;快洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;高温洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;浸泡洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;目标值为%d，开始%s！&quot;</span>, wash_type, wash_mode.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应连续反馈</span></span><br><span class="line">  action_test::LaundryFeedback feedback;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    feedback.wash_percent = i;</span><br><span class="line">    server-&gt;<span class="built_in">publishFeedback</span>(feedback);</span><br><span class="line">    ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>).<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反馈结果</span></span><br><span class="line">  action_test::LaundryResult result;</span><br><span class="line">  result.wash_result = wash_mode + <span class="string">&quot;完成！&quot;</span>;</span><br><span class="line">  server-&gt;<span class="built_in">setSucceeded</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_server&quot;</span>);</span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="comment">// 3.实例化action服务端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作服务器名称，参数3为当一个新目标被接收时在一个单独的线程中被调用，参数4为告诉ActionServer是否在它出现时立即开始发布</span></span><br><span class="line">  <span class="function">ActionServer <span class="title">server</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, boost::bind(&amp;executeCb, _1, &amp;server), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Vpuri"></a></p><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559548910-bc235096-7d99-4292-b382-b91268dfc171.png#averageHue=%231f1b1b&clientId=ucf2197ff-0c36-4&from=paste&height=506&id=ub6200bb0&originHeight=1012&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=286203&status=done&style=none&taskId=u5d1e22a4-1937-479d-8cce-5e1ec8d2b05&title=&width=754" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a name=&quot;J4y9t&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Topic与Message&quot;&gt;&lt;a href=&quot;#Topic与Message&quot; class=&quot;headerlink&quot; title=&quot;Topic与Message&quot;&gt;&lt;/a&gt;Topic与Message&lt;/h1&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="ROS" scheme="http://zuweicun.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>关于过年抢红包的数学模型</title>
    <link href="http://zuweicun.top/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zuweicun.top/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-02-09T14:42:23.000Z</published>
    <updated>2024-09-16T14:18:51.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于过年抢红包的数学模型"><a href="#关于过年抢红包的数学模型" class="headerlink" title="关于过年抢红包的数学模型"></a>关于过年抢红包的数学模型</h1><h2 id="建模初衷"><a href="#建模初衷" class="headerlink" title="建模初衷"></a>建模初衷</h2><p>旧词已去，新春将至，首先祝各位新春快乐，龙年大吉！   </p><p>​     最近，我不禁留意到许多朋友在抢红包这一传统活动中屡次受挫，心生疑惑与好奇。在这个新年风俗的背后，究竟隐藏着怎样的数学模型和本源机制呢？于是，我产生了一个突发奇想的想法，希望通过构建一个专注于抢红包的数学模型，深入探讨这一活动的规律、趋势以及可能的变数。</p><span id="more"></span><p>​     这个数学模型的目标不仅仅是揭示红包金额的分配方式，更是希望通过对抢红包过程的数学建模，挖掘其中的概率学、随机性、和博弈理论等数学原理。通过精心设计模型，我们或许能够理解为何有些人总能赢得更多，而有些人却屡屡受挫的原因。这也为我们提供了一个新的视角，来看待这个看似简单却又蕴含深厚数学内涵的传统文化现象。</p><h2 id="模型雏形"><a href="#模型雏形" class="headerlink" title="模型雏形"></a>模型雏形</h2><p>​    在红包数据庞大的情况下，抢红包的机制可以近似看作是随机抽样。我们可以采用蒙特卡洛模拟方法，通过生成大量的随机样本进行统计分析，从而估算红包分配的平均情况。这种方法通过模拟多次独立的红包抢夺过程，得到了一个近似的红包金额分布，</p><p>​    这种方法的优势在于，它不仅能够在庞大的数据集上进行模拟，而且还能够灵活地应用于不同的分布类型。我们引入了参数 <code>distribution</code>，使得模拟可以选择均匀分布或正态分布等。此外，为了提高效率，我们使用了 NumPy 库生成正态分布，使模拟更加高效。</p><p>   这个模型的局限性在于它仍然是一个概率模型，通过模拟得到的结果是一种期望的近似。在实际应用中，还可以进一步考虑更复杂的因素，例如用户心理、群体行为等，以得到更准确的模拟结果。这个模型的主要目的是为了提供一个直观的近似方法，用于初步理解红包分配的规律。   </p><h2 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h2><p>生成的图像是红包金额分配的模拟结果。在这个模型中，我们进行了多次蒙特卡洛模拟，每次模拟都对同一组人数和总金额进行了10000次红包抽取。图像中的 x 轴表示抢红包的人数，y 轴表示每个人抢到的红包平均金额。</p><p>通过这个图像，我们可以观察到在给定的总金额和人数下，每个人抢到的红包平均金额的分布情况。在模拟的多次试验中，我们得到了多个平均分布曲线，每条曲线代表一次模拟的结果。这样的可视化展示使我们能够更清晰地了解红包分配的随机性和不确定性。</p><p>在图像中，如果某个人数下的平均金额分布较为集中，说明在这种情况下，大多数人抢到的金额差异不大。相反，如果分布较为分散，说明抢到的金额存在较大的差异。</p><p><img src="/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/Figure_1.png" alt="Figure_1"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simulate_red_packet</span>(<span class="params">total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span></span>):</span><br><span class="line">    all_results = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):  <span class="comment"># 模拟10000次抢红包</span></span><br><span class="line">            remaining_amount = total_amount</span><br><span class="line">            remaining_people = total_people</span><br><span class="line">            red_packet = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total_people - <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 随机生成一个红包金额</span></span><br><span class="line">                <span class="keyword">if</span> distribution == <span class="string">&#x27;uniform&#x27;</span>:</span><br><span class="line">                    amount = random.uniform(<span class="number">0.01</span>, remaining_amount - remaining_people * <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">elif</span> distribution == <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                    amount = <span class="built_in">max</span>(<span class="number">0.01</span>, np.random.normal(remaining_amount / remaining_people, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid distribution type&quot;</span>)</span><br><span class="line"></span><br><span class="line">                red_packet.append(amount)</span><br><span class="line">                remaining_amount -= amount</span><br><span class="line">                remaining_people -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后一个红包的金额等于剩余的金额</span></span><br><span class="line">            red_packet.append(remaining_amount)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 随机打乱红包顺序</span></span><br><span class="line">            random.shuffle(red_packet)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录每个人抢到的金额</span></span><br><span class="line">            results.append(red_packet)</span><br><span class="line"></span><br><span class="line">        all_results.append(results)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_results</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_results</span>(<span class="params">all_results</span>):</span><br><span class="line">    average_amounts_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> results <span class="keyword">in</span> all_results:</span><br><span class="line">        average_amounts = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(results[<span class="number">0</span>])):</span><br><span class="line">            total_amount = <span class="built_in">sum</span>(result[i] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line">            average_amount = total_amount / <span class="built_in">len</span>(results)</span><br><span class="line">            average_amounts.append(average_amount)</span><br><span class="line"></span><br><span class="line">        average_amounts_list.append(average_amounts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> average_amounts_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">average_amounts_list, num_simulations</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(average_amounts_list[i]) + <span class="number">1</span>), average_amounts_list[i], label=<span class="string">f&#x27;Simulation <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Person&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Average Amount&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Red Packet Distribution with Varying Data Amount&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    total_amount = <span class="number">100</span>  <span class="comment"># 总金额</span></span><br><span class="line">    total_people = <span class="number">10</span>  <span class="comment"># 总人数</span></span><br><span class="line">    num_simulations = <span class="number">5</span>  <span class="comment"># 模拟次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟均匀分布下的抢红包情况</span></span><br><span class="line">    all_results_uniform = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">    average_amounts_uniform = analyze_results(all_results_uniform)</span><br><span class="line">    plot_distribution(average_amounts_uniform, num_simulations)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟正态分布下的抢红包情况</span></span><br><span class="line">    all_results_normal = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">    average_amounts_normal = analyze_results(all_results_normal)</span><br><span class="line">    plot_distribution(average_amounts_normal, num_simulations)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>我们可以建立一个简单的数学模型，其中包含三个变量：引诱红包的金额量（<code>enticing_amount</code>）、引诱的群聊数量（<code>group_count</code>）、和最终净红包的回报率（<code>return_rate</code>）。我们可以假设这些变量之间存在某种线性关系。</p><p><em><strong>Net_Red_Packet&#x3D;enticing_amount×group_count×return_rate+noise</strong></em></p><p>其中，<em>noise</em> 表示模型中的随机噪声，可以包含一些不可预测的因素。</p><p>为了使用神经网络构建模型，我们可以将其视为一个回归问题。我们的输入特征为引诱红包的金额量、引诱的群聊数量，输出为最终净红包的回报率。</p><p><img src="/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/Figure_3.png" alt="Figure_2"></p><p>可以看到在epoch接近100时，尽管有一点波动，在之后训练损失值已经趋于稳定。</p><p><img src="/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/Figure_2.png" alt="Figure_3"></p><p>在以上可视化图像中不难发现，红包金额有以下几个特点：</p><ol><li><strong>随机性主导分配：</strong> 由于红包的随机性，抢到红包的金额呈现出随机分布的特征。这符合我们对红包抢够的直观认知，即每个人抢到的金额具有不确定性。</li><li><strong>平均金额趋向：</strong> 随着模拟次数的增加，我们观察到平均金额有向某个数值趋近的趋势。这可能是由于模型中设置的金额范围和总人数等参数导致的。在实际情况中，红包金额的平均分配可能受到更多因素的影响，例如红包金额设置、群聊人数等。</li><li><strong>模型的应用范围：</strong> 这个模型在一定程度上反映了红包随机分配的特性，但并不涵盖所有情况。实际中，红包分配还可能受到人为干预、算法调整等因素的影响，这些因素并未在模型中考虑。</li></ol><h2 id="模型总结"><a href="#模型总结" class="headerlink" title="模型总结"></a>模型总结</h2><ol><li><p><strong>更复杂的模型：</strong> 在实际应用中，可以考虑引入更多的因素，如用户关系、历史抢红包记录等，构建更为复杂的数学模型，以更准确地描述红包分配的机制。</p></li><li><p><strong>算法优化：</strong> 针对特定场景，可以优化红包分配的算法，以达到更好的用户体验。这可能需要对模型进行细致的参数调整和算法改进。</p></li><li><p><strong>社会学和心理学因素：</strong> 考虑到红包活动是一种社交行为，未来的研究可以引入社会学和心理学的因素，深入探讨红包背后的社交动机和心理机制。</p><p><strong>以及，可以适当考虑人品问题。</strong></p><p>（本文章无任何研究意义，仅供娱乐，相关可视化代码已经发布到Github上）</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于过年抢红包的数学模型&quot;&gt;&lt;a href=&quot;#关于过年抢红包的数学模型&quot; class=&quot;headerlink&quot; title=&quot;关于过年抢红包的数学模型&quot;&gt;&lt;/a&gt;关于过年抢红包的数学模型&lt;/h1&gt;&lt;h2 id=&quot;建模初衷&quot;&gt;&lt;a href=&quot;#建模初衷&quot; class=&quot;headerlink&quot; title=&quot;建模初衷&quot;&gt;&lt;/a&gt;建模初衷&lt;/h2&gt;&lt;p&gt;旧词已去，新春将至，首先祝各位新春快乐，龙年大吉！   &lt;/p&gt;
&lt;p&gt;​     最近，我不禁留意到许多朋友在抢红包这一传统活动中屡次受挫，心生疑惑与好奇。在这个新年风俗的背后，究竟隐藏着怎样的数学模型和本源机制呢？于是，我产生了一个突发奇想的想法，希望通过构建一个专注于抢红包的数学模型，深入探讨这一活动的规律、趋势以及可能的变数。&lt;/p&gt;</summary>
    
    
    
    <category term="屎山" scheme="http://zuweicun.top/categories/%E5%B1%8E%E5%B1%B1/"/>
    
    
    <category term="屎山" scheme="http://zuweicun.top/tags/%E5%B1%8E%E5%B1%B1/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习</title>
    <link href="http://zuweicun.top/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zuweicun.top/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-01-12T15:57:55.000Z</published>
    <updated>2024-09-16T14:19:15.737Z</updated>
    
    <content type="html"><![CDATA[<p>经过长达一天的重装和环境配置，正式开始OpenCV的学习。</p><span id="more"></span><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/Star_ID/article/details/122656593">OpenCV入门【C++版】_opencv c++入门-CSDN博客</a></p><p><a href="https://oldpan.me/archives/use-vscode-cmake-tools-build-project">利用VScode和cmake编译构建C++工程代码 - Oldpan的个人博客</a></p><p><a href="https://blog.csdn.net/qq_41921826/article/details/129145473">OpenCV - C++实战（05） — 颜色检测_c++图像色素带识别-CSDN博客</a></p><h2 id="基本-（图片-视频）操作"><a href="#基本-（图片-视频）操作" class="headerlink" title="基本 （图片&amp;视频）操作"></a>基本 （图片&amp;视频）操作</h2><p>首先在opencv中创建一个文件夹mytest，用于存放后续的测试程序,并创建程序test1（后续同理）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mytest</span><br><span class="line">cd mytest</span><br><span class="line">gedit test1.cpp</span><br></pre></td></tr></table></figure><p>找一张图片（好友丑照）命名为1.jpg存放于这个目录中用于后续测试（蹂躏）。</p><h3 id="1-图片腐蚀"><a href="#1-图片腐蚀" class="headerlink" title="1 图片腐蚀"></a>1 图片腐蚀</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat element =<span class="built_in">getStructuringElement</span>(MORPH_RECT,<span class="built_in">Size</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">erode</span>(srcImage,dstImage,element);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]腐蚀操作&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能很简单，就是一个腐蚀操作。</p><p>在终端输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ test1.cpp -o test1 `pkg-config --cflags --libs opencv`</span><br><span class="line">./test1</span><br></pre></td></tr></table></figure><p>显示原图和腐蚀操作图。</p><p>效果展示：</p><p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><p>完美运行。</p><h3 id="2-图像模糊"><a href="#2-图像模糊" class="headerlink" title="2.图像模糊"></a>2.图像模糊</h3><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">blur</span>(srcImage,dstImage,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好理解，载入原图之后调用一次blur函数，最后显示效果图。</p><p>效果如下：</p><p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p><h3 id="3-Canny边缘检测"><a href="#3-Canny边缘检测" class="headerlink" title="3  Canny边缘检测"></a>3  Canny边缘检测</h3><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage,edge,grayImage;<span class="comment">//参数定义</span></span><br><span class="line">    dstImage.<span class="built_in">create</span>(srcImage.<span class="built_in">size</span>(),srcImage.<span class="built_in">type</span>());</span><br><span class="line">    <span class="comment">//创建与src同类型大小的矩阵（dest）</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//将原图像转换为灰度图像</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">blur</span>(grayImage,edge,<span class="built_in">Size</span>(<span class="number">3</span>,<span class="number">3</span>));<span class="comment">//3x3内核降噪</span></span><br><span class="line">    <span class="built_in">Canny</span>(edge,edge,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>);<span class="comment">//运行Canny算子</span></span><br><span class="line">    dstImage = edge; <span class="comment">//将Canny算子的结果赋值给dstImage</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>(); <span class="comment">//释放所有窗口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p><h3 id="4-读取视频"><a href="#4-读取视频" class="headerlink" title="4.读取视频"></a>4.读取视频</h3><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="string">&quot;1.avi&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;<span class="comment">//定义Mat变量储存每一帧</span></span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);<span class="comment">//延迟30ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-调取摄像头采集视频"><a href="#5-调取摄像头采集视频" class="headerlink" title="5.调取摄像头采集视频"></a>5.调取摄像头采集视频</h3><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    Mat edges;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">cvtColor</span>(frame,edges,COLOR_BGR2GRAY);<span class="comment">//灰度转换</span></span><br><span class="line">        <span class="built_in">blur</span>(edges,edges,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">        <span class="built_in">Canny</span>(edges,edges,<span class="number">1</span>,<span class="number">31</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（其实就是把Videocapture中的视频源改为参数0）</p><h3 id="6-灰度转化"><a href="#6-灰度转化" class="headerlink" title="6.灰度转化"></a>6.灰度转化</h3><p>图片有多种色彩模式，主要就是包括位图模式，灰度模式，RGB模式，CMYK模式和HSB模式。这里就不详细展开了。值得注意的有两个概念，就是图片的深度和通道，深度表示一个图片的一个像素有几位，通道则表示一个图像由几层颜色表示，一般由单通道（灰度），三通道（RGB）以及四通道（RGB+透明度）表示。</p><p>在opencv中我们一般采用cvtColor这个函数来转换图像的灰度。</p><p><img src="/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/4.png" alt="4"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="type">void</span> <span class="title">cvtColor</span><span class="params">(InputArray src, OutputArray dst, <span class="type">int</span> code, <span class="type">int</span> dstCn=<span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>这里给出函数的定义和常用的几个转换标识</p><h2 id="图像裁剪和缩放"><a href="#图像裁剪和缩放" class="headerlink" title="图像裁剪和缩放"></a>图像裁剪和缩放</h2><p>可以参考</p><p><a href="https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc=%7B%22request_id%22:%22170480359916800185832024%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170480359916800185832024&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120584785-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=opencv%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%A9%E6%94%BE&spm=1018.2226.3001.4187">https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522170480359916800185832024%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;170480359916800185832024&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduend~default-1-120584785-null-null.142^v99^pc_search_result_base6&amp;utm_term&#x3D;opencv%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%A9%E6%94%BE&amp;spm&#x3D;1018.2226.3001.4187</a></p><h3 id="图像尺寸缩放："><a href="#图像尺寸缩放：" class="headerlink" title="图像尺寸缩放："></a>图像尺寸缩放：</h3><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">( InputArray src, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function"> OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">             Size dsize, <span class="comment">//调整成的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fx = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fy = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> interpolation = INTER_LINEAR </span></span></span><br><span class="line"><span class="params"><span class="function">             )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><ul><li>src：输入的图像，Mat类</li><li>dst：输出的图像，当参数dsize不为0时，dst的大小由dsize决定；否则，它的大小由参数fx和fy决定</li><li>dsize：输出图像的大小，写成Size(宽，高)（单位：像素）</li><li>fx和fy：水平&#x2F;竖直方向上的缩放比例</li><li>interpolation：插值方法。取值如下：<br>INTER_NEAREST———最近邻插值<br>INTER_LINEAR———双线性插值（默认设置）<br>INTER_AREA———使用像素区域关系进行重采样<br>INTER_CUBIC———4x4像素邻域的双三次插值<br>INTER_LANCZOS4———8x8像素邻域的Lanczos插值</li><li>注意：参数dsize和参数(fx, fy)不能够同时为0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat outImg;</span><br><span class="line">    <span class="built_in">resize</span>(img, outImg, <span class="built_in">Size</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="number">0.8</span>, <span class="number">0.8</span>);<span class="comment">//宽和高都变为原来的0.8倍</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;改变尺寸后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h3><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    <span class="function">Rect <span class="title">cropArea</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Mat outImg = <span class="built_in">img</span>(cropArea);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;裁剪后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图像绘制和文字输出"><a href="#图像绘制和文字输出" class="headerlink" title="图像绘制和文字输出"></a>图像绘制和文字输出</h2><p>参考资料：<a href="https://blog.csdn.net/k673656/article/details/129227483?ops_request_misc=%7B%22request_id%22:%22170480417316800213038610%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170480417316800213038610&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-129227483-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=opencv%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%E5%92%8C%E6%96%87%E5%AD%97%E7%BB%98%E5%88%B6&spm=1018.2226.3001.4187">Opencv图形绘制与文字输出_opencv mat 显示文字-CSDN博客</a></p><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(InputOutputArray img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>其中center表示中心位置，radius表示半径，thikness可以表示厚度，-1表示填充，与可以表示位FILLED</p><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> 值得注意的是，还可以使用RECT来绘制，函数如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Rect(x,y,width,height), <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="输入文字"><a href="#输入文字" class="headerlink" title="输入文字"></a>输入文字</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">putText</span><span class="params">( InputOutputArray img, <span class="type">const</span> String&amp; text, Point org, <span class="type">int</span> fontFace, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">double</span> fontScale, Scalar color, <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> bottomLeftOrigin = <span class="literal">false</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>img表示初始的文字，text表示文字内容，org表示文字的左下角坐标，fontface表示字体类型，fontscale表示字体大小，最后以为表示图像数据的原点是左下角还是左上角。</p><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p>首先，对几何变换做个简单了解。打开任意一个图像编辑器，一般可以有对图像进行放大、缩小、旋转等操作，这类操作改变了原图中各区域的空间关系。对于这类操作，通常称为图像的<strong>几何变换</strong>。</p><p>一般而言，完成一张图像的几何变换需要<strong>两个独立的算法</strong>：<strong>首先</strong>，需要一个算法实现空间坐标变换，用它描述每个像素如何从初始位置移动到终止位置；<strong>其次</strong>，还需要一个<strong>插值算法</strong>完成输出图像的每个像素的灰度值。</p><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><h4 id="仿射矩阵"><a href="#仿射矩阵" class="headerlink" title="仿射矩阵"></a>仿射矩阵</h4><p>对于空间变换的仿射矩阵有两种计算方式，分别是<strong>方程组法</strong>和<strong>矩阵相乘法</strong>。</p><p><strong>(1) 方程组法</strong></p><p>仿射变换矩阵有六个未知数，所以需要三组对应位置坐标，构造出由六个方程组成的方程组即可解六个未知数。<br>举例：如果(0,0) 、(200,0) 、(0,200)这三个坐标通过某仿射变换矩阵A分别转换为(0,0) 、(100,0) 、(0,100)，则可利用这三组对应坐标构造出六个方程，求解出A。</p><p>对于C++的API函数getAffineTransform()输入参数有两种方式，第一种方式是将原位置坐标和对应的变换后的坐标分别保存在Point2f数组中，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Point2f src[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">200</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">200</span>) &#125;;</span><br><span class="line">Point2f dst[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">100</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">100</span>) &#125;;</span><br><span class="line"></span><br><span class="line">Mat A = <span class="built_in">getAffineTransform</span>(src,dst);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; A&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值A仍然是2行3列的矩阵，指的是<strong>仿射变换矩阵的前两行</strong>。需要注意的是，数据类型是CV_64F而<strong>不是</strong>CV_32F。</p><p>第二种方式是<strong>将原位置坐标和对应的变换后的坐标保存在</strong>Mat中，<strong>每一行代表一个坐标，数据类型必须是</strong>CV_32F，否则会报错，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mat A = <span class="built_in">getAffineTransform</span>(src, dst);</span><br><span class="line">cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用矩阵相乘法计算仿射矩阵，<strong>前提是需要知道基本仿射变换步骤</strong>.</p><p><strong>需要注意的是</strong>，虽然先缩放再平移，但是仿射变换矩阵是<strong>平移仿射矩阵乘以缩放仿射矩阵，而不是缩放仿射矩阵乘以平移仿射矩阵</strong>，即等式右边的运算是从右向左进行的。</p><p>在<a href="https://so.csdn.net/so/search?q=OpenCV&spm=1001.2101.3001.7020">OpenCV</a>中是通过“*”运算符或者gemm函数来实现矩阵的乘法的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//缩放矩阵</span></span><br><span class="line">Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>,<span class="number">1</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//平移矩阵</span></span><br><span class="line"></span><br><span class="line">Mat A;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gemm</span>(src,dst,<span class="number">1.0</span>,<span class="built_in">Mat</span>(),<span class="number">0</span>,A,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透射变换"><a href="#透射变换" class="headerlink" title="透射变换"></a>透射变换</h3><p>仿射变换是在平面上的线性变换加平移，根据其性质可知变换后平行四边形依然是平行四边形，不改变直线的平行关系。透射变换即中心投影变换，利用透视中心、像点、目标点三点共线的条件,按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p><p> 透视变换是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射。</p><p>移动投影中心和承影面，可得到各种形状的变换。（有点像《三体》里的二向箔）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cv::getPerspectiveTransform</span> <span class="params">(<span class="type">const</span> Point2f src[], <span class="type">const</span> Point2f dst[])</span></span></span><br></pre></td></tr></table></figure><p><strong>返回相应 4 个点对的 3x3 透视变换</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpPerspective</span> <span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize, <span class="type">int</span> flags=INTER_LINEAR, <span class="type">int</span> borderMode=BORDER_CONSTANT, <span class="type">const</span> Scalar &amp;borderValue=Scalar())</span></span></span><br></pre></td></tr></table></figure><p><strong>对图像应用透视变换</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">Mat matrix, imgWarp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;Resources/cards.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>, <span class="number">142</span>&#125;, &#123;<span class="number">771</span>, <span class="number">190</span>&#125;, &#123;<span class="number">405</span>, <span class="number">395</span>&#125;, &#123;<span class="number">674</span>, <span class="number">457</span>&#125; &#125;;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;, &#123;w, <span class="number">0.0f</span>&#125;, &#123;<span class="number">0.0f</span>, h&#125;, &#123;w, h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"><span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;ImageWarp&quot;</span>, imgWarp);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：文档扫描应该就是这种变换。</p><h2 id="颜色检测："><a href="#颜色检测：" class="headerlink" title="颜色检测："></a>颜色检测：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::inRange</span> <span class="params">(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure><p>检查数组元素是否位于其他两个数组的元素之间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::namedWindow</span> <span class="params">(<span class="type">const</span> String &amp;winname, <span class="type">int</span> flags = WINDOW_AUTOSIZE)</span></span></span><br></pre></td></tr></table></figure><p><strong>创建一个窗口</strong>。函数namedWindow创建一个可用作图像和轨迹栏占位符的窗口。创建的窗口由它们的名称引用。如果同名的窗口已经存在，则该函数不执行任何操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cv::createTrackbar</span> <span class="params">(<span class="type">const</span> String &amp;trackbarname, <span class="type">const</span> String &amp;winname, <span class="type">int</span> *value, <span class="type">int</span> count, TrackbarCallback onChange = <span class="number">0</span>, <span class="type">void</span> *userdata = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>创建一个</strong>trackbar<strong>并将其附加到指定窗口</strong>。函数createTrackbar创建一个具有指定名称和范围的trackbar（滑块或范围控件），分配一个变量值作为与trackbar同步的位置，并指定回调函数onChange为 在跟踪栏位置变化时被调用。创建的轨迹栏显示在指定的窗口winname中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Mat imgHSV, mask;</span><br><span class="line"><span class="type">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line"><span class="type">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string path = <span class="string">&quot;resources/lambo.png&quot;</span>;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">2555</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目实操"><a href="#项目实操" class="headerlink" title="项目实操"></a>项目实操</h2><h4 id="参考资料：-1"><a href="#参考资料：-1" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://hitwhlc.yuque.com/tosania">@23沈晨阳</a></p><p>此处为语雀内容卡片，点击链接查看：<a href="https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt">https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt</a></p><p><a href="https://blog.csdn.net/qq_40344790/article/details/127653557?ops_request_misc=%7B%22request_id%22:%22170481303716800188516338%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=170481303716800188516338&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=opencv%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8Bc++&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_40344790&#x2F;article&#x2F;details&#x2F;127653557?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522170481303716800188516338%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id&#x3D;170481303716800188516338&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142^v99^pc_search_result_base6&amp;utm_term&#x3D;opencv%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8Bc%2B%2B&amp;spm&#x3D;1018.2226.3001.4187</a></p><h4 id="任务内容："><a href="#任务内容：" class="headerlink" title="任务内容："></a>任务内容：</h4><h5 id="OpenCV红绿灯检测"><a href="#OpenCV红绿灯检测" class="headerlink" title="OpenCV红绿灯检测"></a>OpenCV红绿灯检测</h5><ul><li><p>使用**c++**版本的opencv对视频进行处理</p></li><li><p>读取TrafficLight.mp4</p></li><li><p>检测交通信号灯颜色，并在图像中标出红绿灯位置（中间数字无需检测）</p></li><li><p>将信号灯颜色以字符串输出到图像左上角</p></li><li><p>将处理后的视频输出为result.avi，示例为压缩包内“输出示例.avi”</p></li><li><p>可以进行创新，给大家的视频只是一个示例</p></li><li><p>在语雀中创建文档，完整记录自己的实现方式</p></li><li><p>将代码、result.avi放入同一压缩包内上传到语雀中</p></li><li><p>将result.avi直接传入语雀中，其他人可以直接查看的那种</p></li><li><p>提交截止时间：下周一例会前(2.14)</p></li></ul><h4 id="完成思路："><a href="#完成思路：" class="headerlink" title="完成思路："></a>完成思路：</h4><p>1.将视频的每一帧处理，（高斯模糊，边缘检测，膨胀….），增强特征点的提取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对二值化后的图像进行高斯模糊</span></span><br><span class="line">    <span class="built_in">GaussianBlur</span>(imgDil, imgDil, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对图像进行Canny边缘检测</span></span><br><span class="line">    <span class="built_in">Canny</span>(imgDil, imgDil, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义膨胀操作的内核</span></span><br><span class="line">    Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对Canny边缘检测后的图像进行膨胀</span></span><br><span class="line">    <span class="built_in">dilate</span>(imgDil, imgDil, kernel);</span><br></pre></td></tr></table></figure><p>2.由于红绿灯是由许多小像素点组成的，可能会造成误判，故需要检测一下轮廓过滤出最大的画出矩形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找图像中的轮廓</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="built_in">findContours</span>(imgDil, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储轮廓的多边形逼近和轮廓的矩形边界</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储最大轮廓的相关信息</span></span><br><span class="line"><span class="type">double</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> choose = <span class="number">0</span>, ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，找到最大的符合条件的轮廓</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>) &gt; maxx)</span><br><span class="line">    &#123;</span><br><span class="line">        maxx = <span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        choose = i;</span><br><span class="line">        <span class="keyword">if</span> (maxx &gt; <span class="number">20</span> &amp;&amp; <span class="built_in">contourArea</span>(contours[i]) &gt; <span class="number">2000</span>)</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，绘制最大的轮廓及相关信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choose == i &amp;&amp; ok == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算轮廓的多边形逼近</span></span><br><span class="line">        <span class="type">double</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算轮廓的矩形边界</span></span><br><span class="line">        boundRect[i] = <span class="built_in">boundingRect</span>(conPoly[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形边界</span></span><br><span class="line">        <span class="built_in">rectangle</span>(img, boundRect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">225</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在矩形边界的左上角绘制文本</span></span><br><span class="line">        <span class="built_in">putText</span>(img, c, boundRect[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">100</span>), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于颜色的识别：</li></ul><p>由于inrange函数的局限性，最好将图像转换成HSV颜色空间，相比于RGB颜色空间，HSV颜色空间更适合处理颜色分割和阈值操作。在HSV中，颜色范围可以更容易地通过阈值进行调整，因为色调和明度是分开的。</p><p>使用HSV颜色空间是为了更容易地确定图像中红色和绿色的区域。对于交通灯的颜色检测，通常更关注颜色的种类而不是其亮度或深浅，因此使用HSV更为合适。</p><p>主函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 视频文件路径</span></span><br><span class="line">    string path = <span class="string">&quot;1.avi&quot;</span>;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line">    Mat img;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧数</span></span><br><span class="line">    <span class="type">int</span> cnt = cap.<span class="built_in">get</span>(CAP_PROP_FRAME_COUNT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧的大小</span></span><br><span class="line">    Size sizeReturn = <span class="built_in">Size</span>(cap.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH), cap.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建输出视频的写入对象，设置输出视频文件名、编码方式、帧率和大小</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), cap.get(CAP_PROP_FPS), sizeReturn)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历视频的每一帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取当前帧</span></span><br><span class="line">        cap &gt;&gt; img;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换当前帧为HSV颜色空间</span></span><br><span class="line">        Mat imgHSV;</span><br><span class="line">        <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义绿色和红色的HSV阈值范围</span></span><br><span class="line">        <span class="function">Scalar <span class="title">g_lower</span><span class="params">(h_gmin, s_gmin, v_gmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">g_upper</span><span class="params">(h_gmax, s_gmax, v_gmax)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_lower</span><span class="params">(h_rmin, s_rmin, v_rmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_upper</span><span class="params">(h_rmax, s_rmax, v_rmax)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过HSV阈值得到绿色和红色的掩码</span></span><br><span class="line">        Mat g_mask, r_mask;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, g_lower, g_upper, g_mask);</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, r_lower, r_upper, r_mask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对绿色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workg</span>(g_mask, img, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对红色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workr</span>(r_mask, img, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将处理后的帧写入输出视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(img);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;img&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 释放视频捕捉对象和写入对象</span></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来是不用学人脸识别的，感觉好玩所以写了个基于摄像头输入源的人脸识别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CascadeClassifier faceCascade;</span><br><span class="line">faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">Mat img;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">vector&lt;Rect&gt; face;</span><br><span class="line">faceCascade.<span class="built_in">detectMultiScale</span>(img, face);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(img, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="built_in">putText</span>(img, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后来感觉不够，完全可以基于主屏幕输入画面进行人脸识别，方便帮舍友识别出藏在床底下的老王（bushi）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xutil.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* display = <span class="built_in">XOpenDisplay</span>(<span class="literal">NULL</span>); <span class="comment">// 打开X11显示</span></span><br><span class="line">    Screen* screen = <span class="built_in">DefaultScreenOfDisplay</span>(display); <span class="comment">// 获取默认屏幕</span></span><br><span class="line">    <span class="type">int</span> width = screen-&gt;width; <span class="comment">// 获取屏幕的宽度</span></span><br><span class="line">    <span class="type">int</span> height = screen-&gt;height; <span class="comment">// 获取屏幕的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载人脸检测分类器</span></span><br><span class="line">    CascadeClassifier faceCascade;</span><br><span class="line">    faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建VideoWriter对象，用于将每一帧屏幕图像写入视频文件</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), <span class="number">30</span>, Size(width, height))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取屏幕的XImage对象</span></span><br><span class="line">        XImage* ximage = <span class="built_in">XGetImage</span>(display, <span class="built_in">DefaultRootWindow</span>(display), <span class="number">0</span>, <span class="number">0</span>, width, height, AllPlanes, ZPixmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为OpenCV的Mat对象</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">image</span><span class="params">(height, width, CV_8UC4, ximage-&gt;data)</span></span>; <span class="comment">// 创建Mat对象</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(image, image, cv::COLOR_BGRA2BGR); <span class="comment">// 转换为BGR格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕图像上进行人脸检测和标注</span></span><br><span class="line">        vector&lt;Rect&gt; face;</span><br><span class="line">        faceCascade.<span class="built_in">detectMultiScale</span>(image, face);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rectangle</span>(image, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">putText</span>(image, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示屏幕图像</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Screen&quot;</span>, image);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将修改后的图像写入视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">XDestroyImage</span>(ximage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭X11显示</span></span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放VideoCapture对象和VideoWriter对象的资源</span></span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经过长达一天的重装和环境配置，正式开始OpenCV的学习。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenCV" scheme="http://zuweicun.top/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://zuweicun.top/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>CMake入门</title>
    <link href="http://zuweicun.top/2024/01/12/CMake%E5%85%A5%E9%97%A8/"/>
    <id>http://zuweicun.top/2024/01/12/CMake%E5%85%A5%E9%97%A8/</id>
    <published>2024-01-12T15:55:00.000Z</published>
    <updated>2024-09-16T14:19:09.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><h4 id="1-1Cmake是什么"><a href="#1-1Cmake是什么" class="headerlink" title="1 .1Cmake是什么"></a>1 .1Cmake是什么</h4><p>CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。可以构建、测试、打包项目。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。对于c++工程来说，通过cmake配置，然后通过cmake工具自动生成makefile文件，最后通过make编译出二进制文件。也就是说CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。</p><span id="more"></span><h4 id="1-2-Cmake-优缺点"><a href="#1-2-Cmake-优缺点" class="headerlink" title="1.2 Cmake 优缺点"></a>1.2 Cmake 优缺点</h4><ul><li><p>优点</p></li><li><ul><li>编程式的配置</li><li>支持跨平台</li><li>支持强依赖受控管理</li><li>官方提供的依赖查找方式</li><li>支持配置分离</li><li>支持多种外部调用方式</li><li>官方提供多种系统检测接口</li><li>支持工具链（Toolchain）以传递配置</li><li>官方提供了多种工具链实现</li><li>自身具有版本控制及约束功能</li></ul></li><li><p>缺点</p></li><li><ul><li>文档太差。cmake的文档差是一个公认的问题，那官方文档上连一个具体实例都没有，关键点也不会明确体现出来。</li><li>弱变量及未定义的变量导致非预期行为。cmake是一个弱语言，其变量没有具体的类型之分。你可以使用某个变量代表一个字符串，也可以代表一个列表。而在其他部分使用此变量作为非预期的类型会导致无穷无尽的问题。当然，这是弱语言的共通问题。而在一处使用未被定义的变量更容易发生未预期的行为。</li><li>调试困难。cmake官方目前不支持断点调试功能。</li></ul></li></ul><h3 id="2-Cmake环境配置"><a href="#2-Cmake环境配置" class="headerlink" title="2 Cmake环境配置"></a>2 Cmake环境配置</h3><p>先安装cmake然后进行环境变量配置即可。 验证是否成功，在命令窗口执行 cmake –verson 即可。</p><h3 id="3-简单的Cmake工程"><a href="#3-简单的Cmake工程" class="headerlink" title="3 简单的Cmake工程"></a>3 简单的Cmake工程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:/code/vscodeProject 目录下的文件列表，文档后面都会用到这个路径，后续不在说明。</span><br><span class="line">├─.vscode</span><br><span class="line">├─build</span><br><span class="line">│  ├─.cmak</span><br><span class="line">│  ├─CMakeFiles</span><br><span class="line">│  ├─main</span><br><span class="line">│  ├─src</span><br><span class="line">│  └─Testing</span><br><span class="line">├─exe</span><br><span class="line">├─include</span><br><span class="line">├─main</span><br><span class="line">├─script</span><br><span class="line">└─src</span><br></pre></td></tr></table></figure><p>通过cmake搭建的一个c++编译工程 链接 github: <a href="https://github.com/Persist-Forever/cmakeProc.git">https://github.com/Persist-Forever/cmakeProc.git</a></p><h3 id="4-基本命令"><a href="#4-基本命令" class="headerlink" title="4 基本命令"></a>4 基本命令</h3><h4 id="4-1-描述命令"><a href="#4-1-描述命令" class="headerlink" title="4.1 描述命令"></a>4.1 描述命令</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.0</span><span class="number">.0</span>)  # 指定cmake的最小版本</span><br><span class="line"><span class="built_in">project</span>(getestProc VERSION <span class="number">0.1</span><span class="number">.0</span>)      # 指定项目名称及版本号，初始化项目相关变量</span><br><span class="line"><span class="built_in">project</span>(getestProc C CXX)                # 指定项目支持的语言 C C++</span><br></pre></td></tr></table></figure><h4 id="4-2-关键路径"><a href="#4-2-关键路径" class="headerlink" title="4.2 关键路径"></a>4.2 关键路径</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># PROJECT_SOURCE_DIR 项目的目录 也就是 D:/code/<span class="function">vscodeProject</span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span>$&#123;PROJECT_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"># PROJECT_BINARY_DIR 项目的构建目录 D:/code/vscodeProject/build</span></span><br><span class="line"><span class="function">MESSAGE(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> $&#123;</span>PROJECT_BINARY_DIR&#125;)</span><br></pre></td></tr></table></figure><h4 id="4-3-设置关键字"><a href="#4-3-设置关键字" class="headerlink" title="4.3 设置关键字"></a>4.3 设置关键字</h4><p>SET关键字用来显示指定的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(SRC_LIST XXX.cpp xx2.cpp xx3.cpp ...)</span><br><span class="line"># $&lt;TARGET_OBJECTS:src-dltest-object&gt; 这个设置到一个变量中是因为add_libary可以使用</span><br><span class="line"><span class="built_in">set</span>(src-dltest</span><br><span class="line">     $&lt;TARGET_OBJECTS:src-dltest-object&gt;</span><br><span class="line">     PARENT_SCOPE)</span><br></pre></td></tr></table></figure><h4 id="4-4-获取目录下所有源文件"><a href="#4-4-获取目录下所有源文件" class="headerlink" title="4.4 获取目录下所有源文件"></a>4.4 获取目录下所有源文件</h4><p>该函数用的比较多，注意不会递归。构建文件中经常使用到这一句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br></pre></td></tr></table></figure><h4 id="4-5-信息打印-MASSAGE关键字"><a href="#4-5-信息打印-MASSAGE关键字" class="headerlink" title="4.5 信息打印 MASSAGE关键字"></a>4.5 信息打印 MASSAGE关键字</h4><p>MESSAGE关键字主要用于向终端输出用户自定义的信息，主要包含三种信息</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过</li><li>STATUS，输出前缀为–的信息</li><li>FATAL_ERROR，立即终止所有cmake过程</li></ul><h4 id="4-6-add-library"><a href="#4-6-add-library" class="headerlink" title="4.6 add_library"></a>4.6 add_library</h4><ul><li>第一种用法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            [&lt;source&gt;...])</span><br><span class="line"># 生成 liboptical.<span class="function">so</span></span><br><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(optical share optical.cpp $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure><p>add_library根据源码来生成一个库供他人使用。是个逻辑名称，在项目中必须唯一。完整的库名依赖于具体构建方式（可能为lib.a or .lib）。</p><p>STATIC指静态库，SHARED指动态库，MODULE指在运行期通过类似于dlopen的函数动态加载。</p><ul><li>第二种用法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(&lt;name&gt; OBJECT [&lt;source&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_library</span>(... $&lt;TARGET_OBJECTS:name&gt; ...)</span><br><span class="line"><span class="built_in">add_executable</span>(... $&lt;TARGET_OBJECTS:name&gt; ...)</span><br></pre></td></tr></table></figure><p>生成一个obj对象，该对象库只编译源文件，但不链接。由add_library()或add_executable()创建的目标可以使用$&lt;TARGET_OBJECTS:name&gt;这样的表达式作为源引用对象，其中，name是对象库的名称。</p><h4 id="4-6-add-subdirectory"><a href="#4-6-add-subdirectory" class="headerlink" title="4.6 add_subdirectory"></a>4.6 add_subdirectory</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"># 将 optical otn目录加入到构建系统中，另外参数一般不需要使用</span><br><span class="line"><span class="built_in">add_subdirectory</span>(optical)</span><br><span class="line"><span class="built_in">add_subdirectory</span>(otn)</span><br></pre></td></tr></table></figure><p>将子目录添加到构建系统中。source_dir指定一个目录，其中存放CMakeLists.txt文件和代码文件。binary_dir指定的目录存放输出文件，如果没有指定则使用source_dir。</p><h4 id="4-7-add-executable"><a href="#4-7-add-executable" class="headerlink" title="4.7 add_executable"></a>4.7 add_executable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 第一种：<span class="function">Normal Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span></span></span><br><span class="line"><span class="params"><span class="function">               [EXCLUDE_FROM_ALL]</span></span></span><br><span class="line"><span class="params"><span class="function">               [source1] [source2 ...])</span></span></span><br><span class="line"><span class="function"># 第二种：Imported Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; IMPORTED [GLOBAL])</span></span></span><br><span class="line"><span class="function"># 第三种：Alias Executables</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(&lt;name&gt; ALIAS &lt;target&gt;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#第一种是项目中经常用到的，这里就用第一种举例</span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(main main.cpp $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure><p>该关键字使用指定的源文件来生成目标可执行文件。具体分为三类：普通、导入、别名。此处我们就以普通可执行文件进行说明，其中是可执行文件的名称，在cmake工程中必须唯一。<strong>WIN32用于在windows下创建一个以WinMain为入口的可执行文件</strong>。MACOSX_BUNDLE用于mac系统或者IOS系统下创建一个GUI可执行应用程序。</p><h4 id="4-8-target-link-libraries"><a href="#4-8-target-link-libraries" class="headerlink" title="4.8 target_link_libraries"></a>4.8 target_link_libraries</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(&lt;target&gt; ... &lt;item&gt;... ...)</span><br></pre></td></tr></table></figure><p>指定链接给定目标和&#x2F;或其依赖项时要使用的库。命名的必须是由add_executable()或add_library()之类的命令创建的。一般与 link_directories连用（添加外部库的搜索路径 ）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 第一种方式 一般引入第三方库用这种</span><br><span class="line"><span class="built_in">add_library</span>(hello hello.cpp)        # 生成对象库文件</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp)       # 生成可执行文件</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Demo hello)   # 链接对象库</span><br><span class="line"></span><br><span class="line"># 第二种方式  本项目的研发代码链路</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp)  # 生成对象库文件，不链接</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp $&lt;TARGET_OBJECTS:hello&gt;)</span><br><span class="line"></span><br><span class="line"># 第三种 完全没必要多次一举罗</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp)</span><br><span class="line"><span class="built_in">add_executable</span>(Demo main.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(Demo hello)</span><br></pre></td></tr></table></figure><h4 id="4-9-include"><a href="#4-9-include" class="headerlink" title="4.9 include"></a>4.9 include</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include</span>(&lt;file|<span class="keyword">module</span>&gt; [OPTIONAL] [RESULT_VARIABLE &lt;VAR&gt;]</span><br><span class="line">                      [NO_POLICY_SCOPE])</span><br><span class="line"># 导入device_cfg.cmake文件 其他参数很少用</span><br><span class="line"><span class="built_in">include</span>(device_cfg.cmake)</span><br></pre></td></tr></table></figure><p>从指定的文件加载、运行CMake代码。如果指定文件，则直接处理。如果指定module，则寻找module.cmake文件，首先在${CMAKE_MODULE_PATH}中寻找，然后在CMake的module目录中查找。</p><h4 id="4-10-target-include-directories"><a href="#4-10-target-include-directories" class="headerlink" title="4.10 target_include_directories"></a>4.10 target_include_directories</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_include_directories</span>(&lt;target&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br><span class="line">  </span><br><span class="line"># 生成对象库文件</span><br><span class="line"><span class="built_in">add_library</span>(hello OBJECT hello.cpp) </span><br><span class="line"># 添加头文件目录</span><br><span class="line"><span class="built_in">target_include_directories</span>(hello PUBLIC $&#123;CMAKE_SOURCE_DIR&#125;/<span class="keyword">public</span>)</span><br></pre></td></tr></table></figure><p>在编译目标文件时指定头文件。必须是通过add_executable()或add_library()创建，且不能是ALIAS目标。&lt;INTERFACE|PUBLIC|PRIVATE&gt;修饰其紧跟参数items的作用范围。</p><h4 id="4-11-link-directories"><a href="#4-11-link-directories" class="headerlink" title="4.11 link_directories"></a>4.11 link_directories</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">link_directories</span>([AFTER|BEFORE] directory1 [directory2 ...])</span><br></pre></td></tr></table></figure><p>LINK_DIRECTORIES 命令来指定第三方库所在路径，比如，你的动态库在&#x2F;home&#x2F;myproject&#x2F;libs这个路径下，则通过命令：LINK_DIRECTORIES(&#x2F;home&#x2F;myproject&#x2F;libs)，把该路径添加到第三方库搜索路径中，这样就可以使用相对路径了，使用TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。**官方不建议使用该命令，取而代之的为find_package() find_library()**。</p><h4 id="4-12-find-package"><a href="#4-12-find-package" class="headerlink" title="4.12 find_package()"></a>4.12 find_package()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">## 共支持两种模式</span><br><span class="line"># mode1: Module, 此模式需访问Find&lt;PackageName&gt;.cmake文件</span><br><span class="line"><span class="built_in">find_package</span>(&lt;PackageName&gt; [version] [EXACT] [QUIET] [MODULE]</span><br><span class="line">             [REQUIRED] [[COMPONENTS] [components...]]</span><br><span class="line">             [OPTIONAL_COMPONENTS components...]</span><br><span class="line">             [NO_POLICY_SCOPE])</span><br><span class="line"><span class="built_in">find_package</span>(uts MODULE) #去找 Finduts.cmake  注意指定路径</span><br><span class="line"></span><br><span class="line"># mode2: Config, 此模式需访问&lt;lowercasePackageName&gt;-config.cmake <span class="keyword">or</span> &lt;PackageName&gt;Config.<span class="function">cmake</span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(&lt;PackageName&gt; [version] [EXACT] [QUIET]</span></span></span><br><span class="line"><span class="params"><span class="function">             [REQUIRED] [[COMPONENTS] [components...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [OPTIONAL_COMPONENTS components...]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CONFIG|NO_MODULE]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_POLICY_SCOPE]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NAMES name1 [name2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CONFIGS config1 [config2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [HINTS path1 [path2 ... ]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [PATHS path1 [path2 ... ]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [PATH_SUFFIXES suffix1 [suffix2 ...]]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_DEFAULT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_PACKAGE_ROOT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_ENVIRONMENT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_SYSTEM_ENVIRONMENT_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_PACKAGE_REGISTRY]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing.</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_SYSTEM_PATH]</span></span></span><br><span class="line"><span class="params"><span class="function">             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]</span></span></span><br><span class="line"><span class="params"><span class="function">             [CMAKE_FIND_ROOT_PATH_BOTH |</span></span></span><br><span class="line"><span class="params"><span class="function">              ONLY_CMAKE_FIND_ROOT_PATH |</span></span></span><br><span class="line"><span class="params"><span class="function">              NO_CMAKE_FIND_ROOT_PATH])</span></span></span><br></pre></td></tr></table></figure><p>find_package一般用于加载外部库到项目中，并且会加载库的细节信息。如上find_package有两种模式：Module与Config。</p><p>该命令描述特别复杂，参考博客： <a href="https://blog.csdn.net/fengbingchun/article/details/127473202">(41条消息) CMake中find_package的使用_fengbingchun的博客-CSDN博客</a></p><h4 id="4-13-find-libary"><a href="#4-13-find-libary" class="headerlink" title="4.13 find_libary()"></a>4.13 find_libary()</h4><p>该函数用于库查找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_library</span>(</span><br><span class="line">          &lt;VAR&gt;</span><br><span class="line">          name | NAMES name1 [name2 ...] [NAMES_PER_DIR]</span><br><span class="line">          [HINTS [path | ENV var]... ]</span><br><span class="line">          [PATHS [path | ENV var]... ]</span><br><span class="line">          [<span class="built_in">REGISTRY_VIEW</span> (<span class="number">64</span>|<span class="number">32</span>|<span class="number">64</span>_32|<span class="number">32</span>_64|HOST|TARGET|BOTH)]</span><br><span class="line">          [PATH_SUFFIXES suffix1 [suffix2 ...]]</span><br><span class="line">          [DOC <span class="string">&quot;cache documentation string&quot;</span>]</span><br><span class="line">          [NO_CACHE]</span><br><span class="line">          [REQUIRED]</span><br><span class="line">          [NO_DEFAULT_PATH]</span><br><span class="line">          [NO_PACKAGE_ROOT_PATH]</span><br><span class="line">          [NO_CMAKE_PATH]</span><br><span class="line">          [NO_CMAKE_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_SYSTEM_ENVIRONMENT_PATH]</span><br><span class="line">          [NO_CMAKE_SYSTEM_PATH]</span><br><span class="line">          [NO_CMAKE_INSTALL_PREFIX]</span><br><span class="line">          [CMAKE_FIND_ROOT_PATH_BOTH |</span><br><span class="line">           ONLY_CMAKE_FIND_ROOT_PATH |</span><br><span class="line">           NO_CMAKE_FIND_ROOT_PATH]</span><br><span class="line">)</span><br><span class="line"># 在默认路径下查找/usr/lib/...  libJSON-C.<span class="function">so</span></span><br><span class="line"><span class="function"><span class="title">find_libary</span><span class="params">(json NAMES JSON-C)</span></span></span><br></pre></td></tr></table></figure><p>详细介绍见参考博客： <a href="https://blog.csdn.net/fengbingchun/article/details/127232175">(41条消息) CMake中find_library的使用_fengbingchun的博客-CSDN博客</a></p><h3 id="5-场景实战"><a href="#5-场景实战" class="headerlink" title="5 场景实战"></a>5 场景实战</h3><p>该章节的是为了更好的将cmake应用在构建工程中，分不同场景来练习和实战，将多条cmake命令组合起来完成各种场景的需求。这样才能更好的使用cmake.一些场景后续根据实际需求补上。</p><h4 id="5-1-一个目录一个object"><a href="#5-1-一个目录一个object" class="headerlink" title="5.1 一个目录一个object"></a>5.1 一个目录一个object</h4><p>将一个目录下的源文件通过一个makelist.txt文件编译成一个 object，这样有利于代码结构化管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="built_in">add_library</span>(src-dltest-object OBJECT $(SRC_LIST))</span><br><span class="line"><span class="built_in">set</span>(src-dltest</span><br><span class="line">     $&lt;TARGET_OBJECTS:src-dltest-object&gt;</span><br><span class="line">     PARENT_SCOPE)</span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/lib/)</span><br><span class="line"><span class="built_in">set</span>(src</span><br><span class="line">    $&#123;src-dltest&#125;</span><br><span class="line">    PARENT_SCOPE)</span><br></pre></td></tr></table></figure><h4 id="5-2-编译链-toolchain"><a href="#5-2-编译链-toolchain" class="headerlink" title="5.2 编译链 toolchain"></a>5.2 编译链 toolchain</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># -Dxxx指定编译参数  cmake和makelist里面可以用变量 LLT  CPU_BIT_FLAG 等</span><br><span class="line">cmake .. -DCOMPILER=<span class="string">&quot;$&#123;platform&#125;&quot;</span> -DMODULE=<span class="string">&quot;$&#123;module&#125;&quot;</span> -DLLT=<span class="string">&quot;true&quot;</span> -DCPU_BIT_FLAG=<span class="string">&quot;FLAG_64&quot;</span> </span><br><span class="line">-DCMAKE_TOOLCHAIN_FILE=<span class="string">&quot;$&#123;root_path&#125;&quot;</span>/cmake/toolchain/<span class="string">&quot;$&#123;platform&#125;&quot;</span>_toolchain.cmake</span><br><span class="line">#  编译链cmake 主要设置编译选项等 x86_toolchain.cmake</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_FLAGS <span class="string">&quot; -Wall -Werror -Wfloat-equal -Wshadow XXX&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot; -g -m64 -std=c++17 -Wall -Werror -Wfloat-equal -Wshadow XXX&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="5-3-第三方库引入"><a href="#5-3-第三方库引入" class="headerlink" title="5.3 第三方库引入"></a>5.3 第三方库引入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 方式一 制定绝对路径</span><br><span class="line"><span class="built_in">set</span>(xxx_path xxxx)</span><br><span class="line"><span class="built_in">set</span>(xxx_lib_path $&#123;xxx_path&#125;/lib)</span><br><span class="line"><span class="built_in">set</span>(xxx_include_path $&#123;xxx_path&#125;/include)</span><br><span class="line"></span><br><span class="line"># 方式二 <span class="function">find_package  find_path  find_library</span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(thirdParty REQUIRED)</span></span></span><br><span class="line"><span class="function"># 自动寻找 FindthirdParty.cmake, 路径会根据find_package的规则寻找</span></span><br><span class="line"><span class="function">- thirdParty</span></span><br><span class="line"><span class="function">- party</span></span><br><span class="line"><span class="function"><span class="title">get_filename_component</span><span class="params">(THIRDPARTY_ROOT  <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/xxx/thirdParty&quot;</span> ABSOLUTE)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(THIRDPARTY_INCLUDE_PATH  party</span></span></span><br><span class="line"><span class="params"><span class="function">    HINTS         $&#123;THIRDPARTY_ROOT&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PATH_SUFFIXES  include)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package_handle_standard_args</span><span class="params">(thirdParty REQUIRED_VARS THIRDPARTY_INCLUDE_PATH)</span></span></span><br><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(THIRDPARTY_LIB_PATH  libdrv_thirdParty.so</span></span></span><br><span class="line"><span class="params"><span class="function">    HINTS         $&#123;THIRDPARTY_ROOT&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PATH_SUFFIXES lib)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package_handle_standard_args</span><span class="params">(thirdParty REQUIRED_VARS THIRDPARTY_LIB_PATH)</span></span></span><br></pre></td></tr></table></figure><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h3><p>本文通过六个章节对cmake做了一定的介绍，其中第一章节属于cmake是用来干啥的和优缺点做了说明，第二三章节简要说明了cmake环境配置和一个简单的cmake工程github上可下载。第四章节是一些常用命令的介绍和学习。第五章节是一些场景实战，目前场景比较少，后续根据实际慢慢补上。第六章节是对整篇文章做个总结。</p><p>总体来说，cmake是一们比较容易的语言，系统&#x2F;项目构建中用的比较多，对于程序员来说都应该对构建有一定的了解和实战经验。也许我们会觉得ide使用起来比较方便，但ide只适合实际学习语言的时候使用。真正开发的构建工程大部分使用cmake来搭建的。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1 前言&quot;&gt;&lt;/a&gt;1 前言&lt;/h3&gt;&lt;h4 id=&quot;1-1Cmake是什么&quot;&gt;&lt;a href=&quot;#1-1Cmake是什么&quot; class=&quot;headerlink&quot; title=&quot;1 .1Cmake是什么&quot;&gt;&lt;/a&gt;1 .1Cmake是什么&lt;/h4&gt;&lt;p&gt;CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。可以构建、测试、打包项目。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。对于c++工程来说，通过cmake配置，然后通过cmake工具自动生成makefile文件，最后通过make编译出二进制文件。也就是说CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。&lt;/p&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="Cmake" scheme="http://zuweicun.top/tags/Cmake/"/>
    
  </entry>
  
  <entry>
    <title>神经网络初识</title>
    <link href="http://zuweicun.top/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/"/>
    <id>http://zuweicun.top/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/</id>
    <published>2024-01-12T15:31:21.000Z</published>
    <updated>2024-09-16T14:19:24.910Z</updated>
    
    <content type="html"><![CDATA[<h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://blog.csdn.net/qq_22583741/article/details/129444508?ops_request_misc=%7B%22request_id%22:%22170486960516800197010429%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170486960516800197010429&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129444508-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187">新手入门python实现神经网络，超级简单!_py 神经网络-CSDN博客</a></p><p><a href="https://hitwhlc.yuque.com/attachments/yuque/0/2024/pdf/39221021/1704869715414-7f00ccda-2452-42d9-a816-4a09a794e0ad.pdf">📎Python神经网络编程.pdf</a></p><p><a href="https://blog.csdn.net/weixin_40221426/article/details/132255702?ops_request_misc=%7B%22request_id%22:%22170486960516800197010429%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170486960516800197010429&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-132255702-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&spm=1018.2226.3001.4187">Python学习篇30-神经网络_python神经网络-CSDN博客</a></p><p><a href="https://blog.csdn.net/ft_sunshine/article/details/90221691?ops_request_misc=%7B%22request_id%22:%22170487093716800192217002%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170487093716800192217002&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90221691-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）-CSDN博客</a></p><p><a href="https://blog.csdn.net/baidu_41774120/article/details/125764136?ops_request_misc=%7B%22request_id%22:%22170487093716800192217002%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170487093716800192217002&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125764136-null-null.142%5Ev99%5Epc_search_result_base6&utm_term=%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">反向传播算法推导过程（看一篇就够了）_神经网络反向传播算法推导-CSDN博客</a></p><span id="more"></span><h2 id="1-发展历史"><a href="#1-发展历史" class="headerlink" title="1.发展历史"></a>1.发展历史</h2><p>神经网络的发展历史可以追溯到20世纪中叶。</p><ol><li><strong>McCulloch和Pitts的神经元模型（1943）：</strong></li></ol><p>​Warren McCulloch和Walter Pitts提出了神经元模型，将神经元抽象为二进制开关，形成了后来神经网络的基础。</p><ol start="2"><li><strong>感知器的提出（1957）：</strong></li></ol><p>​Frank Rosenblatt提出了感知器，这是一种基于神经元模型的学习算法。感知器可以实现简单的二分类任务。</p><ol start="3"><li><strong>早期神经网络的研究（1960s-1970s）：</strong></li></ol><p>在这一时期，神经网络受到了关注，但受到了硬件和理论上的限制。神经网络的训练和应用遇到了困难。</p><ol start="4"><li><strong>反向传播算法的提出（1986）：</strong></li></ol><ul><li>David Rumelhart、Geoffrey Hinton和Ronald Williams提出了反向传播算法，为多层神经网络的训练提供了有效的方法。这一突破重新激发了对神经网络的研究兴趣。</li></ul><ol start="5"><li><strong>计算能力的提升（1990s）：</strong></li></ol><p>随着计算能力的提高，研究者们开始更深入地研究神经网络的理论和应用。但由于数据集和计算资源的限制，发展相对较慢。</p><ol start="6"><li><strong>深度学习的崛起（2000年后）：</strong></li></ol><ul><li>随着大规模数据集和强大的计算能力的可用性，深度学习（深度神经网络）再次引起了广泛关注。</li></ul><ul><li>图像分类、语音识别、自然语言处理等领域的成功应用推动了神经网络的发展。</li></ul><ol start="7"><li><p><strong>卷积神经网络（CNN）和循环神经网络（RNN）的出现：</strong></p><ul><li>2012年，AlexNet的成功标志着卷积神经网络（CNN）的兴起，对图像处理任务取得了巨大成功。</li><li>循环神经网络（RNN）在处理序列数据（如自然语言）方面表现出色，为更多领域的应用提供了解决方案。</li></ul></li><li><p><strong>深度学习在各领域的广泛应用：</strong></p></li></ol><ul><li>深度学习技术在计算机视觉、自然语言处理、语音识别、医学影像等领域取得了显著的进展，推动了人工智能的发展。</li></ul><h2 id="2-主体流程"><a href="#2-主体流程" class="headerlink" title="2.主体流程"></a>2.主体流程</h2><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/1.png" alt="1"></p><p><strong>输入层（Input Layer）：</strong></p><ul><li>神经网络的第一层，负责接收输入数据。每个输入节点对应输入数据的一个特征。</li></ul><p><strong>权重和偏差（Weights and Biases）：</strong></p><ul><li>每个连接（神经元之间的连接）都有一个权重，用于调整输入的影响力。每个神经元还有一个偏差，用于调整整体激活的阈值。</li></ul><p><strong>线性组合（Linear Combination）：</strong></p><ul><li>输入层的每个神经元将其输入与相应的权重相乘，然后将所有乘积相加，再加上偏差。这形成了线性组合。</li></ul><p><strong>激活函数（Activation Function）：</strong></p><ul><li>线性组合的结果通常通过激活函数，如Sigmoid、ReLU等，以引入非线性特性。这使得神经网络能够学习非线性关系。这个函数有点像高中学过的神经元阈值（神经网络似乎就是模拟人脑结构），当输入信号或信号组合以某种方式达到一定阈值，才会激活这个节点。</li></ul><p><strong>隐藏层（Hidden Layers）：</strong></p><ul><li>在输入层和输出层之间的层称为隐藏层。神经网络的深度取决于隐藏层的数量。每个隐藏层的神经元接收前一层的输出，并重复之前的步骤。</li></ul><p><strong>输出层（Output Layer）：</strong></p><ul><li>最后一个隐藏层的输出作为神经网络的最终输出。输出的数量通常取决于任务类型，如二分类问题有一个输出节点，多分类问题有多个输出节点。</li></ul><p><strong>损失函数（Loss Function）：</strong></p><ul><li>损失函数度量神经网络输出与真实标签之间的差异。训练过程的目标是最小化损失函数。</li></ul><p><strong>优化算法（Optimization Algorithm）：</strong></p><ul><li>优化算法，如梯度下降，用于调整权重和偏差，以降低损失函数。通过计算损失函数关于权重和偏差的梯度，优化算法更新参数。</li></ul><p><strong>反向传播（Backpropagation）：</strong></p><ul><li>反向传播算法是训练神经网络的关键步骤。通过计算梯度，反向传播从输出层到输入层反向传播误差，并更新权重和偏差。</li></ul><p><strong>训练和预测（Training and Prediction）：</strong></p><ul><li>神经网络通过多次迭代训练数据来学习权重和偏差。在训练后，神经网络可以用于对新数据的预测。</li></ul><p><strong>正则化和调参（Regularization and Hyperparameter Tuning）：</strong></p><ul><li>为了提高泛化能力，可以使用正则化技术，并调整超参数（如学习率、隐藏层节点数）。</li></ul><h2 id="3-矩阵的应用"><a href="#3-矩阵的应用" class="headerlink" title="3.矩阵的应用"></a>3.矩阵的应用</h2><h5 id="学习资料与平台"><a href="#学习资料与平台" class="headerlink" title="学习资料与平台"></a>学习资料与平台</h5><p><a href="https://www.bilibili.com/video/BV1bx411M7Zx/?t=6&spm_id_from=333.1350.jump_directly&vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之神经网络的结构 Part 1 ver 2.0_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Ux411j7ri/?spm_id_from=333.788.recommend_more_video.-1&vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之梯度下降法 Part 2 ver 0.9 beta_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV16x411V7Qg/?spm_id_from=333.788.recommend_more_video.-1&vd_source=a29f1a7926ed643fe5076ad7bf93a8f2">【官方双语】深度学习之反向传播算法 上&#x2F;下 Part 3 ver 0.9 beta_哔哩哔哩_bilibili</a></p><p>（作为计算机专业小白常常听说线性代数在计算机领域尤其重要，今天才真正理解）。</p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/2.png" alt="2"></p><p>​      在神经网络的构建中，存在着巨量的参数权重，每一层的数据都代表着运算量进一步飙升。矩阵作为一种数据间关系表达的优良方式（其实就是数表），可以极大程度的简化运算，并能非常简易地表示出结果。下例：</p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/3.png" alt="3"></p><h2 id="4-梯度下降"><a href="#4-梯度下降" class="headerlink" title="4.梯度下降"></a>4.梯度下降</h2><h4 id="梯度："><a href="#梯度：" class="headerlink" title="梯度："></a>梯度：</h4><ul><li><p><strong>梯度</strong>表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向（梯度的方向）变化最快，变化率（梯度的模）最大，<strong>可理解为导数</strong>。</p></li><li><p>梯度上升和梯度下降是优化算法中常用的两种方法，主要目的是通过迭代找到目标函数的最大值和最小值。</p></li><li><p>例如：</p></li><li><ul><li>想象我们在一座很高的山上，怎么才能以最快的速度下山？我们可以先选择坡度最倾斜的方向走一段距离，然后再重新选择坡度最倾斜的方向，再走一段距离。以此类推，我们就可以以最快的速度到达山底。<strong>（梯度的方向，就是我们要选择的方向）</strong></li></ul></li></ul><h4 id="梯度下降法："><a href="#梯度下降法：" class="headerlink" title="梯度下降法："></a>梯度下降法：</h4><p><strong>梯度下降算法</strong>针对的是最小优化问题(即求最小值问题)，目的是使目标函数沿最快路径下降到最小值。</p><p>通俗的解释，是模拟下山，每次沿着当前位置最陡峭最易下山的方向前进一小步，然后继续沿下一个位置最陡方向前进一小步。这样一步一步走下去，一直走到觉得我们已经到了山脚。</p><p>算法作用于损失函数(也称目标函数、代价函数、误差函数)，是为了找到使损失函数取最小值的权重(w)和偏置(b)。</p><p>梯度下降运行步骤：</p><ol><li>用随机值初始化权重和偏差</li><li>把输入传入网络，得到输出值(预测值)</li><li>计算预测值和真实值(标签值)之间的误差</li><li><strong>对每一个产生误差的神经元，调整相应的（权重和偏差）值以减小误差</strong></li><li>重复迭代，直至得到网络权重和偏差的最佳值</li></ol><p>**批量梯度下降法(BGD)**：每次迭代计算梯度，使用整个数据集。每次更新都会朝着正确的方向进行，最后能够保证收敛于极值点，凸函数收敛于全局极值点，非凸函数可能会收敛于局部极值点，缺陷就是学习时间太长，消耗大量内存。</p><p>**随机梯度下降法(SGD)**：每次迭代计算梯度，从整个数据集中随机选取一个数据，所以每次迭代的时间非常快。但收敛时震荡，不稳定，在最优解附近波动，难以判断是否已经收敛。</p><p>**小批量梯度下降法(MBGD)**：这个是 <strong>BGD</strong> 和 <strong>SGD</strong> 的折中方法， <strong>BGD</strong> 每次使用整体数据，收敛太慢， <strong>SGD</strong> 每次只使用一条数据，虽然收敛快但震荡厉害，所以出现了折中的 <strong>MBGD</strong>，每次使用 <strong>n</strong> 条数据，如果 <strong>n(batch size)</strong> 选择的合适，不仅收敛速度比SGD更快、更稳定，而且在最优解附近的震荡也不会很大，甚至得到比 <strong>BGD</strong> 更好的解。</p><p><strong>batch size</strong> 的选择，一般取2的幂次时能充分利用矩阵运算操作，因此可以在2的幂次中挑选最优取值。例如16、32、64、128、256等等。</p><h2 id="5-反向传播"><a href="#5-反向传播" class="headerlink" title="5.反向传播"></a>5.反向传播</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先来一个<strong>反向传播算法</strong>的定义（转自维基百科）：<strong>反向传播</strong>（英语：<strong>Backpropagation</strong>，缩写为<strong>BP</strong>）是“<strong>误差反向传播</strong>”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见方法。 该方法对网络中<strong>所有权重</strong>计算损失函数的梯度。 这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。（<strong>误差</strong>的反向传播）</p><p>首先拿一个简单的三层神经网络来举例，如下：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515095532783.png" alt="20190515095532783"></p><h5 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h5><p>每个神经元由两部分组成，第一部分（e）是<strong>输入值</strong>和<strong>权重系数</strong>乘积的<strong>和</strong>，第二部分（f(e)）是一个<strong>激活函数</strong>（非线性函数）的输出， y&#x3D;f(e)即为某个神经元的输出，如下：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515100159284.png" alt="20190515100159284"></p><p>下面是<strong>前向传播</strong>过程：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515100805671.png" alt="20190515100805671"><br>———–手动分割———–<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515100845442.png" alt="20190515100845442"><br>———–手动分割———–<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515101005589.png" alt="20190515101005589"></p><p>到这里为止，神经网络的前向传播已经完成，最后输出的y就是本次前向传播神经网络计算出来的结果（预测结果），但这个预测结果不一定是正确的，要和真实的标签（z）相比较，计算预测结果和真实标签的误差（δ \deltaδ），如下：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515101232916.png" alt="20190515101232916"></p><p>下面开始计算每个神经元的误差（δ \deltaδ）：<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515101334960.png" alt="20190515101334960"></p><h5 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h5><p>下面开始利用反向传播的误差，计算各个神经元（权重）的导数，开始反向传播修改权重。</p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515103014208.png" alt="20190515103014208"></p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515103033715.png" alt="20190515103033715"></p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515103116521.png" alt="20190515103116521"></p><h4 id="“正向传播”求损失，“反向传播”回传误差。"><a href="#“正向传播”求损失，“反向传播”回传误差。" class="headerlink" title="“正向传播”求损失，“反向传播”回传误差。"></a><strong>“正向传播”求损失，“反向传播”回传误差</strong>。</h4><p><strong>BP算法，也叫<strong><strong>δ \delta</strong></strong>δ****算法</strong>，下面以3层的感知机为例进行举例讲解。<br><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20190515104858190.png" alt="20190515104858190"></p><p>上图的前向传播（网络输出计算）过程如下：（此处为网络的整个误差的计算，误差E计算方法为mse）</p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/20200331121115812.png" alt="20200331121115812"></p><p>上面的计算过程并不难，只要耐心一步步的拆开式子，逐渐分解即可。现在还有两个问题需要解决：</p><ol><li>误差E有了，怎么调整权重让误差不断减小？</li><li>E是权重w的函数，何如找到使得函数值最小的w。</li></ol><h4 id="（其实这些稀奇古怪的公式已经看不懂了）"><a href="#（其实这些稀奇古怪的公式已经看不懂了）" class="headerlink" title="（其实这些稀奇古怪的公式已经看不懂了）"></a>（其实这些稀奇古怪的公式已经看不懂了）</h4><p>通俗来讲，反向传播就是根据计算结果的误差修改权重信号，俗称打哪指哪，像极了我强行凑答案的样子。通过这种方法可以优化神经网络的整体权重布局，从而使训练结果更上一层楼（也可能中间层的黑箱子照着无法预测的方向走远但是结果准确率超高）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上所述感觉神经网络就是人们用计算机模拟人脑神经元链接构建出来的玩意（果然生物结构才是顶级码农的创造）。对于深度学习，神经网络属于机器学习的一部分，更具体地说是深度学习的一种。机器学习是一种让计算机从数据中学习的方法，而深度学习则是机器学习中的一个分支，强调使用深层次的神经网络结构。</p><p>对于神经网络是否智能这件事，我也说不好，感觉相对人脑来说这种结构实在是太简单了。（比如说计算机永远无法理解我怎么眼睁睁地看着自己把7x8算成45）。目前神经网络似乎缺少了较高程度的自我学习能力，例如发现个什么定律啥的，（照《终结者》一比还是差着层次），但是chatgpt确实很香，看起来AI方面的发展还是很大的，贾维斯指日可待（乐）。</p><h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><p>直接上代码吧，内容都写在注释里了</p><h5 id="神经网络类："><a href="#神经网络类：" class="headerlink" title="神经网络类："></a>神经网络类：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 神经网络类定义</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> scipy.special</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">neuralNetwork</span>:</span><br><span class="line">    <span class="comment"># 初始化神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inputnodes, hiddennodes, outputnodes, learningrate</span>):</span><br><span class="line">        <span class="comment"># 设置每个层中的节点数</span></span><br><span class="line">        self.inodes = inputnodes</span><br><span class="line">        self.hnodes = hiddennodes</span><br><span class="line">        self.onodes = outputnodes</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用随机值初始化权重</span></span><br><span class="line">        self.wih = numpy.random.normal(<span class="number">0.0</span>, <span class="built_in">pow</span>(self.hnodes, -<span class="number">0.5</span>), (self.hnodes, self.inodes))</span><br><span class="line">        self.who = numpy.random.normal(<span class="number">0.0</span>, <span class="built_in">pow</span>(self.onodes, -<span class="number">0.5</span>), (self.onodes, self.hnodes))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置学习率</span></span><br><span class="line">        self.lr = learningrate</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义激活函数为sigmoid函数</span></span><br><span class="line">        self.activation_function = <span class="keyword">lambda</span> x: scipy.special.expit(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, inputs_list, targets_list</span>):</span><br><span class="line">        <span class="comment"># 将输入和目标转换为2维数组</span></span><br><span class="line">        inputs = numpy.array(inputs_list, ndmin=<span class="number">2</span>).T</span><br><span class="line">        targets = numpy.array(targets_list, ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的输入和输出信号</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的输入和输出信号</span></span><br><span class="line">        final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的误差</span></span><br><span class="line">        output_errors = targets - final_outputs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的误差</span></span><br><span class="line">        hidden_errors = numpy.dot(self.who.T, output_errors)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用学习率和梯度更新权重</span></span><br><span class="line">        self.who += self.lr * numpy.dot((output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)), numpy.transpose(hidden_outputs))</span><br><span class="line">        self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)), numpy.transpose(inputs))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查询神经网络</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, input_list</span>):</span><br><span class="line">        <span class="comment"># 将输入转换为2维数组</span></span><br><span class="line">        inputs = numpy.array(input_list, ndmin=<span class="number">2</span>).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算隐藏层的输入和输出信号</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算输出层的输入和输出信号</span></span><br><span class="line">        final_inputs = numpy.dot(self.who, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回网络的输出</span></span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_train.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>**data_file&#x3D;…**：打开 MNIST 训练数据集文件，并将其内容读取到 <strong>data_list</strong> 列表中。</li><li>**data_list&#x3D;data_file.readlines()**：读取文件的所有行，并存储在 <strong>data_list</strong> 列表中。</li><li>**all_values&#x3D;data_list[0].split(‘,’)**：将第一行数据按逗号分隔，存储到 <strong>all_values</strong> 列表中。</li><li>**image_array&#x3D;numpy.asfarray(all_values[1:]).reshape((28,28))**：将 <strong>all_values</strong> 中的像素值转换为浮点数，并重新形状为 28x28 的数组，表示图像的像素矩阵。</li><li>**matplotlib.pyplot.imshow(image_array,cmap&#x3D;’Greys’,interpolation&#x3D;’None’)**：使用 Matplotlib 的 <strong>imshow</strong> 函数将图像以灰度的形式显示在图像窗口中。</li></ol><p>这段代码读取 MNIST 数据集中的第一张图像数据，并显示在图像窗口中。</p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/a350e116ec9ac187600f639bb8574216.png" alt="a350e116ec9ac187600f639bb8574216"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_train.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">5</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>data_list[5]</strong> 表示第6行数据，<strong>all_values&#x3D;data_list[5].split(‘,’)</strong> 将这一行数据根据逗号分割成一个值的列表。然后，将列表中除第一个值外的其余值转换为浮点数数组，并reshape为28x28的图像矩阵，最后使用<strong>matplotlib</strong>库将图像显示在灰度色图上。</p><p>(其实就是根据数据显示原图)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scaled_input=(numpy.asfarray(all_values[<span class="number">1</span>:]) /<span class="number">255.0</span>*<span class="number">0.99</span>)+<span class="number">0.01</span></span><br><span class="line"><span class="built_in">print</span>(scaled_input)</span><br></pre></td></tr></table></figure><p>这段代码对MNIST数据集中第6行的像素值进行了预处理。首先，<strong>numpy.asfarray(all_values[1:])</strong> 将第6行除第一个值外的其余值转换为浮点数数组。然后，通过除以255.0将像素值缩放到0到1之间，接着将数据范围缩放到0.01到1之间，而不是0到1。这是因为在神经网络中，为了避免输入值为0的情况（可能会影响权重的更新），将数据范围设置为稍微偏离0的范围。</p><p>最后，通过<strong>print(scaled_input)</strong> 将缩放后的输入值打印出来，以便查看处理后的数值范围和数据。</p><p>这段代码可以帮助确保在使用神经网络之前对输入数据进行了适当的预处理，以提高神经网络的训练效果。</p><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/416a55bcc508c87e6a28fb7d848dcec6_720.png" alt="416a55bcc508c87e6a28fb7d848dcec6_720"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onodes=<span class="number">10</span></span><br><span class="line">targets=numpy.zeros(onodes)+<span class="number">0.01</span></span><br><span class="line">targets[<span class="built_in">int</span>(all_values[<span class="number">0</span>])]=<span class="number">0.99</span></span><br></pre></td></tr></table></figure><p>这段代码是为了准备目标输出。它创建了一个长度为<strong>onodes</strong>的零数组（全零数组），然后将第**int(all_values[0])<strong>个位置设置为0.99。这个位置对应于</strong>all_values[0]<strong>中的值，通常表示图像中显示的数字。</strong>int(all_values[0])**的值被用作索引，用于将目标输出数组中对应的位置值设置为0.99。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data_file=<span class="built_in">open</span>(<span class="string">&quot;/home/zuquanzhi/pythonProject/mnist_dataset/mnist_test.csv&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data_list=data_file.readlines()</span><br><span class="line">all_values=data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">image_array=numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">&#x27;Greys&#x27;</span>,interpolation=<span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"></span><br><span class="line">all_values=test_data_list[<span class="number">0</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(all_values[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><img src="/2024/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E8%AF%86/1014148cd6ee8d823f12ab6de2c2ea0b_720.png" alt="1014148cd6ee8d823f12ab6de2c2ea0b_720"></p><ol><li><strong>data_file&#x3D;open(“&#x2F;home&#x2F;zuquanzhi&#x2F;pythonProject&#x2F;mnist_dataset&#x2F;mnist_test.csv”,’r’)</strong>: 打开了一个名为<strong>mnist_test.csv</strong>的CSV文件来读取测试数据。</li><li><strong>data_list&#x3D;data_file.readlines()</strong>: 读取CSV文件的内容，并将每一行数据存储在<strong>data_list</strong>列表中。</li><li><strong>all_values&#x3D;data_list[0].split(‘,’)</strong>: 从第一行提取数据，使用逗号作为分隔符将数据拆分为一个值的列表<strong>all_values</strong>。</li><li><strong>image_array&#x3D;numpy.asfarray(all_values[1:]).reshape((28,28))</strong>: 将<strong>all_values</strong>列表中的字符串转换为浮点数，并根据这些值创建一个28x28的二维数组 <strong>image_array</strong>，用于表示图像的像素值。</li><li><strong>matplotlib.pyplot.imshow(image_array,cmap&#x3D;’Greys’,interpolation&#x3D;’None’)</strong>: 使用Matplotlib库中的<strong>imshow</strong>函数将<strong>image_array</strong>作为灰度图像显示出来。</li><li><strong>all_values&#x3D;test_data_list[0].split(‘,’)</strong>: 这里应该更正为<strong>data_list</strong>而不是<strong>test_data_list</strong>，以便使用刚刚加载的测试集数据。这行代码意图是重新读取<strong>data_list</strong>的第一行数据并将其拆分。</li><li><strong>print(all_values[0])</strong>: 打印 <strong>all_values</strong> 列表的第一个值，这可能是与图像相关联的标签或类别。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;参考资料：&quot;&gt;&lt;a href=&quot;#参考资料：&quot; class=&quot;headerlink&quot; title=&quot;参考资料：&quot;&gt;&lt;/a&gt;参考资料：&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_22583741/article/details/129444508?ops_request_misc=%7B%22request_id%22:%22170486960516800197010429%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170486960516800197010429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129444508-null-null.142%5Ev99%5Epc_search_result_base6&amp;utm_term=python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&amp;spm=1018.2226.3001.4187&quot;&gt;新手入门python实现神经网络，超级简单!_py 神经网络-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hitwhlc.yuque.com/attachments/yuque/0/2024/pdf/39221021/1704869715414-7f00ccda-2452-42d9-a816-4a09a794e0ad.pdf&quot;&gt;📎Python神经网络编程.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_40221426/article/details/132255702?ops_request_misc=%7B%22request_id%22:%22170486960516800197010429%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170486960516800197010429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-132255702-null-null.142%5Ev99%5Epc_search_result_base6&amp;utm_term=python%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&amp;spm=1018.2226.3001.4187&quot;&gt;Python学习篇30-神经网络_python神经网络-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ft_sunshine/article/details/90221691?ops_request_misc=%7B%22request_id%22:%22170487093716800192217002%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170487093716800192217002&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-90221691-null-null.142%5Ev99%5Epc_search_result_base6&amp;utm_term=%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187&quot;&gt;“反向传播算法”过程及公式推导（超直观好懂的Backpropagation）-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/baidu_41774120/article/details/125764136?ops_request_misc=%7B%22request_id%22:%22170487093716800192217002%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=170487093716800192217002&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125764136-null-null.142%5Ev99%5Epc_search_result_base6&amp;utm_term=%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187&quot;&gt;反向传播算法推导过程（看一篇就够了）_神经网络反向传播算法推导-CSDN博客&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="神经网络" scheme="http://zuweicun.top/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>蹭饭图</title>
    <link href="http://zuweicun.top/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/"/>
    <id>http://zuweicun.top/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/</id>
    <published>2023-12-19T03:35:38.000Z</published>
    <updated>2024-09-16T14:04:43.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="19班蹭饭图"><a href="#19班蹭饭图" class="headerlink" title="19班蹭饭图"></a>19班蹭饭图</h2><p><img src="/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/19%E8%B9%AD%E9%A5%AD%E5%9B%BE.png" alt="19班蹭饭图"></p><h2 id="20班蹭饭图"><a href="#20班蹭饭图" class="headerlink" title="20班蹭饭图"></a>20班蹭饭图</h2><p><img src="/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/20%E8%B9%AD%E9%A5%AD%E5%9B%BE.png" alt="20班蹭饭图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;19班蹭饭图&quot;&gt;&lt;a href=&quot;#19班蹭饭图&quot; class=&quot;headerlink&quot; title=&quot;19班蹭饭图&quot;&gt;&lt;/a&gt;19班蹭饭图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2023/12/19/%E8%B9%AD%E9%A5%AD%E5%9B%BE/19%E</summary>
      
    
    
    
    <category term="蹭饭图" scheme="http://zuweicun.top/categories/%E8%B9%AD%E9%A5%AD%E5%9B%BE/"/>
    
    
    <category term="蹭饭图" scheme="http://zuweicun.top/tags/%E8%B9%AD%E9%A5%AD%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>筛去重复元素</title>
    <link href="http://zuweicun.top/2023/12/14/%E7%AD%9B%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://zuweicun.top/2023/12/14/%E7%AD%9B%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2023-12-14T12:32:50.000Z</published>
    <updated>2023-12-14T12:45:59.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="筛去重复元素"><a href="#筛去重复元素" class="headerlink" title="筛去重复元素"></a>筛去重复元素</h1><p>最近发现这样一道题，大致意思是给定一个数组，其中元素仅有一个只出现一次，其余元素均出现两次，编写程序以找出这个数。</p><p>这里可以用到异或运算。</p><span id="more"></span><p>异或运算法则如下：</p><ol><li><p>交换律：A ^ B &#x3D; B ^ A</p></li><li><p>结合律：A ^ (B ^ C) &#x3D; (A ^ B) ^ C</p></li><li><p><strong>恒等律：X ^ 0 &#x3D; X</strong></p></li><li><p><strong>归零律：X ^ X &#x3D; 0</strong></p></li><li><p>自反：A ^ B ^ B &#x3D; A ^ 0 &#x3D; A</p><p>这里主要用到后三条性质，可以定义变量key，不断与数组元素进行异或运算，某种意义上达到对于数组的压缩储存。</p></li></ol><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        key^=<span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,func(<span class="built_in">array</span>,<span class="number">13</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;筛去重复元素&quot;&gt;&lt;a href=&quot;#筛去重复元素&quot; class=&quot;headerlink&quot; title=&quot;筛去重复元素&quot;&gt;&lt;/a&gt;筛去重复元素&lt;/h1&gt;&lt;p&gt;最近发现这样一道题，大致意思是给定一个数组，其中元素仅有一个只出现一次，其余元素均出现两次，编写程序以找出这个数。&lt;/p&gt;
&lt;p&gt;这里可以用到异或运算。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://zuweicun.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="c语言" scheme="http://zuweicun.top/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>文件基本操作</title>
    <link href="http://zuweicun.top/2023/12/10/%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://zuweicun.top/2023/12/10/%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2023-12-10T01:56:03.000Z</published>
    <updated>2023-12-10T01:57:26.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><p>（临时抱佛脚，捞捞）</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file; <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="type">char</span> filename[] = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件以进行读写操作（如果文件不存在，则创建新文件）</span></span><br><span class="line">    file = fopen(filename, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件 %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;这是一个文件操作示例。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;欢迎使用 C 语言进行文件操作！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件指针移到文件开头</span></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取内容并输出到屏幕上</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;文件基本操作&quot;&gt;&lt;a href=&quot;#文件基本操作&quot; class=&quot;headerlink&quot; title=&quot;文件基本操作&quot;&gt;&lt;/a&gt;文件基本操作&lt;/h3&gt;&lt;p&gt;（临时抱佛脚，捞捞）&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://zuweicun.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C语言" scheme="http://zuweicun.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>链表基本操作</title>
    <link href="http://zuweicun.top/2023/12/10/%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://zuweicun.top/2023/12/10/%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2023-12-10T01:54:30.000Z</published>
    <updated>2024-09-16T13:59:28.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表基本操作"><a href="#链表基本操作" class="headerlink" title="链表基本操作"></a>链表基本操作</h3><p>（临时抱佛脚的笔记）</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头部插入节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">insertAtBeginning</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表尾部插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAtEnd</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newNode</span> =</span> createNode(data);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个值为 data 的节点</span></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找要删除的节点并记录其前一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != data) &#123;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若找到要删除的节点，则删除它</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = current-&gt;next; <span class="comment">// 删除头节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = current-&gt;next; <span class="comment">// 删除中间或尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(<span class="keyword">struct</span> Node *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeList</span><span class="params">(<span class="keyword">struct</span> Node *head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 初始化链表头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部插入节点</span></span><br><span class="line">    head = insertAtBeginning(head, <span class="number">10</span>);</span><br><span class="line">    head = insertAtBeginning(head, <span class="number">20</span>);</span><br><span class="line">    head = insertAtBeginning(head, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部插入节点</span></span><br><span class="line">    insertAtEnd(head, <span class="number">40</span>);</span><br><span class="line">    insertAtEnd(head, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容：\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    head = deleteNode(head, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后的链表内容：\n&quot;</span>);</span><br><span class="line">    printList(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表节点内存</span></span><br><span class="line">    freeList(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;链表基本操作&quot;&gt;&lt;a href=&quot;#链表基本操作&quot; class=&quot;headerlink&quot; title=&quot;链表基本操作&quot;&gt;&lt;/a&gt;链表基本操作&lt;/h3&gt;&lt;p&gt;（临时抱佛脚的笔记）&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://zuweicun.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="c语言" scheme="http://zuweicun.top/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>删除数字</title>
    <link href="http://zuweicun.top/2023/12/09/%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/"/>
    <id>http://zuweicun.top/2023/12/09/%E5%88%A0%E9%99%A4%E6%95%B0%E5%AD%97/</id>
    <published>2023-12-09T13:09:22.000Z</published>
    <updated>2023-12-09T13:11:35.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除数字-合并空格"><a href="#删除数字-合并空格" class="headerlink" title="删除数字&amp;&amp;合并空格"></a>删除数字&amp;&amp;合并空格</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>从键盘接收一个字符串，由数字、大小写字母和空格组成。程序功能为去掉字符串中的所有数字，最后输出变更后的字符串。注意，并列的空格需要缩减为1个空格。比如键盘输入如下：</strong></p><p><strong>（1）</strong>能够从键盘正确接收字符串；（2分）</p><p><strong>（2）</strong>能够去除数字；（4分）</p><p><strong>（3）</strong>能够合并并列的空格；（4分）</p><p><strong>（4）</strong>能够输出变更后的字符串；（2分）</p><p><strong>（5）</strong>程序能够全面正确运行；（3分）</p><span id="more"></span><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    fgets(a, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 使用fgets获取一行输入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> spaceFlag = <span class="number">0</span>; <span class="comment">// 标志变量，用于检测空格连续性</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] &lt; <span class="string">&#x27;0&#x27;</span> || a[i] &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; a[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            a[j++] = a[i]; <span class="comment">// 将非数字字符和非空格字符移动到数组前部</span></span><br><span class="line">            spaceFlag = <span class="number">0</span>; <span class="comment">// 非空格字符出现时，重置空格连续性标志</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!spaceFlag) &#123;</span><br><span class="line">                a[j++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">// 保留一个空格</span></span><br><span class="line">                spaceFlag = <span class="number">1</span>; <span class="comment">// 标记已经出现一个空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">array</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    fgets(<span class="built_in">array</span>, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 读取输入的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original string: %s\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    delete(<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After deleting and merging: %s\n&quot;</span>, <span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;删除数字-合并空格&quot;&gt;&lt;a href=&quot;#删除数字-合并空格&quot; class=&quot;headerlink&quot; title=&quot;删除数字&amp;amp;&amp;amp;合并空格&quot;&gt;&lt;/a&gt;删除数字&amp;amp;&amp;amp;合并空格&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;从键盘接收一个字符串，由数字、大小写字母和空格组成。程序功能为去掉字符串中的所有数字，最后输出变更后的字符串。注意，并列的空格需要缩减为1个空格。比如键盘输入如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;能够从键盘正确接收字符串；（2分）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;能够去除数字；（4分）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）&lt;/strong&gt;能够合并并列的空格；（4分）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）&lt;/strong&gt;能够输出变更后的字符串；（2分）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）&lt;/strong&gt;程序能够全面正确运行；（3分）&lt;/p&gt;</summary>
    
    
    
    <category term="屎山" scheme="http://zuweicun.top/categories/%E5%B1%8E%E5%B1%B1/"/>
    
    
    <category term="C语言" scheme="http://zuweicun.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>成绩单</title>
    <link href="http://zuweicun.top/2023/12/09/%E6%88%90%E7%BB%A9%E5%8D%95/"/>
    <id>http://zuweicun.top/2023/12/09/%E6%88%90%E7%BB%A9%E5%8D%95/</id>
    <published>2023-12-09T13:01:37.000Z</published>
    <updated>2024-09-16T14:04:46.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TXT成绩单"><a href="#TXT成绩单" class="headerlink" title="TXT成绩单"></a>TXT成绩单</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>一份班级成绩表存储在一个TXT文件中，每行由学号、姓名、数学成绩、英语成绩、C语言成绩组成，如下：</strong></p><p><strong>192000101</strong> <strong>张天天 86 76 85</strong></p><p><strong>192000102</strong> <strong>李笑笑 91 88 76</strong></p><p><strong>…</strong></p><p><strong>192000130</strong> <strong>王维维 88 75 91</strong></p><span id="more"></span><p><strong>编制一个程序，完成下列任务。</strong></p><p>（1）构建一个结构体数组，来存储这个成绩表；（4分）</p><p>（2）能够正确的从文件读取数据到该结构体数组；（5分）</p><p>（3）能够将成绩表输出到屏幕；（4分）</p><p>（4）能输出总成绩进行排序并输出排序后的结果；（7分）</p><p>（5）程序架构良好、代码清晰、能够全面正确运行；（5分）</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul><li><strong>单文件版</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> en;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> student a)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld &quot;</span>, a.number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, a.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.math);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.en);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a.c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a.sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_sum</span><span class="params">(<span class="keyword">struct</span> student *b)</span> &#123;</span><br><span class="line">    b-&gt;sum = b-&gt;math + b-&gt;en + b-&gt;c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="keyword">struct</span> student *arr, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j].sum &gt; arr[j + <span class="number">1</span>].sum) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">students</span>[3] =</span> &#123;</span><br><span class="line">        &#123;<span class="number">123</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">85</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">456</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">70</span>, <span class="number">65</span>, <span class="number">75</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">789</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        calculate_sum(&amp;students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before sorting:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        output(students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(students, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nAfter sorting:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        output(students[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>多文件版（txt文件读取）</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> number;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> en;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件数据到结构体数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readData</span><span class="params">(<span class="keyword">struct</span> Student students[], <span class="type">int</span> *count)</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;grades.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%ld%s%d%d%d&quot;</span>, &amp;students[*count].number, students[*count].name,</span><br><span class="line">                  &amp;students[*count].math, &amp;students[*count].en, &amp;students[*count].c) != EOF) &#123;</span><br><span class="line">        students[*count].total = students[*count].math + students[*count].en + students[*count].c;</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结构体数组数据到屏幕</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printData</span><span class="params">(<span class="keyword">struct</span> Student students[], <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Student Number\tName\tMath\tEnglish\tC Language\tTotal\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld\t%s\t%d\t%d\t%d\t%d\n&quot;</span>, students[i].number, students[i].name,</span><br><span class="line">               students[i].math, students[i].en, students[i].c, students[i].total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数用于排序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">studentA</span> =</span> (<span class="keyword">struct</span> Student *)a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">studentB</span> =</span> (<span class="keyword">struct</span> Student *)b;</span><br><span class="line">    <span class="keyword">return</span> studentB-&gt;total - studentA-&gt;total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[100];</span> <span class="comment">// 假设最多有100个学生</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readData(students, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Student Records:\n&quot;</span>);</span><br><span class="line">    printData(students, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序并输出排序后的结果</span></span><br><span class="line">    qsort(students, count, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nStudent Records after sorting by total score:\n&quot;</span>);</span><br><span class="line">    printData(students, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TXT成绩单&quot;&gt;&lt;a href=&quot;#TXT成绩单&quot; class=&quot;headerlink&quot; title=&quot;TXT成绩单&quot;&gt;&lt;/a&gt;TXT成绩单&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一份班级成绩表存储在一个TXT文件中，每行由学号、姓名、数学成绩、英语成绩、C语言成绩组成，如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;192000101&lt;/strong&gt; &lt;strong&gt;张天天 86 76 85&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;192000102&lt;/strong&gt; &lt;strong&gt;李笑笑 91 88 76&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;…&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;192000130&lt;/strong&gt; &lt;strong&gt;王维维 88 75 91&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="屎山" scheme="http://zuweicun.top/categories/%E5%B1%8E%E5%B1%B1/"/>
    
    
    <category term="C语言" scheme="http://zuweicun.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode0234</title>
    <link href="http://zuweicun.top/2023/11/30/Leetcode0234/"/>
    <id>http://zuweicun.top/2023/11/30/Leetcode0234/</id>
    <published>2023-11-30T12:36:25.000Z</published>
    <updated>2023-11-30T13:27:09.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2,2,1]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="法一：复制到数组"><a href="#法一：复制到数组" class="headerlink" title="法一：复制到数组"></a>法一：复制到数组</h3><p>小生不才，链表使用不够熟练，先用复制链表到数组的笨方法做出来一遍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配数组</span></span><br><span class="line">    <span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!a) &#123;</span><br><span class="line">        <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新遍历链表，将值存入数组</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        a[i] = cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为回文</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] != a[count - <span class="number">1</span> - i]) &#123;</span><br><span class="line">            <span class="built_in">free</span>(a);  <span class="comment">// 释放动态分配的数组内存</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);  <span class="comment">// 释放动态分配的数组内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="法二：快慢指针"><a href="#法二：快慢指针" class="headerlink" title="法二：快慢指针"></a>法二：快慢指针</h3><p>这也是我想到的第二个方法。</p><p>整个流程可以分为以下五个步骤：</p><ol><li><p>找到前半部分链表的尾节点。</p></li><li><p>反转后半部分链表。</p></li><li><p>判断是否回文。</p></li><li><p>恢复链表。</p></li><li><p>返回结果。</p><p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p><p>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p><p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p><p>步骤二可以使用[反转链表](<a href="http://zuweicun.top/2023/11/30/Leetcode0206/#more">Leetcode0206 | 全之の博客 (zuweicun.top)</a>)问题中的解决方法来反转链表的后半部分。</p><p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p><p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p><p>其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;<span class="comment">//创建空节点用于存放“前一个”数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span> =</span> head;<span class="comment">//基操curr遍历</span></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">nextTemp</span> =</span> curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;<span class="comment">//反转函数</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">endOfFirstHalf</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> =</span> head;<span class="comment">//块指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> =</span> head;<span class="comment">//慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;<span class="comment">//一次走两步</span></span><br><span class="line">        slow = slow-&gt;next;<span class="comment">//一次走一步</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;<span class="comment">//由于快慢指针的数量关系，slow返回的应该是链表半节点处</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;<span class="comment">//最终的bool类型判断函数</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">firstHalfEnd</span> =</span> endOfFirstHalf(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">secondHalfStart</span> =</span> reverseList(firstHalfEnd-&gt;next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否回文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p1</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p2</span> =</span> secondHalfStart;</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">    firstHalfEnd-&gt;next = reverseList(secondHalfStart);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="法三：递归"><a href="#法三：递归" class="headerlink" title="法三：递归"></a>法三：递归</h3><p><em>这个递归来源于Leetcode官方题解，其风骚是我至今所遇最强。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，用于存储前半部分链表的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">frontPointer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归检查是否回文</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">recursivelyCheck</span><span class="params">(<span class="keyword">struct</span> ListNode* currentNode)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前节点不为空时进行递归检查</span></span><br><span class="line">    <span class="keyword">if</span> (currentNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归检查下一个节点，如果返回 false，则整体返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (!recursivelyCheck(currentNode-&gt;next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查当前节点的值是否与前半部分链表的节点值相等</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前半部分链表指针移动到下一个节点</span></span><br><span class="line">        frontPointer = frontPointer-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若所有节点都检查完毕，返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查链表是否为回文</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化全局变量 frontPointer</span></span><br><span class="line">    frontPointer = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归检查函数</span></span><br><span class="line">    <span class="keyword">return</span> recursivelyCheck(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>isPalindrome</code> 函数设置 <code>frontPointer</code> 为链表头，并调用 <code>recursivelyCheck</code> 函数。</li><li><code>recursivelyCheck</code> 函数首先检查当前节点是否为 <code>NULL</code>，如果是，则返回 <code>true</code>，因为链表的末尾已经达到。</li><li>然后，<code>recursivelyCheck</code> 递归调用自己，传递当前节点的下一个节点。</li><li>在递归返回之前，检查当前节点的值是否等于 <code>frontPointer</code> 指向的节点的值。如果不等，则返回 <code>false</code>，因为链表不是回文的。</li><li>如果值相等，将 <code>frontPointer</code> 移动到下一个节点。</li><li>最终，如果整个链表都被成功检查，并且没有发现值不相等的情况，那么整个函数返回 <code>true</code>，表示链表是回文的。</li></ol><p>这种方法的核心思想是使用递归从链表的末尾开始比较节点的值，同时使用 <code>frontPointer</code> 从链表的头部开始。这两个指针相向移动，逐一比较节点的值，如果在整个过程中没有找到不相等的节点，则链表被认为是回文的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;回文链表&quot;&gt;&lt;a href=&quot;#回文链表&quot; class=&quot;headerlink&quot; title=&quot;回文链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/palindrome-linked-list/&quot;&gt;回文链表&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个单链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你判断该链表是否为回文链表。如果是，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://zuweicun.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://zuweicun.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode0203</title>
    <link href="http://zuweicun.top/2023/11/30/Leetcode0203/"/>
    <id>http://zuweicun.top/2023/11/30/Leetcode0203/</id>
    <published>2023-11-30T12:05:21.000Z</published>
    <updated>2023-11-30T13:24:30.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">移除链表元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,6,3,4,5,6]</span>, val = <span class="number">6</span></span><br><span class="line">输出：<span class="string">[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[7,7,7,7]</span>, val = 7</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>刚开始思路非常简单：检测到下一个节点是val，删除该节点。写出了下面这段蠢到家的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span>=</span>head;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next==val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>仔细一看题：发现“<strong>新的头节点</strong>”还特意加粗了，看起来如果第一个节点就是空节点程序会直接寄掉。</p><ol><li><code>cur-&gt;next = cur-&gt;next-&gt;next;</code> 表示删除当前节点的下一个节点。这会导致无法处理连续相同值的节点。正确的做法是将当前节点的 <code>next</code> 指针直接指向下下个节点，而不是跳过一个节点。</li><li>函数的返回值是链表的头指针 <code>head</code>，但是在删除节点的过程中，链表头部可能发生变化。因此，应该在删除节点后返回新的头指针。</li></ol><p>修改为以下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElements</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;next = head;<span class="comment">//在头节点前创建一个空节点，用于解决其为val的情况</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> dummy;<span class="comment">//基操用cur遍历</span></span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next-&gt;val==val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> dummy-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newHead;<span class="comment">//返回新的头节点，并释放dummy的空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;移除链表元素&quot;&gt;&lt;a href=&quot;#移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;移除链表元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-linked-list-elements/&quot;&gt;移除链表元素&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你一个链表的头节点 &lt;code&gt;head&lt;/code&gt; 和一个整数 &lt;code&gt;val&lt;/code&gt; ，请你删除链表中所有满足 &lt;code&gt;Node.val == val&lt;/code&gt; 的节点，并返回 &lt;strong&gt;新的头节点&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://zuweicun.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://zuweicun.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode0206</title>
    <link href="http://zuweicun.top/2023/11/30/Leetcode0206/"/>
    <id>http://zuweicun.top/2023/11/30/Leetcode0206/</id>
    <published>2023-11-30T11:21:11.000Z</published>
    <updated>2023-11-30T11:28:48.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基本想法是把列表的首尾节点调换，即每一个指针都指向前一个节点。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">prev</span> =</span><span class="literal">NULL</span>;<span class="comment">//创建一个空头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curr</span>=</span>head;<span class="comment">//创建curr用于遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> =</span>curr-&gt;next;</span><br><span class="line">        curr-&gt;next =prev;</span><br><span class="line">        prev =curr;<span class="comment">//把pre遍历到当前节点</span></span><br><span class="line">        curr=next;<span class="comment">//把当前指针遍历到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list/&quot;&gt;反转链表&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给你单链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你反转链表，并返回反转后的链表。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://zuweicun.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://zuweicun.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode83</title>
    <link href="http://zuweicun.top/2023/11/30/Leetcode83/"/>
    <id>http://zuweicun.top/2023/11/30/Leetcode83/</id>
    <published>2023-11-30T11:02:34.000Z</published>
    <updated>2023-11-30T11:28:48.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：<span class="comment">[1,2]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,1,2,3,3]</span></span><br><span class="line">输出：<span class="comment">[1,2,3]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>根据题干描述，链表已经按照升序排列，即只需要判断前后两个节点是否相等从而确定删除与否即可。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;<span class="comment">//即链表为空，没有重复元素可以删除。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next) &#123;<span class="comment">//条件是当前节点的下一个节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;删除排序链表中的重复元素&quot;&gt;&lt;a href=&quot;#删除排序链表中的重复元素&quot; class=&quot;headerlink&quot; title=&quot;删除排序链表中的重复元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-duplicates-from-sorted-list/&quot;&gt;删除排序链表中的重复元素&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个已排序的链表的头 &lt;code&gt;head&lt;/code&gt; ， &lt;em&gt;删除所有重复的元素，使每个元素只出现一次&lt;/em&gt; 。返回 &lt;em&gt;已排序的链表&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://zuweicun.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="链表" scheme="http://zuweicun.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
