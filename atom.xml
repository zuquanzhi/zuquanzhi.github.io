<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全之の博客</title>
  
  <subtitle>ME = Ctrl C + Ctrl V</subtitle>
  <link href="http://zuweicun.top/atom.xml" rel="self"/>
  
  <link href="http://zuweicun.top/"/>
  <updated>2025-04-10T16:03:07.353Z</updated>
  <id>http://zuweicun.top/</id>
  
  <author>
    <name>ZU Weicun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Agent时代基础设施--MCP协议介绍</title>
    <link href="http://zuweicun.top/2025/04/11/Agent%E6%97%B6%E4%BB%A3%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-MCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://zuweicun.top/2025/04/11/Agent%E6%97%B6%E4%BB%A3%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD-MCP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-04-10T16:00:06.000Z</published>
    <updated>2025-04-10T16:03:07.353Z</updated>
    
    
    
    
    <category term="大模型" scheme="http://zuweicun.top/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="大模型" scheme="http://zuweicun.top/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="Agent" scheme="http://zuweicun.top/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>一文教你学会看多目标检测中的指标</title>
    <link href="http://zuweicun.top/2025/03/16/%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E6%8C%87%E6%A0%87%E9%80%9F%E9%80%9A/"/>
    <id>http://zuweicun.top/2025/03/16/%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%AD%E7%9A%84%E6%8C%87%E6%A0%87%E9%80%9F%E9%80%9A/</id>
    <published>2025-03-15T16:18:59.000Z</published>
    <updated>2025-04-10T15:15:25.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标检测入门：看懂mAP指标的核心要点"><a href="#目标检测入门：看懂mAP指标的核心要点" class="headerlink" title="目标检测入门：看懂mAP指标的核心要点"></a>目标检测入门：看懂mAP指标的核心要点</h1><h2 id="一、从找东西说起——理解检测任务"><a href="#一、从找东西说起——理解检测任务" class="headerlink" title="一、从找东西说起——理解检测任务"></a>一、从找东西说起——理解检测任务</h2><p>想象你在玩一个”找物品”的游戏：房间里藏着10个不同种类的玩具，你需要用手机拍照后圈出每个玩具的位置并说出名称。目标检测任务就类似这个过程，需要完成两个核心目标：</p><ol><li><strong>找到物品位置</strong>：用矩形框或者各种奇形怪状的圈准确框住物体（定位）</li><li><strong>认出物品类别</strong>：正确说出物品名称（分类）</li></ol><p>评估系统好坏时，既不能漏掉目标（如找到8个但漏了2个），也不能乱标位置（如把猫的框画到狗身上），更不能乱起名字（<strong>如把坤哥说成牢大</strong>）。这就是mAP指标要解决的问题。<br><img src="laoda.png" alt="只因你太美"></p><h2 id="二、核心概念拆解"><a href="#二、核心概念拆解" class="headerlink" title="二、核心概念拆解"></a>二、核心概念拆解</h2><h3 id="2-1-IoU"><a href="#2-1-IoU" class="headerlink" title="2.1 IoU"></a>2.1 IoU</h3><p>判断预测框是否正确的标准就像交朋友：</p><ul><li><strong>IoU（交并比）</strong>：计算预测框与真实框的”亲密指数”</li><li>计算方式：重叠面积 ÷ 合并后的总面积</li><li>通过阈值判断是否达标（通常0.5为及格线）<script type="math/tex; mode=display">IoU = \frac{Area(B_{pred} \cap B_{gt})}{Area(B_{pred} \cup B_{gt})}</script></li></ul><p><img src="iou.png" alt="IoU"></p><h3 id="2-2-预测结果分类"><a href="#2-2-预测结果分类" class="headerlink" title="2.2 预测结果分类"></a>2.2 预测结果分类</h3><div class="table-container"><table><thead><tr><th>类型</th><th>判断标准</th><th>现实类比</th></tr></thead><tbody><tr><td>TP</td><td>框的位置正确（IoU≥阈值）且名称正确</td><td>正确找到朋友并叫对名字</td></tr><tr><td>FP</td><td>框的位置错误 或 名称错误</td><td>认错人 或 把路人当朋友</td></tr><tr><td>FN</td><td>真实存在但未被检测到</td><td>真正的朋友站在面前却没认出来</td></tr></tbody></table></div><h3 id="2-3-混淆矩阵衍生指标"><a href="#2-3-混淆矩阵衍生指标" class="headerlink" title="2.3 混淆矩阵衍生指标"></a>2.3 混淆矩阵衍生指标</h3><div class="table-container"><table><thead><tr><th>指标名称</th><th>公式</th><th>物理意义</th></tr></thead><tbody><tr><td>精确率 (Precision)</td><td>$P=\frac{TP}{TP+FP}$</td><td>预测阳性样本的真实阳性率</td></tr><tr><td>召回率 (Recall)</td><td>$R=\frac{TP}{TP+FN}$</td><td>真实阳性样本的检出率</td></tr><tr><td>F1分数 (F1 Score)</td><td>$F1=\frac{2PR}{P+R}$</td><td>精确率与召回率的调和平均</td></tr><tr><td>误检率 (False Positive Rate)</td><td>$FPR=\frac{FP}{FP+TN}$</td><td>负样本被误判为正的比例</td></tr></tbody></table></div><h3 id="2-4-系统效率指标"><a href="#2-4-系统效率指标" class="headerlink" title="2.4 系统效率指标"></a>2.4 系统效率指标</h3><div class="table-container"><table><thead><tr><th>指标名称</th><th>测量方式</th><th>应用场景</th></tr></thead><tbody><tr><td>FPS (Frames Per Second)</td><td>每秒处理帧数</td><td>实时检测系统</td></tr><tr><td>内存占用 (Memory Usage)</td><td>显存/内存消耗量</td><td>嵌入式设备部署</td></tr><tr><td>FLOPs (Floating Point Operations)</td><td>浮点运算次数</td><td>算法复杂度评估</td></tr></tbody></table></div><h2 id="三、mAP的计算逻辑"><a href="#三、mAP的计算逻辑" class="headerlink" title="三、mAP的计算逻辑"></a>三、mAP的计算逻辑</h2><h3 id="3-1-从单个类别说起（AP计算）"><a href="#3-1-从单个类别说起（AP计算）" class="headerlink" title="3.1 从单个类别说起（AP计算）"></a>3.1 从单个类别说起（AP计算）</h3><p>假设现在只检测”猫”这个类别：</p><p><strong>一步步解析</strong>：</p><ol><li><strong>收集检测结果</strong>：记录所有预测框的置信度（把握程度）</li><li><strong>排序</strong>：按置信度从高到低排队</li><li><strong>逐级评估</strong>：<ul><li>从最有把握的预测开始检查</li><li>每个预测点形成一对（召回率，精确率）</li></ul></li><li><strong>绘制PR曲线</strong>：连接所有评估点形成的曲线</li><li><strong>计算曲线下面积</strong>：面积越大说明综合表现越好</li></ol><script type="math/tex; mode=display">AP = \int_{0}^{1} P(R) dR</script><p><img src="image.png" alt="PR曲线示意图：曲线越凸向右上角越好"></p><h3 id="3-2-扩展到多类别（mAP）"><a href="#3-2-扩展到多类别（mAP）" class="headerlink" title="3.2 扩展到多类别（mAP）"></a>3.2 扩展到多类别（mAP）</h3><p>当需要检测多个类别时（如猫、狗、鸟）：</p><ol><li>对每个类别单独计算AP值</li><li>所有AP值的平均就是mAP</li><li>优势：平衡各类别的表现差异</li></ol><script type="math/tex; mode=display">mAP = \frac{1}{N}\sum_{i=1}^{N} AP_i</script><h2 id="四、置信度"><a href="#四、置信度" class="headerlink" title="四、置信度"></a>四、置信度</h2><h3 id="4-1-置信度的数学本质"><a href="#4-1-置信度的数学本质" class="headerlink" title="4.1 置信度的数学本质"></a>4.1 置信度的数学本质</h3><p>置信度是模型对预测结果的综合信心值，由两个核心因素构成：</p><script type="math/tex; mode=display">\text{置信度} = \underbrace{P(\text{类别})}_{\text{分类置信度}} \times \underbrace{IoU}_{\text{定位准确度}}</script><p>其中：</p><ul><li>P(类别) 是模型对物体类别的分类置信度，通常是通过softmax或sigmoid等激活函数计算得到的。</li><li>IoU 则是检测框与真实框的重叠度，反映了定位的准确性。</li></ul><p><img src="conf.png" alt="置信度"></p><p>置信度反映了模型对预测结果的总体信任程度。高置信度意味着模型不仅准确识别了物体的类别，而且对其位置也有较高的确定性。</p><h3 id="4-2-置信度的影响因素"><a href="#4-2-置信度的影响因素" class="headerlink" title="4.2 置信度的影响因素"></a>4.2 置信度的影响因素</h3><p>置信度的高低直接影响目标检测的性能，特别是在多目标检测场景下，如何合理设置置信度阈值是提升模型效果的关键。</p><ul><li><p><strong>分类置信度</strong>：分类置信度越高，模型越能准确地识别物体的类别。分类置信度通常受到训练数据质量、模型结构以及超参数调整等因素的影响。如果模型在某个类别的预测上过于保守或过于激进，可能会影响最终的检测效果。</p></li><li><p><strong>定位准确度（IoU）</strong>：定位的准确度直接决定了模型的检测框是否与真实框高度重合。IoU值过低的预测框通常会被认为是错误的，这就需要通过调节IoU的阈值来权衡误报（FP）与漏报（FN）之间的关系。</p></li></ul><h3 id="4-3-置信度与检测结果"><a href="#4-3-置信度与检测结果" class="headerlink" title="4.3 置信度与检测结果"></a>4.3 置信度与检测结果</h3><p>在实际应用中，目标检测模型会输出每个检测框的置信度值。这个置信度值的高低可以用来做进一步的筛选与决策：</p><ol><li><p><strong>置信度筛选</strong>：设置一个阈值，只有置信度超过该阈值的预测框才会被认为是有效的。这有助于减少错误的检测框（例如将一个非物体框判定为目标）。</p></li><li><p><strong>多目标检测中的置信度问题</strong>：在多目标检测场景中，可能会存在多个物体的检测框与置信度接近的情况。此时，需要通过后处理算法（如非极大值抑制NMS）来消除冗余框，保留最具代表性的检测框。</p></li><li><p><strong>多类别的置信度权衡</strong>：在多类别检测中，每个类别的置信度也不同，因此需要综合考虑每个类别的分类置信度与位置准确度，确保模型对所有类别的均衡检测。</p></li></ol><h3 id="4-4-置信度与mAP的关系"><a href="#4-4-置信度与mAP的关系" class="headerlink" title="4.4 置信度与mAP的关系"></a>4.4 置信度与mAP的关系</h3><p>mAP（mean Average Precision）是评估目标检测模型整体表现的重要指标，而置信度直接影响AP的计算。每个类别的AP计算依赖于预测框的置信度，过低的置信度可能导致许多错误的FP（假阳性）或漏报FN（假阴性），从而导致AP和mAP下降。</p><ul><li><strong>高置信度</strong>：一般能提高TP（真阳性）数量，降低FP和FN数量，从而提高模型的整体精度（AP）。</li><li><strong>低置信度</strong>：会使得模型更多地遗漏真实目标（FN），或错误地识别目标（FP），降低AP，从而影响mAP。</li></ul><p>因此，调整置信度阈值，以平衡检测精度和召回率，是优化目标检测模型性能的重要步骤。</p><h3 id="4-5-置信度阈值的选择"><a href="#4-5-置信度阈值的选择" class="headerlink" title="4.5 置信度阈值的选择"></a>4.5 置信度阈值的选择</h3><p>在实际应用中，设置合理的置信度阈值至关重要。过高的阈值可能导致漏检（FN），而过低的阈值则可能导致误检（FP）。通常通过<strong>Precision-Recall曲线</strong>来选择合适的阈值，使得模型在给定的任务和数据集上取得最佳的平衡。</p><ul><li><strong>高阈值</strong>：减少误报（FP），但可能增加漏检（FN）。</li><li><strong>低阈值</strong>：减少漏检（FN），但可能增加误报（FP）。</li></ul><h2 id="五、给指标检测人的”防杠声明”"><a href="#五、给指标检测人的”防杠声明”" class="headerlink" title="五、给指标检测人的”防杠声明”"></a>五、给指标检测人的”防杠声明”</h2><p>看完这篇博客的你，现在应该：</p><p>🕶️ 能对着PR曲线指点江山：”这个曲线不够翘啊，建议回炉重造”<br>📸 看到误检的猫猫狗狗会冷笑：”呵，FP+1”<br>🤖 跟人battle模型性能时：”先看看mAP@0.5:0.95再说话”</p><p>不过记住：  </p><ul><li>当甲方爸爸说”我全都要”时 → 建议ta把IoU阈值设为0.9  </li><li>当产品经理催”再提点准确率”时 → 请ta先标注2000张测试集  </li><li>当算法同学甩锅”标注有问题”时 → 请ta背诵本文第2.2节  </li><li><strong>但是当学长说你模型练的不行，那就是你真的菜还得多练</strong></li></ul><p>最后送给各位CV人一个灵魂拷问：<br><strong>如果坤坤的篮球被检测成只因，这算TP还是FP？</strong>  </p><p>（答案提示：取决于你的训练集有没有加入律师函警告样本 🤫）</p><blockquote><p>| <em>本文不生产指标，只做指标的搬运工</em><br>| <em>—— 鲁迅（并没有说过）</em></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目标检测入门：看懂mAP指标的核心要点&quot;&gt;&lt;a href=&quot;#目标检测入门：看懂mAP指标的核心要点&quot; class=&quot;headerlink&quot; title=&quot;目标检测入门：看懂mAP指标的核心要点&quot;&gt;&lt;/a&gt;目标检测入门：看懂mAP指标的核心要点&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="计算机视觉" scheme="http://zuweicun.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    <category term="RoboMaster" scheme="http://zuweicun.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/RoboMaster/"/>
    
    
    <category term="多目标检测" scheme="http://zuweicun.top/tags/%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    <category term="YOLO" scheme="http://zuweicun.top/tags/YOLO/"/>
    
    <category term="计算机视觉" scheme="http://zuweicun.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>树莓派配合公网服务器frp转发实现内网穿透</title>
    <link href="http://zuweicun.top/2025/02/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E5%90%88%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8frp%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://zuweicun.top/2025/02/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E5%90%88%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8frp%E8%BD%AC%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2025-02-22T16:16:45.000Z</published>
    <updated>2025-04-10T15:15:25.135Z</updated>
    
    <content type="html"><![CDATA[<p>相信不少的同学都遇到过一个很麻烦的事情——实验室用的服务器只有连上实验室的内网后才能使用，一旦外出开impart或者回家后，就不能进入实验室的服务器继续玩耍（卷）了。这个时候怎么办呢？<br>如果你没有一个公网服务器又不想花钱，cpolar是你的最佳选择，但是如果你有事情就变得完全不一样了——<strong>frp的优雅永不过时</strong>。</p><ul><li><a href="https://gofrp.org/">FRP 项目官网</a></li><li><a href="https://github.com/fatedier/frp">GitHub 仓库</a></li><li><a href="https://gofrp.org/docs/">项目文档</a></li></ul><h3 id="frp是什么？"><a href="#frp是什么？" class="headerlink" title="frp是什么？"></a>frp是什么？</h3><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h3 id="为什么使用-frp-？"><a href="#为什么使用-frp-？" class="headerlink" title="为什么使用 frp ？"></a>为什么使用 frp ？</h3><p>通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p><ul><li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li><li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li><li>代理组间的负载均衡。</li><li>端口复用，多个服务通过同一个服务端端口暴露。</li><li>多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。</li><li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li><li>服务端和客户端 UI 页面。<h2 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h2>为了达到这个目的，在硬件上，我们的读者需要准备如下三件东西：</li></ul><p>一台公网服务器，它的 IP 可以在任何能上网的机器上被 ping 到。<br>一台实验室服务器，它只能在实验室内网被访问。<br>一台你自己的电脑，它能 ping 到公网服务器，但是当你带着它出去玩时，它无法 ping 到实验室服务器。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们记我们的公网服务器为 <code>pub</code> (public server)，实验室服务器为 <code>loc</code> (local server)。我们在 pub 和 loc 上同时下载对应操作系统和芯片指令集的<a href="https://github.com/fatedier/frp/releases">编译版本</a>：</p><p>不过考虑到大部分的服务器都是 x86 芯片的 linux，所以可以直接下载解压如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.55.1/</span>frp_0.<span class="number">55.1</span>_linux_amd64.tar.gz</span><br><span class="line">tar -xvf frp_0.<span class="number">55.1</span>_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>进入 frp_0.55.1_linux_amd64 后，我们会看到如下几个文件：</p><ul><li>frpc： frp 客户端执行程序</li><li>frpc.toml：frp 客户端配置文件</li><li>frps：frp 服务端执行程序</li><li>frps.toml：frp 服务端配置文件</li><li>LICENSE：frp 软件开源协议，不用管<br><img src="image.png" alt="从锦恢大佬那里偷的图"></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为了让我们可以在外部能够访问 <code>loc</code>，我们先来实现 SSH 协议的内网穿透。<br>首先在 <code>pub</code> 上，进入解压后的 <code>frp</code> 文件夹。修改 <code>frps.toml</code> 如下：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bindPort</span> <span class="operator">=</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure><br>bindPort 用于和 frpc 进行绑定。<br>在后台执行如下指令：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/frps -c ./</span>frps.toml</span><br></pre></td></tr></table></figure><br>输出如下日志，代表 frps 启动成功：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">58.972</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[frps/root.go:105]</span> frps uses config file: ./frps<span class="selector-class">.toml</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:225]</span> frps tcp listen on <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:292]</span> http service listen on <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[frps/root.go:114]</span> frps started successfully</span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.775</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:563]</span> <span class="selector-attr">[11abba605bc7fe77]</span> client login info: ip <span class="selector-attr">[58.211.218.74:64089]</span> version <span class="selector-attr">[0.55.1]</span> hostname <span class="selector-attr">[]</span> os <span class="selector-attr">[linux]</span> arch <span class="selector-attr">[amd64]</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.806</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[proxy/tcp.go:82]</span> <span class="selector-attr">[11abba605bc7fe77]</span> <span class="selector-attr">[ssh]</span> tcp proxy listen port <span class="selector-attr">[7001]</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.806</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/control.go:401]</span> <span class="selector-attr">[11abba605bc7fe77]</span> new proxy <span class="selector-attr">[ssh]</span> type <span class="selector-attr">[tcp]</span> success</span><br></pre></td></tr></table></figure></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>下载适用于树莓派的arm64架构的frp文件包：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.35.1/</span>frp_0.<span class="number">35.1</span>_linux_arm64.tar.gz</span><br><span class="line">sudo tar -zxvf frp_0.<span class="number">35.1</span>_linux_arm64.tar.gz</span><br><span class="line"><span class="comment"># 文件名可能会有不同，用ls -a命令查看</span></span><br></pre></td></tr></table></figure><br>编辑其中的frpc.ini文件：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><br>按如下参数说明修改配置文件：</p><ul><li><p>server_addr：服务器的IP地址；</p></li><li><p>server_port：服务器端的端口，与服务端配置文件的bind_port端口相同；</p></li><li><p>local_ip：要在公网访问的本地设备的地址，这里指客户端本机，填127.0.0.1即可；</p></li><li><p>local_port：本地设备要暴露的端口，即理解为提供服务的端口</p></li><li><p>remote_port：在外网的访问端口，此端口上的流量会被转发到本地设备对应的local_port端口上</p></li></ul><p><strong>还有别忘了在服务器防火墙上放行remote_port端口</strong></p><p>配置文件中默认有一个ssh的访问配置，如果我们还想让其他的端口在外网访问到，那就可以照猫画虎来添加一个配置。比如在外网用公网ip的8888端口访问本地设备的80端口，就可以这样写：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[http]</span>                  <span class="comment"># 名字自定，写在方括号里面</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span></span><br></pre></td></tr></table></figure><br>然后启动服务<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/frps -c ./</span>frps.ini</span><br></pre></td></tr></table></figure><br>大功告成。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>以上配置完成，就可以在外网访问本地的服务了，访问方式是：服务器的IP地址/域名:端口。此处端口为客户端配置文件中的remote_port端口。<br>（如果想挂在后台或者开机自启动可以写个小脚本或者挂在终端工具上（如sceen），这里就不细说了。）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kirigaya.cn/blog/article?seq=192">https://kirigaya.cn/blog/article?seq=192</a></li><li><a href="https://www.wlplove.com/archives/33/#1.%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2frp">https://www.wlplove.com/archives/33/#1.%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2frp</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信不少的同学都遇到过一个很麻烦的事情——实验室用的服务器只有连上实验室的内网后才能使用，一旦外出开impart或者回家后，就不能进入实验室的服务器继续玩耍（卷）了。这个时候怎么办呢？&lt;br&gt;如果你没有一个公网服务器又不想花钱，cpolar是你的最佳选择，但是如果你有事情就</summary>
      
    
    
    
    <category term="树莓派项目" scheme="http://zuweicun.top/categories/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="frp转发" scheme="http://zuweicun.top/tags/frp%E8%BD%AC%E5%8F%91/"/>
    
    <category term="树莓派" scheme="http://zuweicun.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="内网穿透" scheme="http://zuweicun.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv3深入学习</title>
    <link href="http://zuweicun.top/2025/01/07/YOLOv3%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zuweicun.top/2025/01/07/YOLOv3%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-01-07T08:30:02.000Z</published>
    <updated>2025-04-10T15:15:25.125Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于yolov3对于目标识别界的重大开创性，跳过1、2两个版本直接学习yolov3，同时也作为后续版本的基石入门。</p><hr><h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><h3 id="1-YOLOv3的核心思想"><a href="#1-YOLOv3的核心思想" class="headerlink" title="1. YOLOv3的核心思想"></a>1. YOLOv3的核心思想</h3><p>YOLOv3（You Only Look Once version 3）是一种单阶段目标检测算法，其核心思想是将目标检测问题转化为一个回归问题。与传统的两阶段检测方法（如R-CNN系列）不同，YOLOv3通过单次前向传播直接预测目标的边界框和类别概率，从而实现高效的目标检测。</p><p>YOLOv3的主要特点包括：</p><ul><li><strong>单次前向传播</strong>：输入图像经过一次网络前向传播即可得到检测结果。</li><li><strong>多尺度预测</strong>：通过不同尺度的特征图检测不同大小的目标。</li><li><strong>锚点机制</strong>：使用预定义的锚点（anchors）来辅助预测边界框。</li></ul><hr><h3 id="2-YOLOv3的网络结构"><a href="#2-YOLOv3的网络结构" class="headerlink" title="2. YOLOv3的网络结构"></a>2. YOLOv3的网络结构</h3><p>YOLOv3的网络结构可以分为三个部分：<strong>Backbone（骨干网络）</strong>、<strong>Neck（特征融合部分）**</strong>和<strong>**Head（检测头）</strong>。</p><h4 id="2-1-Backbone：Darknet-53"><a href="#2-1-Backbone：Darknet-53" class="headerlink" title="2.1 Backbone：Darknet-53"></a>2.1 Backbone：Darknet-53</h4><p>YOLOv3的骨干网络是Darknet-53，它是一个包含53个卷积层的深度卷积神经网络。Darknet-53借鉴了ResNet的思想，使用了残差连接（Residual Connections）来缓解深层网络的梯度消失问题。</p><p>Darknet-53的主要特点：</p><ul><li>使用1x1和3x3卷积层提取特征。</li><li>使用残差块（Residual Block）来构建深层网络。</li><li>输出三个不同尺度的特征图（13x13、26x26、52x52），用于多尺度预测。</li></ul><h4 id="2-2-Neck：特征金字塔网络（FPN）"><a href="#2-2-Neck：特征金字塔网络（FPN）" class="headerlink" title="2.2 Neck：特征金字塔网络（FPN）"></a>2.2 Neck：特征金字塔网络（FPN）</h4><p>YOLOv3通过特征金字塔网络（Feature Pyramid Network, FPN）实现多尺度特征融合。FPN将深层特征图（包含语义信息）与浅层特征图（包含细节信息）进行融合，从而增强网络对不同尺度目标的检测能力。</p><p>FPN的工作流程：</p><ul><li>从深层特征图开始，逐步上采样并与浅层特征图融合。</li><li>最终生成三个不同尺度的特征图（13x13、26x26、52x52），分别用于检测大、中、小目标。</li></ul><h4 id="2-3-Head：检测头"><a href="#2-3-Head：检测头" class="headerlink" title="2.3 Head：检测头"></a>2.3 Head：检测头</h4><p>检测头是YOLOv3的输出部分，负责预测边界框和类别概率。每个尺度的特征图都会预测固定数量的边界框（通常是3个），每个边界框包含以下信息：</p><ul><li>边界框的中心坐标（x, y）。</li><li>边界框的宽度和高度（w, h）。</li><li>目标存在的置信度（confidence）。</li><li>类别概率（class probabilities）。</li></ul><hr><h3 id="3-多尺度预测"><a href="#3-多尺度预测" class="headerlink" title="3. 多尺度预测"></a>3. 多尺度预测</h3><p>YOLOv3在三个不同尺度的特征图上进行预测：</p><ul><li><strong>13x13特征图</strong>：用于检测大目标。</li><li><strong>26x26特征图</strong>：用于检测中等目标。</li><li><strong>52x52特征图</strong>：用于检测小目标。</li></ul><p>每个尺度的特征图会被划分为若干网格（grid cell），每个网格负责预测固定数量的边界框。例如，13x13特征图会被划分为13x13个网格，每个网格预测3个边界框。</p><hr><h3 id="4-锚点机制"><a href="#4-锚点机制" class="headerlink" title="4. 锚点机制"></a>4. 锚点机制</h3><p>YOLOv3使用锚点（anchors）来辅助预测边界框。锚点是一组预定义的边界框尺寸，用于帮助网络更好地预测不同大小和形状的目标。</p><p>锚点的作用：</p><ul><li>每个尺度的特征图使用不同的锚点尺寸。例如，13x13特征图使用较大的锚点，52x52特征图使用较小的锚点。</li><li>网络预测的边界框是基于锚点的偏移量，而不是直接预测边界框的绝对坐标。</li></ul><hr><h3 id="5-边界框的编码与解码"><a href="#5-边界框的编码与解码" class="headerlink" title="5. 边界框的编码与解码"></a>5. 边界框的编码与解码</h3><p>YOLOv3通过编码和解码的方式将预测的边界框与真实边界框进行匹配。</p><h4 id="5-1-编码（Encoding）"><a href="#5-1-编码（Encoding）" class="headerlink" title="5.1 编码（Encoding）"></a>5.1 编码（Encoding）</h4><p>在训练时，需要将真实的边界框（ground truth）编码为网络输出的格式。</p><p>假设我们有一个真实的边界框$ (x, y, w, h) $，对应的锚点为$ (p_w, p_h) $，则编码后的边界框为：</p><ul><li>$ tx = (x - cx) / stride $</li><li>$ ty = (y - cy) / stride $</li><li>$ tw = log(w / p_w) $</li><li>$ th = log(h / p_h) $</li></ul><p>其中，$ (cx, cy) $是当前网格的左上角坐标，$ (tx, ty) $是中心偏移量，$ (tw, th) $是缩放比例，$ stride $是特征图的步长。</p><h4 id="5-2-解码（Decoding）"><a href="#5-2-解码（Decoding）" class="headerlink" title="5.2 解码（Decoding）"></a>5.2 解码（Decoding）</h4><p>在推理时，需要将网络输出的边界框解码为实际的坐标。假设网络输出为$ (tx, ty, tw, th) $，对应的锚点为$ (p_w, p_h) $，则解码后的边界框为：</p><ul><li>$ x = (sigmoid(tx) + cx) * stride $</li><li>$ y = (sigmoid(ty) + cy) * stride $</li><li>$ w = exp(tw) * p_w $</li><li>$ h = exp(th) * p_h $</li></ul><hr><h3 id="6-损失函数"><a href="#6-损失函数" class="headerlink" title="6. 损失函数"></a>6. 损失函数</h3><p>YOLOv3的损失函数由三部分组成：</p><ul><li><strong>定位损失（Localization Loss）</strong>：计算预测边界框与真实边界框之间的误差，通常使用均方误差（MSE）。</li><li><strong>置信度损失（Confidence Loss）</strong>：计算预测的置信度与真实值之间的误差，通常使用二元交叉熵（Binary Cross-Entropy）。</li><li><strong>分类损失（Classification Loss）</strong>：计算预测的类别概率与真实类别之间的误差，通常使用交叉熵（Cross-Entropy）。</li></ul><hr><h3 id="7-训练与推理"><a href="#7-训练与推理" class="headerlink" title="7. 训练与推理"></a>7. 训练与推理</h3><h4 id="7-1-训练"><a href="#7-1-训练" class="headerlink" title="7.1 训练"></a>7.1 训练</h4><p>在训练时，YOLOv3通过以下步骤进行优化：</p><ol><li>输入图像经过网络前向传播，得到三个尺度的预测结果。</li><li>将预测结果与真实标签进行匹配，计算损失。</li><li>使用反向传播更新网络参数。</li></ol><h4 id="7-2-推理"><a href="#7-2-推理" class="headerlink" title="7.2 推理"></a>7.2 推理</h4><p>在推理时，YOLOv3通过以下步骤生成检测结果：</p><ol><li>输入图像经过网络前向传播，得到三个尺度的预测结果。</li><li>对预测的边界框进行解码，得到实际的坐标。</li><li>使用非极大值抑制（NMS）去除重叠的边界框，得到最终的检测结果。</li></ol><hr><h2 id="细节实现"><a href="#细节实现" class="headerlink" title="细节实现"></a>细节实现</h2><h3 id="1-网络输出的结构"><a href="#1-网络输出的结构" class="headerlink" title="1. 网络输出的结构"></a>1. 网络输出的结构</h3><p>YOLOv3的网络输出是三个尺度的特征图（13x13、26x26、52x52），每个尺度的特征图会预测固定数量的边界框（通常是3个）。每个边界框的输出包含以下信息：</p><ul><li><strong>边界框的中心坐标偏移量（tx, ty）</strong>：相对于当前网格的偏移量。</li><li><strong>边界框的宽度和高度缩放量（tw, th）</strong>：相对于锚点的缩放量。</li><li><strong>目标存在的置信度（confidence）</strong>：表示当前边界框包含目标的概率。</li><li><strong>类别概率（class probabilities）</strong>：表示目标属于每个类别的概率。</li></ul><p>假设每个尺度预测3个边界框，类别数为C，则每个尺度的输出维度为：</p><ul><li>13x13尺度的输出维度：<code>13 x 13 x 3 x (5 + C)</code></li><li>26x26尺度的输出维度：<code>26 x 26 x 3 x (5 + C)</code></li><li>52x52尺度的输出维度：<code>52 x 52 x 3 x (5 + C)</code></li></ul><p>其中，<code>5</code>表示边界框的4个坐标值（tx, ty, tw, th）和1个置信度，<code>C</code>表示类别数。</p><hr><h3 id="2-后处理计算"><a href="#2-后处理计算" class="headerlink" title="2. 后处理计算"></a>2. 后处理计算</h3><p>后处理计算的目的是将网络的原始输出转换为实际的边界框坐标和类别信息。具体步骤如下：</p><h4 id="2-1-解码边界框坐标"><a href="#2-1-解码边界框坐标" class="headerlink" title="2.1 解码边界框坐标"></a>2.1 解码边界框坐标</h4><p>网络的输出是边界框的偏移量和缩放量，需要通过解码将其转换为实际的边界框坐标。</p><p>假设网络的输出为$ (tx, ty, tw, th) $，对应的锚点为$ (a_w, a_h) $，当前网格的左上角坐标为$ (cx, cy) $，特征图的步长为$ stride $，则解码后的边界框坐标为：</p><ul><li><strong>中心坐标</strong>：<ul><li>$   x = (sigmoid(tx) + cx) * stride $</li><li>$   y = (sigmoid(ty) + cy) * stride $</li></ul></li><li><strong>宽度和高度</strong>：<ul><li>$   w = exp(tw) * p_w $</li><li>$   h = exp(th) * p_h $</li></ul></li></ul><p>其中，$ sigmoid $函数用于将偏移量限制在0到1之间，确保边界框的中心位于当前网格内。</p><h4 id="2-2-计算置信度和类别概率"><a href="#2-2-计算置信度和类别概率" class="headerlink" title="2.2 计算置信度和类别概率"></a>2.2 计算置信度和类别概率</h4><p>网络的输出还包括置信度和类别概率，需要通过以下步骤进行处理：</p><ul><li><strong>置信度</strong>：直接使用$ sigmoid $函数将输出值转换为概率值，表示当前边界框包含目标的概率。</li><li><strong>类别概率</strong>：对每个类别的输出值应用$ sigmoid $函数，得到每个类别的概率值。</li></ul><h4 id="2-3-过滤低置信度的边界框"><a href="#2-3-过滤低置信度的边界框" class="headerlink" title="2.3 过滤低置信度的边界框"></a>2.3 过滤低置信度的边界框</h4><p>为了减少计算量，通常会过滤掉置信度低于某个阈值（如0.5）的边界框。只有置信度高于阈值的边界框才会进入下一步处理。</p><h4 id="2-4-非极大值抑制（NMS）"><a href="#2-4-非极大值抑制（NMS）" class="headerlink" title="2.4 非极大值抑制（NMS）"></a>2.4 非极大值抑制（NMS）</h4><p>非极大值抑制（Non-Maximum Suppression, NMS）用于去除重叠的边界框，保留最优的检测结果。NMS的具体步骤如下：</p><ol><li>对所有边界框按置信度从高到低排序。</li><li>选择置信度最高的边界框，将其加入最终结果列表。</li><li>计算该边界框与其余边界框的交并比（IoU）。</li><li>删除IoU高于某个阈值（如0.5）的边界框。</li><li>重复步骤2-4，直到所有边界框都被处理。</li></ol><hr><h3 id="3-置信度的计算"><a href="#3-置信度的计算" class="headerlink" title="3. 置信度的计算"></a>3. 置信度的计算</h3><p>置信度（confidence）是网络输出的一个重要部分，表示当前边界框包含目标的概率。置信度的计算步骤如下：</p><ol><li><strong>网络输出</strong>：网络输出的置信度是一个标量值（通常记为$ t_conf $），范围是任意的（未经过激活函数处理）。</li><li><strong>Sigmoid激活</strong>：为了将置信度转换为概率值，需要对$ t_conf $应用Sigmoid函数：<br>$ \text{confidence} = \sigma(t_conf) = \frac{1}{1 + e^{-t_conf}} $<br>这样，置信度的值被限制在0到1之间。</li><li><strong>置信度的意义</strong>：置信度表示当前边界框内是否存在目标。如果置信度接近1，说明边界框内很可能存在目标；如果接近0，则说明边界框内很可能没有目标。</li></ol><hr><h3 id="3-1-类别概率的计算"><a href="#3-1-类别概率的计算" class="headerlink" title="3.1 类别概率的计算"></a>3.1 类别概率的计算</h3><p>类别概率（class probabilities）表示目标属于每个类别的概率。</p><ol><li><strong>网络输出</strong>：网络输出的类别概率是一个长度为$ C $的向量（$ C $为类别数），记为$ t_class $。每个值表示对应类别的得分（未经过激活函数处理）。</li><li><strong>Sigmoid激活</strong>：对$ t_class $中的每个值应用$ Sigmoid $函数，将其转换为概率值：<br>$ \text{class_prob}_i = \sigma(t_class_i) = \frac{1}{1 + e^{-t_class_i}} $<br>这样，每个类别的概率值被限制在0到1之间。</li><li><strong>类别概率的意义</strong>：$ class_prob_i $表示目标属于第$ i $个类别的概率。YOLOv3使用$ Sigmoid $函数而不是$ Softmax $函数，因此每个类别的概率是独立的，可以同时预测多个类别（适用于多标签分类任务）。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736055615050-19591ae5-d726-49fa-9129-d6f5e1fd6af6.png" alt=""></p><hr><h3 id="3-2-过滤低置信度的边界框"><a href="#3-2-过滤低置信度的边界框" class="headerlink" title="3.2 过滤低置信度的边界框"></a>3.2 过滤低置信度的边界框</h3><p>在得到置信度和类别概率后，通常需要过滤掉低置信度的边界框，以减少计算量并提高检测结果的可靠性。具体步骤如下：</p><ol><li><strong>设置置信度阈值</strong>：通常设置一个置信度阈值（如0.5），只有置信度高于该阈值的边界框才会被保留。</li><li><strong>过滤边界框</strong>：遍历所有边界框，保留置信度高于阈值的边界框，丢弃低于阈值的边界框。</li></ol><hr><h3 id="3-3-非极大值抑制（NMS）"><a href="#3-3-非极大值抑制（NMS）" class="headerlink" title="3.3 非极大值抑制（NMS）"></a>3.3 非极大值抑制（NMS）</h3><p>非极大值抑制（Non-Maximum Suppression, NMS）是目标检测中常用的后处理步骤，用于去除重叠的边界框，保留最优的检测结果。NMS的具体步骤如下：</p><ol><li><strong>按置信度排序</strong>：将所有边界框按置信度从高到低排序。</li><li><strong>选择最高置信度的边界框</strong>：从排序后的列表中选择置信度最高的边界框，将其加入最终结果列表。</li><li><strong>计算交并比（IoU）</strong>：计算该边界框与其余所有边界框的交并比（Intersection over Union, IoU）。IoU的计算公式为：<br>$ \text{IoU} = \frac{\text{Area of Intersection}}{\text{Area of Union}} $<br>其中，<code>Area of Intersection</code>是两个边界框的交集面积，<code>Area of Union</code>是两个边界框的并集面积。</li><li><strong>去除重叠边界框</strong>：删除与当前边界框IoU高于某个阈值（如0.5）的边界框。</li><li><strong>重复步骤2-4</strong>：重复上述过程，直到所有边界框都被处理。</li></ol><hr><h3 id="3-具体示例"><a href="#3-具体示例" class="headerlink" title="3. 具体示例"></a>3. 具体示例</h3><p>假设我们有一个13x13尺度的输出，类别数为80，锚点为<code>(10, 13), (16, 30), (33, 23)</code>，特征图的步长为32。</p><h4 id="3-1-网络输出"><a href="#3-1-网络输出" class="headerlink" title="3.1 网络输出"></a>3.1 网络输出</h4><p>网络的输出维度为<code>13 x 13 x 3 x 85</code>，其中<code>85 = 5 + 80</code>（5表示边界框的4个坐标值和1个置信度，80表示类别数）。</p><h4 id="3-2-解码边界框"><a href="#3-2-解码边界框" class="headerlink" title="3.2 解码边界框"></a>3.2 解码边界框</h4><p>对于每个网格和每个锚点，解码边界框的步骤如下：</p><ol><li>提取$ (tx, ty, tw, th) $和置信度、类别概率。</li><li>使用$ Sigmoid $函数计算中心坐标偏移量：<ul><li>$ x = (\sigma(tx) + cx) \times 32 $</li><li>$   y = (\sigma(ty) + cy) \times 32  $</li></ul></li><li>使用指数函数计算宽度和高度：<ul><li>$ w = \exp(tw) \times a_w $</li><li>$  h = \exp(th) \times a_h  $</li></ul></li><li>将边界框坐标转换为$ (x_min, y_min, x_max, y_max) $格式：<ul><li>$    x_{\text{min}} = x - w / 2  $</li><li>$    y_{\text{min}} = y - h / 2  $</li><li>$    x_{\text{max}} = x + w / 2  $</li><li>$ y_{\text{max}} = y + h / 2  $</li></ul></li></ol><h4 id="3-3-置信度和类别概率的计算"><a href="#3-3-置信度和类别概率的计算" class="headerlink" title="3.3 置信度和类别概率的计算"></a>3.3 置信度和类别概率的计算</h4><ol><li>对置信度$ t_conf $应用$ Sigmoid $函数：<br>$ \text{confidence} = \sigma(t_conf) $</li><li>对类别概率$ t_class $应用$ Sigmoid $函数：<br>$ \text{class_prob}_i = \sigma(t_class_i) $</li></ol><h4 id="3-4-过滤和NMS"><a href="#3-4-过滤和NMS" class="headerlink" title="3.4 过滤和NMS"></a>3.4 过滤和NMS</h4><ol><li>过滤掉置信度低于0.5的边界框。</li><li>对剩余的边界框按置信度排序。</li><li>使用NMS去除重叠的边界框，保留最优的检测结果。</li></ol><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><hr><h3 id="1-网络架构：Darknet-53"><a href="#1-网络架构：Darknet-53" class="headerlink" title="1. 网络架构：Darknet-53"></a>1. 网络架构：Darknet-53</h3><p>YOLOv3的骨干网络是Darknet-53，这是一个53层的卷积神经网络（CNN），借鉴了ResNet的残差结构，但设计更为轻量化和高效。</p><h4 id="1-1-Darknet-53的结构"><a href="#1-1-Darknet-53的结构" class="headerlink" title="1.1 Darknet-53的结构"></a>1.1 Darknet-53的结构</h4><ul><li><strong>输入</strong>：YOLOv3的输入图像尺寸通常为416x416（或其他尺寸，如608x608）。</li><li><strong>卷积层</strong>：Darknet-53主要由卷积层、批量归一化（Batch Normalization）和Leaky ReLU激活函数组成。<ul><li>卷积层：使用3x3和1x1卷积核，3x3卷积用于提取特征，1x1卷积用于调整通道数。</li><li>批量归一化：加速训练并提高模型稳定性。</li><li>Leaky ReLU：激活函数，公式为 $  f(x) = \max(x, 0.1x)  $，避免梯度消失。</li></ul></li><li><strong>残差块（Residual Block）</strong>：Darknet-53的核心组件是残差块，每个残差块包含两个3x3卷积层和一个跳跃连接（Shortcut Connection）。<ul><li>跳跃连接将输入直接加到输出上，缓解梯度消失问题，使网络能够训练得更深。</li><li>Darknet-53共有23个残差块。</li></ul></li></ul><h4 id="1-2-Darknet-53的特点"><a href="#1-2-Darknet-53的特点" class="headerlink" title="1.2 Darknet-53的特点"></a>1.2 Darknet-53的特点</h4><ul><li><strong>深度</strong>：53层网络，比YOLOv2的Darknet-19更深，但比ResNet-152更轻量。</li><li><strong>效率</strong>：Darknet-53在ImageNet分类任务上达到了与ResNet-152相当的精度，但速度更快。</li><li><strong>多尺度特征提取</strong>：Darknet-53通过不同层提取不同尺度的特征，为后续的多尺度预测提供支持。</li></ul><hr><h3 id="2-多尺度预测"><a href="#2-多尺度预测" class="headerlink" title="2. 多尺度预测"></a>2. 多尺度预测</h3><p>YOLOv3在三个不同尺度的特征图上进行目标检测，分别对应13x13、26x26和52x52的特征图。这种多尺度设计使其能够检测不同大小的目标。</p><h4 id="2-1-特征金字塔网络（FPN）"><a href="#2-1-特征金字塔网络（FPN）" class="headerlink" title="2.1 特征金字塔网络（FPN）"></a>2.1 特征金字塔网络（FPN）</h4><p>YOLOv3借鉴了特征金字塔网络（Feature Pyramid Network, FPN）的思想，通过上采样和特征融合实现多尺度预测。</p><ul><li><strong>上采样（Upsampling）</strong>：将低分辨率的特征图通过插值方法（如双线性插值）放大到高分辨率。</li><li><strong>特征融合</strong>：将上采样后的特征图与来自浅层的特征图进行拼接（Concatenation），结合低级特征（细节信息）和高级特征（语义信息）。<ul><li>例如，13x13的特征图通过上采样得到26x26的特征图，然后与Darknet-53中间层的26x26特征图拼接。</li></ul></li></ul><h4 id="2-2-三个尺度的预测"><a href="#2-2-三个尺度的预测" class="headerlink" title="2.2 三个尺度的预测"></a>2.2 三个尺度的预测</h4><ul><li><strong>13x13特征图</strong>：用于检测大目标。</li><li><strong>26x26特征图</strong>：用于检测中等目标。</li><li><strong>52x52特征图</strong>：用于检测小目标。</li></ul><p>每个尺度的特征图都会输出预测结果，包括边界框坐标、置信度和类别概率。</p><hr><h3 id="3-锚框（Anchor-Boxes）机制"><a href="#3-锚框（Anchor-Boxes）机制" class="headerlink" title="3. 锚框（Anchor Boxes）机制"></a>3. 锚框（Anchor Boxes）机制</h3><p>YOLOv3使用锚框（Anchor Boxes）来预测目标的边界框。锚框是预定义的边界框，用于捕捉不同形状和尺寸的目标。</p><h4 id="3-1-锚框的选择"><a href="#3-1-锚框的选择" class="headerlink" title="3.1 锚框的选择"></a>3.1 锚框的选择</h4><ul><li><strong>K-means聚类</strong>：YOLOv3使用K-means聚类算法从训练数据集中自动学习锚框的尺寸。<ul><li>对训练集中所有目标的边界框进行聚类，得到9个聚类中心（即9个锚框）。</li><li>这些锚框被分配到三个尺度上，每个尺度分配3个锚框。</li></ul></li><li><strong>锚框的尺寸</strong>：不同尺度的锚框尺寸不同，例如：<ul><li>13x13尺度的锚框较大，适合检测大目标。</li><li>52x52尺度的锚框较小，适合检测小目标。</li></ul></li></ul><h4 id="3-2-锚框的预测"><a href="#3-2-锚框的预测" class="headerlink" title="3.2 锚框的预测"></a>3.2 锚框的预测</h4><ul><li>每个网格单元（Grid Cell）预测3个边界框，每个边界框对应一个锚框。</li><li>每个边界框预测以下内容：<ul><li>边界框坐标（x, y, w, h）：x和y是中心点坐标，w和h是宽度和高度。</li><li>置信度（Confidence）：表示边界框内是否包含目标，以及预测框的准确性。</li><li>类别概率（Class Probabilities）：表示目标属于每个类别的概率。</li></ul></li></ul><hr><h3 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4. 损失函数"></a>4. 损失函数</h3><p>以下是YOLOv3中三个损失计算函数的详细公式和解释：</p><hr><h4 id="1-坐标损失（Coordinate-Loss）"><a href="#1-坐标损失（Coordinate-Loss）" class="headerlink" title="1. 坐标损失（Coordinate Loss）"></a>1. 坐标损失（Coordinate Loss）</h4><p>坐标损失用于衡量预测的边界框坐标（中心点 (x, y) 和宽高 (w, h)）与真实边界框坐标之间的差异。YOLOv3使用均方误差（MSE）来计算坐标损失。</p><h5 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736056982107-a76914d6-e67e-4dc2-a3a9-70c511955a5f.png" alt=""></p><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>$  S^2  $：网格单元的数量（例如，13x13、26x26、52x52）。</li><li>$  B  $：每个网格单元预测的边界框数量（YOLOv3中 ( B = 3 )）。</li><li>$ \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 ( i ) 个网格单元的第 ( j ) 个边界框是否负责检测目标（如果是则为1，否则为0）。</li><li>$  x_i, y_i  $：预测的边界框中心点坐标。</li><li>$  \hat{x}_i, \hat{y}_i  $：真实的边界框中心点坐标。</li><li>$  w_i, h_i  $：预测的边界框宽度和高度。</li><li>$  \hat{w}_i, \hat{h}_i  $：真实的边界框宽度和高度。</li><li>$  \lambda_{\text{coord}}  $：坐标损失的权重（通常设置为5）。</li></ul><hr><h4 id="2-置信度损失（Confidence-Loss）"><a href="#2-置信度损失（Confidence-Loss）" class="headerlink" title="2. 置信度损失（Confidence Loss）"></a>2. 置信度损失（Confidence Loss）</h4><p>置信度损失用于衡量预测的置信度（即边界框内是否包含目标）与真实值之间的差异。YOLOv3使用二分类交叉熵损失来计算置信度损失。</p><h5 id="公式：-1"><a href="#公式：-1" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736056991829-7210b841-2fa5-4cf0-b402-bc9756a8a691.png" alt=""></p><h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>$  \hat{C}_i  $：预测的置信度（即边界框内包含目标的概率）。</li><li>$  \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 ( i ) 个网格单元的第 ( j ) 个边界框是否负责检测目标（如果是则为1，否则为0）。</li><li>对于负样本（不包含目标的边界框），置信度损失仅计算 $  \log(1 - \hat{C}_i)  $。</li></ul><hr><h4 id="3-类别损失（Class-Loss）"><a href="#3-类别损失（Class-Loss）" class="headerlink" title="3. 类别损失（Class Loss）"></a>3. 类别损失（Class Loss）</h4><p>类别损失用于衡量预测的类别概率与真实类别之间的差异。YOLOv3使用多分类交叉熵损失来计算类别损失。</p><h5 id="公式：-2"><a href="#公式：-2" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736057000321-c51f7efd-2012-429e-8635-d4b10122b037.png" alt=""></p><h5 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>$ p_i(c)  $：真实的类别概率（如果是类别$  c  $则为1，否则为0）。</li><li>$ \hat{p}_i(c)  $：预测的类别概率（通过$ Sigmoid $函数输出）。</li><li>$ \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 $  i   $个网格单元的第$   j   $个边界框是否负责检测目标（如果是则为1，否则为0）。</li><li>$  c  $：类别索引， $ \text{classes}  $是所有类别的集合。</li></ul><hr><h4 id="4-总损失函数"><a href="#4-总损失函数" class="headerlink" title="4. 总损失函数"></a>4. 总损失函数</h4><p>YOLOv3的总损失函数是上述三个损失函数的加权和：<br><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736057096661-f17820de-b536-4b52-b14d-c2b662de9c8d.png" alt=""></p><h5 id="参数说明：-3"><a href="#参数说明：-3" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>总损失函数是坐标损失、置信度损失和类别损失的总和。</li><li>每个损失函数的权重可以通过超参数调整（例如，坐标损失的权重 $  \lambda_{\text{coord}}  $ 通常设置为5）。</li></ul><hr><h3 id="5-训练与推理"><a href="#5-训练与推理" class="headerlink" title="5. 训练与推理"></a>5. 训练与推理</h3><h4 id="5-1-训练"><a href="#5-1-训练" class="headerlink" title="5.1 训练"></a>5.1 训练</h4><ul><li><strong>数据增强</strong>：使用随机裁剪、翻转、颜色抖动等技术增强数据。</li><li><strong>损失优化</strong>：通过反向传播优化损失函数，更新网络参数。</li><li><strong>预训练</strong>：Darknet-53通常在ImageNet数据集上进行预训练，然后在目标检测任务上进行微调。</li></ul><h4 id="5-2-推理"><a href="#5-2-推理" class="headerlink" title="5.2 推理"></a>5.2 推理</h4><ul><li><strong>输入图像</strong>：将图像调整为固定尺寸（如416x416）并输入网络。</li><li><strong>预测输出</strong>：网络输出三个尺度的预测结果。</li><li><strong>非极大值抑制（NMS）</strong>：去除重叠的边界框，保留置信度最高的预测框。</li></ul><hr><h2 id="代码阅读（汉化）"><a href="#代码阅读（汉化）" class="headerlink" title="代码阅读（汉化）"></a>代码阅读（汉化）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ultralytics YOLOv3 🚀, AGPL-3.0 license</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用自定义数据集训练YOLOv3模型。模型和数据集会自动从最新的YOLOv3版本下载。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单GPU训练用法:</span></span><br><span class="line"><span class="string">    $ python train.py --data coco128.yaml --weights yolov5s.pt --img 640  # 从预训练模型开始训练（推荐）</span></span><br><span class="line"><span class="string">    $ python train.py --data coco128.yaml --weights &#x27;&#x27; --cfg yolov5s.yaml --img 640  # 从零开始训练</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多GPU DDP训练用法:</span></span><br><span class="line"><span class="string">    $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 train.py --data coco128.yaml --weights yolov5s.pt --img 640 --device 0,1,2,3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">模型:     https://github.com/ultralytics/yolov5/tree/master/models</span></span><br><span class="line"><span class="string">数据集:   https://github.com/ultralytics/yolov5/tree/master/data</span></span><br><span class="line"><span class="string">教程:   https://docs.ultralytics.com/yolov5/tutorials/train_custom_data</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> comet_ml  <span class="comment"># 必须在torch之前导入（如果已安装）</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    comet_ml = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">FILE = Path(__file__).resolve()</span><br><span class="line">ROOT = FILE.parents[<span class="number">0</span>]  <span class="comment"># YOLOv3根目录</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">str</span>(ROOT) <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.append(<span class="built_in">str</span>(ROOT))  <span class="comment"># 将ROOT添加到PATH</span></span><br><span class="line">ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  <span class="comment"># 相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> val <span class="keyword">as</span> validate  <span class="comment"># 用于epoch结束时的mAP计算</span></span><br><span class="line"><span class="keyword">from</span> models.experimental <span class="keyword">import</span> attempt_load</span><br><span class="line"><span class="keyword">from</span> models.yolo <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> utils.autoanchor <span class="keyword">import</span> check_anchors</span><br><span class="line"><span class="keyword">from</span> utils.autobatch <span class="keyword">import</span> check_train_batch_size</span><br><span class="line"><span class="keyword">from</span> utils.callbacks <span class="keyword">import</span> Callbacks</span><br><span class="line"><span class="keyword">from</span> utils.dataloaders <span class="keyword">import</span> create_dataloader</span><br><span class="line"><span class="keyword">from</span> utils.downloads <span class="keyword">import</span> attempt_download, is_url</span><br><span class="line"><span class="keyword">from</span> utils.general <span class="keyword">import</span> (</span><br><span class="line">    LOGGER,</span><br><span class="line">    TQDM_BAR_FORMAT,</span><br><span class="line">    check_amp,</span><br><span class="line">    check_dataset,</span><br><span class="line">    check_file,</span><br><span class="line">    check_git_info,</span><br><span class="line">    check_git_status,</span><br><span class="line">    check_img_size,</span><br><span class="line">    check_requirements,</span><br><span class="line">    check_suffix,</span><br><span class="line">    check_yaml,</span><br><span class="line">    colorstr,</span><br><span class="line">    get_latest_run,</span><br><span class="line">    increment_path,</span><br><span class="line">    init_seeds,</span><br><span class="line">    intersect_dicts,</span><br><span class="line">    labels_to_class_weights,</span><br><span class="line">    labels_to_image_weights,</span><br><span class="line">    methods,</span><br><span class="line">    one_cycle,</span><br><span class="line">    print_args,</span><br><span class="line">    print_mutation,</span><br><span class="line">    strip_optimizer,</span><br><span class="line">    yaml_save,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> utils.loggers <span class="keyword">import</span> Loggers</span><br><span class="line"><span class="keyword">from</span> utils.loggers.comet.comet_utils <span class="keyword">import</span> check_comet_resume</span><br><span class="line"><span class="keyword">from</span> utils.loss <span class="keyword">import</span> ComputeLoss</span><br><span class="line"><span class="keyword">from</span> utils.metrics <span class="keyword">import</span> fitness</span><br><span class="line"><span class="keyword">from</span> utils.plots <span class="keyword">import</span> plot_evolve</span><br><span class="line"><span class="keyword">from</span> utils.torch_utils <span class="keyword">import</span> (</span><br><span class="line">    EarlyStopping,</span><br><span class="line">    ModelEMA,</span><br><span class="line">    de_parallel,</span><br><span class="line">    select_device,</span><br><span class="line">    smart_DDP,</span><br><span class="line">    smart_optimizer,</span><br><span class="line">    smart_resume,</span><br><span class="line">    torch_distributed_zero_first,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LOCAL_RANK = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;LOCAL_RANK&quot;</span>, -<span class="number">1</span>))  <span class="comment"># https://pytorch.org/docs/stable/elastic/run.html</span></span><br><span class="line">RANK = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;RANK&quot;</span>, -<span class="number">1</span>))</span><br><span class="line">WORLD_SIZE = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;WORLD_SIZE&quot;</span>, <span class="number">1</span>))</span><br><span class="line">GIT_INFO = check_git_info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">hyp, opt, device, callbacks</span>):  <span class="comment"># hyp是路径/to/hyp.yaml或hyp字典</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在自定义数据集上训练YOLOv3模型并管理训练过程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        hyp (str | dict): 超参数yaml文件的路径或超参数字典。</span></span><br><span class="line"><span class="string">        opt (argparse.Namespace): 包含训练选项的解析命令行参数。</span></span><br><span class="line"><span class="string">        device (torch.device): 加载和训练模型的设备。</span></span><br><span class="line"><span class="string">        callbacks (Callbacks): 处理训练生命周期各个阶段的回调函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    单GPU训练用法:</span></span><br><span class="line"><span class="string">        $ python train.py --data coco128.yaml --weights yolov5s.pt --img 640  # 从预训练模型开始训练（推荐）</span></span><br><span class="line"><span class="string">        $ python train.py --data coco128.yaml --weights &#x27;&#x27; --cfg yolov5s.yaml --img 640  # 从零开始训练</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    多GPU DDP训练用法:</span></span><br><span class="line"><span class="string">        $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 train.py --data coco128.yaml --weights</span></span><br><span class="line"><span class="string">            yolov5s.pt --img 640 --device 0,1,2,3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    模型: https://github.com/ultralytics/yolov5/tree/master/models</span></span><br><span class="line"><span class="string">    数据集: https://github.com/ultralytics/yolov5/tree/master/data</span></span><br><span class="line"><span class="string">    教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    示例:</span></span><br><span class="line"><span class="string">        ```python</span></span><br><span class="line"><span class="string">        from ultralytics import train</span></span><br><span class="line"><span class="string">        import argparse</span></span><br><span class="line"><span class="string">        import torch</span></span><br><span class="line"><span class="string">        from utils.callbacks import Callbacks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 示例用法</span></span><br><span class="line"><span class="string">        args = argparse.Namespace(</span></span><br><span class="line"><span class="string">            data=&#x27;coco128.yaml&#x27;,</span></span><br><span class="line"><span class="string">            weights=&#x27;yolov5s.pt&#x27;,</span></span><br><span class="line"><span class="string">            cfg=&#x27;yolov5s.yaml&#x27;,</span></span><br><span class="line"><span class="string">            img_size=640,</span></span><br><span class="line"><span class="string">            epochs=50,</span></span><br><span class="line"><span class="string">            batch_size=16,</span></span><br><span class="line"><span class="string">            device=&#x27;0&#x27;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        device = torch.device(f&#x27;cuda:&#123;args.device&#125;&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)</span></span><br><span class="line"><span class="string">        callbacks = Callbacks()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        train(hyp=&#x27;hyp.scratch.yaml&#x27;, opt=args, device=device, callbacks=callbacks)</span></span><br></pre></td></tr></table></figure><pre><code>&quot;&quot;&quot;save_dir, epochs, batch_size, weights, single_cls, evolve, data, cfg, resume, noval, nosave, workers, freeze = (    Path(opt.save_dir),    opt.epochs,    opt.batch_size,    opt.weights,    opt.single_cls,    opt.evolve,    opt.data,    opt.cfg,    opt.resume,    opt.noval,    opt.nosave,    opt.workers,    opt.freeze,)callbacks.run(&quot;on_pretrain_routine_start&quot;)# 目录w = save_dir / &quot;weights&quot;  # 权重目录(w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # 创建目录last, best = w / &quot;last.pt&quot;, w / &quot;best.pt&quot;# 超参数if isinstance(hyp, str):    with open(hyp, errors=&quot;ignore&quot;) as f:        hyp = yaml.safe_load(f)  # 加载超参数字典LOGGER.info(colorstr(&quot;超参数: &quot;) + &quot;, &quot;.join(f&quot;&#123;k&#125;=&#123;v&#125;&quot; for k, v in hyp.items()))opt.hyp = hyp.copy()  # 保存超参数到检查点# 保存运行设置if not evolve:    yaml_save(save_dir / &quot;hyp.yaml&quot;, hyp)    yaml_save(save_dir / &quot;opt.yaml&quot;, vars(opt))# 日志记录器data_dict = Noneif RANK in &#123;-1, 0&#125;:    loggers = Loggers(save_dir, weights, opt, hyp, LOGGER)  # 日志记录器实例    # 注册动作    for k in methods(loggers):        callbacks.register_action(k, callback=getattr(loggers, k))    # 处理自定义数据集工件链接    data_dict = loggers.remote_dataset    if resume:  # 如果从远程工件恢复运行        weights, epochs, hyp, batch_size = opt.weights, opt.epochs, opt.hyp, opt.batch_size# 配置plots = not evolve and not opt.noplots  # 创建图表cuda = device.type != &quot;cpu&quot;init_seeds(opt.seed + 1 + RANK, deterministic=True)with torch_distributed_zero_first(LOCAL_RANK):    data_dict = data_dict or check_dataset(data)  # 检查是否为Nonetrain_path, val_path = data_dict[&quot;train&quot;], data_dict[&quot;val&quot;]nc = 1 if single_cls else int(data_dict[&quot;nc&quot;])  # 类别数量names = &#123;0: &quot;item&quot;&#125; if single_cls and len(data_dict[&quot;names&quot;]) != 1 else data_dict[&quot;names&quot;]  # 类别名称is_coco = isinstance(val_path, str) and val_path.endswith(&quot;coco/val2017.txt&quot;)  # COCO数据集# 模型check_suffix(weights, &quot;.pt&quot;)  # 检查权重pretrained = weights.endswith(&quot;.pt&quot;)if pretrained:    with torch_distributed_zero_first(LOCAL_RANK):        weights = attempt_download(weights)  # 如果本地没有找到则下载    ckpt = torch.load(weights, map_location=&quot;cpu&quot;)  # 将检查点加载到CPU以避免CUDA内存泄漏    model = Model(cfg or ckpt[&quot;model&quot;].yaml, ch=3, nc=nc, anchors=hyp.get(&quot;anchors&quot;)).to(device)  # 创建模型    exclude = [&quot;anchor&quot;] if (cfg or hyp.get(&quot;anchors&quot;)) and not resume else []  # 排除键    csd = ckpt[&quot;model&quot;].float().state_dict()  # 检查点状态字典为FP32    csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # 交集    model.load_state_dict(csd, strict=False)  # 加载    LOGGER.info(f&quot;从 &#123;weights&#125; 转移了 &#123;len(csd)&#125;/&#123;len(model.state_dict())&#125; 项&quot;)  # 报告else:    model = Model(cfg, ch=3, nc=nc, anchors=hyp.get(&quot;anchors&quot;)).to(device)  # 创建模型amp = check_amp(model)  # 检查AMP# 冻结freeze = [f&quot;model.&#123;x&#125;.&quot; for x in (freeze if len(freeze) &gt; 1 else range(freeze[0]))]  # 冻结的层for k, v in model.named_parameters():    v.requires_grad = True  # 训练所有层    # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN转为0（注释掉以避免训练结果不稳定）    if any(x in k for x in freeze):        LOGGER.info(f&quot;冻结 &#123;k&#125;&quot;)        v.requires_grad = False# 图像大小gs = max(int(model.stride.max()), 32)  # 网格大小（最大步幅）imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # 验证imgsz是gs的倍数# 批量大小if RANK == -1 and batch_size == -1:  # 仅限单GPU，估计最佳批量大小    batch_size = check_train_batch_size(model, imgsz, amp)    loggers.on_params_update(&#123;&quot;batch_size&quot;: batch_size&#125;)# 优化器nbs = 64  # 名义批量大小accumulate = max(round(nbs / batch_size), 1)  # 在优化前累积损失hyp[&quot;weight_decay&quot;] *= batch_size * accumulate / nbs  # 缩放权重衰减optimizer = smart_optimizer(model, opt.optimizer, hyp[&quot;lr0&quot;], hyp[&quot;momentum&quot;], hyp[&quot;weight_decay&quot;])# 学习率调度器if opt.cos_lr:    lf = one_cycle(1, hyp[&quot;lrf&quot;], epochs)  # 余弦 1-&gt;hyp[&#39;lrf&#39;]else:    def lf(x):        &quot;&quot;&quot;线性学习率调度器函数，根据epoch比例计算衰减。&quot;&quot;&quot;        return (1 - x / epochs) * (1.0 - hyp[&quot;lrf&quot;]) + hyp[&quot;lrf&quot;]  # 线性scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)# EMAema = ModelEMA(model) if RANK in &#123;-1, 0&#125; else None# 恢复best_fitness, start_epoch = 0.0, 0if pretrained:    if resume:        best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)    del ckpt, csd# DP模式if cuda and RANK == -1 and torch.cuda.device_count() &gt; 1:    LOGGER.warning(        &quot;警告 ⚠️ 不推荐使用DP模式，建议使用torch.distributed.run以获得最佳DDP多GPU结果。\n&quot;        &quot;请参阅多GPU教程：https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training 以开始使用。&quot;    )    model = torch.nn.DataParallel(model)# SyncBatchNormif opt.sync_bn and cuda and RANK != -1:    model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)    LOGGER.info(&quot;使用 SyncBatchNorm()&quot;)# 训练数据加载器train_loader, dataset = create_dataloader(    train_path,    imgsz,    batch_size // WORLD_SIZE,    gs,    single_cls,    hyp=hyp,    augment=True,    cache=None if opt.cache == &quot;val&quot; else opt.cache,    rect=opt.rect,    rank=LOCAL_RANK,    workers=workers,    image_weights=opt.image_weights,    quad=opt.quad,    prefix=colorstr(&quot;训练: &quot;),    shuffle=True,    seed=opt.seed,)labels = np.concatenate(dataset.labels, 0)mlc = int(labels[:, 0].max())  # 最大标签类别assert mlc &lt; nc, f&quot;标签类别 &#123;mlc&#125; 超过了 &#123;data&#125; 中的 nc=&#123;nc&#125;。可能的类别标签是 0-&#123;nc - 1&#125;&quot;# 进程0if RANK in &#123;-1, 0&#125;:    val_loader = create_dataloader(        val_path,        imgsz,        batch_size // WORLD_SIZE * 2,        gs,        single_cls,        hyp=hyp,        cache=None if noval else opt.cache,        rect=True,        rank=-1,        workers=workers * 2,        pad=0.5,        prefix=colorstr(&quot;验证: &quot;),    )[0]    if not resume:        if not opt.noautoanchor:            check_anchors(dataset, model=model, thr=hyp[&quot;anchor_t&quot;], imgsz=imgsz)  # 运行AutoAnchor        model.half().float()  # 预降低锚点精度    callbacks.run(&quot;on_pretrain_routine_end&quot;, labels, names)# DDP模式if cuda and RANK != -1:    model = smart_DDP(model)# 模型属性nl = de_parallel(model).model[-1].nl  # 检测层数量（用于缩放超参数）hyp[&quot;box&quot;] *= 3 / nl  # 按层缩放hyp[&quot;cls&quot;] *= nc / 80 * 3 / nl  # 按类别和层缩放hyp[&quot;obj&quot;] *= (imgsz / 640) ** 2 * 3 / nl  # 按图像大小和层缩放hyp[&quot;label_smoothing&quot;] = opt.label_smoothingmodel.nc = nc  # 将类别数量附加到模型model.hyp = hyp  # 将超参数附加到模型model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # 将类别权重附加到模型model.names = names# 开始训练t0 = time.time()nb = len(train_loader)  # 批次数量nw = max(round(hyp[&quot;warmup_epochs&quot;] * nb), 100)  # 预热迭代次数，最大（3个epoch，100次迭代）# nw = min(nw, (epochs - start_epoch) / 2 * nb)  # 将预热限制在训练的一半以下last_opt_step = -1maps = np.zeros(nc)  # 每个类别的mAPresults = (0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)scheduler.last_epoch = start_epoch - 1  # 不要移动scaler = torch.cuda.amp.GradScaler(enabled=amp)stopper, stop = EarlyStopping(patience=opt.patience), Falsecompute_loss = ComputeLoss(model)  # 初始化损失类callbacks.run(&quot;on_train_start&quot;)LOGGER.info(    f&#39;图像大小 &#123;imgsz&#125; 训练, &#123;imgsz&#125; 验证\n&#39;    f&#39;使用 &#123;train_loader.num_workers * WORLD_SIZE&#125; 个数据加载器工作进程\n&#39;    f&quot;记录结果到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;\n&quot;    f&#39;开始训练 &#123;epochs&#125; 个epoch...&#39;)for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------    callbacks.run(&quot;on_train_epoch_start&quot;)    model.train()    # 更新图像权重（可选，仅限单GPU）    if opt.image_weights:        cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # 类别权重        iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # 图像权重        dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # 随机加权索引    # 更新马赛克边框（可选）    # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)    # dataset.mosaic_border = [b - imgsz, -b]  # 高度，宽度边框    mloss = torch.zeros(3, device=device)  # 平均损失    if RANK != -1:        train_loader.sampler.set_epoch(epoch)    pbar = enumerate(train_loader)    LOGGER.info((&quot;\n&quot; + &quot;%11s&quot; * 7) % (&quot;Epoch&quot;, &quot;GPU_mem&quot;, &quot;box_loss&quot;, &quot;obj_loss&quot;, &quot;cls_loss&quot;, &quot;Instances&quot;, &quot;Size&quot;))    if RANK in &#123;-1, 0&#125;:        pbar = tqdm(pbar, total=nb, bar_format=TQDM_BAR_FORMAT)  # 进度条    optimizer.zero_grad()    for i, (imgs, targets, paths, _) in pbar:  # batch -------------------------------------------------------------        callbacks.run(&quot;on_train_batch_start&quot;)        ni = i + nb * epoch  # 自训练开始以来的集成批次数量        imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8转为float32，0-255转为0.0-1.0        # 预热        if ni &lt;= nw:            xi = [0, nw]  # x插值            # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou损失比率（obj_loss = 1.0或iou）            accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())            for j, x in enumerate(optimizer.param_groups):                # bias lr从0.1下降到lr0，其他lr从0.0上升到lr0                x[&quot;lr&quot;] = np.interp(ni, xi, [hyp[&quot;warmup_bias_lr&quot;] if j == 0 else 0.0, x[&quot;initial_lr&quot;] * lf(epoch)])                if &quot;momentum&quot; in x:                    x[&quot;momentum&quot;] = np.interp(ni, xi, [hyp[&quot;warmup_momentum&quot;], hyp[&quot;momentum&quot;]])        # 多尺度        if opt.multi_scale:            sz = random.randrange(int(imgsz * 0.5), int(imgsz * 1.5) + gs) // gs * gs  # 大小            sf = sz / max(imgs.shape[2:])  # 缩放因子            if sf != 1:                ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # 新形状（拉伸到gs倍数）                imgs = nn.functional.interpolate(imgs, size=ns, mode=&quot;bilinear&quot;, align_corners=False)        # 前向传播        with torch.cuda.amp.autocast(amp):            pred = model(imgs)  # 前向传播            loss, loss_items = compute_loss(pred, targets.to(device))  # 损失按批量大小缩放            if RANK != -1:                loss *= WORLD_SIZE  # 在DDP模式下梯度在设备间平均            if opt.quad:                loss *= 4.0        # 反向传播        scaler.scale(loss).backward()        # 优化 - https://pytorch.org/docs/master/notes/amp_examples.html        if ni - last_opt_step &gt;= accumulate:            scaler.unscale_(optimizer)  # 取消梯度缩放            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # 梯度裁剪            scaler.step(optimizer)  # 优化器步骤            scaler.update()            optimizer.zero_grad()            if ema:                ema.update(model)            last_opt_step = ni        # 日志        if RANK in &#123;-1, 0&#125;:            mloss = (mloss * i + loss_items) / (i + 1)  # 更新平均损失            mem = f&quot;&#123;torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g&#125;G&quot;  # (GB)            pbar.set_description(                (&quot;%11s&quot; * 2 + &quot;%11.4g&quot; * 5)                % (f&quot;&#123;epoch&#125;/&#123;epochs - 1&#125;&quot;, mem, *mloss, targets.shape[0], imgs.shape[-1])            )            callbacks.run(&quot;on_train_batch_end&quot;, model, ni, imgs, targets, paths, list(mloss))            if callbacks.stop_training:                return        # 结束批次 ------------------------------------------------------------------------------------------------    # 学习率调度器    lr = [x[&quot;lr&quot;] for x in optimizer.param_groups]  # 用于日志记录器    scheduler.step()    if RANK in &#123;-1, 0&#125;:        # mAP        callbacks.run(&quot;on_train_epoch_end&quot;, epoch=epoch)        ema.update_attr(model, include=[&quot;yaml&quot;, &quot;nc&quot;, &quot;hyp&quot;, &quot;names&quot;, &quot;stride&quot;, &quot;class_weights&quot;])        final_epoch = (epoch + 1 == epochs) or stopper.possible_stop        if not noval or final_epoch:  # 计算mAP            results, maps, _ = validate.run(                data_dict,                batch_size=batch_size // WORLD_SIZE * 2,                imgsz=imgsz,                half=amp,                model=ema.ema,                single_cls=single_cls,                dataloader=val_loader,                save_dir=save_dir,                plots=False,                callbacks=callbacks,                compute_loss=compute_loss,            )        # 更新最佳mAP        fi = fitness(np.array(results).reshape(1, -1))  # [P, R, mAP@.5, mAP@.5-.95]的加权组合        stop = stopper(epoch=epoch, fitness=fi)  # 早停检查        if fi &gt; best_fitness:            best_fitness = fi        log_vals = list(mloss) + list(results) + lr        callbacks.run(&quot;on_fit_epoch_end&quot;, log_vals, epoch, best_fitness, fi)        # 保存模型        if (not nosave) or (final_epoch and not evolve):  # 如果保存            ckpt = &#123;                &quot;epoch&quot;: epoch,                &quot;best_fitness&quot;: best_fitness,                &quot;model&quot;: deepcopy(de_parallel(model)).half(),                &quot;ema&quot;: deepcopy(ema.ema).half(),                &quot;updates&quot;: ema.updates,                &quot;optimizer&quot;: optimizer.state_dict(),                &quot;opt&quot;: vars(opt),                &quot;git&quot;: GIT_INFO,  # &#123;remote, branch, commit&#125; 如果是git仓库                &quot;date&quot;: datetime.now().isoformat(),            &#125;            # 保存最后、最佳并删除            torch.save(ckpt, last)            if best_fitness == fi:                torch.save(ckpt, best)            if opt.save_period &gt; 0 and epoch % opt.save_period == 0:                torch.save(ckpt, w / f&quot;epoch&#123;epoch&#125;.pt&quot;)            del ckpt            callbacks.run(&quot;on_model_save&quot;, last, epoch, final_epoch, best_fitness, fi)    # 早停    if RANK != -1:  # 如果是DDP训练        broadcast_list = [stop if RANK == 0 else None]        dist.broadcast_object_list(broadcast_list, 0)  # 将&#39;stop&#39;广播到所有rank        if RANK != 0:            stop = broadcast_list[0]    if stop:        break  # 必须中断所有DDP rank    # 结束epoch ----------------------------------------------------------------------------------------------------# 结束训练 -----------------------------------------------------------------------------------------------------if RANK in &#123;-1, 0&#125;:    LOGGER.info(f&quot;\n&#123;epoch - start_epoch + 1&#125; 个epoch在 &#123;(time.time() - t0) / 3600:.3f&#125; 小时内完成。&quot;)    for f in last, best:        if f.exists():            strip_optimizer(f)  # 去除优化器            if f is best:                LOGGER.info(f&quot;\n验证 &#123;f&#125;...&quot;)                results, _, _ = validate.run(                    data_dict,                    batch_size=batch_size // WORLD_SIZE * 2,                    imgsz=imgsz,                    model=attempt_load(f, device).half(),                    iou_thres=0.65 if is_coco else 0.60,  # 最佳pycocotools在iou 0.65                    single_cls=single_cls,                    dataloader=val_loader,                    save_dir=save_dir,                    save_json=is_coco,                    verbose=True,                    plots=plots,                    callbacks=callbacks,                    compute_loss=compute_loss,                )  # 使用图表验证最佳模型                if is_coco:                    callbacks.run(&quot;on_fit_epoch_end&quot;, list(mloss) + list(results) + lr, epoch, best_fitness, fi)    callbacks.run(&quot;on_train_end&quot;, last, best, epoch, results)torch.cuda.empty_cache()return results</code></pre><p>def parse_opt(known=False):<br>    “””<br>    解析命令行参数以配置YOLO模型的训练。</p><pre><code>参数:    known (bool): 仅解析已知参数的标志，默认为False。返回:    (argparse.Namespace): 解析后的命令行参数。示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">options = parse_opt()</span><br><span class="line"><span class="built_in">print</span>(options.weights)</span><br></pre></td></tr></table></figure>注意:    * 默认权重路径为 &#39;yolov3-tiny.pt&#39;。    * 设置 `known` 为True以仅解析已知参数，适用于部分参数解析。参考:    * 模型: https://github.com/ultralytics/yolov5/tree/master/models    * 数据集: https://github.com/ultralytics/yolov5/tree/master/data    * 训练教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data&quot;&quot;&quot;parser = argparse.ArgumentParser()parser.add_argument(&quot;--weights&quot;, type=str, default=ROOT / &quot;yolov3-tiny.pt&quot;, help=&quot;初始权重路径&quot;)parser.add_argument(&quot;--cfg&quot;, type=str, default=&quot;&quot;, help=&quot;模型yaml路径&quot;)parser.add_argument(&quot;--data&quot;, type=str, default=ROOT / &quot;data/coco128.yaml&quot;, help=&quot;数据集yaml路径&quot;)parser.add_argument(&quot;--hyp&quot;, type=str, default=ROOT / &quot;data/hyps/hyp.scratch-low.yaml&quot;, help=&quot;超参数路径&quot;)parser.add_argument(&quot;--epochs&quot;, type=int, default=100, help=&quot;总训练epoch数&quot;)parser.add_argument(&quot;--batch-size&quot;, type=int, default=16, help=&quot;所有GPU的总批量大小，-1表示自动批量&quot;)parser.add_argument(&quot;--imgsz&quot;, &quot;--img&quot;, &quot;--img-size&quot;, type=int, default=640, help=&quot;训练、验证图像大小（像素）&quot;)parser.add_argument(&quot;--rect&quot;, action=&quot;store_true&quot;, help=&quot;矩形训练&quot;)parser.add_argument(&quot;--resume&quot;, nargs=&quot;?&quot;, const=True, default=False, help=&quot;恢复最近的训练&quot;)parser.add_argument(&quot;--nosave&quot;, action=&quot;store_true&quot;, help=&quot;仅保存最终检查点&quot;)parser.add_argument(&quot;--noval&quot;, action=&quot;store_true&quot;, help=&quot;仅在最终epoch验证&quot;)parser.add_argument(&quot;--noautoanchor&quot;, action=&quot;store_true&quot;, help=&quot;禁用AutoAnchor&quot;)parser.add_argument(&quot;--noplots&quot;, action=&quot;store_true&quot;, help=&quot;不保存任何图表文件&quot;)parser.add_argument(&quot;--evolve&quot;, type=int, nargs=&quot;?&quot;, const=300, help=&quot;超参数进化x代&quot;)parser.add_argument(&quot;--bucket&quot;, type=str, default=&quot;&quot;, help=&quot;gsutil存储桶&quot;)parser.add_argument(&quot;--cache&quot;, type=str, nargs=&quot;?&quot;, const=&quot;ram&quot;, help=&quot;图像缓存 ram/disk&quot;)parser.add_argument(&quot;--image-weights&quot;, action=&quot;store_true&quot;, help=&quot;使用加权图像选择进行训练&quot;)parser.add_argument(&quot;--device&quot;, default=&quot;&quot;, help=&quot;cuda设备，例如 0 或 0,1,2,3 或 cpu&quot;)parser.add_argument(&quot;--multi-scale&quot;, action=&quot;store_true&quot;, help=&quot;图像大小变化 +/- 50%%&quot;)parser.add_argument(&quot;--single-cls&quot;, action=&quot;store_true&quot;, help=&quot;将多类数据训练为单类&quot;)parser.add_argument(&quot;--optimizer&quot;, type=str, choices=[&quot;SGD&quot;, &quot;Adam&quot;, &quot;AdamW&quot;], default=&quot;SGD&quot;, help=&quot;优化器&quot;)parser.add_argument(&quot;--sync-bn&quot;, action=&quot;store_true&quot;, help=&quot;使用SyncBatchNorm，仅在DDP模式下可用&quot;)parser.add_argument(&quot;--workers&quot;, type=int, default=8, help=&quot;最大数据加载器工作进程数（DDP模式下每rank）&quot;)parser.add_argument(&quot;--project&quot;, default=ROOT / &quot;runs/train&quot;, help=&quot;保存到project/name&quot;)parser.add_argument(&quot;--name&quot;, default=&quot;exp&quot;, help=&quot;保存到project/name&quot;)parser.add_argument(&quot;--exist-ok&quot;, action=&quot;store_true&quot;, help=&quot;允许现有project/name，不递增&quot;)parser.add_argument(&quot;--quad&quot;, action=&quot;store_true&quot;, help=&quot;四倍数据加载器&quot;)parser.add_argument(&quot;--cos-lr&quot;, action=&quot;store_true&quot;, help=&quot;余弦学习率调度器&quot;)parser.add_argument(&quot;--label-smoothing&quot;, type=float, default=0.0, help=&quot;标签平滑epsilon&quot;)parser.add_argument(&quot;--patience&quot;, type=int, default=100, help=&quot;早停耐心（无改进的epoch数）&quot;)parser.add_argument(&quot;--freeze&quot;, nargs=&quot;+&quot;, type=int, default=[0], help=&quot;冻结层：backbone=10, first3=0 1 2&quot;)parser.add_argument(&quot;--save-period&quot;, type=int, default=-1, help=&quot;每x个epoch保存检查点（如果小于1则禁用）&quot;)parser.add_argument(&quot;--seed&quot;, type=int, default=0, help=&quot;全局训练种子&quot;)parser.add_argument(&quot;--local_rank&quot;, type=int, default=-1, help=&quot;自动DDP多GPU参数，不要修改&quot;)# 日志记录器参数parser.add_argument(&quot;--entity&quot;, default=None, help=&quot;实体&quot;)parser.add_argument(&quot;--upload_dataset&quot;, nargs=&quot;?&quot;, const=True, default=False, help=&#39;上传数据，&quot;val&quot;选项&#39;)parser.add_argument(&quot;--bbox_interval&quot;, type=int, default=-1, help=&quot;设置边界框图像记录间隔&quot;)parser.add_argument(&quot;--artifact_alias&quot;, type=str, default=&quot;latest&quot;, help=&quot;数据集工件的版本&quot;)return parser.parse_known_args()[0] if known else parser.parse_args()</code></pre><p>def main(opt, callbacks=Callbacks()):<br>    “””<br>    主训练/进化脚本，处理模型检查、DDP设置、训练和超参数进化。</p><pre><code>参数:    opt (argparse.Namespace): 解析后的命令行选项。    callbacks (Callbacks, 可选): 处理训练事件的回调对象。默认为Callbacks()。返回:    None异常:    AssertionError: 如果某些约束被违反（例如，当特定选项与DDP训练不兼容时）。注意:   - 有关使用DDP进行多GPU训练的教程：https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training示例:    单GPU训练:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python train.py --data coco128.yaml --weights yolov5s.pt --img <span class="number">640</span>  <span class="comment"># 从预训练模型开始训练（推荐）</span></span><br><span class="line">$ python train.py --data coco128.yaml --weights <span class="string">&#x27;&#x27;</span> --cfg yolov5s.yaml --img <span class="number">640</span>  <span class="comment"># 从零开始训练</span></span><br></pre></td></tr></table></figure>    多GPU DDP训练:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m torch.distributed.run --nproc_per_node <span class="number">4</span> --master_port <span class="number">1</span> train.py --data coco128.yaml \</span><br><span class="line">--weights yolov5s.pt --img <span class="number">640</span> --device <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>    模型: https://github.com/ultralytics/yolov5/tree/master/models    数据集: https://github.com/ultralytics/yolov5/tree/master/data    教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data&quot;&quot;&quot;if RANK in &#123;-1, 0&#125;:    print_args(vars(opt))    check_git_status()    check_requirements(ROOT / &quot;requirements.txt&quot;)# 恢复（从指定或最近的last.pt）if opt.resume and not check_comet_resume(opt) and not opt.evolve:    last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())    opt_yaml = last.parent.parent / &quot;opt.yaml&quot;  # 训练选项yaml    opt_data = opt.data  # 原始数据集    if opt_yaml.is_file():        with open(opt_yaml, errors=&quot;ignore&quot;) as f:            d = yaml.safe_load(f)    else:        d = torch.load(last, map_location=&quot;cpu&quot;)[&quot;opt&quot;]    opt = argparse.Namespace(**d)  # 替换    opt.cfg, opt.weights, opt.resume = &quot;&quot;, str(last), True  # 恢复    if is_url(opt_data):        opt.data = check_file(opt_data)  # 避免HUB恢复认证超时else:    opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = (        check_file(opt.data),        check_yaml(opt.cfg),        check_yaml(opt.hyp),        str(opt.weights),        str(opt.project),    )  # 检查    assert len(opt.cfg) or len(opt.weights), &quot;必须指定 --cfg 或 --weights&quot;    if opt.evolve:        if opt.project == str(ROOT / &quot;runs/train&quot;):  # 如果默认项目名称，重命名为runs/evolve            opt.project = str(ROOT / &quot;runs/evolve&quot;)        opt.exist_ok, opt.resume = opt.resume, False  # 将resume传递给exist_ok并禁用resume    if opt.name == &quot;cfg&quot;:        opt.name = Path(opt.cfg).stem  # 使用model.yaml作为名称    opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))# DDP模式device = select_device(opt.device, batch_size=opt.batch_size)if LOCAL_RANK != -1:    msg = &quot;与YOLOv3多GPU DDP训练不兼容&quot;    assert not opt.image_weights, f&quot;--image-weights &#123;msg&#125;&quot;    assert not opt.evolve, f&quot;--evolve &#123;msg&#125;&quot;    assert opt.batch_size != -1, f&quot;自动批量 --batch-size -1 &#123;msg&#125;, 请传递有效的 --batch-size&quot;    assert opt.batch_size % WORLD_SIZE == 0, f&quot;--batch-size &#123;opt.batch_size&#125; 必须是 WORLD_SIZE 的倍数&quot;    assert torch.cuda.device_count() &gt; LOCAL_RANK, &quot;DDP命令的CUDA设备不足&quot;    torch.cuda.set_device(LOCAL_RANK)    device = torch.device(&quot;cuda&quot;, LOCAL_RANK)    dist.init_process_group(backend=&quot;nccl&quot; if dist.is_nccl_available() else &quot;gloo&quot;)# 训练if not opt.evolve:    train(opt.hyp, opt, device, callbacks)# 超参数进化（可选）else:    # 超参数进化元数据（突变比例0-1，下限，上限）    meta = &#123;        &quot;lr0&quot;: (1, 1e-5, 1e-1),  # 初始学习率（SGD=1E-2, Adam=1E-3）        &quot;lrf&quot;: (1, 0.01, 1.0),  # 最终OneCycleLR学习率（lr0 * lrf）        &quot;momentum&quot;: (0.3, 0.6, 0.98),  # SGD动量/Adam beta1        &quot;weight_decay&quot;: (1, 0.0, 0.001),  # 优化器权重衰减        &quot;warmup_epochs&quot;: (1, 0.0, 5.0),  # 预热epoch数（可以是小数）        &quot;warmup_momentum&quot;: (1, 0.0, 0.95),  # 预热初始动量        &quot;warmup_bias_lr&quot;: (1, 0.0, 0.2),  # 预热初始偏差学习率        &quot;box&quot;: (1, 0.02, 0.2),  # 框损失增益        &quot;cls&quot;: (1, 0.2, 4.0),  # 类别损失增益        &quot;cls_pw&quot;: (1, 0.5, 2.0),  # 类别BCELoss正样本权重        &quot;obj&quot;: (1, 0.2, 4.0),  # 目标损失增益（按像素缩放）        &quot;obj_pw&quot;: (1, 0.5, 2.0),  # 目标BCELoss正样本权重        &quot;iou_t&quot;: (0, 0.1, 0.7),  # IoU训练阈值        &quot;anchor_t&quot;: (1, 2.0, 8.0),  # 锚点倍数阈值        &quot;anchors&quot;: (2, 2.0, 10.0),  # 每个输出网格的锚点数量（0表示忽略）        &quot;fl_gamma&quot;: (0, 0.0, 2.0),  # 焦点损失gamma（efficientDet默认gamma=1.5）        &quot;hsv_h&quot;: (1, 0.0, 0.1),  # 图像HSV-Hue增强（比例）        &quot;hsv_s&quot;: (1, 0.0, 0.9),  # 图像HSV-Saturation增强（比例）        &quot;hsv_v&quot;: (1, 0.0, 0.9),  # 图像HSV-Value增强（比例）        &quot;degrees&quot;: (1, 0.0, 45.0),  # 图像旋转（+/- 度）        &quot;translate&quot;: (1, 0.0, 0.9),  # 图像平移（+/- 比例）        &quot;scale&quot;: (1, 0.0, 0.9),  # 图像缩放（+/- 增益）        &quot;shear&quot;: (1, 0.0, 10.0),  # 图像剪切（+/- 度）        &quot;perspective&quot;: (0, 0.0, 0.001),  # 图像透视（+/- 比例），范围0-0.001        &quot;flipud&quot;: (1, 0.0, 1.0),  # 图像上下翻转（概率）        &quot;fliplr&quot;: (0, 0.0, 1.0),  # 图像左右翻转（概率）        &quot;mosaic&quot;: (1, 0.0, 1.0),  # 图像马赛克（概率）        &quot;mixup&quot;: (1, 0.0, 1.0),  # 图像混合（概率）        &quot;copy_paste&quot;: (1, 0.0, 1.0),    &#125;  # 分段复制粘贴（概率）    with open(opt.hyp, errors=&quot;ignore&quot;) as f:        hyp = yaml.safe_load(f)  # 加载超参数字典        if &quot;anchors&quot; not in hyp:  # 如果hyp.yaml中注释了anchors            hyp[&quot;anchors&quot;] = 3    if opt.noautoanchor:        del hyp[&quot;anchors&quot;], meta[&quot;anchors&quot;]    opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # 仅在最终epoch验证/保存    # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # 可进化的索引    evolve_yaml, evolve_csv = save_dir / &quot;hyp_evolve.yaml&quot;, save_dir / &quot;evolve.csv&quot;    if opt.bucket:        # 如果存在则下载evolve.csv        subprocess.run(            [                &quot;gsutil&quot;,                &quot;cp&quot;,                f&quot;gs://&#123;opt.bucket&#125;/evolve.csv&quot;,                str(evolve_csv),            ]        )    for _ in range(opt.evolve):  # 进化代数        if evolve_csv.exists():  # 如果evolve.csv存在：选择最佳超参数并突变            # 选择父代            parent = &quot;single&quot;  # 父代选择方法：&#39;single&#39; 或 &#39;weighted&#39;            x = np.loadtxt(evolve_csv, ndmin=2, delimiter=&quot;,&quot;, skiprows=1)            n = min(5, len(x))  # 考虑的前n个结果            x = x[np.argsort(-fitness(x))][:n]  # 前n个突变            w = fitness(x) - fitness(x).min() + 1e-6  # 权重（总和 &gt; 0）            if parent == &quot;single&quot; or len(x) == 1:                # x = x[random.randint(0, n - 1)]  # 随机选择                x = x[random.choices(range(n), weights=w)[0]]  # 加权选择            elif parent == &quot;weighted&quot;:                x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # 加权组合            # 突变            mp, s = 0.8, 0.2  # 突变概率，sigma            npr = np.random            npr.seed(int(time.time()))            g = np.array([meta[k][0] for k in hyp.keys()])  # 增益 0-1            ng = len(meta)            v = np.ones(ng)            while all(v == 1):  # 突变直到发生变化（防止重复）                v = (g * (npr.random(ng) &lt; mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)            for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)                hyp[k] = float(x[i + 7] * v[i])  # 突变        # 限制在范围内        for k, v in meta.items():            hyp[k] = max(hyp[k], v[1])  # 下限            hyp[k] = min(hyp[k], v[2])  # 上限            hyp[k] = round(hyp[k], 5)  # 有效数字        # 训练突变        results = train(hyp.copy(), opt, device, callbacks)        callbacks = Callbacks()        # 写入突变结果        keys = (            &quot;metrics/precision&quot;,            &quot;metrics/recall&quot;,            &quot;metrics/mAP_0.5&quot;,            &quot;metrics/mAP_0.5:0.95&quot;,            &quot;val/box_loss&quot;,            &quot;val/obj_loss&quot;,            &quot;val/cls_loss&quot;,        )        print_mutation(keys, results, hyp.copy(), save_dir, opt.bucket)    # 绘制结果    plot_evolve(evolve_csv)    LOGGER.info(        f&#39;超参数进化完成 &#123;opt.evolve&#125; 代\n&#39;        f&quot;结果保存到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;\n&quot;        f&#39;使用示例: $ python train.py --hyp &#123;evolve_yaml&#125;&#39;    )</code></pre><p>def run(**kwargs):<br>    “””<br>    使用指定配置运行YOLOv3模型的训练过程。</p><pre><code>参数:    data (str): 数据集YAML文件的路径。    weights (str): 预训练权重文件的路径或 &#39;&#39; 表示从零开始训练。    cfg (str): 模型配置文件的路径。    hyp (str): 超参数YAML文件的路径。    epochs (int): 总训练epoch数。    batch_size (int): 所有GPU的总批量大小。    imgsz (int): 训练和验证的图像大小（像素）。    rect (bool): 使用矩形训练以更好地保留宽高比。    resume (bool | str): 如果为True，则恢复最近的训练，如果为字符串，则从特定检查点恢复训练。    nosave (bool): 仅保存最终检查点，不保存中间检查点。    noval (bool): 仅在最终epoch验证模型性能。    noautoanchor (bool): 禁用自动锚点生成。    noplots (bool): 不保存任何图表。    evolve (int): 超参数进化的代数。    bucket (str): 用于保存运行工件的Google Cloud Storage存储桶名称。    cache (str | None): 缓存图像以加快训练速度（&#39;ram&#39; 或 &#39;disk&#39;）。    image_weights (bool): 使用加权图像选择进行训练。    device (str): 用于训练的设备，例如 &#39;0&#39; 表示第一个GPU或 &#39;cpu&#39; 表示CPU。    multi_scale (bool): 使用多尺度训练。    single_cls (bool): 将多类数据集训练为单类。    optimizer (str): 使用的优化器（&#39;SGD&#39;, &#39;Adam&#39;, 或 &#39;AdamW&#39;）。    sync_bn (bool): 使用同步批归一化（仅在DDP模式下可用）。    workers (int): 最大数据加载器工作进程数（DDP模式下每rank）。    project (str): 输出目录的位置。    name (str): 运行的唯一名称。    exist_ok (bool): 允许现有输出目录。    quad (bool): 使用四倍数据加载器。    cos_lr (bool): 使用余弦学习率调度器。    label_smoothing (float): 标签平滑epsilon。    patience (int): 早停耐心（无改进的epoch数）。    freeze (list[int]): 冻结的层列表，例如 [0] 表示仅冻结第一层。    save_period (int): 每 &#39;save_period&#39; 个epoch保存检查点（如果小于1则禁用）。    seed (int): 全局训练种子以确保可重复性。    local_rank (int): 用于自动DDP多GPU参数解析，不要修改。返回:    None示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> run</span><br><span class="line">run(data=<span class="string">&#x27;coco128.yaml&#x27;</span>, weights=<span class="string">&#x27;yolov5m.pt&#x27;</span>, imgsz=<span class="number">320</span>, epochs=<span class="number">100</span>, batch_size=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>注意:    - 确保数据集YAML文件和初始权重可访问。    - 参考 [Ultralytics YOLOv5 仓库](https://github.com/ultralytics/yolov5) 获取模型和数据配置。    - 使用 [训练教程](https://docs.ultralytics.com/yolov5/tutorials/train_custom_data) 进行自定义数据集训练。&quot;&quot;&quot;opt = parse_opt(True)for k, v in kwargs.items():    setattr(opt, k, v)main(opt)return opt</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    opt = parse_opt()<br>    main(opt)<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta"># Ultralytics YOLOv3 🚀, AGPL-3.0 license</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">在图像、视频、目录、通配符、YouTube、网络摄像头、流媒体等上运行 YOLOv3 检测推理。</span><br><span class="line"></span><br><span class="line">用法 - 来源:</span><br><span class="line">    $ python detect.py --weights yolov5s.pt --source <span class="number">0</span>                               <span class="meta"># 网络摄像头</span></span><br><span class="line">                                                     img.jpg                         <span class="meta"># 图像</span></span><br><span class="line">                                                     vid.mp4                         <span class="meta"># 视频</span></span><br><span class="line">                                                     screen                          <span class="meta"># 截图</span></span><br><span class="line">                                                     path/                           <span class="meta"># 目录</span></span><br><span class="line">                                                     list.txt                        <span class="meta"># 图像列表</span></span><br><span class="line">                                                     list.streams                    <span class="meta"># 流媒体列表</span></span><br><span class="line">                                                     &#x27;path/*.jpg&#x27;                    <span class="meta"># 通配符</span></span><br><span class="line">                                                     &#x27;https://youtu.be/LNwODJXcvt4&#x27;  <span class="meta"># YouTube</span></span><br><span class="line">                                                     &#x27;rtsp://example.com/media.mp4&#x27;  <span class="meta"># RTSP, RTMP, HTTP 流</span></span><br><span class="line"></span><br><span class="line">用法 - 格式:</span><br><span class="line">    $ python detect.py --weights yolov5s.pt                 <span class="meta"># PyTorch</span></span><br><span class="line">                                 yolov5s.torchscript        <span class="meta"># TorchScript</span></span><br><span class="line">                                 yolov5s.onnx               <span class="meta"># ONNX Runtime 或 OpenCV DNN with --dnn</span></span><br><span class="line">                                 yolov5s_openvino_model     <span class="meta"># OpenVINO</span></span><br><span class="line">                                 yolov5s.engine             <span class="meta"># TensorRT</span></span><br><span class="line">                                 yolov5s.mlmodel            <span class="meta"># CoreML (macOS-only)</span></span><br><span class="line">                                 yolov5s_saved_model        <span class="meta"># TensorFlow SavedModel</span></span><br><span class="line">                                 yolov5s.pb                 <span class="meta"># TensorFlow GraphDef</span></span><br><span class="line">                                 yolov5s.tflite             <span class="meta"># TensorFlow Lite</span></span><br><span class="line">                                 yolov5s_edgetpu.tflite     <span class="meta"># TensorFlow Edge TPU</span></span><br><span class="line">                                 yolov5s_paddle_model       <span class="meta"># PaddlePaddle</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">import argparse</span><br><span class="line">import os</span><br><span class="line">import platform</span><br><span class="line">import sys</span><br><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line">FILE = Path(__file__).resolve()</span><br><span class="line">ROOT = FILE.parents[<span class="number">0</span>]  <span class="meta"># YOLOv3 根目录</span></span><br><span class="line">if str(ROOT) not in sys.path:</span><br><span class="line">    sys.path.append(str(ROOT))  <span class="meta"># 将 ROOT 添加到 PATH</span></span><br><span class="line">ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  <span class="meta"># 相对路径</span></span><br><span class="line"></span><br><span class="line">from ultralytics.utils.plotting import Annotator, colors, save_one_box</span><br><span class="line"></span><br><span class="line">from models.common import DetectMultiBackend</span><br><span class="line">from utils.dataloaders import IMG_FORMATS, VID_FORMATS, LoadImages, LoadScreenshots, LoadStreams</span><br><span class="line">from utils.general import (</span><br><span class="line">    LOGGER,</span><br><span class="line">    Profile,</span><br><span class="line">    check_file,</span><br><span class="line">    check_img_size,</span><br><span class="line">    check_imshow,</span><br><span class="line">    check_requirements,</span><br><span class="line">    colorstr,</span><br><span class="line">    cv2,</span><br><span class="line">    increment_path,</span><br><span class="line">    non_max_suppression,</span><br><span class="line">    print_args,</span><br><span class="line">    scale_boxes,</span><br><span class="line">    strip_optimizer,</span><br><span class="line">    xyxy2xywh,</span><br><span class="line">)</span><br><span class="line">from utils.torch_utils import select_device, smart_inference_mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@smart_inference_mode()</span><br><span class="line">def run(</span><br><span class="line">    weights=ROOT / <span class="string">&quot;yolov5s.pt&quot;</span>,  <span class="meta"># 模型路径或 Triton URL</span></span><br><span class="line">    source=ROOT / <span class="string">&quot;data/images&quot;</span>,  <span class="meta"># 文件/目录/URL/通配符/截图/0(网络摄像头)</span></span><br><span class="line">    data=ROOT / <span class="string">&quot;data/coco128.yaml&quot;</span>,  <span class="meta"># 数据集.yaml 路径</span></span><br><span class="line">    imgsz=(<span class="number">640</span>, <span class="number">640</span>),  <span class="meta"># 推理尺寸 (高度, 宽度)</span></span><br><span class="line">    conf_thres=<span class="number">0.25</span>,  <span class="meta"># 置信度阈值</span></span><br><span class="line">    iou_thres=<span class="number">0.45</span>,  <span class="meta"># NMS IOU 阈值</span></span><br><span class="line">    max_det=<span class="number">1000</span>,  <span class="meta"># 每张图像的最大检测数</span></span><br><span class="line">    device=<span class="string">&quot;&quot;</span>,  <span class="meta"># CUDA 设备，例如 0 或 0,1,2,3 或 cpu</span></span><br><span class="line">    view_img=False,  <span class="meta"># 显示结果</span></span><br><span class="line">    save_txt=False,  <span class="meta"># 将结果保存到 *.txt</span></span><br><span class="line">    save_conf=False,  <span class="meta"># 在 --save-txt 标签中保存置信度</span></span><br><span class="line">    save_crop=False,  <span class="meta"># 保存裁剪的预测框</span></span><br><span class="line">    nosave=False,  <span class="meta"># 不保存图像/视频</span></span><br><span class="line">    classes=None,  <span class="meta"># 按类别过滤：--class 0 或 --class 0 2 3</span></span><br><span class="line">    agnostic_nms=False,  <span class="meta"># 类别无关的 NMS</span></span><br><span class="line">    augment=False,  <span class="meta"># 增强推理</span></span><br><span class="line">    visualize=False,  <span class="meta"># 可视化特征</span></span><br><span class="line">    update=False,  <span class="meta"># 更新所有模型</span></span><br><span class="line">    project=ROOT / <span class="string">&quot;runs/detect&quot;</span>,  <span class="meta"># 将结果保存到 project/name</span></span><br><span class="line">    name=<span class="string">&quot;exp&quot;</span>,  <span class="meta"># 将结果保存到 project/name</span></span><br><span class="line">    exist_ok=False,  <span class="meta"># 允许现有 project/name，不递增</span></span><br><span class="line">    line_thickness=<span class="number">3</span>,  <span class="meta"># 边界框厚度 (像素)</span></span><br><span class="line">    hide_labels=False,  <span class="meta"># 隐藏标签</span></span><br><span class="line">    hide_conf=False,  <span class="meta"># 隐藏置信度</span></span><br><span class="line">    half=False,  <span class="meta"># 使用 FP16 半精度推理</span></span><br><span class="line">    dnn=False,  <span class="meta"># 使用 OpenCV DNN 进行 ONNX 推理</span></span><br><span class="line">    vid_stride=<span class="number">1</span>,  <span class="meta"># 视频帧率步长</span></span><br><span class="line">):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    在各种输入源（如图像、视频、流媒体、YouTube URL）上运行 YOLOv3 检测推理。</span><br><span class="line"></span><br><span class="line">    参数:</span><br><span class="line">        weights (str <span class="string">| Path): 模型权重文件路径或 Triton URL (默认: &#x27;yolov5s.pt&#x27;)。</span></span><br><span class="line">        source (str <span class="string">| Path): 输入数据源，如文件、目录、URL、通配符模式或设备标识符 (默认: &#x27;data/images&#x27;)。</span></span><br><span class="line">        data (str <span class="string">| Path): 数据集 YAML 文件路径 (默认: &#x27;data/coco128.yaml&#x27;)。</span></span><br><span class="line">        imgsz (tuple[int, int]): 推理尺寸，格式为 (高度, 宽度) (默认: (<span class="number">640</span>, <span class="number">640</span>))。</span><br><span class="line">        conf_thres (float): 检测的置信度阈值 (默认: <span class="number">0.25</span>)。</span><br><span class="line">        iou_thres (float): 非最大抑制 (NMS) 的交并比 (IOU) 阈值 (默认: <span class="number">0.45</span>)。</span><br><span class="line">        max_det (int): 每张图像的最大检测数 (默认: <span class="number">1000</span>)。</span><br><span class="line">        device (str): CUDA 设备标识符，例如 &#x27;0&#x27;, &#x27;0,1,2,3&#x27;, 或 &#x27;cpu&#x27; (默认: &#x27;&#x27;)。</span><br><span class="line">        view_img (bool): 是否在推理过程中显示结果 (默认: False)。</span><br><span class="line">        save_txt (bool): 是否将检测结果保存到文本文件 (默认: False)。</span><br><span class="line">        save_conf (bool): 是否在文本标签中保存检测置信度 (默认: False)。</span><br><span class="line">        save_crop (bool): 是否保存裁剪的检测框 (默认: False)。</span><br><span class="line">        nosave (bool): 是否防止保存带有检测结果的图像或视频 (默认: False)。</span><br><span class="line">        classes (list[int] <span class="string">| None): 按类别索引过滤，例如 [0, 2, 3] (默认: None)。</span></span><br><span class="line">        agnostic_nms (bool): 是否执行类别无关的 NMS (默认: False)。</span><br><span class="line">        augment (bool): 是否应用增强推理 (默认: False)。</span><br><span class="line">        visualize (bool): 是否可视化特征图 (默认: False)。</span><br><span class="line">        update (bool): 是否更新所有模型 (默认: False)。</span><br><span class="line">        project (str <span class="string">| Path): 结果保存的项目目录路径 (默认: &#x27;runs/detect&#x27;)。</span></span><br><span class="line">        name (str): 项目目录中的特定运行名称 (默认: &#x27;exp&#x27;)。</span><br><span class="line">        exist_ok (bool): 是否允许现有 project/name 目录而不递增运行索引 (默认: False)。</span><br><span class="line">        line_thickness (int): 边界框线条的厚度 (像素) (默认: <span class="number">3</span>)。</span><br><span class="line">        hide_labels (bool): 是否在结果中隐藏标签 (默认: False)。</span><br><span class="line">        hide_conf (bool): 是否在结果中隐藏置信度 (默认: False)。</span><br><span class="line">        half (bool): 是否使用半精度 (FP16) 进行推理 (默认: False)。</span><br><span class="line">        dnn (bool): 是否使用 OpenCV DNN 进行 ONNX 推理 (默认: False)。</span><br><span class="line">        vid_stride (int): 视频帧率的步长 (默认: <span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line">    返回:</span><br><span class="line">        None</span><br><span class="line"></span><br><span class="line">    注意:</span><br><span class="line">        该函数支持多种输入源，如图像文件、视频文件、目录、URL 模式、网络摄像头流和 YouTube 链接。它还支持多种模型格式，包括 PyTorch、ONNX、OpenVINO、TensorRT、CoreML、TensorFlow、PaddlePaddle 等。结果可以实时显示或保存到指定目录。使用命令行参数修改函数的行为。</span><br><span class="line"></span><br><span class="line">    示例:</span><br><span class="line">        ```python</span><br><span class="line">        <span class="meta"># 在图像上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;data/images/bus.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># 在视频上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;data/videos/video.mp4&#x27;, view_img=True)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># 在网络摄像头上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;0&#x27;, view_img=True)</span><br></pre></td></tr></table></figure><br>    “””<br>    source = str(source)<br>    save_img = not nosave and not source.endswith(“.txt”)  # 保存推理图像<br>    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)<br>    is_url = source.lower().startswith((“rtsp://“, “rtmp://“, “http://“, “https://“))<br>    webcam = source.isnumeric() or source.endswith(“.streams”) or (is_url and not is_file)<br>    screenshot = source.lower().startswith(“screen”)<br>    if is_url and is_file:<br>        source = check_file(source)  # 下载</p><pre><code># 目录save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # 递增运行(save_dir / &quot;labels&quot; if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # 创建目录# 加载模型device = select_device(device)model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)stride, names, pt = model.stride, model.names, model.ptimgsz = check_img_size(imgsz, s=stride)  # 检查图像尺寸# 数据加载器bs = 1  # 批量大小if webcam:    view_img = check_imshow(warn=True)    dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)    bs = len(dataset)elif screenshot:    dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)else:    dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)vid_path, vid_writer = [None] * bs, [None] * bs# 运行推理model.warmup(imgsz=(1 if pt or model.triton else bs, 3, *imgsz))  # 预热seen, windows, dt = 0, [], (Profile(), Profile(), Profile())for path, im, im0s, vid_cap, s in dataset:    with dt[0]:        im = torch.from_numpy(im).to(model.device)        im = im.half() if model.fp16 else im.float()  # uint8 转换为 fp16/32        im /= 255  # 0 - 255 转换为 0.0 - 1.0        if len(im.shape) == 3:            im = im[None]  # 扩展为批量维度    # 推理    with dt[1]:        visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False        pred = model(im, augment=augment, visualize=visualize)    # NMS    with dt[2]:        pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det)    # 第二阶段分类器 (可选)    # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)    # 处理预测结果    for i, det in enumerate(pred):  # 每张图像        seen += 1        if webcam:  # 批量大小 &gt;= 1            p, im0, frame = path[i], im0s[i].copy(), dataset.count            s += f&quot;&#123;i&#125;: &quot;        else:            p, im0, frame = path, im0s.copy(), getattr(dataset, &quot;frame&quot;, 0)        p = Path(p)  # 转换为 Path        save_path = str(save_dir / p.name)  # im.jpg        txt_path = str(save_dir / &quot;labels&quot; / p.stem) + (&quot;&quot; if dataset.mode == &quot;image&quot; else f&quot;_&#123;frame&#125;&quot;)  # im.txt        s += &quot;&#123;:g&#125;x&#123;:g&#125; &quot;.format(*im.shape[2:])  # 打印字符串        gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # 归一化增益 whwh        imc = im0.copy() if save_crop else im0  # 用于保存裁剪        annotator = Annotator(im0, line_width=line_thickness, example=str(names))        if len(det):            # 将框从 img_size 缩放到 im0 尺寸            det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()            # 打印结果            for c in det[:, 5].unique():                n = (det[:, 5] == c).sum()  # 每个类别的检测数                s += f&quot;&#123;n&#125; &#123;names[int(c)]&#125;&#123;&#39;s&#39; * (n &gt; 1)&#125;, &quot;  # 添加到字符串            # 写入结果            for *xyxy, conf, cls in reversed(det):                if save_txt:  # 写入文件                    xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # 归一化 xywh                    line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # 标签格式                    with open(f&quot;&#123;txt_path&#125;.txt&quot;, &quot;a&quot;) as f:                        f.write((&quot;%g &quot; * len(line)).rstrip() % line + &quot;\n&quot;)                if save_img or save_crop or view_img:  # 添加边界框到图像                    c = int(cls)  # 整数类别                    label = None if hide_labels else (names[c] if hide_conf else f&quot;&#123;names[c]&#125; &#123;conf:.2f&#125;&quot;)                    annotator.box_label(xyxy, label, color=colors(c, True))                if save_crop:                    save_one_box(xyxy, imc, file=save_dir / &quot;crops&quot; / names[c] / f&quot;&#123;p.stem&#125;.jpg&quot;, BGR=True)        # 流式结果        im0 = annotator.result()        if view_img:            if platform.system() == &quot;Linux&quot; and p not in windows:                windows.append(p)                cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # 允许窗口调整大小 (Linux)                cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])            cv2.imshow(str(p), im0)            cv2.waitKey(1)  # 1 毫秒        # 保存结果 (带检测的图像)        if save_img:            if dataset.mode == &quot;image&quot;:                cv2.imwrite(save_path, im0)            else:  # &#39;video&#39; 或 &#39;stream&#39;                if vid_path[i] != save_path:  # 新视频                    vid_path[i] = save_path                    if isinstance(vid_writer[i], cv2.VideoWriter):                        vid_writer[i].release()  # 释放之前的视频写入器                    if vid_cap:  # 视频                        fps = vid_cap.get(cv2.CAP_PROP_FPS)                        w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))                        h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))                    else:  # 流                        fps, w, h = 30, im0.shape[1], im0.shape[0]                    save_path = str(Path(save_path).with_suffix(&quot;.mp4&quot;))  # 强制结果视频为 *.mp4 后缀                    vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*&quot;mp4v&quot;), fps, (w, h))                vid_writer[i].write(im0)    # 打印时间 (仅推理)    LOGGER.info(f&quot;&#123;s&#125;&#123;&#39;&#39; if len(det) else &#39;(no detections), &#39;&#125;&#123;dt[1].dt * 1E3:.1f&#125;ms&quot;)# 打印结果t = tuple(x.t / seen * 1e3 for x in dt)  # 每张图像的速度LOGGER.info(f&quot;Speed: %.1fms 预处理, %.1fms 推理, %.1fms NMS 每张图像 at shape &#123;(1, 3, *imgsz)&#125;&quot; % t)if save_txt or save_img:    s = f&quot;\n&#123;len(list(save_dir.glob(&#39;labels/*.txt&#39;)))&#125; 标签保存到 &#123;save_dir / &#39;labels&#39;&#125;&quot; if save_txt else &quot;&quot;    LOGGER.info(f&quot;结果保存到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;&#123;s&#125;&quot;)if update:    strip_optimizer(weights[0])  # 更新模型 (修复 SourceChangeWarning)</code></pre><p>def parse_opt():<br>    “””<br>    解析并返回用于运行 YOLOv3 模型检测的命令行选项。</p><pre><code>参数:    --weights (list[str]): 模型路径或 Triton URL。默认: ROOT / &quot;yolov3-tiny.pt&quot;。    --source (str): 输入数据源，如文件/目录/URL/通配符/截图/0(网络摄像头)。默认: ROOT / &quot;data/images&quot;。    --data (str): 可选的数据集.yaml 路径。默认: ROOT / &quot;data/coco128.yaml&quot;。    --imgsz (list[int]): 推理尺寸，格式为高度, 宽度。接受多个值。默认: [640]。    --conf-thres (float): 预测的置信度阈值。默认: 0.25。    --iou-thres (float): 非最大抑制 (NMS) 的交并比 (IoU) 阈值。默认: 0.45。    --max-det (int): 每张图像的最大检测数。默认: 1000。    --device (str): CUDA 设备标识符，例如 &quot;0&quot; 或 &quot;0,1,2,3&quot; 或 &quot;cpu&quot;。默认: &quot;&quot; (自动选择)。    --view-img (bool): 显示结果。默认: False。    --save-txt (bool): 将结果保存到 *.txt 文件。默认: False。    --save-conf (bool): 在文本标签中保存置信度分数。默认: False。    --save-crop (bool): 保存裁剪的预测框。默认: False。    --nosave (bool): 不保存带有检测结果的图像/视频。默认: False。    --classes (list[int] | None): 按类别过滤结果，例如 [0, 2, 3]。默认: None。    --agnostic-nms (bool): 执行类别无关的 NMS。默认: False。    --augment (bool): 应用增强推理。默认: False。    --visualize (bool): 可视化特征图。默认: False。    --update (bool): 更新所有模型。默认: False。    --project (str): 保存结果的目录；结果保存到 &quot;project/name&quot;。默认: ROOT / &quot;runs/detect&quot;。    --name (str): 特定运行的名称；结果保存到 &quot;project/name&quot;。默认: &quot;exp&quot;。    --exist-ok (bool): 允许结果保存到现有目录而不递增。默认: False。    --line-thickness (int): 边界框线条的厚度 (像素)。默认: 3。    --hide-labels (bool): 隐藏检测结果中的标签。默认: False。    --hide-conf (bool): 隐藏标签中的置信度分数。默认: False。    --half (bool): 使用 FP16 半精度推理。默认: False。    --dnn (bool): 使用 OpenCV DNN 后端进行 ONNX 推理。默认: False。    --vid-stride (int): 视频输入的帧率步长。默认: 1。返回:    argparse.Namespace: 解析的命令行参数，用于 YOLOv3 推理配置。示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">options = parse_opt()</span><br><span class="line">run(**<span class="built_in">vars</span>(options))</span><br></pre></td></tr></table></figure>&quot;&quot;&quot;parser = argparse.ArgumentParser()parser.add_argument(    &quot;--weights&quot;, nargs=&quot;+&quot;, type=str, default=ROOT / &quot;yolov3-tiny.pt&quot;, help=&quot;模型路径或 triton URL&quot;)parser.add_argument(&quot;--source&quot;, type=str, default=ROOT / &quot;data/images&quot;, help=&quot;文件/目录/URL/通配符/截图/0(网络摄像头)&quot;)parser.add_argument(&quot;--data&quot;, type=str, default=ROOT / &quot;data/coco128.yaml&quot;, help=&quot;(可选) 数据集.yaml 路径&quot;)parser.add_argument(&quot;--imgsz&quot;, &quot;--img&quot;, &quot;--img-size&quot;, nargs=&quot;+&quot;, type=int, default=[640], help=&quot;推理尺寸 h,w&quot;)parser.add_argument(&quot;--conf-thres&quot;, type=float, default=0.25, help=&quot;置信度阈值&quot;)parser.add_argument(&quot;--iou-thres&quot;, type=float, default=0.45, help=&quot;NMS IoU 阈值&quot;)parser.add_argument(&quot;--max-det&quot;, type=int, default=1000, help=&quot;每张图像的最大检测数&quot;)parser.add_argument(&quot;--device&quot;, default=&quot;&quot;, help=&quot;cuda 设备，例如 0 或 0,1,2,3 或 cpu&quot;)parser.add_argument(&quot;--view-img&quot;, action=&quot;store_true&quot;, help=&quot;显示结果&quot;)parser.add_argument(&quot;--save-txt&quot;, action=&quot;store_true&quot;, help=&quot;将结果保存到 *.txt&quot;)parser.add_argument(&quot;--save-conf&quot;, action=&quot;store_true&quot;, help=&quot;在 --save-txt 标签中保存置信度&quot;)parser.add_argument(&quot;--save-crop&quot;, action=&quot;store_true&quot;, help=&quot;保存裁剪的预测框&quot;)parser.add_argument(&quot;--nosave&quot;, action=&quot;store_true&quot;, help=&quot;不保存图像/视频&quot;)parser.add_argument(&quot;--classes&quot;, nargs=&quot;+&quot;, type=int, help=&quot;按类别过滤：--classes 0 或 --classes 0 2 3&quot;)parser.add_argument(&quot;--agnostic-nms&quot;, action=&quot;store_true&quot;, help=&quot;类别无关的 NMS&quot;)parser.add_argument(&quot;--augment&quot;, action=&quot;store_true&quot;, help=&quot;增强推理&quot;)parser.add_argument(&quot;--visualize&quot;, action=&quot;store_true&quot;, help=&quot;可视化特征&quot;)parser.add_argument(&quot;--update&quot;, action=&quot;store_true&quot;, help=&quot;更新所有模型&quot;)parser.add_argument(&quot;--project&quot;, default=ROOT / &quot;runs/detect&quot;, help=&quot;将结果保存到 project/name&quot;)parser.add_argument(&quot;--name&quot;, default=&quot;exp&quot;, help=&quot;将结果保存到 project/name&quot;)parser.add_argument(&quot;--exist-ok&quot;, action=&quot;store_true&quot;, help=&quot;允许现有 project/name 目录而不递增&quot;)parser.add_argument(&quot;--line-thickness&quot;, default=3, type=int, help=&quot;边界框厚度 (像素)&quot;)parser.add_argument(&quot;--hide-labels&quot;, default=False, action=&quot;store_true&quot;, help=&quot;隐藏标签&quot;)parser.add_argument(&quot;--hide-conf&quot;, default=False, action=&quot;store_true&quot;, help=&quot;隐藏置信度&quot;)parser.add_argument(&quot;--half&quot;, action=&quot;store_true&quot;, help=&quot;使用 FP16 半精度推理&quot;)parser.add_argument(&quot;--dnn&quot;, action=&quot;store_true&quot;, help=&quot;使用 OpenCV DNN 进行 ONNX 推理&quot;)parser.add_argument(&quot;--vid-stride&quot;, type=int, default=1, help=&quot;视频帧率步长&quot;)opt = parser.parse_args()opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # 扩展print_args(vars(opt))return opt</code></pre><p>def main(opt):<br>    “””<br>    运行 YOLO 模型的入口点；检查需求并使用解析的选项调用 <code>run</code>。</p><pre><code>参数:    opt (argparse.Namespace): 解析的命令行选项，包括：        - weights (str | list of str): 模型权重路径或 Triton 服务器 URL。        - source (str): 输入源，可以是文件、目录、URL、通配符、截图或网络摄像头索引。        - data (str): 数据集配置文件路径 (.yaml)。        - imgsz (tuple of int): 推理图像尺寸，格式为 (高度, 宽度)。        - conf_thres (float): 检测的置信度阈值。        - iou_thres (float): 非最大抑制 (NMS) 的交并比 (IoU) 阈值。        - max_det (int): 每张图像的最大检测数。        - device (str): 运行推理的设备；选项为 CUDA 设备 id(s) 或 &#39;cpu&#39;。        - view_img (bool): 显示推理结果的标志。        - save_txt (bool): 将检测结果保存为 .txt 格式。        - save_conf (bool): 在 .txt 标签中保存检测置信度。        - save_crop (bool): 保存裁剪的边界框预测。        - nosave (bool): 不保存带有检测结果的图像/视频。        - classes (list of int): 按类别过滤结果，例如 --class 0 2 3。        - agnostic_nms (bool): 使用类别无关的 NMS。        - augment (bool): 启用增强推理。        - visualize (bool): 可视化特征图。        - update (bool): 在推理过程中更新模型。        - project (str): 保存结果的目录。        - name (str): 结果目录的名称。        - exist_ok (bool): 允许现有 project/name 目录而不递增。        - line_thickness (int): 边界框线条的厚度。        - hide_labels (bool): 在边界框上隐藏类别标签。        - hide_conf (bool): 在边界框上隐藏置信度分数。        - half (bool): 使用 FP16 半精度推理。        - dnn (bool): 使用 OpenCV DNN 后端进行 ONNX 推理。        - vid_stride (int): 视频帧率步长。返回:    None示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    opt = parse_opt()</span><br><span class="line">    main(opt)</span><br></pre></td></tr></table></figure>注意:    将此函数作为使用 YOLO 进行对象检测的入口点，支持多种输入源，如图像、视频、目录、网络摄像头、流媒体等。该函数确保检查所有需求，并通过调用 `run` 函数启动检测过程。&quot;&quot;&quot;check_requirements(ROOT / &quot;requirements.txt&quot;, exclude=(&quot;tensorboard&quot;, &quot;thop&quot;))run(**vars(opt))</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    opt = parse_opt()<br>    main(opt)<br>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;鉴于yolov3对于目标识别界的重大开创性，跳过1、2两个版本直接学习yolov3，同时也作为后续版本的基石入门。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;主要原理&quot;&gt;&lt;a href=&quot;#主要原理&quot; class=&quot;headerlink&quot; title=&quot;主要原理&quot;&gt;&lt;/a&gt;主要原理</summary>
      
    
    
    
    <category term="RoboMaster" scheme="http://zuweicun.top/categories/RoboMaster/"/>
    
    <category term="计算机视觉" scheme="http://zuweicun.top/categories/RoboMaster/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="YOLO 目标识别" scheme="http://zuweicun.top/tags/YOLO-%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>近世代数</title>
    <link href="http://zuweicun.top/2024/11/16/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0/"/>
    <id>http://zuweicun.top/2024/11/16/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0/</id>
    <published>2024-11-16T13:30:20.000Z</published>
    <updated>2025-04-10T15:15:25.138Z</updated>
    
    <content type="html"><![CDATA[<p><img src="第 1 页.png" alt=""><br><img src="第 2 页.png" alt=""><br><img src="第 3 页.png" alt=""><br><img src="第 4 页.png" alt=""><br><img src="第 5 页.png" alt=""><br><img src="第 6 页.png" alt=""><br><img src="第 7 页.png" alt=""><br><img src="第 8 页.png" alt=""><br><img src="第 9 页.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;第 1 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;第 2 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;第 3 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;第 4 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=</summary>
      
    
    
    
    <category term="数学基础" scheme="http://zuweicun.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="近世代数" scheme="http://zuweicun.top/tags/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>vim从入门到入土</title>
    <link href="http://zuweicun.top/2024/10/15/vim%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>http://zuweicun.top/2024/10/15/vim%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2024-10-15T12:31:14.000Z</published>
    <updated>2025-04-10T15:15:25.127Z</updated>
    
    <content type="html"><![CDATA[<p>首先声明我的vscode坚定拥护者身份，奈何十年老古董实在带不动，不得不重新捡起vim开始朴素（装逼）生活。<br><span id="more"></span></p><h2 id="1-什么是-Vim？"><a href="#1-什么是-Vim？" class="headerlink" title="1. 什么是 Vim？"></a>1. 什么是 Vim？</h2><p>Vim 是一个强大的文本编辑器，基于经典的 vi 编辑器。它的核心设计理念是高效编辑文本，特别适合程序员和技术用户 <strong>(高逼格用户)</strong>。</p><p>与大多数文本编辑器不同，Vim 的操作基于模式切换，它拥有多个操作模式，使你能够在插入、编辑、命令等操作之间快速切换。</p><p><strong><em>Vim vs Vi：Vim 是 vi 的增强版，提供了更多的功能，如多级撤销、语法高亮、扩展的脚本支持等。</em></strong></p><h2 id="2-Vim-的主要模式"><a href="#2-Vim-的主要模式" class="headerlink" title="2. Vim 的主要模式"></a>2. Vim 的主要模式</h2><p>Vim 的操作基于不同的模式，主要有以下几种模式：<br><strong>1.普通模式 (Normal Mode)：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">默认进入的模式，用于导航和操作文本。</span><br><span class="line">进入方式：启动 Vim 后默认进入，或按 Esc 回到普通模式。</span><br><span class="line">常用命令：</span><br><span class="line">h：向左移动光标。</span><br><span class="line">j：向下移动光标。</span><br><span class="line">k：向上移动光标。</span><br><span class="line">l：向右移动光标。</span><br><span class="line"><span class="selector-tag">dd</span>：删除当前行。</span><br><span class="line">yy：复制当前行。</span><br><span class="line"><span class="selector-tag">p</span>：在光标之后粘贴。</span><br></pre></td></tr></table></figure><br><strong>2.插入模式 (Insert Mode)：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于编辑文本，类似于普通文本编辑器的输入状态。</span><br><span class="line">进入方式：按 <span class="selector-tag">i</span> 或 <span class="selector-tag">a</span> 进入。</span><br><span class="line">退出方式：按 Esc 退出插入模式，回到普通模式。</span><br></pre></td></tr></table></figure><br><strong>3.可视模式 (Visual Mode)：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用于选择文本块。</span><br><span class="line">进入方式：按 v 进入。</span><br><span class="line">常用操作：</span><br><span class="line">y：复制选中的文本。</span><br><span class="line">d：删除选中的文本。</span><br><span class="line"><span class="selector-tag">p</span>：粘贴选中的文本。</span><br></pre></td></tr></table></figure><p><strong>4.命令行模式 (Command-Line Mode)：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用于执行命令，如保存、退出、查找等。</span><br><span class="line">进入方式：按 : 进入。</span><br><span class="line">常用命令：</span><br><span class="line"><span class="symbol">:w</span>：保存文件。</span><br><span class="line"><span class="symbol">:q</span>：退出文件。</span><br><span class="line"><span class="symbol">:wq</span>：保存并退出。</span><br><span class="line"><span class="symbol">:q!</span>：强制退出（不保存修改）。</span><br></pre></td></tr></table></figure><h2 id="3-基本操作指南"><a href="#3-基本操作指南" class="headerlink" title="3. 基本操作指南"></a>3. 基本操作指南</h2><h3 id="3-1-移动光标"><a href="#3-1-移动光标" class="headerlink" title="3.1 移动光标"></a>3.1 移动光标</h3><p>Vim 的基本光标移动是基于 h、j、k、l 四个键，可以用来代替方向键。此外，Vim 提供了更多强大的导航功能：</p><pre><code>w：跳转到下一个单词的开头。b：跳转到上一个单词的开头。gg：跳转到文件开头。G：跳转到文件末尾。Ctrl + f：向下翻页。Ctrl + b：向上翻页。</code></pre><h3 id="3-2-插入和编辑文本"><a href="#3-2-插入和编辑文本" class="headerlink" title="3.2 插入和编辑文本"></a>3.2 插入和编辑文本</h3><p>在普通模式下，通过按以下键进入插入模式以编辑文本：</p><pre><code>i：在光标前插入文本。I：在当前行的行首插入文本。a：在光标后插入文本。A：在当前行的行尾插入文本。o：在光标下方新建一行并插入。O：在光标上方新建一行并插入。</code></pre><h3 id="3-3-删除文本"><a href="#3-3-删除文本" class="headerlink" title="3.3 删除文本"></a>3.3 删除文本</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x：删除光标所在的字符。</span><br><span class="line"><span class="built_in">dd</span>：删除当前行。</span><br><span class="line">d + 移动命令：根据移动命令删除内容，例如 <span class="built_in">dw</span> 删除到下一个单词开头，d$ 删除到行尾。</span><br></pre></td></tr></table></figure><h3 id="3-4-复制和粘贴"><a href="#3-4-复制和粘贴" class="headerlink" title="3.4 复制和粘贴"></a>3.4 复制和粘贴</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yy：复制当前行。</span><br><span class="line">y + 移动命令：复制指定范围的内容，例如 yw 复制到下一个单词开头。</span><br><span class="line"><span class="selector-tag">p</span>：在光标后粘贴内容。</span><br><span class="line"><span class="selector-tag">P</span>：在光标前粘贴内容。</span><br></pre></td></tr></table></figure><h3 id="3-5-撤销和重做"><a href="#3-5-撤销和重做" class="headerlink" title="3.5 撤销和重做"></a>3.5 撤销和重做</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u：撤销上一步操作。</span><br><span class="line">Ctrl + <span class="built_in">r</span>：重做撤销的操作。</span><br></pre></td></tr></table></figure><h2 id="4-Vim-高级操作"><a href="#4-Vim-高级操作" class="headerlink" title="4. Vim 高级操作"></a>4. Vim 高级操作</h2><h3 id="4-1-查找和替换"><a href="#4-1-查找和替换" class="headerlink" title="4.1 查找和替换"></a>4.1 查找和替换</h3><p>Vim 提供了强大的查找和替换功能：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/pattern：向前查找 pattern。</span><br><span class="line"><span class="string">?p</span>attern：向后查找 pattern。</span><br><span class="line">n：跳转到下一个匹配项。</span><br><span class="line">N：跳转到上一个匹配项。</span><br><span class="line"><span class="symbol">:s/old/new/g</span>：将当前行中的 old 替换为 new。</span><br><span class="line"><span class="symbol">:%s/old/new/g</span>：将整个文件中的 old 替换为 new。</span><br></pre></td></tr></table></figure></p><h3 id="4-2-多文件和窗口操作"><a href="#4-2-多文件和窗口操作" class="headerlink" title="4.2 多文件和窗口操作"></a>4.2 多文件和窗口操作</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:e</span> filename：打开一个新文件。</span><br><span class="line"><span class="symbol">:vsp</span> filename：垂直分屏打开文件。</span><br><span class="line"><span class="symbol">:sp</span> filename：水平分屏打开文件。</span><br><span class="line"><span class="title class_">Ctrl</span> + w + h/j/k/l：在不同窗口间切换。</span><br></pre></td></tr></table></figure><h3 id="4-3-宏录制与回放"><a href="#4-3-宏录制与回放" class="headerlink" title="4.3 宏录制与回放"></a>4.3 宏录制与回放</h3><p>Vim 支持录制操作的宏，可以将常用操作记录下来并反复执行：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">q</span> + 字母：开始录制宏到指定的字母键（如 <span class="selector-tag">q</span> <span class="selector-tag">a</span> 开始录制到 <span class="selector-tag">a</span>）。</span><br><span class="line">执行所需操作。</span><br><span class="line"><span class="selector-tag">q</span>：停止录制。</span><br><span class="line">@<span class="selector-tag">a</span>：回放录制的宏 <span class="selector-tag">a</span>。</span><br></pre></td></tr></table></figure></p><h2 id="5-Vim-的配置"><a href="#5-Vim-的配置" class="headerlink" title="5. Vim 的配置"></a>5. Vim 的配置</h2><p>Vim 可以通过编辑 .vimrc 文件进行自定义，这个文件通常位于用户的主目录下。通过编辑 .vimrc，你可以为 Vim 添加一些个性化的配置，以提高编辑效率。以下是一些常用配置选项：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>        <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>     <span class="comment">&quot; 设置 Tab 键宽度为 4 个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>  <span class="comment">&quot; 设置自动缩进为 4 个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab     <span class="comment">&quot; 将 Tab 转换为空格</span></span><br><span class="line"><span class="keyword">set</span> cursorline    <span class="comment">&quot; 高亮当前行</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>         <span class="comment">&quot; 启用语法高亮</span></span><br><span class="line"><span class="keyword">set</span> relativenumber <span class="comment">&quot; 显示相对行号</span></span><br></pre></td></tr></table></figure></p><h2 id="6-常用-Vim-插件"><a href="#6-常用-Vim-插件" class="headerlink" title="6. 常用 Vim 插件"></a>6. 常用 Vim 插件</h2><p>Vim 的强大之处还在于其插件支持，可以通过插件扩展其功能。以下是一些常用的 Vim 插件：</p><ol><li>NerdTree：文件浏览器插件，允许你在 Vim 中以树状结构浏览文件。</li><li>Vim-Airline：美化状态栏，提供更丰富的状态信息。</li><li>Fzf：强大的文件搜索工具，能够快速定位和打开文件。</li><li>YouCompleteMe：代码自动补全插件，支持多种编程语言的补全。</li><li>Syntastic：语法检查工具，能够帮助你及时发现代码中的错误。</li></ol><p>可以通过 Vim 的插件管理工具（如 Vundle 或 Pathogen）来安装和管理这些插件。</p><h2 id="7-如何退出-Vim"><a href="#7-如何退出-Vim" class="headerlink" title="7. 如何退出 Vim"></a>7. 如何退出 Vim</h2><p>退出 Vim 是初学者经常遇到的问题。以下是几种退出方式：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:q</span>：退出（无修改时）。</span><br><span class="line"><span class="symbol">:wq</span> 或 <span class="title class_">ZZ</span>：保存并退出。</span><br><span class="line"><span class="symbol">:q!</span>：强制退出（不保存修改）。</span><br><span class="line"><span class="symbol">:wq!</span>：强制保存并退出。</span><br></pre></td></tr></table></figure></p><p>掌握了这些内容基本就足够在服务器终端上大展身手了，网上有很多大佬开发了各种各样的vim插件（说实话vim的最终解就是vscode），以后可能会继续更新这些插件配置相关内容</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先声明我的vscode坚定拥护者身份，奈何十年老古董实在带不动，不得不重新捡起vim开始朴素（装逼）生活。&lt;br&gt;</summary>
    
    
    
    <category term="工具" scheme="http://zuweicun.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vim" scheme="http://zuweicun.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>nth_element函数深入</title>
    <link href="http://zuweicun.top/2024/10/02/nth-element%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/"/>
    <id>http://zuweicun.top/2024/10/02/nth-element%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</id>
    <published>2024-10-02T14:48:02.000Z</published>
    <updated>2025-04-10T15:15:25.126Z</updated>
    
    <content type="html"><![CDATA[<p><code>nth_element</code> 是 C++ 标准模板库 (STL) 中的一个非常有用的算法，它的功能是对范围内的元素进行部分排序，使得第 <code>n</code> 小的元素排到指定位置，其前面的元素都小于等于它，后面的元素都大于等于它，但前后的元素不一定是完全排序的。</p><p><code>nth_element</code> 算法基于<a href="http://zuweicun.top/2024/10/02/快排/">快速排序</a>，时间复杂度在平均情况下是 O(n)，最坏情况是 O(n^2)，但通过随机化选取枢轴可以避免最坏情况的频繁发生。</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>first</code>: 范围的起始迭代器。</li><li><code>nth</code>: 指定要找到的第 n 小元素的迭代器。</li><li><code>last</code>: 范围的结束迭代器（不包括 <code>last</code> 指向的元素）。</li><li><code>comp</code>: 可选的自定义比较器，用于自定义排序规则。</li></ul><h3 id="nth-element-的核心特点"><a href="#nth-element-的核心特点" class="headerlink" title="nth_element 的核心特点"></a><code>nth_element</code> 的核心特点</h3><ul><li>部分排序：<code>nth_element</code> 不会对整个数组进行完全排序，而只会确保第 <code>n</code> 小的元素排到第 <code>n</code> 位。</li><li>前后区间无序：在 <code>nth_element</code> 之后，<code>[first, nth)</code> 中的元素只会比 <code>*nth</code> 小，<code>[nth+1, last)</code> 中的元素比 <code>*nth</code> 大，但这些子区间并不会是有序的。</li></ul><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第5小的元素，并确保它位于vec[4]</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">4</span>, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第5小的元素是：&quot;</span> &lt;&lt; vec[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前面的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">begin</span>() + <span class="number">4</span>; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后面的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>() + <span class="number">5</span>; it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第5小的元素是：5</span><br><span class="line">前面的元素：1<span class="number"> 2 </span>4<span class="number"> 3 </span></span><br><span class="line">后面的元素：10<span class="number"> 7 </span>9<span class="number"> 8 </span>6 </span><br></pre></td></tr></table></figure></p><p>在这个示例中，<code>nth_element</code> 保证 <code>vec[4]</code> 是第 5 小的元素（因为从 0 开始计数），并且前 4 个元素小于等于 5，后面的元素大于等于 5，但前后部分的元素是无序的。</p><h3 id="nth-element-的应用场景"><a href="#nth-element-的应用场景" class="headerlink" title="nth_element 的应用场景"></a><code>nth_element</code> 的应用场景</h3><ol><li><strong>Top K 问题</strong>：你可以用 <code>nth_element</code> 来高效找到数组中前 K 大（或前 K 小）元素，而不需要对整个数组排序。</li><li><strong>中位数查找</strong>：用 <code>nth_element</code> 可以高效找到无序数组中的中位数，避免排序的 O(n log n) 时间开销。</li><li><strong>数据过滤</strong>：可以用 <code>nth_element</code> 来过滤掉过大或过小的元素，只保留前面或后面的一部分。</li></ol><h3 id="nth-element-与完整排序的对比"><a href="#nth-element-与完整排序的对比" class="headerlink" title="nth_element 与完整排序的对比"></a><code>nth_element</code> 与完整排序的对比</h3><p>相比 <code>std::sort</code> 或 <code>std::partial_sort</code>，<code>nth_element</code> 只确保第 <code>n</code> 小的元素在正确位置，并且左右部分并不保证是有序的。这使得它在需要部分排序的场景下更加高效。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>nth_element</code> 实际上是基于快速选择 (Quickselect) 算法的变种。它采用与快速排序类似的分区策略，只不过在每次分区后，它仅处理包含第 <code>n</code> 小元素的那一部分。这使得它比对整个数组进行完全排序更快。</p><ol><li>选取一个枢轴元素，并将比它小的元素放到左边，大的放到右边。</li><li>如果 <code>n</code> 恰好是枢轴的位置，则排序结束。</li><li>如果 <code>n</code> 小于枢轴的位置，则递归处理左半部分；如果 <code>n</code> 大于枢轴的位置，则递归处理右半部分。</li></ol><h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><p>可以通过自定义比较器改变 <code>nth_element</code> 的排序规则。例如，按照降序排列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义比较器：从大到小排序</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">4</span>, vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第5大的元素是：&quot;</span> &lt;&lt; vec[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;nth_element&lt;/code&gt; 是 C++ 标准模板库 (STL) 中的一个非常有用的算法，它的功能是对范围内的元素进行部分排序，使得第 &lt;code&gt;n&lt;/code&gt; 小的元素排到指定位置，其前面的元素都小于等于它，后面的元素都大于等于它，但前后的元素不一</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://zuweicun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="STL" scheme="http://zuweicun.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>快排</title>
    <link href="http://zuweicun.top/2024/10/02/%E5%BF%AB%E6%8E%92/"/>
    <id>http://zuweicun.top/2024/10/02/%E5%BF%AB%E6%8E%92/</id>
    <published>2024-10-02T13:54:45.000Z</published>
    <updated>2025-04-10T15:15:25.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速排序（Quick-Sort）的C-实现"><a href="#快速排序（Quick-Sort）的C-实现" class="headerlink" title="快速排序（Quick Sort）的C++实现"></a>快速排序（Quick Sort）的C++实现</h3><h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h4><p>快速排序是一种基于 <strong>分治法</strong> 的高效排序算法。通过选择一个“基准”（pivot），快速排序将序列分成两个子序列，分别递归地进行排序。在平均情况下，时间复杂度为 ( O(n \log n) )，且具有较小的常数因子，在实际中通常比其他排序算法更快。</p><h4 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h4><ol><li><strong>选择基准值（Pivot）</strong>: 通常选择序列中的第一个元素或中间元素作为基准值。</li><li><strong>分区（Partitioning）</strong>: 将序列中的元素按照基准值划分成两部分：左侧部分小于基准值，右侧部分大于基准值。</li><li><strong>递归调用</strong>: 对左侧和右侧的子序列分别进行快速排序。</li><li><strong>结束条件</strong>: 当子序列的长度为1或0时，不再递归。</li></ol><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><h5 id="标准的递归实现："><a href="#标准的递归实现：" class="headerlink" title="标准的递归实现："></a>标准的递归实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，返回基准值的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];  <span class="comment">// 基准值</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];  <span class="comment">// 将小于基准值的元素移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左向右找大于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];  <span class="comment">// 将大于基准值的元素移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;  <span class="comment">// 基准值归位</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回基准值的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 划分序列</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pivotIndex - <span class="number">1</span>);  <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, high);  <span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">29</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-细节分析"><a href="#4-细节分析" class="headerlink" title="4. 细节分析"></a>4. 细节分析</h4><ol><li><p><strong>选择基准值</strong>: 代码中选择了第一个元素作为基准值 <code>pivot</code>，在某些情况下（如已排序的数组）会导致最坏的时间复杂度 ( O(n^2) )。通过随机选择基准值或选择中间元素，可以提高算法在特定输入下的效率。</p></li><li><p><strong>分区过程</strong>: </p><ul><li>从右向左找第一个小于基准值的元素，放在左侧；</li><li>从左向右找第一个大于基准值的元素，放在右侧；</li><li>这个过程不断交替进行，直到左右两侧交叉，最后将基准值归位。</li></ul></li><li><p><strong>递归调用</strong>: 快速排序通过递归实现对左右两个子序列的排序。由于每次递归调用的数组长度缩小，因此在平均情况下递归深度为 ( \log n )。</p></li><li><p><strong>时间复杂度</strong>:</p><ul><li><strong>最优时间复杂度</strong>: 当每次划分都非常均匀时，递归深度为 ( \log n )，每次分区的代价为 ( O(n) )，因此时间复杂度为 ( O(n \log n) )。</li><li><strong>最坏时间复杂度</strong>: 当数组已经有序或接近有序时，每次划分都导致极端不平衡的分区，递归深度为 ( O(n) )，时间复杂度为 ( O(n^2) )。</li></ul></li><li><p><strong>空间复杂度</strong>: 快速排序是 <strong>原地排序</strong> 算法，因此空间复杂度仅为递归调用时的栈空间，最优情况下为 ( O(\log n) )，最坏情况下为 ( O(n) )。</p></li></ol><h4 id="5-迭代实现"><a href="#5-迭代实现" class="headerlink" title="5. 迭代实现"></a>5. 迭代实现</h4><p>使用递归容易导致栈溢出问题，在此基础上可以使用栈手动模拟递归过程，进行迭代实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> s, <span class="type">int</span> e) : <span class="built_in">start</span>(s), <span class="built_in">end</span>(e) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数与递归版相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) --high;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) ++low;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代实现的快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortIterative</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;Range&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(<span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Range range = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; range.end) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = <span class="built_in">partition</span>(arr, range.start, range.end);</span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(range.start, pivot - <span class="number">1</span>));</span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(pivot + <span class="number">1</span>, range.end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">29</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSortIterative</span>(arr);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;快速排序（Quick-Sort）的C-实现&quot;&gt;&lt;a href=&quot;#快速排序（Quick-Sort）的C-实现&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quick Sort）的C++实现&quot;&gt;&lt;/a&gt;快速排序（Quick Sort）的C++实现</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://zuweicun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="STL" scheme="http://zuweicun.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的深度思考和总结</title>
    <link href="http://zuweicun.top/2024/10/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://zuweicun.top/2024/10/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-02T12:51:56.000Z</published>
    <updated>2025-04-10T15:15:25.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-数据结构的本质"><a href="#1-数据结构的本质" class="headerlink" title="1.数据结构的本质"></a>1.数据结构的本质</h4><p>数据结构的本质其实就是<strong>链表和数组</strong>，其他复杂的数据结构不过是这些基本结构的高级抽象。无论是树、栈、队列，还是更高级的图结构，归根结底都是基于数组或链表构建的。它们通过底层的实现细节和不同的逻辑组织方式，提供了更易用的API接口。</p><span id="more"></span><p><img src="DataStructure.png" alt="DataStructure"></p><p>比如，<strong>树</strong>这种数据结构，既可以用数组来实现，也可以用链表构建。数组的优势在于可以通过索引快速访问，节省空间，而链表的优势则在于高效的插入和删除操作。但链表由于使用指针，会占用更多的空间。</p><p>我们可以从<strong>Redis</strong>的实现上看到这一点，它内部有字符串、集合等数据结构，每一种数据类型都有不同的实现方式。其实，我们自己也可以根据具体的业务场景，设计并实现出个性化的数据结构，并定义一些适合当前业务需求的API接口。</p><p>语言层面也为我们提供了丰富的数据结构工具。比如在<strong>Python</strong>中，除了常用的字典和列表外，还可以通过<code>collections</code>模块找到一些更灵活和高效的数据类型，如<code>defaultdict</code>、双端队列<code>deque</code>、计数器<code>Counter</code>等。<strong>Java</strong>的<code>java.util</code>包中也包含了大量用于扩展基础数据结构的工具类。</p><p>综上所述，数据结构的底层其实就是<strong>数组和链表</strong>。无论是集合还是字典，都是通过哈希函数来将元素映射到具体的存储位置上。</p><h4 id="那么，算法的本质是什么？"><a href="#那么，算法的本质是什么？" class="headerlink" title="那么，算法的本质是什么？"></a>那么，算法的本质是什么？</h4><p>算法的本质其实就是<strong>穷举</strong>。但穷举并不是那么简单的，它需要做到两点：<strong>不漏</strong>和<strong>聪明的穷举</strong>。</p><p>计算机与人类解决问题的思维方式完全不同。人类可能通过一个公式就能解决问题，而计算机则依赖<strong>计算能力</strong>不断进行尝试，直到得到结果。计算机最大的优点就是速度快、不怕累。因此，算法就是用<strong>计算机语言</strong>把人的问题转化为机器能够执行的程序，通过不断的尝试来解决。</p><h5 id="1-不漏"><a href="#1-不漏" class="headerlink" title="1. 不漏"></a>1. <strong>不漏</strong></h5><p>“不漏”指的是算法给出的解答必须是完整的。比如很多组合问题常用<strong>回溯算法</strong>来解决，算法需要确保所有可能的解都被考虑到，没有遗漏。</p><h5 id="2-聪明的穷举"><a href="#2-聪明的穷举" class="headerlink" title="2. 聪明的穷举"></a>2. <strong>聪明的穷举</strong></h5><p>“聪明的穷举”就是通过优化策略来提高效率。最简单的算法可能是暴力破解，但它通常效率低下。为了提高效率，我们需要进行优化，而所有的优化手段，归根结底都是为了<strong>更聪明地穷举</strong>。</p><p>举个例子，<strong>双指针</strong>和<strong>滑动窗口</strong>技巧就是为了在穷举过程中减少不必要的时间消耗。相比于传统的双重循环，它们能显著提高时间效率。同样的，有时可以选择更合适的数据结构来减少穷举，比如使用双链表代替单链表，可以节省一定的操作步骤。</p><p>在算法设计中，还有一些优化技巧，比如<strong>剪枝</strong>，即在遍历树时提早终止不必要的分支；又比如<strong>记忆化搜索</strong>，通过缓存中间结果来避免重复计算。</p><h2 id="综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同"><a href="#综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同" class="headerlink" title="综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同"></a><strong>综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同</strong></h2><h4 id="2-线性数据结构"><a href="#2-线性数据结构" class="headerlink" title="2. 线性数据结构"></a>2. <strong>线性数据结构</strong></h4><h5 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a><strong>数组 (Array)</strong></h5><ul><li><strong>定义与特性</strong><br>数组是内存中连续分配的元素集合，支持常数时间的随机访问。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 定义一个包含5个整数的数组</span></span><br><span class="line"><span class="type">int</span> element = arr[<span class="number">2</span>];  <span class="comment">// 访问索引为2的元素</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">10</span>;  <span class="comment">// 修改索引为1的元素</span></span><br></pre></td></tr></table></figure></li><li><strong>优缺点分析</strong>  <ul><li>优点：支持常数时间的随机访问，适合查找场景。</li><li>缺点：插入和删除操作需要移动大量元素，效率较低。</li></ul></li><li><strong>典型应用场景与变体</strong>  <ul><li><strong>动态数组</strong>：大小可动态变化的数组，如C++中的<code>std::vector</code>。  </li><li><strong>稀疏矩阵</strong>：存储少量非零元素的矩阵，节省内存。</li></ul></li></ul><h5 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 (Linked List)"></a><strong>链表 (Linked List)</strong></h5><ul><li><strong>定义与特性</strong><br>链表是由一系列节点组成的，每个节点包含数据和指向下一个节点的指针。支持高效的插入和删除操作。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* head = <span class="literal">nullptr</span>;  <span class="comment">// 创建一个空链表</span></span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node&#123;<span class="number">10</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 创建一个新节点</span></span><br><span class="line">head = newNode;  <span class="comment">// 将新节点作为链表头部</span></span><br></pre></td></tr></table></figure></li><li><strong>单链表与双链表</strong>  <ul><li><strong>单链表</strong>：每个节点仅指向下一个节点。</li><li><strong>双链表</strong>：每个节点同时指向前一个和后一个节点，便于双向遍历。</li></ul></li><li><strong>优缺点分析</strong>  <ul><li>优点：插入和删除操作的时间复杂度为O(1)。</li><li>缺点：不能随机访问，查找某个元素需要遍历链表。</li></ul></li><li><strong>典型应用</strong>  <ul><li><strong>LRU缓存</strong>：使用双向链表和哈希表实现最近最少使用（Least Recently Used）缓存策略。</li><li><strong>队列</strong>：使用链表实现的队列，支持高效的入队和出队操作。</li></ul></li></ul><h5 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a><strong>栈与队列</strong></h5><ul><li><p><strong>栈 (Stack)</strong></p><ul><li><strong>定义与特性</strong><br>栈是一种后进先出（LIFO, Last In First Out）数据结构，只有栈顶元素可以被访问。常用于递归问题的处理。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> stack[MAX];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stack[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack[top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>实际应用</strong>  <ul><li><strong>递归求解</strong>：如深度优先搜索（DFS）中使用栈模拟递归。</li><li><strong>表达式求值</strong>：后缀表达式求值。</li></ul></li></ul></li><li><p><strong>队列 (Queue)</strong></p><ul><li><strong>定义与特性</strong><br>队列是一种先进先出（FIFO, First In First Out）数据结构，常用于任务调度、广度优先搜索（BFS）等场景。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> queue[MAX];</span><br><span class="line"><span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    queue[rear++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue[front++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>实际应用</strong>  <ul><li><strong>任务调度</strong>：常用于处理操作系统中的任务调度、打印队列等。</li><li><strong>广度优先搜索 (BFS)</strong>：通过队列实现层序遍历。</li></ul></li></ul></li></ul><h4 id="3-树结构"><a href="#3-树结构" class="headerlink" title="3. 树结构"></a>3. <strong>树结构</strong></h4><h5 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 (Binary Tree)"></a><strong>二叉树 (Binary Tree)</strong></h5><ul><li><strong>定义与特性</strong><br>二叉树是每个节点最多有两个子节点的树结构，子节点分别称为左子节点和右子节点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode&#123;<span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 创建根节点</span></span><br><span class="line">root-&gt;left = <span class="keyword">new</span> TreeNode&#123;<span class="number">2</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 添加左子节点</span></span><br><span class="line">root-&gt;right = <span class="keyword">new</span> TreeNode&#123;<span class="number">3</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 添加右子节点</span></span><br></pre></td></tr></table></figure></li><li><strong>遍历方式</strong><ul><li><strong>前序遍历</strong>：根节点 -&gt; 左子树 -&gt; 右子树</li><li><strong>中序遍历</strong>：左子树 -&gt; 根节点 -&gt; 右子树</li><li><strong>后序遍历</strong>：左子树 -&gt; 右子树 -&gt; 根节点</li><li><strong>层序遍历</strong>：按层访问，常用队列实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="二叉搜索树-Binary-Search-Tree-BST"><a href="#二叉搜索树-Binary-Search-Tree-BST" class="headerlink" title="二叉搜索树 (Binary Search Tree, BST)"></a><strong>二叉搜索树 (Binary Search Tree, BST)</strong></h5><ul><li><strong>定义与特性</strong><br>二叉搜索树是一种有序二叉树，对于每个节点，其左子树的所有节点值小于该节点值，右子树的所有节点值大于该节点值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&#123;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>操作</strong>  <ul><li><strong>插入</strong>：新元素按照顺序插入到合适位置。</li><li><strong>查找</strong>：从根节点开始，根据大小关系查找节点。</li><li><strong>删除</strong>：删除节点时需要考虑其子节点的调整。</li></ul></li><li><strong>平衡性问题与优化</strong>  <ul><li><strong>AVL树</strong>：通过旋转保持树的平衡，确保插入、删除、查找操作时间复杂度为O(log n)。</li><li><strong>红黑树</strong>：类似AVL树，但平衡条件稍弱，插入和删除更高效。</li></ul></li></ul><h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 (Heap)"></a><strong>堆 (Heap)</strong></h5><ul><li><strong>定义与特性</strong><br>堆是一棵完全二叉树，分为最大堆和最小堆。最大堆中每个节点的值都大于或等于其子节点，最小堆则相反。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-数据结构的本质&quot;&gt;&lt;a href=&quot;#1-数据结构的本质&quot; class=&quot;headerlink&quot; title=&quot;1.数据结构的本质&quot;&gt;&lt;/a&gt;1.数据结构的本质&lt;/h4&gt;&lt;p&gt;数据结构的本质其实就是&lt;strong&gt;链表和数组&lt;/strong&gt;，其他复杂的数据结构不过是这些基本结构的高级抽象。无论是树、栈、队列，还是更高级的图结构，归根结底都是基于数组或链表构建的。它们通过底层的实现细节和不同的逻辑组织方式，提供了更易用的API接口。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://zuweicun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://zuweicun.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Transformer架构初步</title>
    <link href="http://zuweicun.top/2024/09/20/Transformer/"/>
    <id>http://zuweicun.top/2024/09/20/Transformer/</id>
    <published>2024-09-20T08:20:04.000Z</published>
    <updated>2025-04-10T15:15:25.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Transformer-架构及技术细节详解"><a href="#Transformer-架构及技术细节详解" class="headerlink" title="Transformer 架构及技术细节详解"></a>Transformer 架构及技术细节详解</h3><p>Transformer 是近年来自然语言处理 (NLP) 和序列建模任务中最具影响力的神经网络架构。它通过<strong>自注意力机制</strong>替代了传统的 RNN (递归神经网络) 和 LSTM (长短期记忆网络)，并凭借其并行化计算和捕捉长距离依赖的能力，在机器翻译、文本生成、文本分类等任务中取得了显著的效果。</p><h4 id="Transformer-的核心模块："><a href="#Transformer-的核心模块：" class="headerlink" title="Transformer 的核心模块："></a>Transformer 的核心模块：</h4><ul><li><strong>多头自注意力机制 (Multi-Head Self-Attention)</strong></li><li><strong>前馈神经网络 (Feed-Forward Network, FFN)</strong></li><li><strong>残差连接 (Residual Connection) 和层归一化 (Layer Normalization)</strong></li><li><strong>位置编码 (Positional Encoding)</strong></li><li><strong>编码器-解码器架构 (Encoder-Decoder Architecture)</strong></li></ul><h4 id="Transformer-的架构整体由两个主要部分组成："><a href="#Transformer-的架构整体由两个主要部分组成：" class="headerlink" title="Transformer 的架构整体由两个主要部分组成："></a>Transformer 的架构整体由两个主要部分组成：</h4><ul><li><strong>编码器 (Encoder)</strong>：由多个相同的编码器层组成，每一层包含一个多头自注意力模块和一个前馈神经网络模块。</li><li><strong>解码器 (Decoder)</strong>：与编码器类似，但有额外的一个注意力机制，用于对编码器的输出进行处理。</li></ul><p>下面详细介绍各个组成模块。</p><h3 id="1-自注意力机制-Self-Attention-Mechanism"><a href="#1-自注意力机制-Self-Attention-Mechanism" class="headerlink" title="1. 自注意力机制 (Self-Attention Mechanism)"></a>1. <strong>自注意力机制 (Self-Attention Mechanism)</strong></h3><p>自注意力机制的核心目标是捕捉序列中的长距离依赖，通过为输入中的每个 token 分配不同的重要性权重。自注意力机制是 Transformer 中最关键的部分，它通过以下步骤实现：</p><h4 id="a-Query-Key-Value-矩阵计算："><a href="#a-Query-Key-Value-矩阵计算：" class="headerlink" title="a. Query, Key, Value 矩阵计算："></a>a. <strong>Query, Key, Value 矩阵计算</strong>：</h4><p>每个输入 token $( x_i )$ 经过线性变换，分别得到 Query $( Q_i )$，Key $( K_i )$，Value $( V_i )$：</p><script type="math/tex; mode=display">Q_i = x_i W_Q, \quad K_i = x_i W_K, \quad V_i = x_i W_V</script><p>其中 $( W_Q )$, $( W_K )$, $( W_V )$ 是可学习的权重矩阵。这些矩阵的维度通常为 $( d_k \times d )$ （这里 $( d_k )$ 是 Key 矩阵的维度）。</p><h4 id="b-计算注意力得分："><a href="#b-计算注意力得分：" class="headerlink" title="b. 计算注意力得分："></a>b. <strong>计算注意力得分</strong>：</h4><p>通过 Query 和 Key 的点积计算每个 token 之间的相似性，接着通过 softmax 函数计算注意力权重：</p><script type="math/tex; mode=display">\text{Attention}(Q, K, V) = \text{softmax} \left( \frac{QK^T}{\sqrt{d_k}} \right) V</script><p>这里的 $( \sqrt{d_k} )$ 是缩放因子，用来防止点积值过大导致梯度消失或爆炸问题。</p><h4 id="c-多头注意力机制-Multi-Head-Attention-："><a href="#c-多头注意力机制-Multi-Head-Attention-：" class="headerlink" title="c. 多头注意力机制 (Multi-Head Attention)："></a>c. <strong>多头注意力机制 (Multi-Head Attention)</strong>：</h4><p>为了让模型从不同的子空间中学习到不同的上下文信息，Transformer 使用多个不同的 Query、Key 和 Value 矩阵来进行多次自注意力计算。然后将各个头的输出拼接起来：</p><script type="math/tex; mode=display">\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \text{head}_2, \dots, \text{head}_h)W_O</script><p>每个头的输出 ( \text{head}_i ) 是通过单独的 Query、Key、Value 矩阵计算的注意力。最终拼接结果通过线性变换 ( W_O ) 进行整合。</p><h3 id="2-前馈神经网络-Feed-Forward-Network-FFN"><a href="#2-前馈神经网络-Feed-Forward-Network-FFN" class="headerlink" title="2. 前馈神经网络 (Feed-Forward Network, FFN)"></a>2. <strong>前馈神经网络 (Feed-Forward Network, FFN)</strong></h3><p>每个注意力层的输出都会通过一个全连接前馈神经网络进行进一步处理。这个 FFN 通常包含两个线性变换和一个非线性激活函数：</p><script type="math/tex; mode=display">\text{FFN}(x) = \text{ReLU}(xW_1 + b_1)W_2 + b_2</script><p>其中 $( W_1 )$ 和 $( W_2 )$ 是可学习的权重矩阵，$( b_1 )$ 和 $( b_2 )$ 是偏置向量。</p><h3 id="4-位置编码-Positional-Encoding"><a href="#4-位置编码-Positional-Encoding" class="headerlink" title="4. 位置编码 (Positional Encoding)"></a>4. <strong>位置编码 (Positional Encoding)</strong></h3><p>由于 Transformer 结构不依赖 RNN，因此它无法直接从序列中提取位置信息。为了让模型感知序列中的顺序，Transformer 引入了位置编码（Positional Encoding）。最常见的固定位置编码使用正弦和余弦函数表示：</p><script type="math/tex; mode=display">PE_{(pos, 2i)} = \sin \left( \frac{pos}{10000^{2i/d}} \right), \quad PE_{(pos, 2i+1)} = \cos \left( \frac{pos}{10000^{2i/d}} \right)</script><p>其中 $( pos )$ 是序列中的位置，$( i )$ 是维度索引。这样的位置编码允许模型在不同的频率上为每个位置引入唯一的表示。</p><h3 id="6-掩码机制-Masking-Mechanism"><a href="#6-掩码机制-Masking-Mechanism" class="headerlink" title="6. 掩码机制 (Masking Mechanism)"></a>6. <strong>掩码机制 (Masking Mechanism)</strong></h3><p>掩码在 Transformer 中是一个重要的概念，特别是在解码器中，它确保模型只处理已生成的部分，避免将未来信息泄露给当前步骤。掩码主要分为两种：</p><ul><li><strong>填充掩码 (Padding Mask)</strong>：用于忽略序列中的填充部分（padding tokens），以避免这些无关信息影响模型的计算。</li><li><strong>未来掩码 (Future Mask or Look-ahead Mask)</strong>：应用于解码器，防止模型在训练时看到未来的 tokens。未来掩码会将位于当前位置之后的 tokens 的注意力分数置为 -∞。</li></ul><p>如果还有其他部分需要格式化为 LaTeX，欢迎指出，我可以继续帮助你完成整个文档的调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Transformer-架构及技术细节详解&quot;&gt;&lt;a href=&quot;#Transformer-架构及技术细节详解&quot; class=&quot;headerlink&quot; title=&quot;Transformer 架构及技术细节详解&quot;&gt;&lt;/a&gt;Transformer 架构及技术细节详解&lt;/</summary>
      
    
    
    
    <category term="科研" scheme="http://zuweicun.top/categories/%E7%A7%91%E7%A0%94/"/>
    
    
    <category term="Transformer" scheme="http://zuweicun.top/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://zuweicun.top/2024/09/20/KMP/"/>
    <id>http://zuweicun.top/2024/09/20/KMP/</id>
    <published>2024-09-20T08:15:29.000Z</published>
    <updated>2025-04-10T15:15:25.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP-算法（Knuth-Morris-Pratt）笔记"><a href="#KMP-算法（Knuth-Morris-Pratt）笔记" class="headerlink" title="KMP 算法（Knuth-Morris-Pratt）笔记"></a>KMP 算法（Knuth-Morris-Pratt）笔记</h1><h2 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h2><p>KMP 算法用于 <strong>字符串匹配</strong>，通过预处理模式串，避免重复的字符比较，从而实现高效匹配。它的时间复杂度是 <strong>O(n + m)</strong>，其中 n 是主串长度，m 是模式串长度。</p><h2 id="2-主要思想"><a href="#2-主要思想" class="headerlink" title="2. 主要思想"></a>2. 主要思想</h2><p>当模式串中的某个字符匹配失败时，利用已知的部分匹配结果，跳过不必要的比较。这是通过 <strong>部分匹配表</strong>（也称为 <strong>前缀表</strong>）实现的。</p><h2 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3. 术语解释"></a>3. 术语解释</h2><ul><li><strong>前缀</strong>：从字符串的第一个字符开始，不包含最后一个字符的子串。</li><li><strong>后缀</strong>：从字符串的最后一个字符开始，不包含第一个字符的子串。</li><li><strong>部分匹配表</strong>：记录每个字符位置前的部分字符串的最长相同前缀和后缀的长度。</li></ul><h2 id="4-部分匹配表的构建"><a href="#4-部分匹配表的构建" class="headerlink" title="4. 部分匹配表的构建"></a>4. 部分匹配表的构建</h2><p>部分匹配表记录模式串在匹配失败时，可以跳过的字符数量。假设模式串为 <code>pattern</code>，前缀表 <code>prefix[i]</code> 的值表示在 <code>pattern[0...i]</code> 中，最长相同前缀和后缀的长度。</p><p><strong>构建步骤</strong>：</p><ol><li>初始时，<code>prefix[0] = 0</code>，表示第一个字符没有前缀和后缀。</li><li>使用双指针法遍历模式串，一个指针指向当前字符，一个指向最长前缀的下一个字符。</li><li>若当前字符匹配，前缀长度加 1；否则，回退到前一个匹配的前缀位置。</li></ol><h2 id="5-KMP-主算法步骤"><a href="#5-KMP-主算法步骤" class="headerlink" title="5. KMP 主算法步骤"></a>5. KMP 主算法步骤</h2><ol><li>预处理模式串，计算其部分匹配表。</li><li>在主串中按顺序比较字符，若匹配成功，则继续比较下一个字符；若匹配失败，根据部分匹配表跳过一部分字符，减少不必要的比较。</li><li>重复步骤 2 直到找到所有匹配位置或遍历完整个主串。</li></ol><h2 id="6-KMP-代码实现"><a href="#6-KMP-代码实现" class="headerlink" title="6. KMP 代码实现"></a>6. KMP 代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表（前缀表）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computePrefixFunction</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m, <span class="type">int</span>* prefix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; pattern[k] != pattern[i]) &#123;</span><br><span class="line">            k = prefix[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[k] == pattern[i]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 主算法，返回匹配的起始位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span>* matches, <span class="type">int</span>&amp; match_count)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="type">int</span> prefix[m];</span><br><span class="line">    <span class="built_in">computePrefixFunction</span>(pattern, m, prefix);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">    match_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; pattern[q] != text[i]) &#123;</span><br><span class="line">            q = prefix[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[q] == text[i]) &#123;</span><br><span class="line">            ++q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == m) &#123;</span><br><span class="line">            matches[match_count++] = i - m + <span class="number">1</span>;</span><br><span class="line">            q = prefix[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> matches[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> match_count;</span><br><span class="line">    <span class="built_in">kmpSearch</span>(text, pattern, matches, match_count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (match_count == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;匹配位置：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; match_count; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; matches[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-时间复杂度"><a href="#7-时间复杂度" class="headerlink" title="7. 时间复杂度"></a>7. 时间复杂度</h2><ul><li><strong>预处理模式串</strong>：O(m)</li><li><strong>主串匹配</strong>：O(n)<br>因此，整个算法的时间复杂度为 <strong>O(n + m)</strong>。</li></ul><h2 id="8-应用场景"><a href="#8-应用场景" class="headerlink" title="8. 应用场景"></a>8. 应用场景</h2><p>KMP 算法适用于以下场景：</p><ul><li>字符串匹配问题，例如在文本中查找某个单词或子字符串。</li><li>DNA 序列匹配等生物信息学领域。</li></ul><h2 id="9-优势"><a href="#9-优势" class="headerlink" title="9. 优势"></a>9. 优势</h2><ul><li>当模式串包含大量重复部分时，KMP 算法能显著减少比较次数，效率高于朴素的字符串匹配算法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KMP-算法（Knuth-Morris-Pratt）笔记&quot;&gt;&lt;a href=&quot;#KMP-算法（Knuth-Morris-Pratt）笔记&quot; class=&quot;headerlink&quot; title=&quot;KMP 算法（Knuth-Morris-Pratt）笔记&quot;&gt;&lt;/a&gt;KM</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://zuweicun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://zuweicun.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>堆栈</title>
    <link href="http://zuweicun.top/2024/09/20/%E5%A0%86%E6%A0%88/"/>
    <id>http://zuweicun.top/2024/09/20/%E5%A0%86%E6%A0%88/</id>
    <published>2024-09-20T08:14:26.000Z</published>
    <updated>2025-04-10T15:15:25.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-堆栈笔记"><a href="#C-堆栈笔记" class="headerlink" title="C++ 堆栈笔记"></a>C++ 堆栈笔记</h2><h3 id="1-什么是堆栈？"><a href="#1-什么是堆栈？" class="headerlink" title="1. 什么是堆栈？"></a>1. 什么是堆栈？</h3><p>堆栈（Stack）是一种基础的数据结构，遵循<strong>后进先出</strong>（LIFO, Last In First Out）原则，意味着最后插入堆栈的元素最先被弹出。堆栈的使用场景非常广泛，如处理递归、括号匹配、表达式求值、回溯算法等。它通常用于管理程序的运行状态。</p><h3 id="2-堆栈的特点与应用场景"><a href="#2-堆栈的特点与应用场景" class="headerlink" title="2. 堆栈的特点与应用场景"></a>2. 堆栈的特点与应用场景</h3><h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><ul><li><strong>线性数据结构</strong>：堆栈通过一个线性方式组织元素，只有栈顶（顶部）元素可以被访问。</li><li><strong>操作受限</strong>：仅允许在栈的顶部进行插入（push）和删除（pop）操作，无法直接访问或修改栈中的其他元素。</li><li><strong>动态增长</strong>：堆栈可以动态调整大小，尤其是在使用标准库的实现时（如 C++ 中的 <code>std::stack</code>）。</li></ul><h4 id="2-2-典型应用场景"><a href="#2-2-典型应用场景" class="headerlink" title="2.2 典型应用场景"></a>2.2 典型应用场景</h4><ul><li><strong>递归调用管理</strong>：函数递归时，每次函数调用都会在堆栈中保存局部变量和返回地址，直到递归结束，再从堆栈中逐步恢复状态。</li><li><strong>表达式求值</strong>：在表达式求值过程中，特别是中缀转后缀表达式和逆波兰表达式的计算，堆栈是核心工具。</li><li><strong>括号匹配</strong>：用于检查表达式中括号是否配对，堆栈可以方便地追踪最近遇到的左括号，并在遇到右括号时进行匹配。</li><li><strong>浏览器前进/后退操作</strong>：用户在浏览网页时，前进和后退操作是典型的堆栈应用。前进操作和后退操作分别模拟两种不同的堆栈。</li></ul><h3 id="3-堆栈的操作"><a href="#3-堆栈的操作" class="headerlink" title="3. 堆栈的操作"></a>3. 堆栈的操作</h3><h4 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h4><p>堆栈的主要操作包括：</p><ul><li><strong>push</strong>：将元素插入堆栈的顶部。</li><li><strong>pop</strong>：移除堆栈顶部的元素。</li><li><strong>top（peek）</strong>：返回栈顶元素但不移除它。</li><li><strong>isEmpty</strong>：检查堆栈是否为空。</li><li><strong>size</strong>：返回堆栈中元素的数量。</li></ul><h4 id="3-2-C-标准库实现"><a href="#3-2-C-标准库实现" class="headerlink" title="3.2 C++ 标准库实现"></a>3.2 C++ 标准库实现</h4><p>C++ 提供了标准的 <code>std::stack</code> 容器来实现堆栈。以下是一个简单的例子，演示如何使用 C++ 实现堆栈的基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈操作</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element after pop: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断堆栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is not empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出堆栈大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-C-手动实现堆栈"><a href="#4-C-手动实现堆栈" class="headerlink" title="4. C++ 手动实现堆栈"></a>4. C++ 手动实现堆栈</h3><p>除了使用标准库的堆栈，我们也可以通过数组或者链表手动实现堆栈。以下是基于数组的实现：</p><h4 id="4-1-使用数组实现堆栈"><a href="#4-1-使用数组实现堆栈" class="headerlink" title="4.1 使用数组实现堆栈"></a>4.1 使用数组实现堆栈</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> arr[MAX]; <span class="comment">// 堆栈数组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Stack</span>() &#123; top = <span class="number">-1</span>; &#125; <span class="comment">// 初始化栈顶</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt;= MAX - <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack Overflow&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[++top] = x;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; pushed into stack&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack Underflow&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> x = arr[top--];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// peek 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is Empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (top &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; s.<span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot; Popped from stack&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element is &quot;</span> &lt;&lt; s.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack empty: &quot;</span> &lt;&lt; s.<span class="built_in">isEmpty</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-链表实现堆栈"><a href="#4-2-链表实现堆栈" class="headerlink" title="4.2 链表实现堆栈"></a>4.2 链表实现堆栈</h4><p>链表实现堆栈可以避免数组的固定大小限制，它具有动态扩展的能力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    StackNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">StackNode* <span class="title">newNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    StackNode* stackNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>();</span><br><span class="line">    stackNode-&gt;data = data;</span><br><span class="line">    stackNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> stackNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(StackNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(StackNode** root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    StackNode* stackNode = <span class="built_in">newNode</span>(data);</span><br><span class="line">    stackNode-&gt;next = *root;</span><br><span class="line">    *root = stackNode;</span><br><span class="line">    std::cout &lt;&lt; data &lt;&lt; <span class="string">&quot; pushed to stack\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(StackNode** root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(*root))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    StackNode* temp = *root;</span><br><span class="line">    *root = (*root)-&gt;next;</span><br><span class="line">    <span class="type">int</span> popped = temp-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> popped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(StackNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(root))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StackNode* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pop</span>(&amp;root) &lt;&lt; <span class="string">&quot; popped from stack\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element is &quot;</span> &lt;&lt; <span class="built_in">peek</span>(root) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-常见堆栈应用"><a href="#5-常见堆栈应用" class="headerlink" title="5. 常见堆栈应用"></a>5. 常见堆栈应用</h3><h4 id="5-1-括号匹配问题"><a href="#5-1-括号匹配问题" class="headerlink" title="5.1 括号匹配问题"></a>5.1 括号匹配问题</h4><p>堆栈可以用于括号匹配的检测，以下是一个简单的实现，用于检查括号是否匹配：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">areBracketsBalanced</span><span class="params">(<span class="type">const</span> std::string&amp; expr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : expr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> top = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> ((ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                (ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string expr = <span class="string">&quot;&#123;[()]&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">areBracketsBalanced</span>(expr))</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Balanced\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not Balanced\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-表达式求值"><a href="#5-2-表达式求值" class="headerlink" title="5.2 表达式求值"></a>5.2 表达式求值</h4><p>堆栈在后缀表达式（逆波兰表达式）计算中非常有用。以下是基于堆栈的后缀表达式求值实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evaluatePostfix</span><span class="params">(<span class="type">const</span> std::string&amp; expr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : expr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> val1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> val2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: s.<span class="built_in">push</span>(val2 + val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: s.<span class="built_in">push</span>(val2 - val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: s.<span class="built_in">push</span>(val2 * val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: s.<span class="built_in">push</span>(val2 / val1); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string expr = <span class="string">&quot;231*+9-&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">evaluatePostfix</span>(expr) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-堆栈的时间与空间复杂度"><a href="#6-堆栈的时间与空间复杂度" class="headerlink" title="6. 堆栈的时间与空间复杂度"></a>6. 堆栈的时间与空间复杂度</h3><ul><li><p><strong>时间复杂度</strong>：</p><ul><li><code>push</code> 操作：O(1)</li><li><code>pop</code> 操作：O(1)</li><li><code>peek</code> 操作：O(1)</li></ul></li><li><p><strong>空间复杂度</strong>：O(n)，其中 n 是堆栈中的元素个数。对于链表实现，额外的空间复杂度还包括链表节点的指针存储。</p></li></ul><h3 id="7-堆栈的局限性"><a href="#7-堆栈的局限性" class="headerlink" title="7. 堆栈的局限性"></a>7. 堆栈的局限性</h3><p>虽然堆栈是一种非常高效的结构，但它的局限性包括：</p><ul><li><strong>只能访问栈顶元素</strong>：堆栈限制了只能访问最顶部的元素，无法直接随机访问任何位置的元素。</li><li><strong>溢出风险</strong>：对于基于数组的实现，如果栈超过预设大小，会产生溢出问题。</li><li><strong>应用受限</strong>：对于需要随机访问或双向遍历的应用场景，堆栈并不适用。</li></ul><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>堆栈是一种重要的数据结构，广泛应用于程序运行管理和算法设计中。C++ 提供了 <code>std::stack</code> 方便我们使用堆栈，同时我们也可以基于数组或链表手动实现堆栈，来适应不同的应用场景。理解和掌握堆栈的实现和应用，有助于编写高效的算法和程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-堆栈笔记&quot;&gt;&lt;a href=&quot;#C-堆栈笔记&quot; class=&quot;headerlink&quot; title=&quot;C++ 堆栈笔记&quot;&gt;&lt;/a&gt;C++ 堆栈笔记&lt;/h2&gt;&lt;h3 id=&quot;1-什么是堆栈？&quot;&gt;&lt;a href=&quot;#1-什么是堆栈？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://zuweicun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://zuweicun.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="http://zuweicun.top/2024/09/20/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://zuweicun.top/2024/09/20/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2024-09-20T08:12:06.000Z</published>
    <updated>2025-04-10T15:15:25.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习笔记：顺序表（SQList）的理解与实现"><a href="#学习笔记：顺序表（SQList）的理解与实现" class="headerlink" title="学习笔记：顺序表（SQList）的理解与实现"></a>学习笔记：顺序表（SQList）的理解与实现</h1><h2 id="1-什么是顺序表（SQList）-s"><a href="#1-什么是顺序表（SQList）-s" class="headerlink" title="1. 什么是顺序表（SQList） ß"></a>1. 什么是顺序表（SQList） ß</h2><p>顺序表是一种常见的线性数据结构，其特点是通过一组连续的内存空间来存储数据元素。在顺序表中，每个元素都有一个直接的前驱和后继（除了第一个元素没有前驱，最后一个元素没有后继）。顺序表的操作主要包括插入、删除、查找等。</p><h2 id="2-顺序表的特点"><a href="#2-顺序表的特点" class="headerlink" title="2. 顺序表的特点"></a>2. 顺序表的特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>访问速度快</strong>：由于元素在内存中是连续存储的，因此可以通过索引直接访问，时间复杂度为 O(1)。</li><li><strong>易于实现</strong>：使用数组或容器如 <code>std::vector</code> 可以轻松实现顺序表。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>插入和删除效率低</strong>：当在表中间插入或删除元素时，需要移动后续的所有元素，最坏情况下的时间复杂度为 O(n)。</li><li><strong>空间预分配</strong>：需要提前知道表的最大容量，否则可能会导致内存不足。</li></ul><h2 id="3-顺序表的实现"><a href="#3-顺序表的实现" class="headerlink" title="3. 顺序表的实现"></a>3. 顺序表的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 当前顺序表的实际大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQList</span>() : <span class="built_in">size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向顺序表中添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> elem)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(elem);</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据索引获取元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Index out of bounds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定索引处的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Index out of bounds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elements.<span class="built_in">erase</span>(elements.<span class="built_in">begin</span>() + index);</span><br><span class="line">        --size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印顺序表的内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顺序表的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SQList list;</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line">    list.<span class="built_in">print</span>(); <span class="comment">// 输出: 1 2 3</span></span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">remove</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">print</span>(); <span class="comment">// 输出: 1 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4. 时间复杂度分析"></a>4. 时间复杂度分析</h2><ul><li><strong>访问</strong>: O(1)，直接通过索引访问。</li><li><strong>插入</strong>: 最坏情况下为 O(n)，当插入位置位于表的开头或中间时。</li><li><strong>删除</strong>: 最坏情况下为 O(n)，当删除位置位于表的开头或中间时。</li><li><strong>查找</strong>: O(n)，需要遍历整个表。</li></ul><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><p>顺序表适合用于需要频繁访问但插入和删除较少的情况，例如缓存数据、静态数据集合等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习笔记：顺序表（SQList）的理解与实现&quot;&gt;&lt;a href=&quot;#学习笔记：顺序表（SQList）的理解与实现&quot; class=&quot;headerlink&quot; title=&quot;学习笔记：顺序表（SQList）的理解与实现&quot;&gt;&lt;/a&gt;学习笔记：顺序表（SQList）的理解与</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://zuweicun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://zuweicun.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>screen命令应用</title>
    <link href="http://zuweicun.top/2024/09/18/screen%E5%91%BD%E4%BB%A4%E5%BA%94%E7%94%A8/"/>
    <id>http://zuweicun.top/2024/09/18/screen%E5%91%BD%E4%BB%A4%E5%BA%94%E7%94%A8/</id>
    <published>2024-09-18T15:42:35.000Z</published>
    <updated>2025-04-10T15:15:25.126Z</updated>
    
    <content type="html"><![CDATA[<p><code>screen</code> 是一个非常强大的终端会话管理工具，它可以让你在多个终端窗口中运行任务，并在会话断开后继续保持任务的执行状态。特别适合长时间运行的任务或远程连接的任务管理。<br>对于远程服务器player简直是屠龙宝刀。</p><h3 id="常见用法："><a href="#常见用法：" class="headerlink" title="常见用法："></a>常见用法：</h3><p>以下是一些常见的 <code>screen</code> 命令和用法：</p><h4 id="1-启动新的-screen-会话"><a href="#1-启动新的-screen-会话" class="headerlink" title="1. 启动新的 screen 会话"></a>1. <strong>启动新的 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure><ul><li>启动一个新的 <code>screen</code> 会话。在新窗口中，你可以运行任何命令。</li><li>默认情况下，<code>screen</code> 会自动分配一个会话 ID。</li></ul><h4 id="2-启动带名称的-screen-会话"><a href="#2-启动带名称的-screen-会话" class="headerlink" title="2. 启动带名称的 screen 会话"></a>2. <strong>启动带名称的 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name</span><br></pre></td></tr></table></figure><ul><li>通过 <code>-S</code> 选项为会话指定名称 <code>session_name</code>，便于管理多个会话。</li></ul><h4 id="3-分离（Detach）会话"><a href="#3-分离（Detach）会话" class="headerlink" title="3. 分离（Detach）会话"></a>3. <strong>分离（Detach）会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + D</span><br></pre></td></tr></table></figure><ul><li>使用快捷键 <code>Ctrl + A + D</code>，可以将当前会话暂时分离（detach），但命令仍会继续在后台执行。</li></ul><h4 id="4-恢复（Reattach）已分离的会话"><a href="#4-恢复（Reattach）已分离的会话" class="headerlink" title="4. 恢复（Reattach）已分离的会话"></a>4. <strong>恢复（Reattach）已分离的会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r</span><br></pre></td></tr></table></figure><ul><li>恢复上一个分离的 <code>screen</code> 会话。</li></ul><h4 id="5-查看现有-screen-会话"><a href="#5-查看现有-screen-会话" class="headerlink" title="5. 查看现有 screen 会话"></a>5. <strong>查看现有 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure><ul><li>列出当前所有的 <code>screen</code> 会话，包括那些分离的会话。例如：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There are screens on:</span><br><span class="line">    <span class="number">1234</span><span class="selector-class">.session_name</span>    (Detached)</span><br><span class="line">    <span class="number">5678</span><span class="selector-class">.pts-0</span><span class="selector-class">.hostname</span>  (Attached)</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-恢复指定的会话"><a href="#6-恢复指定的会话" class="headerlink" title="6. 恢复指定的会话"></a>6. <strong>恢复指定的会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure><ul><li>恢复名为 <code>session_name</code> 的会话。你可以通过 <code>screen -ls</code> 查看到所有会话名称。</li></ul><h4 id="7-杀掉-screen-会话"><a href="#7-杀掉-screen-会话" class="headerlink" title="7. 杀掉 screen 会话"></a>7. <strong>杀掉 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -X -S session_name quit</span><br></pre></td></tr></table></figure><ul><li><code>-S session_name</code> 指定会话名，<code>-X quit</code> 用于杀掉该会话。</li></ul><h4 id="8-在会话中分屏操作"><a href="#8-在会话中分屏操作" class="headerlink" title="8. 在会话中分屏操作"></a>8. <strong>在会话中分屏操作</strong></h4><ul><li><p><strong>水平分屏：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + S</span><br></pre></td></tr></table></figure><p>然后使用 <code>Ctrl + A + Tab</code> 来在不同的屏幕之间切换。</p></li><li><p><strong>垂直分屏：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + |  <span class="comment"># 使用 | 进行垂直分屏</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭分屏：</strong><br>将光标聚焦到需要关闭的分屏窗口中，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + X</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-退出-screen-会话"><a href="#9-退出-screen-会话" class="headerlink" title="9. 退出 screen 会话"></a>9. <strong>退出 <code>screen</code> 会话</strong></h4><p>在会话窗口中直接输入 <code>exit</code>，或在分屏中通过 <code>Ctrl + A + X</code> 来关闭。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;screen&lt;/code&gt; 是一个非常强大的终端会话管理工具，它可以让你在多个终端窗口中运行任务，并在会话断开后继续保持任务的执行状态。特别适合长时间运行的任务或远程连接的任务管理。&lt;br&gt;对于远程服务器player简直是屠龙宝刀。&lt;/p&gt;
&lt;h3 id=&quot;常见</summary>
      
    
    
    
    <category term="科研" scheme="http://zuweicun.top/categories/%E7%A7%91%E7%A0%94/"/>
    
    
    <category term="命令" scheme="http://zuweicun.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>yolo初步</title>
    <link href="http://zuweicun.top/2024/04/10/yolo%E5%88%9D%E6%AD%A5/"/>
    <id>http://zuweicun.top/2024/04/10/yolo%E5%88%9D%E6%AD%A5/</id>
    <published>2024-04-10T13:48:36.000Z</published>
    <updated>2024-09-16T14:17:11.075Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<br /><a href="https://towardsdatascience.com/chess-rolls-or-basketball-lets-create-a-custom-object-detection-model-ef53028eac7d">A simple way of creating a custom object detection model</a>（这个就是卓晴教程的原版）<br /><a href="https://blog.csdn.net/sinat_28371057/article/details/120598220?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=yolo5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-120598220.142^v99^control&amp;spm=1018.2226.3001.4187">YOLOv5的详细使用教程，以及使用yolov5训练自己的数据集_yolo5训练集-CSDN博客</a></p><p><a name="Ub0k6"></a></p><span id="more"></span><h1 id="使用预训练模型"><a href="#使用预训练模型" class="headerlink" title="使用预训练模型"></a>使用预训练模型</h1><p><a name="Ir8Je"></a></p><h2 id="安装环境依赖"><a href="#安装环境依赖" class="headerlink" title="安装环境依赖"></a>安装环境依赖</h2><p><a name="ucNeD"></a></p><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure><p>镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com.cnpmjs.org<span class="regexp">/ultralytics/y</span>olov5 <span class="comment"># clone repo</span></span><br></pre></td></tr></table></figure><p><a name="LHIoW"></a></p><h2 id="必要环境"><a href="#必要环境" class="headerlink" title="必要环境"></a>必要环境</h2><p>官方给出的要求是：python&gt;=3.7、PyTorch&gt;=1.5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> yolov5</span><br><span class="line">pip install -U -r requirements.txt</span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install -U -r requirements.txt</span></span><br><span class="line"><span class="attribute">Cython</span></span><br><span class="line"><span class="attribute">numpy</span>==<span class="number">1</span>.<span class="number">17</span></span><br><span class="line"><span class="attribute">opencv</span>-python</span><br><span class="line"><span class="attribute">torch</span>&gt;=<span class="number">1</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">matplotlib</span></span><br><span class="line"><span class="attribute">pillow</span></span><br><span class="line"><span class="attribute">tensorboard</span></span><br><span class="line"><span class="attribute">PyYAML</span>&gt;=<span class="number">5</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">torchvision</span></span><br><span class="line"><span class="attribute">scipy</span></span><br><span class="line"><span class="attribute">tqdm</span></span><br><span class="line"><span class="attribute">git</span>+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Nvidia Apex (optional) for mixed precision training --------------------------</span></span><br><span class="line"><span class="comment"># git clone https://github.com/NVIDIA/apex &amp;&amp; cd apex &amp;&amp; pip install -v --no-cache-dir --global-option=&quot;--cpp_ext&quot; --global-option=&quot;--cuda_ext&quot; . --user &amp;&amp; cd .. &amp;&amp; rm -rf apex</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Conda commands (in place of pip) ---------------------------------------------</span></span><br><span class="line"><span class="comment"># conda update -yn base -c defaults conda</span></span><br><span class="line"><span class="comment"># conda install -yc anaconda numpy opencv matplotlib tqdm pillow ipython</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge scikit-image pycocotools tensorboard</span></span><br><span class="line"><span class="comment"># conda install -yc spyder-ide spyder-line-profiler</span></span><br><span class="line"><span class="comment"># conda install -yc pytorch pytorch torchvision</span></span><br><span class="line"><span class="comment"># conda install -yc conda-forge protobuf numpy &amp;&amp; pip install onnx  # https://github.com/onnx/onnx#linux-and-macos</span></span><br></pre></td></tr></table></figure><p><a name="Lpb3W"></a></p><h2 id="下载预训练模型和标注数据集"><a href="#下载预训练模型和标注数据集" class="headerlink" title="下载预训练模型和标注数据集"></a>下载预训练模型和标注数据集</h2><p><a name="VMqUW"></a></p><h3 id="执行脚本下载模型"><a href="#执行脚本下载模型" class="headerlink" title="执行脚本下载模型"></a>执行脚本下载模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Download common models</span></span><br><span class="line"> </span><br><span class="line">python3 -c <span class="string">&quot;from utils.google_utils import *;</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5s.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5m.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5l.pt&#x27;);</span></span><br><span class="line"><span class="string">attempt_download(&#x27;weights/yolov5x.pt&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p>（attempt_download函数在/yolov5/utils/google_utils.py脚本中定义）<br><a name="rFxrZ"></a></p><h3 id="下载标注数据集"><a href="#下载标注数据集" class="headerlink" title="下载标注数据集"></a>下载标注数据集</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">python3</span> -c <span class="string">&quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span> <span class="comment"># download dataset</span></span><br></pre></td></tr></table></figure><p>执行上面的代码，会下载：coco128.zip数据集，该数据是COCO train2017数据的一部分，只取了coco数据集中的128张标注的图片，coco128.zip下载完后解压到/yolov5目录下即可，解压后的coco128文件结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coco128</span><br><span class="line"><span class="operator">|</span><span class="comment">-- LICENSE</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- README.txt  # 相关说明</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- annotations  # 空目录</span></span><br><span class="line"><span class="operator">|</span><span class="comment">-- images   # 128张jpg图片</span></span><br><span class="line">`<span class="comment">-- labels  # 128张标注的txt文件</span></span><br></pre></td></tr></table></figure><p>/yolov5/utils/google_utils.py脚本是下载预训练模型和标注的训练数据集，该脚本代码内容如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"># This file <span class="keyword">contains</span> google utils: https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>reference<span class="operator">/</span>libraries</span><br><span class="line"># pip install <span class="comment">--upgrade google-cloud-storage</span></span><br><span class="line"># <span class="keyword">from</span> google.cloud import storage</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line">import <span class="type">time</span></span><br><span class="line"><span class="keyword">from</span> pathlib import Path</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def attempt_download(weights):</span><br><span class="line">    # Attempt <span class="keyword">to</span> download pretrained weights if <span class="keyword">not</span> found locally</span><br><span class="line">    weights <span class="operator">=</span> weights.strip()</span><br><span class="line">    msg <span class="operator">=</span> weights <span class="operator">+</span> <span class="string">&#x27; missing, try downloading from https://drive.google.com/drive/folders/1Drs_Aiu7xx6S-ix95f9kNsA6ueKRpN2J&#x27;</span></span><br><span class="line"> </span><br><span class="line">    r <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    if len(weights) <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> os.path.isfile(weights):</span><br><span class="line">        d <span class="operator">=</span> &#123;<span class="string">&#x27;yolov3-spp.pt&#x27;</span>: <span class="string">&#x27;1mM67oNw4fZoIOL1c8M3hHmj66d8e-ni_&#x27;</span>,  # yolov3<span class="operator">-</span>spp.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5s.pt&#x27;</span>: <span class="string">&#x27;1R5T6rIyy3lLwgFXNms8whc-387H0tMQO&#x27;</span>,  # yolov5s.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5m.pt&#x27;</span>: <span class="string">&#x27;1vobuEExpWQVpXExsJ2w-Mbf3HJjWkQJr&#x27;</span>,  # yolov5m.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5l.pt&#x27;</span>: <span class="string">&#x27;1hrlqD1Wdei7UT4OgT785BEk1JwnSvNEV&#x27;</span>,  # yolov5l.yaml</span><br><span class="line">             <span class="string">&#x27;yolov5x.pt&#x27;</span>: <span class="string">&#x27;1mM8aZJlWTxOg7BZJvNUMrTnA2AbeCVzS&#x27;</span>,  # yolov5x.yaml</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">        file <span class="operator">=</span> Path(weights).name</span><br><span class="line">        if file <span class="keyword">in</span> d:</span><br><span class="line">            r <span class="operator">=</span> gdrive_download(id<span class="operator">=</span>d[file], name<span class="operator">=</span>weights)</span><br><span class="line"> </span><br><span class="line">        if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">            os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">            s <span class="operator">=</span> &quot;curl -L -o %s &#x27;https://storage.googleapis.com/ultralytics/yolov5/ckpt/%s&#x27;&quot; <span class="operator">%</span> (weights, file)</span><br><span class="line">            r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line"> </span><br><span class="line">            # Error <span class="keyword">check</span></span><br><span class="line">            if <span class="keyword">not</span> (r <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> os.path.exists(weights) <span class="keyword">and</span> os.path.getsize(weights) <span class="operator">&gt;</span> <span class="number">1E6</span>):  # weights exist <span class="keyword">and</span> <span class="operator">&gt;</span> <span class="number">1</span>MB</span><br><span class="line">                os.remove(weights) if os.path.exists(weights) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial downloads</span><br><span class="line">                raise Exception(msg)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def gdrive_download(id<span class="operator">=</span><span class="string">&#x27;1HaXkef9z6y5l4vUnCYgdmEAj61c6bfWO&#x27;</span>, name<span class="operator">=</span><span class="string">&#x27;coco.zip&#x27;</span>):</span><br><span class="line">    # https:<span class="operator">/</span><span class="operator">/</span>gist.github.com<span class="operator">/</span>tanaikech<span class="operator">/</span>f0f2d122e05bf5f971611258c22c110f</span><br><span class="line">    # Downloads a file <span class="keyword">from</span> Google Drive, accepting presented query</span><br><span class="line">    # <span class="keyword">from</span> utils.google_utils import <span class="operator">*</span>; gdrive_download()</span><br><span class="line">    t <span class="operator">=</span> time.time()</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Downloading https://drive.google.com/uc?export=download&amp;id=%s as %s... &#x27;</span> <span class="operator">%</span> (id, name), <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove existing</span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Attempt file download</span><br><span class="line">    os.system(&quot;curl -c ./cookie -s -L \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; &gt; /dev/null&quot; <span class="operator">%</span> id)</span><br><span class="line">    if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>):  # <span class="keyword">large</span> file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -Lb ./cookie \&quot;https:<span class="operator">/</span><span class="operator">/</span>drive.google.com<span class="operator">/</span>uc?export<span class="operator">=</span>download<span class="operator">&amp;</span>confirm<span class="operator">=</span>`awk <span class="string">&#x27;/download/ &#123;print $NF&#125;&#x27;</span> .<span class="operator">/</span>cookie`<span class="operator">&amp;</span>id<span class="operator">=</span><span class="operator">%</span>s\&quot; -o %s&quot; <span class="operator">%</span> (</span><br><span class="line">            id, name)</span><br><span class="line">    <span class="keyword">else</span>:  # small file</span><br><span class="line">        s <span class="operator">=</span> &quot;curl -s -L -o %s &#x27;https://drive.google.com/uc?export=download&amp;id=%s&#x27;&quot; <span class="operator">%</span> (name, id)</span><br><span class="line">    r <span class="operator">=</span> os.system(s)  # <span class="keyword">execute</span>, capture <span class="keyword">return</span> <span class="keyword">values</span></span><br><span class="line">    os.remove(<span class="string">&#x27;cookie&#x27;</span>) if os.path.exists(<span class="string">&#x27;cookie&#x27;</span>) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"> </span><br><span class="line">    # Error <span class="keyword">check</span></span><br><span class="line">    if r <span class="operator">!=</span> <span class="number">0</span>:</span><br><span class="line">        os.remove(name) if os.path.exists(name) <span class="keyword">else</span> <span class="keyword">None</span>  # remove partial</span><br><span class="line">        print(<span class="string">&#x27;Download error &#x27;</span>)  # raise Exception(<span class="string">&#x27;Download error&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line">    # Unzip if archive</span><br><span class="line">    if name.endswith(<span class="string">&#x27;.zip&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;unzipping... &#x27;</span>, <span class="keyword">end</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        os.system(<span class="string">&#x27;unzip -q %s&#x27;</span> <span class="operator">%</span> name)  # unzip</span><br><span class="line">        os.remove(name)  # remove zip <span class="keyword">to</span> <span class="keyword">free</span> space</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">&#x27;Done (%.1fs)&#x27;</span> <span class="operator">%</span> (time.time() <span class="operator">-</span> t))</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"> </span><br><span class="line"># def upload_blob(bucket_name, source_file_name, destination_blob_name):</span><br><span class="line">#     # Uploads a file <span class="keyword">to</span> a bucket</span><br><span class="line">#     # https:<span class="operator">/</span><span class="operator">/</span>cloud.google.com<span class="operator">/</span>storage<span class="operator">/</span>docs<span class="operator">/</span>uploading<span class="operator">-</span>objects#storage<span class="operator">-</span>upload<span class="operator">-</span>object<span class="operator">-</span>python</span><br><span class="line">#</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(destination_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.upload_from_filename(source_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;File &#123;&#125; uploaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_file_name,</span><br><span class="line">#         destination_blob_name))</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># def download_blob(bucket_name, source_blob_name, destination_file_name):</span><br><span class="line">#     # Uploads a <span class="type">blob</span> <span class="keyword">from</span> a bucket</span><br><span class="line">#     storage_client <span class="operator">=</span> storage.Client()</span><br><span class="line">#     bucket <span class="operator">=</span> storage_client.get_bucket(bucket_name)</span><br><span class="line">#     <span class="type">blob</span> <span class="operator">=</span> bucket.blob(source_blob_name)</span><br><span class="line">#</span><br><span class="line">#     blob.download_to_filename(destination_file_name)</span><br><span class="line">#</span><br><span class="line">#     print(<span class="string">&#x27;Blob &#123;&#125; downloaded to &#123;&#125;.&#x27;</span>.format(</span><br><span class="line">#         source_blob_name,</span><br><span class="line">#         destination_file_name))</span><br></pre></td></tr></table></figure><p><a name="FqoFo"></a></p><h2 id="训练下载的coco128数据集"><a href="#训练下载的coco128数据集" class="headerlink" title="训练下载的coco128数据集"></a>训练下载的coco128数据集</h2><p>创建训练数据集的配置文件Dataset.yaml<br />上面下载好coco128.zip小型数据集之后，这些数据集可以用于训练和验证<br />/content/yolov5/models/yolov5l.yaml。coco128.yaml中定义了：<br />训练图片的路径（或训练图片列表的.txt文件）<br />与验证集相同的图片<br />目标的类别数<br />类名列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># COCO <span class="number">2017</span> dataset http:<span class="operator">/</span><span class="operator">/</span>cocodataset.org <span class="operator">-</span> <span class="keyword">first</span> <span class="number">128</span> training images</span><br><span class="line"># Download command:  python <span class="operator">-</span>c &quot;from yolov5.utils.google_utils import gdrive_download; gdrive_download(&#x27;1n_oKgR81BJtqk75b00eAjdv03qVCQn2f&#x27;,&#x27;coco128.zip&#x27;)&quot;</span><br><span class="line"># Train command: python train.py <span class="comment">--data ./data/coco128.yaml</span></span><br><span class="line"># Dataset should be placed next <span class="keyword">to</span> yolov5 folder:</span><br><span class="line">#   <span class="operator">/</span>parent_folder</span><br><span class="line">#     <span class="operator">/</span>coco128</span><br><span class="line">#     <span class="operator">/</span>yolov5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 训练集和验证集 （图片的目录路径或 <span class="operator">*</span>.txt图片路径）</span><br><span class="line">train: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line">val: ..<span class="operator">/</span>coco128<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span></span><br><span class="line"> </span><br><span class="line"># 类别数 number <span class="keyword">of</span> classes</span><br><span class="line">nc: <span class="number">80</span></span><br><span class="line"> </span><br><span class="line"># 类别列表 class names</span><br><span class="line">names: [<span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;bicycle&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;motorcycle&#x27;</span>, <span class="string">&#x27;airplane&#x27;</span>, <span class="string">&#x27;bus&#x27;</span>, <span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>, <span class="string">&#x27;boat&#x27;</span>, <span class="string">&#x27;traffic light&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;fire hydrant&#x27;</span>, <span class="string">&#x27;stop sign&#x27;</span>, <span class="string">&#x27;parking meter&#x27;</span>, <span class="string">&#x27;bench&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;sheep&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;elephant&#x27;</span>, <span class="string">&#x27;bear&#x27;</span>, <span class="string">&#x27;zebra&#x27;</span>, <span class="string">&#x27;giraffe&#x27;</span>, <span class="string">&#x27;backpack&#x27;</span>, <span class="string">&#x27;umbrella&#x27;</span>, <span class="string">&#x27;handbag&#x27;</span>, <span class="string">&#x27;tie&#x27;</span>, <span class="string">&#x27;suitcase&#x27;</span>, <span class="string">&#x27;frisbee&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;skis&#x27;</span>, <span class="string">&#x27;snowboard&#x27;</span>, <span class="string">&#x27;sports ball&#x27;</span>, <span class="string">&#x27;kite&#x27;</span>, <span class="string">&#x27;baseball bat&#x27;</span>, <span class="string">&#x27;baseball glove&#x27;</span>, <span class="string">&#x27;skateboard&#x27;</span>, <span class="string">&#x27;surfboard&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;tennis racket&#x27;</span>, <span class="string">&#x27;bottle&#x27;</span>, <span class="string">&#x27;wine glass&#x27;</span>, <span class="string">&#x27;cup&#x27;</span>, <span class="string">&#x27;fork&#x27;</span>, <span class="string">&#x27;knife&#x27;</span>, <span class="string">&#x27;spoon&#x27;</span>, <span class="string">&#x27;bowl&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sandwich&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;broccoli&#x27;</span>, <span class="string">&#x27;carrot&#x27;</span>, <span class="string">&#x27;hot dog&#x27;</span>, <span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;donut&#x27;</span>, <span class="string">&#x27;cake&#x27;</span>, <span class="string">&#x27;chair&#x27;</span>, <span class="string">&#x27;couch&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;potted plant&#x27;</span>, <span class="string">&#x27;bed&#x27;</span>, <span class="string">&#x27;dining table&#x27;</span>, <span class="string">&#x27;toilet&#x27;</span>, <span class="string">&#x27;tv&#x27;</span>, <span class="string">&#x27;laptop&#x27;</span>, <span class="string">&#x27;mouse&#x27;</span>, <span class="string">&#x27;remote&#x27;</span>, <span class="string">&#x27;keyboard&#x27;</span>, <span class="string">&#x27;cell phone&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;microwave&#x27;</span>, <span class="string">&#x27;oven&#x27;</span>, <span class="string">&#x27;toaster&#x27;</span>, <span class="string">&#x27;sink&#x27;</span>, <span class="string">&#x27;refrigerator&#x27;</span>, <span class="string">&#x27;book&#x27;</span>, <span class="string">&#x27;clock&#x27;</span>, <span class="string">&#x27;vase&#x27;</span>, <span class="string">&#x27;scissors&#x27;</span>, <span class="string">&#x27;teddy bear&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;hair drier&#x27;</span>, <span class="string">&#x27;toothbrush&#x27;</span>]</span><br></pre></td></tr></table></figure><p><a name="cCzV7"></a></p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>对数据集进行打标签，可以选择如下两种打标工具：<br />Labelbox<br />CVAT<br />也可以使用LabelImg，选用ylolo格式进行标注<br />将标签导出为darknet格式，每个标注图像有一个<em>.txt文件（如果图像中没有对象，则不需要</em>.txt文件），*.txt文件格式如下：</p><p>每行一个对象<br />每行都是：class x_center y_center width height格式<br />框的坐标格式必须采用归一化格式的xywh（从0到1），如果你框以像素为单位，则将x_center和width除以图像宽度，将y_center和height除以图像的高度<br />类别是从索引0开始的<br />通过在器路径名中将/images/<em>.jpg替换为/label/</em>.txt，可以定位每个图像的标签文件，示例图像和标签对为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset<span class="operator">/</span>images<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>jpg  # image</span><br><span class="line">dataset<span class="operator">/</span>labels<span class="operator">/</span>train2017<span class="operator">/</span><span class="number">000000109622.</span>txt  # label</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">45</span> <span class="number">0.479492</span> <span class="number">0.688771</span> <span class="number">0.955609</span> <span class="number">0.5955</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.736516</span> <span class="number">0.247188</span> <span class="number">0.498875</span> <span class="number">0.476417</span></span><br><span class="line"><span class="number">50</span> <span class="number">0.637063</span> <span class="number">0.732938</span> <span class="number">0.494125</span> <span class="number">0.510583</span></span><br><span class="line"><span class="number">45</span> <span class="number">0.339438</span> <span class="number">0.418896</span> <span class="number">0.678875</span> <span class="number">0.7815</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.646836</span> <span class="number">0.132552</span> <span class="number">0.118047</span> <span class="number">0.096937</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.773148</span> <span class="number">0.129802</span> <span class="number">0.090734</span> <span class="number">0.097229</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.668297</span> <span class="number">0.226906</span> <span class="number">0.131281</span> <span class="number">0.146896</span></span><br><span class="line"><span class="number">49</span> <span class="number">0.642859</span> <span class="number">0.079219</span> <span class="number">0.148063</span> <span class="number">0.148062</span></span><br></pre></td></tr></table></figure><p><a name="Fk4Lk"></a></p><h2 id="组织文件结构"><a href="#组织文件结构" class="headerlink" title="组织文件结构"></a>组织文件结构</h2><p><strong><em>/coco128目录应该和yolov5目录同级，同时确保coco128/labels和coco128/images两个目录同级</em></strong><br><img src="4cc9eb4348385e98b15dc0f5db0dc95.png" alt="4cc9eb4348385e98b15dc0f5db0dc95"></p><h2 id="选择训练模型"><a href="#选择训练模型" class="headerlink" title="选择训练模型"></a>选择训练模型</h2><p>上面已经修改了自定义数据集的配置文件，同时组织好了数据。下面就可以选择一个模型进行训练了。</p><p>从./models目录下选择一个模型的配置文件，这里我们选择yolov5s.ymal，这是一个最小最快的模型。关于其他模型之间的比较下面介绍。选择好模型之后，如果你使用的不是coco数据集进行训练，而是自定义的数据集，此时只需要修改*.yaml配置文件中的nc: 80参数和数据的类别列表</p><p>下面是yolo5s.ymal配置文件的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># parameters</span><br><span class="line">nc: <span class="number">80</span>  # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span>  # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span>  # layer channel multiple</span><br><span class="line"> </span><br><span class="line"># anchors</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line"> </span><br><span class="line"># YOLOv5 backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">1</span>, Focus, [<span class="number">64</span>, <span class="number">3</span>]],  # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">128</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">256</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],  # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">9</span>, BottleneckCSP, [<span class="number">512</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, SPP, [<span class="number">1024</span>, [<span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>]]],</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line"># YOLOv5 head</span><br><span class="line">head:</span><br><span class="line">  [[<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],  # <span class="number">9</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],  # <span class="number">13</span></span><br><span class="line"> </span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, <span class="string">&#x27;nearest&#x27;</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat backbone P3</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">256</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">18</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P4</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">512</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">22</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"> </span><br><span class="line">   [<span class="number">-2</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">   [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]],  # cat head P5</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">3</span>, BottleneckCSP, [<span class="number">1024</span>, <span class="literal">False</span>]],</span><br><span class="line">   [<span class="number">-1</span>, <span class="number">1</span>, nn.Conv2d, [na <span class="operator">*</span> (nc <span class="operator">+</span> <span class="number">5</span>), <span class="number">1</span>, <span class="number">1</span>]],  # <span class="number">26</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"> </span><br><span class="line">   [[], <span class="number">1</span>, Detect, [nc, anchors]],  # Detect(P5, P4, P3)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>yolov5s.yaml配置文件中主要定义了：</p><ul><li>参数（parameters）：类别等</li><li>anchor</li><li>YOLOv5 backbone</li><li>YOLOv5 head</li></ul><p><a name="tQOKw"></a></p><h2 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h2><p>运行下面的命令训练coco128.ymal，训练5epochs。可以有两种训练方式，如下参数：</p><p>—cfg yolov5s.yaml —weights ‘’：从头开始训练<br />—cfg yolov5s.yaml —weights yolov5s.pt：从预训练的模型加载开始训练<br />YOLOv5在coco128上训练5epochs的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 16 --epochs 5 --data ./data/coco128.yaml --cfg ./models/yolov5s.yaml --weights &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>训练的更多可选参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--epochs：训练的epoch，默认值300</span></span><br><span class="line"><span class="comment">--batch-size：默认值16</span></span><br><span class="line"><span class="comment">--cfg：模型的配置文件，默认为yolov5s.yaml</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco128.yaml</span></span><br><span class="line"><span class="comment">--img-size：训练和测试输入大小，默认为[640, 640]</span></span><br><span class="line"><span class="comment">--rect：rectangular training，布尔值</span></span><br><span class="line"><span class="comment">--resume：是否从最新的last.pt中恢复训练，布尔值</span></span><br><span class="line"><span class="comment">--nosave：仅仅保存最后的checkpoint，布尔值</span></span><br><span class="line"><span class="comment">--notest：仅仅在最后的epoch上测试，布尔值</span></span><br><span class="line"><span class="comment">--evolve：进化超参数（evolve hyperparameters），布尔值</span></span><br><span class="line"><span class="comment">--bucket：gsutil bucket，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--cache-images：缓存图片可以更快的开始训练，布尔值</span></span><br><span class="line"><span class="comment">--weights：初始化参数路径，默认值&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--name：如果提供，将results.txt重命名为results_name.txt</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--adam：使用adam优化器，布尔值</span></span><br><span class="line"><span class="comment">--multi-scale：改变图片尺寸img-size +/0- 50%，布尔值</span></span><br><span class="line"><span class="comment">--single-cls：训练单个类别的数据集，布尔值</span></span><br></pre></td></tr></table></figure><p><a name="ZacJ9"></a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试的更多可选参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--weights ：预训练模型路径，默认值weights/yolov5s.pt</span></span><br><span class="line"><span class="comment">--data：数据集的配置文件，默认为data/coco.yaml</span></span><br><span class="line"><span class="comment">--batch-size：默认值32</span></span><br><span class="line"><span class="comment">--img-size：推理大小（pixels），默认640</span></span><br><span class="line"><span class="comment">--conf-thres：目标置信度阈值，默认0.001</span></span><br><span class="line"><span class="comment">--iou-thres：NMS的IOU阈值，默认0.65</span></span><br><span class="line"><span class="comment">--save-json：把结果保存为cocoapi-compatible的json文件</span></span><br><span class="line"><span class="comment">--task：默认val，可选其他值：val, test, study</span></span><br><span class="line"><span class="comment">--device：cuda设备，例如：0或0,1,2,3或cpu，默认&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--half：半精度的FP16推理</span></span><br><span class="line"><span class="comment">--single-cls：将其视为单类别，布尔值</span></span><br><span class="line"><span class="comment">--augment：增强推理，布尔值</span></span><br><span class="line"><span class="comment">--verbose：显示类别的mAP，布尔值</span></span><br><span class="line">————————————————</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py <span class="comment">--weights yolov5s.pt --data ./data/coco.yaml --img 640</span></span><br></pre></td></tr></table></figure><p><a name="t0dKT"></a></p><h1 id="实现yolo自由（自训练模型）"><a href="#实现yolo自由（自训练模型）" class="headerlink" title="实现yolo自由（自训练模型）"></a>实现yolo自由（自训练模型）</h1><p>上面的都是官方给出的训练模型，我也尝试了一下训练自己的。<br><a name="Jqm55"></a></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>首先是image的手框转换成yolo文件，我使用的是清华小丑（bushi）给的开源工具<a href="https://www.makesense.ai/">https://www.makesense.ai/</a>生成的。（由于小车上的回传节点还没开始写就用手机try一下）<br><a name="Y2qP3"></a></p><h2 id="yolo环境配置"><a href="#yolo环境配置" class="headerlink" title="yolo环境配置"></a>yolo环境配置</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="operator">/</span><span class="operator">/</span>github.com<span class="operator">/</span>ultralytics<span class="operator">/</span>yolov5 # clone repo</span><br></pre></td></tr></table></figure><p>同上，不过目录结构似乎不太一样(尤其是datasets的部分，差异太多我干脆直接提出来了)<br /></p><p><img src="f299a1faae42c3dfa23869900cfc571.png" alt="f299a1faae42c3dfa23869900cfc571"></p><p>数据集标注好之后，存放如下目录格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$ tree hat_hair_beard</span><br><span class="line">hat_hair_beard</span><br><span class="line">├── images</span><br><span class="line">│   ├── train2017        # 训练集图片，这里我只列举几张示例</span><br><span class="line">│   │   ├── <span class="number">000050.</span>jpg</span><br><span class="line">│   │   ├── <span class="number">000051.</span>jpg</span><br><span class="line">│   │   └── <span class="number">000052.</span>jpg</span><br><span class="line">│   └── val2017          # 验证集图片</span><br><span class="line">│       ├── <span class="number">001800.</span>jpg</span><br><span class="line">│       ├── <span class="number">001801.</span>jpg</span><br><span class="line">│       └── <span class="number">001802.</span>jpg</span><br><span class="line">└── labels               </span><br><span class="line">    ├── train2017       # 训练集的标签文件</span><br><span class="line">    │   ├── <span class="number">000050.</span>txt</span><br><span class="line">    │   ├── <span class="number">000051.</span>txt</span><br><span class="line">    │   └── <span class="number">000052.</span>txt</span><br><span class="line">    └── val2017         # 验证集的标签文件</span><br><span class="line">        ├── <span class="number">001800.</span>txt</span><br><span class="line">        ├── <span class="number">001801.</span>txt</span><br><span class="line">        └── <span class="number">001802.</span>txt</span><br><span class="line"> </span><br><span class="line"><span class="number">6</span> directories, <span class="number">13</span> files</span><br><span class="line">(yolov5) shl<span class="variable">@zfcv</span>:<span class="operator">~</span><span class="operator">/</span>shl<span class="operator">/</span>yolov5$</span><br></pre></td></tr></table></figure><p><a name="UTe92"></a></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><a name="RF2a3"></a></p><h3 id="数据配置文件"><a href="#数据配置文件" class="headerlink" title="数据配置文件"></a>数据配置文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"># COCO128 dataset https:<span class="operator">/</span><span class="operator">/</span>www.kaggle.com<span class="operator">/</span>ultralytics<span class="operator">/</span>coco128 (<span class="keyword">first</span> <span class="number">128</span> images <span class="keyword">from</span> COCO train2017) <span class="keyword">by</span> Ultralytics</span><br><span class="line"># Example usage: python train.py <span class="comment">--data coco128.yaml</span></span><br><span class="line"># parent</span><br><span class="line"># ├── yolov5</span><br><span class="line"># └── datasets</span><br><span class="line">#     └── coco128  ← downloads here (<span class="number">7</span> MB)</span><br><span class="line"></span><br><span class="line"># Train<span class="operator">/</span>val<span class="operator">/</span>test sets <span class="keyword">as</span> <span class="number">1</span>) dir: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs, <span class="number">2</span>) file: path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs.txt, <span class="keyword">or</span> <span class="number">3</span>) list: [path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs1, path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>imgs2, ..]</span><br><span class="line">path: .<span class="operator">/</span>datasets # dataset root dir</span><br><span class="line">train: images<span class="operator">/</span>train_test # train images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">val: images<span class="operator">/</span>val_test # val images (relative <span class="keyword">to</span> <span class="string">&#x27;path&#x27;</span>) <span class="number">128</span> images</span><br><span class="line">test: # test images (optional)</span><br><span class="line"></span><br><span class="line"># Classes</span><br><span class="line">names:</span><br><span class="line">  <span class="number">0</span>: dijia</span><br><span class="line"></span><br><span class="line"># Download script<span class="operator">/</span>URL (optional)</span><br><span class="line">#download: https:<span class="operator">/</span><span class="operator">/</span>ultralytics.com<span class="operator">/</span>assets<span class="operator">/</span>coco128.zip</span><br></pre></td></tr></table></figure><p>主要修改了train和val的路径，以及names的数量和名称（用于测试）<br><a name="fMVyi"></a></p><h3 id="模型配置文件"><a href="#模型配置文件" class="headerlink" title="模型配置文件"></a>模型配置文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># YOLOv5 🚀 <span class="keyword">by</span> Ultralytics, AGPL<span class="number">-3.0</span> license</span><br><span class="line"></span><br><span class="line"># Parameters</span><br><span class="line">nc: <span class="number">1</span> # number <span class="keyword">of</span> classes</span><br><span class="line">depth_multiple: <span class="number">0.33</span> # model depth multiple</span><br><span class="line">width_multiple: <span class="number">0.50</span> # layer channel multiple</span><br><span class="line">anchors:</span><br><span class="line">  <span class="operator">-</span> [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>] # P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>] # P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">  <span class="operator">-</span> [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>] # P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [<span class="keyword">from</span>, number, <span class="keyword">module</span>, args]</span><br><span class="line">  [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">64</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>]], # <span class="number">0</span><span class="operator">-</span>P1<span class="operator">/</span><span class="number">2</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">128</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">1</span><span class="operator">-</span>P2<span class="operator">/</span><span class="number">4</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">128</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">3</span><span class="operator">-</span>P3<span class="operator">/</span><span class="number">8</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">6</span>, C3, [<span class="number">256</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">5</span><span class="operator">-</span>P4<span class="operator">/</span><span class="number">16</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">9</span>, C3, [<span class="number">512</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">1024</span>, <span class="number">3</span>, <span class="number">2</span>]], # <span class="number">7</span><span class="operator">-</span>P5<span class="operator">/</span><span class="number">32</span></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, SPPF, [<span class="number">1024</span>, <span class="number">5</span>]], # <span class="number">9</span></span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"># YOLOv5 v6<span class="number">.0</span> head</span><br><span class="line">head: [</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">6</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, nn.Upsample, [<span class="keyword">None</span>, <span class="number">2</span>, &quot;nearest&quot;]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">4</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat backbone P3</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">256</span>, <span class="literal">False</span>]], # <span class="number">17</span> (P3<span class="operator">/</span><span class="number">8</span><span class="operator">-</span>small)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">256</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">14</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P4</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">512</span>, <span class="literal">False</span>]], # <span class="number">20</span> (P4<span class="operator">/</span><span class="number">16</span><span class="operator">-</span>medium)</span><br><span class="line"></span><br><span class="line">    [<span class="number">-1</span>, <span class="number">1</span>, Conv, [<span class="number">512</span>, <span class="number">3</span>, <span class="number">2</span>]],</span><br><span class="line">    [[<span class="number">-1</span>, <span class="number">10</span>], <span class="number">1</span>, Concat, [<span class="number">1</span>]], # cat head P5</span><br><span class="line">    [<span class="number">-1</span>, <span class="number">3</span>, C3, [<span class="number">1024</span>, <span class="literal">False</span>]], # <span class="number">23</span> (P5<span class="operator">/</span><span class="number">32</span><span class="operator">-</span><span class="keyword">large</span>)</span><br><span class="line"></span><br><span class="line">    [[<span class="number">17</span>, <span class="number">20</span>, <span class="number">23</span>], <span class="number">1</span>, Detect, [nc, anchors]], # Detect(P3, P4, P5)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>这里改个nc就行了（数据集的类别数）<br><a name="ShPbp"></a></p><h2 id="开始训练-1"><a href="#开始训练-1" class="headerlink" title="开始训练"></a>开始训练</h2><p>在终端输入以下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py <span class="comment">--img 640 --batch 8 --epochs 300 --data ./data/test.yaml --cfg ./models/test.yaml --weights ./weights/yolov5s.pt --device cpu</span></span><br></pre></td></tr></table></figure><p>各个参数作用：</p><ul><li>img：640×640</li><li>batch：类别</li><li>epochs：训练迭代次数</li><li>data：数据配置文件位置</li><li>cfg：模型配置文件位置</li><li>weights： 训练权重数据，如果本地没有的话应该会自动下载，以开始训练</li><li>device： 这个还没搞明白 正常来说是应该调用gpu的，但是我的驱动似乎有点问题，故 cpu，启动！</li></ul><p><img src="a5aa4e4d73279a6ea804ffc393a818b.png" alt="a5aa4e4d73279a6ea804ffc393a818b"></p><p>训练结束后，会生成两个预训练的模型：</p><ul><li>best.pt：保存的是中间一共比较好模型</li><li>last.pt：训练结束后保存的最后模型</li></ul><p>尽量把最终训练的模型保存拷贝一份，防止下载再训练给覆盖，白玩<br><a name="g8lUK"></a></p><h3 id="浅浅展示训练成果"><a href="#浅浅展示训练成果" class="headerlink" title="浅浅展示训练成果"></a>浅浅展示训练成果</h3><p><br /><img src="d3b58a358174697795bb89c1d86d4bb.png" alt="d3b58a358174697795bb89c1d86d4bb"></p><p><img src="4edb813049a6da8f7e926d72ebb0357.png" alt="4edb813049a6da8f7e926d72ebb0357"></p><p><img src="d164b7d5fd9b273031ec37aca0e9872.png" alt="d164b7d5fd9b273031ec37aca0e9872"></p><h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 detect.py <span class="comment">--source ./data/images/image_9.png --weights ./weights/best.pt --device cpu</span></span><br></pre></td></tr></table></figure><p>由于数据量较小，准确率较低，就不放图了）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考文献：&lt;br /&gt;&lt;a href=&quot;https://towardsdatascience.com/chess-rolls-or-basketball-lets-create-a-custom-object-detection-model-ef53028eac7d&quot;&gt;A simple way of creating a custom object detection model&lt;/a&gt;（这个就是卓晴教程的原版）&lt;br /&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_28371057/article/details/120598220?ops_request_misc=&amp;amp;request_id=&amp;amp;biz_id=102&amp;amp;utm_term=yolo5&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-120598220.142^v99^control&amp;amp;spm=1018.2226.3001.4187&quot;&gt;YOLOv5的详细使用教程，以及使用yolov5训练自己的数据集_yolo5训练集-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;Ub0k6&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="yolo" scheme="http://zuweicun.top/tags/yolo/"/>
    
  </entry>
  
  <entry>
    <title>高精度算法</title>
    <link href="http://zuweicun.top/2024/04/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <id>http://zuweicun.top/2024/04/02/%E9%AB%98%E7%B2%BE%E5%BA%A6/</id>
    <published>2024-04-02T02:55:06.000Z</published>
    <updated>2025-04-10T15:15:25.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h1><p>在处理数据的时候经常需要用到一些无比巨大的数，比如41856410684191645611这种的，或者是十进制的二进制转化，显然cpp里不能直接用int存放这些数据，然而long类型也是有上限的，这时就需要引入一个新的算法，叫做高精度算法<br><span id="more"></span></p><h2 id="算法本质思想"><a href="#算法本质思想" class="headerlink" title="算法本质思想"></a>算法本质思想</h2><p>感觉多数思路就是用数组之类的容器存放数据，采用最原始的方式一点点进位计算之类的。（果然高端的食材往往采用最朴素的烹饪方式）。</p><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><p>高精度计算中有几个细节需要注意：</p><ul><li><p>数据接受和储存： 当输入的数很长时，可以使用字符串方式输入和储存，再用字符串函数进行操作运算，将每一位去取出，存入数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void init(<span class="type">int</span> a[]) &#123; <span class="comment">// 传入数组</span></span><br><span class="line">    <span class="type">string</span> s;</span><br><span class="line">    cin &gt;&gt; s; </span><br><span class="line">    <span class="built_in">len</span> = s.length(); <span class="comment">// s.length --&gt; 计算字符串位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">len</span>; i++)     </span><br><span class="line">        a[i] = s[<span class="built_in">len</span> -i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//将字符串s转换为数组a, 倒序存储</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进位错位处理：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 加法进位: c[i] = a[i] + b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c[i] <span class="comment">%= 10;</span></span><br><span class="line">            ++c[i++];</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">//减法借位: c[i] = a[i] - b[i]</span><br><span class="line"> </span><br><span class="line">code:    if(a[i] &lt; b[i]) &#123;</span><br><span class="line">             --a[i+<span class="number">1</span>];</span><br><span class="line">             a[i] += <span class="number">10</span>;   </span><br><span class="line">         &#125; </span><br><span class="line"> </span><br><span class="line">//乘法进位: c[i + j - <span class="number">1</span>] = a[i] * b[j] + x + c[i + j - <span class="number">1</span>];</span><br><span class="line">          x = c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">          c[i + j - <span class="number">1</span>] <span class="comment">% 10;</span></span><br></pre></td></tr></table></figure><h3 id="高精度加法："><a href="#高精度加法：" class="headerlink" title="高精度加法："></a>高精度加法：</h3><p>输入两个数到变量中，然后用赋值语句求它们的和后输出 . But，我们知道，在 C++ 语言中任何数据类型都有一定表示范围. 当两个加数很大时，以前的算法显然不能求出精确解，因此我们需要寻求另一种方法 .在读小学时，我们做加法都采用竖式方法 . 这样我们方便写出两个整数相加的算法 .</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度加法</span></span><br><span class="line"><span class="keyword">string</span> add(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = digit1 + digit2 + carry;</span><br><span class="line">        carry = s / <span class="number">10</span>;</span><br><span class="line">        sum = to_string(s % <span class="number">10</span>) + sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度减法</span></span><br><span class="line"><span class="keyword">string</span> subtract(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> borrow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n1 - <span class="number">1</span>, j = n2 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">string</span> diff = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> d = digit1 - digit2 - borrow;</span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            d += <span class="number">10</span>;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        diff = to_string(d) + diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除前导零</span></span><br><span class="line">    diff.erase(<span class="number">0</span>, diff.find_first_not_of(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> (diff == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度乘法</span></span><br><span class="line"><span class="keyword">string</span> multiply(<span class="keyword">string</span> num1, <span class="keyword">string</span> num2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.<span class="keyword">size</span>(), n2 = num2.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; result(n1 + n2, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = mul + result[i + j + <span class="number">1</span>];</span><br><span class="line">            result[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">            result[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换为字符串</span></span><br><span class="line">    <span class="keyword">string</span> product = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(product.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123;  <span class="comment">// 忽略前导零</span></span><br><span class="line">            product += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (product == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 高精度除法（除以低精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, int&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, int divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    int <span class="built_in">remainder</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (char digit : dividend) &#123;</span><br><span class="line">        int <span class="built_in">num</span> = digit - &#x27;<span class="number">0</span>&#x27; + <span class="built_in">remainder</span> * <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">quotient</span> += to_string(<span class="built_in">num</span> / divisor);</span><br><span class="line">        <span class="built_in">remainder</span> = <span class="built_in">num</span> <span class="symbol">%</span> divisor;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="高精度除以高精度"><a href="#高精度除以高精度" class="headerlink" title="高精度除以高精度"></a>高精度除以高精度</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 高精度除法（除以高精度）</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="built_in">divide</span>(<span class="built_in">string</span> dividend, <span class="built_in">string</span> divisor) &#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">quotient</span> = <span class="string">&quot;0&quot;</span>, <span class="built_in">remainder</span> = dividend;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">remainder</span>.size() &gt;= divisor.size() &amp;&amp; <span class="built_in">remainder</span> &gt;= divisor) &#123;</span><br><span class="line">        int n = <span class="built_in">remainder</span>.size() - divisor.size();</span><br><span class="line">        <span class="built_in">string</span> temp = divisor;</span><br><span class="line">        temp.<span class="built_in">append</span>(n, &#x27;<span class="number">0</span>&#x27;); // 补零</span><br><span class="line">        int count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">remainder</span> &gt;= temp) &#123;</span><br><span class="line">            <span class="built_in">remainder</span> = subtract(<span class="built_in">remainder</span>, temp);</span><br><span class="line">            <span class="built_in">quotient</span> = add(<span class="built_in">quotient</span>, <span class="string">&quot;1&quot;</span> + <span class="built_in">string</span>(n, &#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除前导零</span><br><span class="line">    <span class="built_in">quotient</span>.erase(<span class="number">0</span>, <span class="built_in">quotient</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">remainder</span>.erase(<span class="number">0</span>, <span class="built_in">remainder</span>.find_first_not_of(&#x27;<span class="number">0</span>&#x27;));</span><br><span class="line">    <span class="built_in">return</span> make_pair((<span class="built_in">quotient</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">quotient</span>, (<span class="built_in">remainder</span> == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : <span class="built_in">remainder</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压位技巧"><a href="#压位技巧" class="headerlink" title="压位技巧"></a>压位技巧</h3><p>谁说数组每个元素只能是一位数？显然这会造成巨大的浪费。<br>这时我们就可以使用压位的技巧来节省运行时间。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压位技巧高精度加法</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span>(<span class="params"><span class="built_in">string</span> num1, <span class="built_in">string</span> num2</span>)</span> &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">result</span>(<span class="params">max(num1.size(</span>), num2.<span class="title">size</span>()) + 1, 0)</span>; <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="built_in">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">    <span class="built_in">int</span> i = num1.size() - <span class="number">1</span>, j = num2.size() - <span class="number">1</span>, k = result.size() - <span class="number">1</span>; <span class="comment">// 从个位开始相加</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">        <span class="built_in">int</span> digit1 = (i &gt;= <span class="number">0</span>) ? num1[i--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num1的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> digit2 = (j &gt;= <span class="number">0</span>) ? num2[j--] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>; <span class="comment">// 获取num2的当前位数字</span></span><br><span class="line">        <span class="built_in">int</span> sum = digit1 + digit2 + carry; <span class="comment">// 当前位的和</span></span><br><span class="line">        result[k--] = sum % <span class="number">10</span>; <span class="comment">// 将当前位的和放入结果数组</span></span><br><span class="line">        carry = sum / <span class="number">10</span>; <span class="comment">// 更新进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转换结果数组为字符串</span></span><br><span class="line">    <span class="built_in">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> digit : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(sum.empty() &amp;&amp; digit == <span class="number">0</span>)) &#123; <span class="comment">// 忽略前导零</span></span><br><span class="line">            sum += to_string(digit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum == <span class="string">&quot;&quot;</span>) ? <span class="string">&quot;0&quot;</span> : sum; <span class="comment">// 如果结果为空字符串，则返回&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> num1 = <span class="string">&quot;123456789012345678901234567890&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> num2 = <span class="string">&quot;987654321098765432109876543210&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;高精度加法结果：&quot;</span> &lt;&lt; <span class="keyword">add</span>(num1, num2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>总之大多数需要根据现实情况变通。。。。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高精度算法&quot;&gt;&lt;a href=&quot;#高精度算法&quot; class=&quot;headerlink&quot; title=&quot;高精度算法&quot;&gt;&lt;/a&gt;高精度算法&lt;/h1&gt;&lt;p&gt;在处理数据的时候经常需要用到一些无比巨大的数，比如41856410684191645611这种的，或者是十进制的二进制转化，显然cpp里不能直接用int存放这些数据，然而long类型也是有上限的，这时就需要引入一个新的算法，叫做高精度算法&lt;br&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://zuweicun.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="高精度" scheme="http://zuweicun.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>ROS2初步</title>
    <link href="http://zuweicun.top/2024/03/11/ROS2%E5%88%9D%E6%AD%A5/"/>
    <id>http://zuweicun.top/2024/03/11/ROS2%E5%88%9D%E6%AD%A5/</id>
    <published>2024-03-11T12:16:00.000Z</published>
    <updated>2024-09-16T14:18:13.195Z</updated>
    
    <content type="html"><![CDATA[<p><a name="w3PS4"></a></p><h1 id="安装ROS2"><a href="#安装ROS2" class="headerlink" title="安装ROS2"></a>安装ROS2</h1><p>鱼香yyds<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; bash fishros</span><br></pre></td></tr></table></figure><br>卸载ROS<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove ros-foxy-* &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure><br><a name="hoy3W"></a><br><span id="more"></span></p><h1 id="基础概念："><a href="#基础概念：" class="headerlink" title="基础概念："></a>基础概念：</h1><p>与ROS1类似，ROS中同样具有节点，工作空间，功能包等概念<br><a name="ALm4g"></a></p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><a name="RgFga"></a></p><h3 id="每一个节点都负责一个单独的模块。"><a href="#每一个节点都负责一个单独的模块。" class="headerlink" title="每一个节点都负责一个单独的模块。"></a>每一个节点都负责一个单独的模块。</h3><p>举个不太恰当的例子：外卖员小哥外卖给主播小姐姐吃，送累了就刷小姐姐直播跳舞，这里外卖小哥和小姐姐都是一个节点，大家共同构成了一个整体，营造出lianghao社会（bushi）<br />ROS2中的节点也是如此，每一个节点也是只负责一个单独的模块化的功能（比如一个节点负责控制车轮转动，一个节点负责从激光雷达获取数据、一个节点负责处理激光雷达的数据、一个节点负责定位等等）</p><blockquote><p><a name="sQg5i"></a></p><h3 id="节点通信（详见）"><a href="#节点通信（详见）" class="headerlink" title="节点通信（详见）"></a>节点通信（详见）</h3></blockquote><p>ROS2中主要有以下四种通信方式：</p><ul><li>话题-topics</li><li>服务-services</li><li>动作-Action</li><li>参数-parameters</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1709952196063-33689e90-6391-444f-b3f8-054f02b98e34.gif#averageHue=%23faf7fb&amp;clientId=uc1f625e0-63bc-4&amp;from=drop&amp;id=u42629f68&amp;originHeight=480&amp;originWidth=854&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=2993370&amp;status=done&amp;style=none&amp;taskId=u5f22b082-1278-4c51-a0b8-8d390e71c3e&amp;title=" alt="Nodes-TopicandService.gif"></p><p><a name="SasOs"></a></p><h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>需要使用指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;</span><br></pre></td></tr></table></figure><br><a name="qUDBx"></a></p><h3 id="命令行查看节点信息"><a href="#命令行查看节点信息" class="headerlink" title="命令行查看节点信息"></a>命令行查看节点信息</h3><p>这里涉及以下两个概念：</p><ul><li>GUI（Graphical User Interface）就是平常我们说的图形用户界面，大家用的Windows是就是可视化的，我们可以通过鼠标点击按钮等图形化交互完成任务。</li><li><p>CLI（Command-Line Interface）就是命令行界面了，我们所用的终端，黑框框就是命令行界面，没有图形化。<br><a name="JdGKJ"></a></p><h3 id="节点相关CLI："><a href="#节点相关CLI：" class="headerlink" title="节点相关CLI："></a>节点相关CLI：</h3><p>列举几个常用的：<br />运行节点(</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>查看节点列表(常用)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>查看节点信息(常用)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 node listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>重映射节点名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle</span><br></pre></td></tr></table></figure><p><a name="qg3CI"></a></p><h2 id="工作空间-amp-amp-功能包："><a href="#工作空间-amp-amp-功能包：" class="headerlink" title="工作空间&amp;&amp;功能包："></a>工作空间&amp;&amp;功能包：</h2><p>想要找到一个可执行文件（节点）必须依赖于一个功能包，这些包可以统一放在某个工作空间里。<br />创建工作空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p turtle_ws/src</span><br><span class="line"><span class="built_in">cd</span> turtle_ws/src</span><br></pre></td></tr></table></figure><p>功能包：<br />可以理解为存放节点的容器。<br />ROS2中功能包根据编译方式的不同分为三种类型。</p></li><li><p>ament_python，适用于python程序</p></li><li>cmake，适用于C++</li><li><p>ament_cmake，适用于C++程序,是cmake的增强版<br><a name="YUrMN"></a></p><h3 id="功能包获取"><a href="#功能包获取" class="headerlink" title="功能包获取"></a>功能包获取</h3></li><li><p>安装一般使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-&lt;version&gt;-package_name</span><br></pre></td></tr></table></figure></li><li><p>手动编译：有点麻烦，一般都是需要对包进行修改的时候shiytong<br><a name="mddWh"></a></p><h3 id="相关指令——ros2pkg"><a href="#相关指令——ros2pkg" class="headerlink" title="相关指令——ros2pkg"></a>相关指令——ros2pkg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create       Create a new ROS2 package</span><br><span class="line">executables  Output a list of package specific executables</span><br><span class="line">list         Output a list of available packages</span><br><span class="line">prefix       Output the prefix path of a package</span><br><span class="line">xml          Output the XML of the package manifest or a specific tag</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>1.创建功能包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create &lt;package-name&gt;  --build-type  &#123;cmake,ament_cmake,ament_python&#125;  --dependencies &lt;依赖名字&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>2.列出可执行文件</strong><br />列出所有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg executablesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>列出某个功能包的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg executables turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709952853767-34253709-40e1-445a-9df0-99407cbf16e4.png#averageHue=%23262321&amp;clientId=uc1f625e0-63bc-4&amp;from=paste&amp;id=u29043447&amp;originHeight=82&amp;originWidth=430&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u5ab1ac60-bfbc-4ace-97a5-3a014d2af0f&amp;title=" alt=""><br /><strong>3.列出所有的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg listCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>4.输出某个包所在路径的前缀</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg prefix  &lt;package-name&gt;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>比如小乌龟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg prefix turtlesimCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><strong>5.列出包的清单描述文件</strong><br /><strong>每一个功能包都有一个标配的manifest.xml文件，用于记录这个包的名字，构建工具，编译信息，拥有者，干啥用的等信息。</strong><br /><strong>通过这个信息，就可以自动为该功能包安装依赖，构建时确定编译顺序等</strong><br />查看小乌龟模拟器功能包的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg xml turtlesim</span><br></pre></td></tr></table></figure><p><a name="WrcLt"></a></p><h2 id="colcon"><a href="#colcon" class="headerlink" title="colcon:"></a>colcon:</h2><p>colcon其是就是个功能包的构建工具，说白了就是编译器。<br />ros2默认死没有colcon的，所以需要安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-colcon-common-extensions</span><br></pre></td></tr></table></figure><p><a name="BzyYh"></a></p><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p><a name="moZ8W"></a></p><h3 id="5-1-只编译一个包"><a href="#5-1-只编译一个包" class="headerlink" title="5.1 只编译一个包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_51-%e5%8f%aa%e7%bc%96%e8%af%91%e4%b8%80%e4%b8%aa%e5%8c%85">5.1 只编译一个包</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><a name="Mb0AY"></a></p><h3 id="5-2-不编译测试单元"><a href="#5-2-不编译测试单元" class="headerlink" title="5.2 不编译测试单元"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_52-%e4%b8%8d%e7%bc%96%e8%af%91%e6%b5%8b%e8%af%95%e5%8d%95%e5%85%83">5.2 不编译测试单元</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select YOUR_PKG_NAME  --cmake-args -DBUILD_TESTING=0Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><a name="Dt5J5"></a></p><h3 id="5-3-运行编译的包的测试"><a href="#5-3-运行编译的包的测试" class="headerlink" title="5.3 运行编译的包的测试"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_53-%e8%bf%90%e8%a1%8c%e7%bc%96%e8%af%91%e7%9a%84%e5%8c%85%e7%9a%84%e6%b5%8b%e8%af%95">5.3 运行编译的包的测试</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon testCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p><a name="Gacar"></a></p><h3 id="5-4-允许通过更改src下的部分文件来改变install（重要）"><a href="#5-4-允许通过更改src下的部分文件来改变install（重要）" class="headerlink" title="5.4 允许通过更改src下的部分文件来改变install（重要）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.3ROS2%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8Colcon?id=_54-%e5%85%81%e8%ae%b8%e9%80%9a%e8%bf%87%e6%9b%b4%e6%94%b9src%e4%b8%8b%e7%9a%84%e9%83%a8%e5%88%86%e6%96%87%e4%bb%b6%e6%9d%a5%e6%94%b9%e5%8f%98install%ef%bc%88%e9%87%8d%e8%a6%81%ef%bc%89">5.4 允许通过更改src下的部分文件来改变install（重要）</a></h3><p>（每次调整 python 脚本时都不必重新build了）</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build <span class="comment">--symlink-install</span></span><br></pre></td></tr></table></figure><p><a name="DEwTp"></a></p><h2 id="手撸节点test（c-）"><a href="#手撸节点test（c-）" class="headerlink" title="手撸节点test（c++）"></a>手撸节点test（c++）</h2><p>由于python的运行效率实在是一言难尽，我们只学习C++_的版本<br><a name="b6gfN"></a></p><h3 id="创建工作空间-amp-amp-功能包"><a href="#创建工作空间-amp-amp-功能包" class="headerlink" title="创建工作空间&amp;&amp; 功能包"></a>创建工作空间&amp;&amp; 功能包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p town_ws/src</span><br><span class="line"><span class="built_in">cd</span> town_ws/src</span><br><span class="line">ros2 pkg create village_wang --build-type ament_cmake --dependencies rclcpp</span><br></pre></td></tr></table></figure><p>创建完成的目录结构如下：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709953867147-9f288dcf-5e47-4151-9465-e4418685f654.png#averageHue=%23300a24&amp;clientId=u7f35f781-53fd-4&amp;from=drop&amp;id=ua3e86124&amp;originHeight=118&amp;originWidth=212&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=7896&amp;status=done&amp;style=none&amp;taskId=u4fdf03cc-db2e-4232-9a0f-487eae2ca95&amp;title=" alt="image-20210727193256467.png"><br><a name="XZHy1"></a></p><h3 id="POP方式编写节点"><a href="#POP方式编写节点" class="headerlink" title="POP方式编写节点"></a>POP方式编写节点</h3><p>在village_wang/src中创建wang2.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    /*初始化rclcpp</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;rclcpp::Node&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    // 打印一句自我介绍</span><br><span class="line">    RCLCPP_INFO(node-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗wang2.&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数中首先初始化rclcpp，然后新建了一个Node节点的对象，命名为wang2，接着使用rclcpp让这个节点暴露在外面，并检测退出信号（Ctrl+C），检测到退出信号后，就会执行rcl.shutdown()关闭节点。<br><a name="FGd6F"></a></p><h4 id="添加到cmakelists"><a href="#添加到cmakelists" class="headerlink" title="添加到cmakelists"></a>添加到cmakelists</h4><p>在CmakeLists.txt最后一行加入下面两行代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add<span class="constructor">_executable(<span class="params">wang2_node</span> <span class="params">src</span><span class="operator">/</span><span class="params">wang2</span>.<span class="params">cpp</span>)</span></span><br><span class="line">ament<span class="constructor">_target_dependencies(<span class="params">wang2_node</span> <span class="params">rclcpp</span>)</span></span><br></pre></td></tr></table></figure><p>添加这两行代码的目的是让编译器编译wang2.cpp这个文件，不然不会主动编译。接着在上面两行代码下面添加下面的代码。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  wang2_node</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个是C++比Python要麻烦的地方，需要手动将编译好的文件安装到install/village_wang/lib/village_wang下.<br><a name="WfmFe"></a></p><h4 id="编译运行："><a href="#编译运行：" class="headerlink" title="编译运行："></a>编译运行：</h4><p>打开vscode终端，进入town_ws<br><a name="Z1Ujk"></a></p><h3 id="编译节点"><a href="#编译节点" class="headerlink" title="编译节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e7%bc%96%e8%af%91%e8%8a%82%e7%82%b9">编译节点</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build</span><br></pre></td></tr></table></figure><p><a name="FFV99"></a></p><h3 id="source环境"><a href="#source环境" class="headerlink" title="source环境"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=source%e7%8e%af%e5%a2%83">source环境</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> install/setup.bash</span><br></pre></td></tr></table></figure><p><a name="xqzlR"></a></p><h3 id="运行节点"><a href="#运行节点" class="headerlink" title="运行节点"></a><a href="https://fishros.com/d2lros2foxy/#/chapt3/3.6.2POP%E6%96%B9%E6%B3%95%E7%BC%96%E5%86%99C++%E8%8A%82%E7%82%B9%E5%B9%B6%E6%B5%8B%E8%AF%95?id=%e8%bf%90%e8%a1%8c%e8%8a%82%e7%82%b9">运行节点</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run village_wang wang2_node</span><br></pre></td></tr></table></figure><p>不出意外，你可以看到王二的自我介绍。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954465823-94f63561-dbe0-4ac6-90a6-3e3720ef2823.png#averageHue=%231f1d1c&amp;clientId=u7f35f781-53fd-4&amp;from=drop&amp;id=ucbef2116&amp;originHeight=317&amp;originWidth=644&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=105682&amp;status=done&amp;style=none&amp;taskId=u3d85a105-b651-4405-8a1d-378ebd2cea7&amp;title=" alt="a85481a9b56ae5cf6bee46a440140235.png"><br />当节点运行起来后，使用ros2 node list 指令来查看现有的节点。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709954606260-0bd6726b-4a2b-4717-bf95-eba0cac67750.png#averageHue=%23363534&amp;clientId=u7f35f781-53fd-4&amp;from=drop&amp;id=u21cafeca&amp;originHeight=68&amp;originWidth=437&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=14564&amp;status=done&amp;style=none&amp;taskId=ubda76a82-e9ab-43e9-943a-dd83f8acea4&amp;title=" alt="972b7669eb967a31c2a0d959b7301ad9.png"><br><a name="MJsrM"></a></p><h2 id="OPP方式编写节点"><a href="#OPP方式编写节点" class="headerlink" title="OPP方式编写节点"></a>OPP方式编写节点</h2><p>还是在wang2.cpp输入代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleDogNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">SingleDogNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>,name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="mRwWY"></a></p><h3 id="修改cmakelists-amp-amp-运行"><a href="#修改cmakelists-amp-amp-运行" class="headerlink" title="修改cmakelists&amp;&amp;运行"></a>修改cmakelists&amp;&amp;运行</h3><p>同上，不多赘述<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709965221810-a121ef27-b3a9-42f7-a674-f23eee0c3e3b.png#averageHue=%231d1d1c&amp;clientId=u488a9513-274b-4&amp;from=drop&amp;id=u35b36f1c&amp;originHeight=1344&amp;originWidth=1108&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=230404&amp;status=done&amp;style=none&amp;taskId=u6451a532-fc8b-4701-8e02-2a8ab5680a6&amp;title=" alt="8014891cb75b9e90255db630b7115fad.png"><br />运行成功。<br><a name="zvknJ"></a></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>鱼香教程里的举例实在是难以忘却，这里我cv过来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这里的王二和李四两个节点，通过话题来互相通信（传递数据）。</span><br><span class="line"></span><br><span class="line">李四节点会创建一个发布者（Publisher）来发布一个话题（艳娘传奇,小鱼取个英文名叫sexy_girl）。单身汉王二节点，他创建了一个订阅者（Subscriber）来订阅李四发布的话题sexy_girl。</span><br><span class="line"></span><br><span class="line">那艳娘传奇的内容是什么呢？我们暂且规定为由文字组成的字符串（连插图都没的那种）。</span><br><span class="line"></span><br><span class="line">[object Promise]</span><br><span class="line">李四王二通信模型是一个一对一（一个发布者，一个订阅者）的模型，除此之外ROS2中话题通信其实还可以是1对n,n对1,n对n的。</span><br></pre></td></tr></table></figure><p><a name="HgXzG"></a></p><h3 id="话题通讯"><a href="#话题通讯" class="headerlink" title="话题通讯"></a>话题通讯</h3><p><a name="jWcs8"></a></p><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4></li><li><p>话题名字是关键,发布订阅接口类型要相同，发布的是字符串，接受也要用字符串来接收;</p></li><li>同一个人(节点)可以订阅多个话题，同时也可以发布多个话题，就像一本书的作者也可以是另外一本书的读者;</li><li>同一个小说不能有多个作者（版权问题），但跟小说不一样，同一个话题可以有多个发布者。<br><a name="YaREO"></a><h4 id="相关工具："><a href="#相关工具：" class="headerlink" title="相关工具："></a>相关工具：</h4><a name="FnJns"></a><h5 id="rqt-graph"><a href="#rqt-graph" class="headerlink" title="rqt_graph:"></a>rqt_graph:</h5>ROS2作为一个强大的工具，在运行过程中，我们是可以通过命令来看到节点和节点之间的数据关系的。<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709972464260-688eb5ba-8779-4843-ad42-7a00609803f8.png#averageHue=%23e9e9e8&amp;clientId=ud645a189-b8aa-4&amp;from=drop&amp;id=ud5918dcf&amp;originHeight=591&amp;originWidth=761&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=53857&amp;status=done&amp;style=none&amp;taskId=u304193b0-36aa-4ccc-9cbe-cdec436b6b7&amp;title=" alt="image-20210803113450234.png"></li></ul><p><a name="Cm70r"></a></p><h5 id="命令行界面——CLI"><a href="#命令行界面——CLI" class="headerlink" title="命令行界面——CLI"></a>命令行界面——CLI</h5><p>返回系统活动所有主题列表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list</span><br></pre></td></tr></table></figure><br>增加消息类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic list -t</span><br></pre></td></tr></table></figure><br>打印实时话题内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic <span class="built_in">echo</span> /chatter</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>查看主题信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic info  /chatter</span><br></pre></td></tr></table></figure><br>查看消息类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure><br>手动发布命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 topic pub /chatter std_msgs/msg/String <span class="string">&#x27;data: &quot;123&quot;&#x27;</span></span><br></pre></td></tr></table></figure><br><a name="B7agU"></a></p><h3 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h3><p>创建话题订阅者的一般流程：</p><ol><li>导入订阅的话题接口类型</li><li>创建订阅回调函数</li><li>声明并创建订阅者</li><li>编写订阅回调处理逻辑<br><a name="vIZWC"></a><h3 id="王三"><a href="#王三" class="headerlink" title="王三"></a>王三</h3></li></ol><ul><li><p>将wang2.cpp代码修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;rclcpp/rclcpp.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/string.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;std_msgs/msg/u_int32.hpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using std::placeholders::_1;</span><br><span class="line">using std::placeholders::_2;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    创建一个类节点，名字叫做SingleDogNode,继承自Node.</span><br><span class="line">*/</span><br><span class="line">class SingleDogNode : public rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    // 构造函数,有一个参数为节点名称</span><br><span class="line">    SingleDogNode(std::string name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">        // 打印一句自我介绍</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;大家好，我是单身狗%s.&quot;</span>, name.c_str());</span><br><span class="line">         // 创建一个订阅者来订阅李四写的小说，通过名字sexy_girl</span><br><span class="line">        sub_novel = this-&gt;create_subscription&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, 10, std::<span class="built_in">bind</span>(&amp;SingleDogNode::topic_callback, this, _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 声明一个订阅者（成员变量）,用于订阅小说</span><br><span class="line">    rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr sub_novel;</span><br><span class="line"></span><br><span class="line">    // 收到话题数据的回调函数</span><br><span class="line">    void topic_callback(const std_msgs::msg::String::SharedPtr msg)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;朕已阅：&#x27;%s&#x27;&quot;</span>, msg-&gt;data.c_str());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    rclcpp::init(argc, argv);</span><br><span class="line">    /*产生一个Wang2的节点*/</span><br><span class="line">    auto node = std::make_shared&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    /* 运行节点，并检测退出信号*/</span><br><span class="line">    rclcpp::spin(node);</span><br><span class="line">    rclcpp::shutdown();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用C++订阅话题，需要添加对应的消息类型头文件：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">string.hpp</span>&quot;</span></span><br><span class="line"><span class="meta">#include &quot;<span class="string">std_msgs</span>/<span class="string">msg</span>/<span class="string">u_int</span>32.<span class="string">hpp</span>&quot;</span></span><br></pre></td></tr></table></figure><p>创建订阅者和发布者时依然使用this-&gt;create_subscription和this-&gt;create_publisher方法。<br />C++中创建一个订阅者，需要传入话题类型、话题名称、所要绑定的回调函数，以及通信Qos.<br /><strong>std::bind()</strong><br /><strong>C++的类成员函数不能像普通函数那样用于回调，因为每个成员函数都需要有一个对象实例去调用它。 通常情况下，要实现成员函数作为回调函数：一种过去常用的方法就是把该成员函数设计为静态成员函数（因为类的成员函数需要隐含的this指针 而回调函数没有办法提供），但这样做有一个缺点，就是会破坏类的结构性，因为静态成员函数只能访问该类的静态成员变量和静态成员函数，不能访问非静态的，要解决这个问题，可以把对象实例的指针或引用做为参数传给它。 后面就可以靠这个对象实例的指针或引用访问非静态成员函数。另一种办法就是使用std::bind和std::function结合实现回调技术。(目前还看不太懂)</strong></p></li><li><p>编译运行</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure></li><li><p>source运行<br><a name="KES9k"></a></p><h3 id="李四"><a href="#李四" class="headerlink" title="李四"></a>李四</h3><p>突然发现李四的源码在教程里没有，自己搓了个试试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的数组</span></span><br><span class="line">std::string novel[] = &#123;</span><br><span class="line"><span class="string">&quot;第一回：潋滟湖 1 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第二回：潋滟湖 2 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第三回：潋滟湖 3 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第四回：潋滟湖 4 次偶遇胡艳娘&quot;</span>,</span><br><span class="line"><span class="string">&quot;第五回：潋滟湖 5 次偶遇胡艳娘&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个小说内容的索引</span></span><br><span class="line"><span class="type">int</span> nb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个类节点，名字叫做WriterNode,继承自Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriterNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数,有一个参数为节点名称</span></span><br><span class="line"><span class="built_in">WriterNode</span>(std::string name) : <span class="built_in">Node</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一句自我介绍</span></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;大家好，我是%s,我是一名作家！&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建一个发布者来发布小说内容，通过名字sexy_girl</span></span><br><span class="line">    pub_novel = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;sexy_girl&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 创建一个定时器，每隔五秒发布一章小说内容</span></span><br><span class="line">    timer = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>), std::<span class="built_in">bind</span>(&amp;WriterNode::timer_callback, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 声明一个发布者（成员变量）,用于发布小说内容</span></span><br><span class="line">rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr pub_novel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个定时器（成员变量）,用于定时发布小说内容</span></span><br><span class="line">rclcpp::TimerBase::SharedPtr timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器触发的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 新建一个小说内容的消息</span></span><br><span class="line">    std_msgs::msg::String novel_msg;</span><br><span class="line">    <span class="comment">// 判断小说内容的索引是否超出数组范围</span></span><br><span class="line">    <span class="keyword">if</span> (nb &lt; <span class="built_in">sizeof</span>(novel) / <span class="built_in">sizeof</span>(novel[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取小说内容</span></span><br><span class="line">        novel_msg.data = novel[nb];</span><br><span class="line">        <span class="comment">// 发布小说内容</span></span><br><span class="line">        pub_novel-&gt;<span class="built_in">publish</span>(novel_msg);</span><br><span class="line">        <span class="comment">// 打印发布的小说内容</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;发布小说内容：%s&quot;</span>, novel_msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">// 小说内容的索引加一</span></span><br><span class="line">        nb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 小说内容已经发布完毕，取消定时器</span></span><br><span class="line">        timer-&gt;<span class="built_in">cancel</span>();</span><br><span class="line">        <span class="comment">// 打印结束语</span></span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;小说已经完结，感谢大家的支持！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv); <span class="comment">// 初始化rclcpp</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;WriterNode&gt;(<span class="string">&quot;li4&quot;</span>); <span class="comment">// 新建一个节点</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node); <span class="comment">// 保持节点运行，检测是否收到退出指令（Ctrl+C）</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>(); <span class="comment">// 关闭rclcpp</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Ctrl+Shift+5切分一个终端出来，输入下面命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 run  village_li  li4_node</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1709973381445-1adfa01f-8fab-4b2e-862b-37be052c45b0.png#averageHue=%232e2e2e&amp;clientId=ud645a189-b8aa-4&amp;from=drop&amp;id=u0011d78d&amp;originHeight=243&amp;originWidth=1362&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=120502&amp;status=done&amp;style=none&amp;taskId=u430b4fc9-7dae-41d0-813a-b956f4cda2a&amp;title=" alt="image-20210804074600329.png"><br><a name="ffgNa"></a></p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>C++中创建一个发布者也比较简单，使用this-&gt;create_publisher即可创建一个发布者。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pub_</span> = this-&gt;create_publisher&lt;std_msgs::msg::UInt32&gt;(<span class="string">&quot;sexy_girl_money&quot;</span>,<span class="number">10</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这里提供了三个参数，分别是该发布者要发布的话题名称（sexy_girl_money）、发布者要发布的话题类型（std_msgs::msg::UInt32）、Qos（10）<br><a name="hnt3J"></a></p><h3 id="服务和接口"><a href="#服务和接口" class="headerlink" title="服务和接口"></a>服务和接口</h3><p><a name="RpsO0"></a></p><h3 id="接口：接口其实是一种规范"><a href="#接口：接口其实是一种规范" class="headerlink" title="接口：接口其实是一种规范"></a>接口：接口其实是一种规范</h3><p>当接口类型统一的时候，适配显然就不是问题了，大家的服务和响应都是一致的规范格式<br><a name="MYwEG"></a></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><a name="eTGJG"></a></p><h5 id="查看接口列表（当前环境下）"><a href="#查看接口列表（当前环境下）" class="headerlink" title="查看接口列表（当前环境下）"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_41%e6%9f%a5%e7%9c%8b%e6%8e%a5%e5%8f%a3%e5%88%97%e8%a1%a8%ef%bc%88%e5%bd%93%e5%89%8d%e7%8e%af%e5%a2%83%e4%b8%8b%ef%bc%89">查看接口列表（当前环境下）</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface list</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811318-9c2e1b9d-119d-4c2d-80ee-8b9effa311de.png#averageHue=%23282828&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=u6b0684ac&amp;originHeight=366&amp;originWidth=700&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ueea0a066-269f-4a44-908b-66eff688a8a&amp;title=" alt=""><br><a name="gfepk"></a></p><h5 id="查看所有接口包"><a href="#查看所有接口包" class="headerlink" title="查看所有接口包"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_42%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3%e5%8c%85">查看所有接口包</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface packages</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811026-b7326182-2b56-499b-bf97-5580abcd8c68.png#averageHue=%23252525&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=uc9cacca0&amp;originHeight=500&amp;originWidth=444&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uba98428e-3d16-4193-926e-7b18b031853&amp;title=" alt=""><br><a name="EDlMf"></a></p><h5 id="查看某一个包下的所有接口"><a href="#查看某一个包下的所有接口" class="headerlink" title="查看某一个包下的所有接口"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_43%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e5%8c%85%e4%b8%8b%e7%9a%84%e6%89%80%e6%9c%89%e6%8e%a5%e5%8f%a3">查看某一个包下的所有接口</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface package std_msgs</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811203-ae44eadd-e3cf-41ce-8f6e-17452d028e89.png#averageHue=%23262626&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=u11110c34&amp;originHeight=246&amp;originWidth=669&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue6b53307-54e5-482e-9233-ae6dfa80bfa&amp;title=" alt=""><br><a name="kgaGi"></a></p><h5 id="查看某一个接口详细的内容"><a href="#查看某一个接口详细的内容" class="headerlink" title="查看某一个接口详细的内容"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_44%e6%9f%a5%e7%9c%8b%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e8%af%a6%e7%bb%86%e7%9a%84%e5%86%85%e5%ae%b9">查看某一个接口详细的内容</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface show std_msgs/msg/String</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811860-73d814e9-0ad4-4f3c-8b03-cc84d50b8e00.png#averageHue=%23292929&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=uff812660&amp;originHeight=114&amp;originWidth=764&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufbd1877f-055c-45bb-b469-d1c4c124258&amp;title=" alt=""><br><a name="YVXNq"></a></p><h5 id="输出某一个接口所有属性"><a href="#输出某一个接口所有属性" class="headerlink" title="输出某一个接口所有属性"></a><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.5ROS2%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D?id=_45-%e8%be%93%e5%87%ba%e6%9f%90%e4%b8%80%e4%b8%aa%e6%8e%a5%e5%8f%a3%e6%89%80%e6%9c%89%e5%b1%9e%e6%80%a7">输出某一个接口所有属性</a></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 interface proto sensor_msgs/msg/Image</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710036811870-5f07a163-7673-4f56-a3c5-337c13939d9a.png#averageHue=%23212121&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=paste&amp;id=u9b08528d&amp;originHeight=208&amp;originWidth=611&amp;originalType=url&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf0315698-41a2-4e5e-b260-a5dff7aa66e&amp;title=" alt=""></p></li></ul><p><a name="PJTRk"></a></p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>显然，服务和话题的区别在于话题是没有返回的，只是单向的数据传递。而服务是双向的客户端发送，服务端响应。<br><a name="JJ4MV"></a></p><h3 id="自定义话题接口"><a href="#自定义话题接口" class="headerlink" title="自定义话题接口"></a>自定义话题接口</h3><ul><li>新建工作空间</li></ul><p>在town_ws的src文件夹下，运行下面的指令，即可完成village_interfaces功能包的创建。    <br />     <strong>注意，这里包的编译类型我们使用ament_cmake方式。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create village_interfaces --build-type ament_cmake </span><br></pre></td></tr></table></figure><br><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037304935-3b720491-175f-421f-b8b8-cd410932ca33.png#averageHue=%23212121&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u0e50a9c7&amp;originHeight=179&amp;originWidth=503&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=15650&amp;status=done&amp;style=none&amp;taskId=u951c0305-6102-4c35-885a-e55d3f3c93b&amp;title=" alt="image-20210809151545012.png"></p><ul><li>新建msg文件和Novel.msg（小说消息）</li></ul><p><strong>注意:msg文件开头首字母一定要大写，ROS2强制要求，盲猜应该是为了和类名保持一致</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd village_interfaces</span><br><span class="line">mkdir msg</span><br><span class="line">touch Novel.msg </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ul><li>编写Novel.msg内容</li></ul><p>我们的目的是给李四的小说每一章增加一张图片，原来李四写小说是对外发布一个std_msgs/msg/String字符串类型的数据。<br />而发布图片的格式，我们需要采用ros自带的传感器消息接口中的图片sensor_msgs/msg/Image数据类型，所以我们新的消息文件的内容就是将两者合并，在ROS2中可以写做这样：<br /><strong>在msg文件中可以使用#号添加注释。</strong><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">#</span> 标准消息接口<span class="type">std_msgs</span>下的<span class="built_in">String</span>类型</span><br><span class="line"><span class="type">std_msgs</span><span class="operator">/</span><span class="built_in">String</span> <span class="variable">content</span></span><br><span class="line"><span class="type">#</span> 图像消息，调用<span class="type">sensor_msgs</span>下的<span class="built_in">Image</span>类型</span><br><span class="line"><span class="type">sensor_msgs</span><span class="operator">/</span><span class="built_in">Image</span> <span class="variable">image</span></span><br></pre></td></tr></table></figure><br>这种组合结构图如下：<br />[object Promise]<br />这个图一共三层，第一层是消息定义层，第二层是ROS2已有的std_msgs,sensor_msgs，其组成关系是由下一层组合成上一层。<br />最下面一层string、uint8、uint32是ROS2中的原始数据类型，原始数据类型有下面几种，ROS2中所有的接口都是由这些原始数据类型组成。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="type">byte</span></span><br><span class="line">char</span><br><span class="line"><span class="type">float32</span>,<span class="type">float64</span></span><br><span class="line"><span class="type">int8</span>,<span class="type">uint8</span></span><br><span class="line"><span class="type">int16</span>,<span class="type">uint16</span></span><br><span class="line"><span class="type">int32</span>,<span class="type">uint32</span></span><br><span class="line"><span class="type">int64</span>,<span class="type">uint64</span></span><br><span class="line"><span class="type">string</span></span><br></pre></td></tr></table></figure></p><ul><li>Another way</li></ul><p>我们不使用std_msgs/String 而是直接使用最下面一层的string。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure></p><ul><li>说明</li></ul><p>如何知道，std_msgs/String是由基础数据类型string组成的，其实可以通过下面的指令来查看<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">show</span> <span class="symbol">std_msgs</span>/<span class="symbol">msg</span>/<span class="symbol">String</span></span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">string</span> <span class="class"><span class="keyword">data</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>原来std_msgs的String就是包含一个叫变量名为data的string类型变量，这也是在4.2和4.3章节中代码要用.data才能拿到真正的数据的原因：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> <span class="built_in">String</span></span><br><span class="line">msg = <span class="built_in">String</span>()</span><br><span class="line">msg.data = <span class="string">&#x27;第%d回：潋滟湖 %d 次偶遇胡艳娘&#x27;</span> % (self.i,self.i)</span><br><span class="line"><span class="comment"># msg 是 std_msgs.msg.String() 的对象</span></span><br><span class="line"><span class="comment"># msg.data data是string类型的对象，其定义是string data</span></span><br></pre></td></tr></table></figure><br>最终Novel.msg<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用ROS2原始的数据类型</span></span><br><span class="line"><span class="built_in">string</span> content</span><br><span class="line"><span class="comment"># 图像消息，调用sensor_msgs下的Image类型</span></span><br><span class="line">sensor_msgs/Image image</span><br></pre></td></tr></table></figure></p><ul><li>修改Cmakelists.txt</li></ul><p>完成了代码的编写还不够，我们还需要在CMakeLists.txt中告诉编译器，你要给我把Novel.msg转换成Python库和C++的头文件。<br />直接添加下面的代码到CMakeLists.txt即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#添加对sensor_msgs的</span><br><span class="line"><span class="built_in">find_package</span>(sensor_msgs REQUIRED)</span><br><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line">#添加消息文件和依赖</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line"><span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">    DEPENDENCIES sensor_msgs</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><br>find_package用于查找rosidl_default_generators位置，下面rosidl_generate_interfaces就是声明msg文件所属的工程名字、文件位置以及依赖DEPENDENCIES。<br /><strong>踩坑报告：</strong></p><ul><li><strong>重点强调一下依赖部分DEPENDENCIES，我们消息中用到的依赖这里必须写上，即使不写编译器也不会报错，直到运行的时候才会出错。</strong></li><li><strong>而且rosidl_generate_interfaces()</strong> 函数必须在 <strong>ament_package()</strong> 函数之前调用。</li></ul><p>代码大概是这样的<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038380883-6becece5-b4cd-4c3d-bc11-cdcffa9dcf1d.png#averageHue=%23201f1f&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=ua4ec7301&amp;originHeight=843&amp;originWidth=1469&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=471267&amp;status=done&amp;style=none&amp;taskId=u795fc122-a6a1-4427-9f9d-d20f8507983&amp;title=" alt="e3877412c40448c0995ba2884a1ae7c1.png"></p><ul><li>修改package.xml</li></ul><p>修改village_interfaces目录下的package.xml，添加下面三行代码，为工程添加一下所需的依赖。<br /><strong>这里其实不添加也可以</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>sensor_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure><br>代码位置：<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037769727-982ef5d8-77a3-446a-9035-8861ead0bf4e.png#averageHue=%23201f1f&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u06f1f241&amp;originHeight=492&amp;originWidth=1099&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=105921&amp;status=done&amp;style=none&amp;taskId=u1930cd93-9480-4455-b99b-a9971abac6c&amp;title=" alt="image-20210816145202732.png"></p><ul><li>编译</li></ul><p>回到town_ws<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_interfaces</span><br></pre></td></tr></table></figure></p><ul><li>验证</li></ul><p>过上节课说过的ros2 interface常用的命令来测试。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 <span class="keyword">interface</span> <span class="symbol">package</span> <span class="symbol">village_interfaces</span>  #查看包下所有接口</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">show</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #查看内容</span><br><span class="line"><span class="symbol">ros2</span> <span class="symbol">interface</span> <span class="symbol">proto</span> <span class="symbol">village_interfaces</span>/<span class="symbol">msg</span>/<span class="symbol">Novel</span> #显示属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><a name="zucuy"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710037813556-ec2ce503-73b2-4496-ad09-0d176cf48bdb.png#averageHue=%23242424&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u580048f1&amp;originHeight=367&amp;originWidth=751&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=58470&amp;status=done&amp;style=none&amp;taskId=u39622192-29e6-41b5-9414-a9b8c7ed920&amp;title=" alt="image-20210816145503946.png"></h3><p>我们可以在运行结果中看到，Novel的消息内容是由content数据和传感器数据image共同组成的了。</p><p><a name="vtOSp"></a></p><h3 id="服务："><a href="#服务：" class="headerlink" title="服务："></a>服务：</h3><ul><li>服务：客户端发送请求给服务端，服务端可以根据客户端的请求做一些处理，然后返回结果给客户端。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035790713-136e7676-715a-48d2-92ad-41e569c869f1.gif#averageHue=%23fcf9fd&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=PMpbD&amp;originHeight=480&amp;originWidth=854&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=380270&amp;status=done&amp;style=none&amp;taskId=u365753d7-dbb5-4e03-9548-c451b5f740a&amp;title=" alt="Service-SingleServiceClient.gif"><br /><img src="https://cdn.nlark.com/yuque/0/2024/gif/39221021/1710035797325-0dfe07bb-99eb-4afc-9625-737c1827a667.gif#averageHue=%2394a2cc&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=mTDBy&amp;originHeight=480&amp;originWidth=854&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=898464&amp;status=done&amp;style=none&amp;taskId=u4ef526f9-0e06-43be-ab48-beff9eb1ad0&amp;title=" alt="Service-MultipleServiceClient.gif"></p><p>下面操作一下ros2自带的样例服务：<br><a name="ZLIvy"></a></p><h4 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h4><p>运行一个服务节点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 run examples_rclpy_minimal_service service</span><br><span class="line"><span class="comment">//服务的功能是将两个数字相加，给定a，b两个数，返回sum也就是ab之和</span></span><br></pre></td></tr></table></figure><br><a name="OhYmw"></a></p><h5 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 service list</span><br></pre></td></tr></table></figure><p><a name="ZNyUa"></a></p><h5 id="手动调用服务（一定要注意a：-b-的空格）"><a href="#手动调用服务（一定要注意a：-b-的空格）" class="headerlink" title="手动调用服务（一定要注意a：  b: 的空格）"></a>手动调用服务（一定要注意a：  b: 的空格）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts <span class="string">&quot;&#123;a: 5,b: 10&#125;&quot;</span></span><br><span class="line"><span class="comment">//需要再启动一个终端</span></span><br></pre></td></tr></table></figure><p><a name="RHF6C"></a></p><h5 id="查看服务接口类型"><a href="#查看服务接口类型" class="headerlink" title="查看服务接口类型"></a>查看服务接口类型</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 service type /add_two_ints</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="AIADv"></a></p><h5 id="查找使用某一接口的服务"><a href="#查找使用某一接口的服务" class="headerlink" title="查找使用某一接口的服务"></a>查找使用某一接口的服务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ros2 service find example_interfaces/srv/AddTwoInts</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="X9wyU"></a></p><h4 id="自定义服务接口"><a href="#自定义服务接口" class="headerlink" title="自定义服务接口"></a>自定义服务接口</h4><p>我们来看一下服务的消息接口长什么样子？<br />服务接口格式：xxx.srv<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int64 a</span><br><span class="line"><span class="section">int64 b</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line">int64 sum</span><br></pre></td></tr></table></figure><br>与话题不同的是，srv文件比msg文件中间多出了三个—-这三个杠杠就是分界线，上方的是客户端发送请求的数据结构定义，下方的是服务端响应结果的数据结构定义。<br />参考下面的步骤：</p><ul><li>新建srv文件夹，并在文件夹下新建xxx.srv</li><li>在xxx.srv下编写服务接口内容并保存</li><li>在CmakeLists.txt添加依赖和srv文件目录</li><li>在package.xml中添加xxx.srv所需的依赖</li><li>编译功能包即可生成python与c++头文件</li></ul><p>当然在做上面的步骤之前，我们还需要做一件很重要的事情。就是根据业务需求，确定好请求的数据结构和返回的数据结构。我们依然是在village_interfaces下创建服务接口。<br />开始之前，我们先根据李四的需求来确定数据结构。<br />上一节中李四对借钱的要求如下：</p><ol><li>借钱一定要打欠条，收到欠条才能给钱</li><li>每次借钱不能超过自己全部资金的10%且一定是整数，也就是说李四假如现在有100块钱，那么最多借出去100x10%=10块钱</li></ol><p>总结一下就是，李三发送借钱请求的时候一定要有欠条，我们想一下，欠条中应该至少包含两条信息</p><ul><li>借钱者名字，字符串类型、可以用string表示</li><li>金额，整形，可以用uint32表示</li></ul><p>那请求的数据结构我们就可以确定下来了，接着确定返回的数据的格式。<br />既然是借钱，那李四就有可能拒绝，会有借钱失败的情况，所以返回数据应该有这两条信息：</p><ul><li>是否出借：只有成功和失败两种情况，布尔类型（bool）可表示</li><li><p>出借金额：无符号整形，可以用uint32表示，借钱失败时为0。<br><a name="SOi0x"></a></p><h5 id="创建srv文件夹及BorrowMoney-srv消息文件"><a href="#创建srv文件夹及BorrowMoney-srv消息文件" class="headerlink" title="创建srv文件夹及BorrowMoney.srv消息文件"></a>创建srv文件夹及BorrowMoney.srv消息文件</h5><p>在village_interfaces下新建srv文件夹<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710038764606-c8035912-d3b5-4a18-8758-978165a7a504.png#averageHue=%23222222&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u87e80afd&amp;originHeight=160&amp;originWidth=471&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=14984&amp;status=done&amp;style=none&amp;taskId=u6fcc9d9a-d569-433f-86c9-0a6ed8b969f&amp;title=" alt="image-20210811162010736.png"><br><a name="yxyCD"></a></p><h5 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint32 money</span><br><span class="line">---</span><br><span class="line"><span class="type">bool</span> success</span><br><span class="line">uint32 money</span><br></pre></td></tr></table></figure><p><a name="efh5K"></a></p><h5 id="修改Cmakelists-txt"><a href="#修改Cmakelists-txt" class="headerlink" title="修改Cmakelists.txt"></a>修改Cmakelists.txt</h5><p>我们已经添加过依赖DEPENDENCIES和msg文件了，所以这里我们直接添加一个srv即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(rosidl_default_generators REQUIRED)</span><br><span class="line"><span class="built_in">rosidl_generate_interfaces</span>($&#123;PROJECT_NAME&#125;</span><br><span class="line">  #---msg---</span><br><span class="line">  <span class="string">&quot;msg/Novel.msg&quot;</span></span><br><span class="line">  #---srv---</span><br><span class="line">  <span class="string">&quot;srv/BorrowMoney.srv&quot;</span></span><br><span class="line">  DEPENDENCIES sensor_msgs</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>需要关注的是这一行”srv/BorrowMoney.srv”,添加了对应的文件位置。</p></li><li><p>踩坑：在rosidl_generate_interfaces()函数中传递了一个依赖项sensor_msgs，但是在使用find_package()函数之前没有找到它。需要在CMakeLists.txt 文件中添加find_package(sensor_msgs REQUIRED)，以确保 <strong>sensor_msgs</strong> 包被正确地找到和链接。<br><a name="io4wO"></a></p><h5 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改package.xml</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;sensor_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;</span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="Ink82"></a></p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --packages-select village_interfaces</span><br></pre></td></tr></table></figure><p><a name="lVN2C"></a></p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>这次测试我们依然使用ros2 interface指令进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash </span><br><span class="line">ros2 interface package village_interfaces</span><br><span class="line">ros2 interface show village_interfaces/srv/BorrowMoney</span><br><span class="line">ros2 interface proto village_interfaces/srv/BorrowMoney </span><br></pre></td></tr></table></figure><p><a name="uONPm"></a></p><h4 id="服务的c-实现"><a href="#服务的c-实现" class="headerlink" title="服务的c++实现"></a>服务的c++实现</h4><p><strong>一句话：张三拿多少钱钱给王二，王二凑够多少个章节的艳娘传奇给他，可参考以下步骤</strong></p></li></ul><ol><li>导入服务接口</li><li>创建服务端回调函数</li><li>声明并创建服务端</li><li>编写回调函数逻辑处理请求<br><a name="c7FPU"></a><h5 id="添加接口-amp-amp-依赖"><a href="#添加接口-amp-amp-依赖" class="headerlink" title="添加接口&amp;&amp;依赖"></a>添加接口&amp;&amp;依赖</h5>因为village_wang的包类型是ament_cmake，故需要进行以下两步操作：<br /><strong>第一步修改package.xml</strong><br />加入下面的代码（告诉colcon，编译之前要确保有village_interfaces存在）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;depend&gt;village_interfaces&lt;/depend&gt;</span><br></pre></td></tr></table></figure><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710039585985-a81f2aa8-b41e-461b-bc89-2642cab063a3.png#averageHue=%23222120&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=ud2b27244&amp;originHeight=109&amp;originWidth=542&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=18085&amp;status=done&amp;style=none&amp;taskId=u0cad5214-f47f-4485-a806-092b7a4e5d0&amp;title=" alt="image-20210816153438400.png"><br /><strong>第二步修改和CMakeLists.txt</strong><br />在CMakeLists.txt中加入下面一行代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(village_interfaces REQUIRED)</span><br></pre></td></tr></table></figure><strong>find_package是cmake的语法，用于查找库。找到后，还需要将其和可执行文件链接起来</strong><br />所以还需要修改ament_target_dependencies，在其中添加village_interfaces。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ament_target_dependencies</span>(wang2_node </span><br><span class="line">  rclcpp </span><br><span class="line">  village_interfaces</span><br><span class="line">)</span><br></pre></td></tr></table></figure>对于C++来说，添加服务接口只需在程序中引入对应的头文件即可。<br /><strong>这个头文件就是我们SellNovel.srv生成的头文件</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;village_interfaces/srv/sell_novel.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><a name="Fhg7q"></a><h5 id="声明回调函数"><a href="#声明回调函数" class="headerlink" title="声明回调函数"></a>声明回调函数</h5>添加完服务接口接着就可以声明一个<strong>卖书请求回调函数</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sell_book_callback</span><span class="params">(<span class="type">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>再创建一个队列，用于存放自己看过的二手书，创建队列需要用到queue容器，所以我们先用#include <queue>在程序开头引入该容器，再在代码中添加下面这句话。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个小说章节队列</span></span><br><span class="line">std::queue&lt;std::string&gt;  novels_queue;</span><br></pre></td></tr></table></figure><br><a name="LaIsk"></a></p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>当张三请求王二买二手书的时候，假如王二手里书的数量不足，王二就等攒够了对应数量的书再返回给张三。<br />等待攒够章节的操作需要在卖书服务函数中阻塞当前线程，阻塞后王二就收不到李四写的小说了，这样一来就会造成一个很尴尬的情景：<br /><strong>在卖书服务回调函数中等着书库（队列）里小说章节数量满足张三需求，接收小说的程序等着这边的卖书回调函数结束，好把书放进书库（队列）里。</strong><br />这种互相等待的情况，我们称之为死锁<br />ROS2默认是单线程的，同时只有一个线程在跑，大家都是顺序执行，你干完我干，一条线下去。<br />所以为了解决这个问题，我们可以使用多线程，即每次收到服务请求后，单独开一个线程来处理，不影响其他部分。<br><a name="aZhlq"></a></p><h5 id="回调函数组"><a href="#回调函数组" class="headerlink" title="回调函数组"></a>回调函数组</h5><p>ROS2中要使用多线程执行器和回调组来实现多线程，我们先在SingleDogNode中声明一个回调组成员变量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务回调组</span></span><br><span class="line">rclcpp::CallbackGroup::SharedPtr callback_group_service_;</span><br></pre></td></tr></table></figure><br>最终结果<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class SingleDogNode : <span class="keyword">public</span> rclcpp<span class="type">::Node</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    SingleDogNode(std<span class="type">::string</span> name) : Node(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 声明一个服务回调组</span></span><br><span class="line">    rclcpp<span class="type">::CallbackGroup</span><span class="type">::SharedPtr</span> callback_group_service_;</span><br><span class="line">    <span class="comment">//创建一个小说章节队列</span></span><br><span class="line">    std<span class="type">::queue</span>&lt;std<span class="type">::string</span>&gt;  novels_queue;</span><br><span class="line">    <span class="comment">// 声明一个服务端</span></span><br><span class="line">    rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br><span class="line">    <span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    <span class="literal">void</span> sell_book_callback(const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Request</span><span class="type">::SharedPtr</span> request,</span><br><span class="line">        const village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span><span class="type">::Response</span><span class="type">::SharedPtr</span> response)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对请求数据进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><a name="rAhK4"></a></p><h5 id="实例化服务端-amp-amp-编写回调函数处理请求"><a href="#实例化服务端-amp-amp-编写回调函数处理请求" class="headerlink" title="实例化服务端&amp;&amp;编写回调函数处理请求"></a>实例化服务端&amp;&amp;编写回调函数处理请求</h5><p>在ROS2中，回调函数组也是一个对象，通过实例化create_callback_group类即可创建一个callback_group_service的对象。<br />在SingleDogNode的构造函数中添加下面这行代码，即可完成实例化<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">callback_group_service_</span> = this-&gt;create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br />我们使用成员函数作为回调函数，这里要根据回调函数中参数个数，设置占位符，即告诉编译器，这个函数需要传入的参数个数。<br /><strong>在之前订阅话题的回调函数中，我们已经用到过一次了，因为话题回调只有一个参数，所以只需要一个占位符，这里服务的回调是两个参数，所以要设置两个</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br></pre></td></tr></table></figure><br>在private:下<strong>声明服务端</strong><br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个服务端</span></span><br><span class="line">rclcpp<span class="type">::Service</span>&lt;village_interfaces<span class="type">::srv</span><span class="type">::SellNovel</span>&gt;<span class="type">::SharedPtr</span> server_;</span><br></pre></td></tr></table></figure><br>在构造函数中<strong>实例化服务端</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化卖二手书的服务</span></span><br><span class="line">server_ = this<span class="punctuation">-&gt;</span>create_service&lt;village_interfaces::srv::SellNovel&gt;(<span class="string">&quot;sell_novel&quot;</span>,</span><br><span class="line">                            std::<span class="title function_ invoke__">bind</span>(&amp;SingleDogNode::sell_book_callback,this,_1,_2),</span><br><span class="line">                            rmw_qos_profile_services_default,</span><br><span class="line">                            callback_group_service_);</span><br></pre></td></tr></table></figure><br>实例化服务端可以直接使用create_service函数，该函数是一个模版函数，需要输入要创建的服务类型，这里我们使用的是<village_interfaces::srv::SellNovel>，这个函数有四个参数需要输入,小鱼接下来进行一一介绍</p><ul><li>“sell_novel”服务名称，没啥好说的，要唯一哦，因为服务只能有一个</li><li>std::bind(&amp;SingleDogNode::sell_book_callback,this,_1,_2)回调函数，这里指向了我们2.3.1中我们声明的sell_book_callback</li><li>rmw_qos_profile_services_default 通信质量，这里使用服务默认的通信质量</li><li>callback<em>group_service</em>，回调组，我们前面创建回调组就是在这里使用的，告诉ROS2，当你要调用回调函数处理请求时，请把它放到单独线程的回调组中<br><a name="q5mnn"></a><h5 id="编写回调函数"><a href="#编写回调函数" class="headerlink" title="编写回调函数"></a>编写回调函数</h5><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调函数，当收到买书请求时调用该函数，用于处理数据</span></span><br><span class="line">    void sell_book_callback(<span class="keyword">const</span> village_interfaces::srv::SellNovel::Request::SharedPtr request,</span><br><span class="line">        <span class="keyword">const</span> village_interfaces::srv::SellNovel::Response::SharedPtr response)</span><br><span class="line">    &#123;</span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;收到一个买书请求，一共给了%d钱&quot;</span>,request-&gt;money);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> novelsNum = request-&gt;money*<span class="number">1</span>;  <span class="comment">//应给小说数量，一块钱一章</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前书库里书的数量是否满足张三要买的数量，不够则进入等待函数</span></span><br><span class="line">        <span class="keyword">if</span>(novels_queue.size()&lt;novelsNum)</span><br><span class="line">        &#123;</span><br><span class="line">            RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：不能满足需求,开始等待&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置rate周期为1s，代表1s检查一次</span></span><br><span class="line">            rclcpp::Rate loop_rate(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当书库里小说数量小于请求数量时一直循环</span></span><br><span class="line">            <span class="keyword">while</span> (novels_queue.size()&lt;novelsNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断系统是否还在运行</span></span><br><span class="line">                <span class="keyword">if</span>(!rclcpp::ok())</span><br><span class="line">                &#123;</span><br><span class="line">                    RCLCPP_ERROR(this-&gt;get_logger(), <span class="string">&quot;程序被终止了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//打印一下当前的章节数量和缺少的数量</span></span><br><span class="line">                RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;等待中，目前已有%d章，还差%d章&quot;</span>,novels_queue.size(),novelsNum-novels_queue.size());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//rate.sleep()让整个循环1s运行一次</span></span><br><span class="line">                loop_rate.sleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 章节数量满足需求了</span></span><br><span class="line">        RCLCPP_INFO(this-&gt;get_logger(), <span class="string">&quot;当前艳娘传奇章节存量为%d：已经满足需求&quot;</span>,novels_queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一本本把书取出来，放进请求响应对象response中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;novelsNum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            response-&gt;novels.push_back(novels_queue.front());</span><br><span class="line">            novels_queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br />当收到请求时，先计算一下应该给张三多少书novelsNum，然后判断书库里书的数量够不够，不够则进入攒书程序。如果够或者攒够了就把书放到服务响应对象里，返回给张三。这里我们还需要修改一下话题回调函数，增加了一行代码，将小说放到书库里novels_queue.push(msg-&gt;data);<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到话题数据的回调函数</span></span><br><span class="line"> void <span class="title function_ invoke__">topic_callback</span>(<span class="keyword">const</span> std_msgs::msg::<span class="type">String</span>::SharedPtr msg)&#123;</span><br><span class="line">     <span class="comment">// 新建一张人民币</span></span><br><span class="line">     std_msgs::msg::UInt32 money;</span><br><span class="line">     money.data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送人民币给李四</span></span><br><span class="line">    pub_<span class="punctuation">-&gt;</span><span class="title function_ invoke__">publish</span>(money);</span><br><span class="line">    <span class="title function_ invoke__">RCLCPP_INFO</span>(this<span class="punctuation">-&gt;</span><span class="title function_ invoke__">get_logger</span>(), <span class="string">&quot;王二：我收到了：&#x27;%s&#x27; ，并给了李四：%d 元的稿费&quot;</span>, msg<span class="punctuation">-&gt;</span>data.<span class="title function_ invoke__">c_str</span>(),money.data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将小说放入novels_queue中</span></span><br><span class="line">    novels_queue.<span class="title function_ invoke__">push</span>(msg<span class="punctuation">-&gt;</span>data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a name="S7CCg"></a><h5 id="修改main函数"><a href="#修改main函数" class="headerlink" title="修改main函数"></a>修改main函数</h5>因为我们要让整个程序变成多线程的，所以我们要把节点的执行器变成多线程执行器。<br />修改一下main函数，新建一个多线程执行器，添加王二节点并spin,完整代码如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">/*产生一个Wang2的节点*/</span></span><br><span class="line">    <span class="keyword">auto</span> node = std::<span class="built_in">make_shared</span>&lt;SingleDogNode&gt;(<span class="string">&quot;wang2&quot;</span>);</span><br><span class="line">    <span class="comment">/* 运行节点，并检测退出信号*/</span></span><br><span class="line">    rclcpp::executors::MultiThreadedExecutor exector;</span><br><span class="line">    exector.<span class="built_in">add_node</span>(node);</span><br><span class="line">    exector.<span class="built_in">spin</span>();</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a href="https://raw.githubusercontent.com/fishros/ros2_town/af8b29f7b23153d35348ebfcd3b1bc5760c6c5a6/village_wang/src/wang2.cpp">wang2.cpp</a><br><a name="NmoFR"></a><h5 id="编译："><a href="#编译：" class="headerlink" title="编译："></a>编译：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon <span class="keyword">build</span> --packages-<span class="keyword">select</span> village_wang</span><br></pre></td></tr></table></figure><a name="YjbW2"></a><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_wang wang2_node</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2@ubuntu:~/code/town_ws$ ros2 service list -t</span><br><span class="line">/sell_book [village_interfaces/srv/SellNovel]</span><br><span class="line">ros2 service call /sell_book  village_interfaces/srv/SellNovel &quot;&#123;money: 5&#125;&quot;</span><br><span class="line">source install/setup.bash</span><br><span class="line">ros2 run village_li li4_node</span><br><span class="line"></span><br></pre></td></tr></table></figure><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040232046-33fa90eb-16d0-4459-8907-ec1d53912d34.png#averageHue=%232f2f2f&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=bKVka&amp;originHeight=251&amp;originWidth=1424&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=135885&amp;status=done&amp;style=none&amp;taskId=ud6755017-b9b4-40d3-a3d5-08f505ffa75&amp;title=" alt="image-20210831124712850.png"></li></ul><p><a href="https://fishros.com/d2lros2foxy/#/chapt4/4.10%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0(C++">客户端实现</a>?id=_3%e5%ae%a2%e6%88%b7%e7%ab%af%ef%bc%88%e5%bc%a0%e4%b8%89%ef%bc%89%e5%ae%9e%e7%8e%b0)<img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1710040911063-ab181be4-89fa-4a05-8da4-a2b5d58c0444.png#averageHue=%23eeebe9&amp;clientId=ud3f5d7d5-6e8f-4&amp;from=drop&amp;id=u4725bfe1&amp;originHeight=430&amp;originWidth=380&amp;originalType=binary&amp;ratio=1.5625&amp;rotation=0&amp;showTitle=false&amp;size=62757&amp;status=done&amp;style=none&amp;taskId=u2b8126d0-3aa8-4cae-b16e-308b2b4d88f&amp;title=" alt="28bff3501425d8b0e5a018fb3f7cfb1b.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a name=&quot;w3PS4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装ROS2&quot;&gt;&lt;a href=&quot;#安装ROS2&quot; class=&quot;headerlink&quot; title=&quot;安装ROS2&quot;&gt;&lt;/a&gt;安装ROS2&lt;/h1&gt;&lt;p&gt;鱼香yyds&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http://fishros.com/install -O fishros &amp;amp;&amp;amp; bash fishros&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;卸载ROS&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt remove ros-foxy-* &amp;amp;&amp;amp; sudo apt autoremove&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;a name=&quot;hoy3W&quot;&gt;&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="ROS" scheme="http://zuweicun.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>ROS1初步</title>
    <link href="http://zuweicun.top/2024/03/11/ROS1%E5%88%9D%E6%AD%A5/"/>
    <id>http://zuweicun.top/2024/03/11/ROS1%E5%88%9D%E6%AD%A5/</id>
    <published>2024-03-11T12:12:21.000Z</published>
    <updated>2024-09-16T14:18:29.665Z</updated>
    
    <content type="html"><![CDATA[<p><a name="J4y9t"></a></p><h1 id="Topic与Message"><a href="#Topic与Message" class="headerlink" title="Topic与Message"></a>Topic与Message</h1><span id="more"></span><p>基础概念：<br />1.话题Topic是节点间进行持续通讯的一种形式<br />2.话题通讯的两个节点通过话题的名称建立起话题通讯连接。<br />3.话题中通讯的数据，叫做消息Message<br />4.消息Message通常会按照一定的频率持续不断的发送，以保证消息数据的实时性。<br />5.消息的发送方叫做话题的发布者Publisher<br />6.消息的接收方叫做话题的订阅者Subsciber<br />更多有：<br />1.一个ROS节点网络中，可以同时存在多个话题<br />2.一个话题可以有多个发布者，也可以有多个订阅者<br />3.一个节点可以对多个话题进行订阅，也可以发布多个话题<br />4.不痛得传感器消息通常会拥有各自独立话题名称，每个话题只有一个发布者<br />5.机器人速度指令话题通常会有多个发布者，但是同一时间只能有一个发言人。<br><a name="v1QhS"></a></p><h2 id="Topic的C-实现"><a href="#Topic的C-实现" class="headerlink" title="Topic的C++实现"></a>Topic的C++实现</h2><p>发布者的具体步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家发布一个话题并得到消息发送对象<br />4.生成要发送的消息包并进行发送数据的赋值。<br />5.调用消息发送对象的publish()函数将消息包发送到话题当中。<br />为了查看有关的Topic我们可以使用以下的常用工具：<br />rostopic list<br />列出当前系统汇总所有活跃着的话题<br />rostopic echo 主体名称<br />显示指定话题中发送的消息包内容<br />rostopic hz 主体名称<br />统计指定话题中消息包的发送频率<br />而话题的订阅需要满足以下的步骤：<br />1.确定话题名称和消息类型<br />2.在代码文件中include<ros.h>和消息类型对应的头文件<br />3.在main函数中通过NodeHandler大管家订阅一个话题并设置消息接收回调函数<br />4.定义一个回调函数，对接收到的消息包进行处理。<br />5.main函数中需要执行ros::spinOnce()，让回调函数能够响应接受到的消息包<br><a name="JxKTI"></a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;chao_node&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;node_chao is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//这里第二个参数表示缓存空间</span></span><br><span class="line">  <span class="function">Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chao is sending\n&quot;</span>);</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line">    msg.data = <span class="string">&quot;chao is sending message&quot;</span>;</span><br><span class="line">    pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_msgs/String.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yao_callback</span><span class="params">(std_msgs::String msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_WARN</span>(msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;ma_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_chao&quot;</span>, <span class="number">10</span>, chao_callback);</span><br><span class="line"><span class="comment">//这里第三个参数类似于单片机里的中断函数</span></span><br><span class="line">  Subscriber sub_yao = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;node_yao&quot;</span>, <span class="number">10</span>, yao_callback);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">spinOnce</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="L26MD"></a></p><h3 id="图形化界面rqt-graph"><a href="#图形化界面rqt-graph" class="headerlink" title="图形化界面rqt_graph"></a>图形化界面rqt_graph</h3><p>运行三个节点和roscore，然后在一个新的终端中输入rqt_graph可以得到一个用来观察当前消息链路的图形化界面<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705307614453-48eb5146-7ae3-40e1-b12c-6cc0a99ed5cb.png#averageHue=%23817243&amp;clientId=ued9d9fb6-a67b-4&amp;from=paste&amp;height=586&amp;id=u8f7c53f5&amp;originHeight=1172&amp;originWidth=2532&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=466221&amp;status=done&amp;style=none&amp;taskId=u54a4f49e-81fd-4e78-bf60-cd6d364613b&amp;title=&amp;width=1266" alt="image.png"><br><a name="DLwhc"></a></p><h3 id="launch文件同时启动多个节点"><a href="#launch文件同时启动多个节点" class="headerlink" title="launch文件同时启动多个节点"></a>launch文件同时启动多个节点</h3><p>launch文件是一种遵循XML语法的描述文件，这里启动多个节点只是launch文件的功能之一。 <br />对应到启动节点，我们可以使用这个流程：<br />1.使用launch文件，可以通过roslaunch指令一次启动多个节点。<br />2.在launch文件中，为节点添加output=”screen”属性，可以容纳个节点信息输出在终端中。（ROS_WARN不受该属性控制）<br />3.在launch文件中，为节点添加launch-prefix=”gnome-terminal -e”属性，可以让节点单独运行在一个独立终端中。<br />具体的，我们使用这个代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><br>而我们使用时只需要在终端中使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch 包名 launch文件名</span><br></pre></td></tr></table></figure><br>就可以运行了<br><a name="Xp45g"></a></p><h2 id="Topic的python实现"><a href="#Topic的python实现" class="headerlink" title="Topic的python实现"></a>Topic的python实现</h2><p>python实现基本上和c++实现差不多，无非就是c++中的NodeHandler变成了python中的rospy<br />看看代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment">#说明解释器和编码</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: <span class="comment">#主函数</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;chao_node&quot;</span>)<span class="comment">#申明节点</span></span><br><span class="line">    rospy.logwarn(<span class="string">&quot;node chao is running&quot;</span>)<span class="comment">#启动标签，打个warn让你吓一跳（</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;node_chao&quot;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)<span class="comment">#控制频率</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;node chao is sending message&quot;</span>)</span><br><span class="line">        msg = String()</span><br><span class="line">        msg.data = <span class="string">&quot;this is node chao&#x27;s message&quot;</span></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>接收端：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yao_callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.logwarn(msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;ma_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;node_chao&quot;</span>, String, chao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    sub1 = rospy.Subscriber(<span class="string">&quot;node_yao&quot;</span>, String, yao_callback, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><br>和c++的程序实现十分相似<br />值得说明的是，在launch中c++直接是一个可执行文件，而python则是要加入后缀py<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;yao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;ssr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;chao_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;chao_node&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;atr_py_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;ma_node.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;ma_node&quot;</span> <span class="attr">launch-prefix</span>=<span class="string">&quot;gnome-terminal -e&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><br><a name="Wz45W"></a></p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>service是ros中另一种通讯方式，类似于服务器和终端之间请求式的关系。<br />主要操作步骤分为：<br />1.服务端Server注册<br />2.客户端Client注册<br />3.节点管理器进行话题匹配<br />4.服务端请求服务<br />5.服务端提供服务<br><a name="OQdRg"></a></p><h2 id="终端指令的实现"><a href="#终端指令的实现" class="headerlink" title="终端指令的实现"></a>终端指令的实现</h2><p>我们使用ros自带的小乌龟来手动模拟一下一个service实现的过程<br />首先启动ros核心并召唤出小乌龟<br />然后使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rqt_service_caller rqt_service_caller</span><br></pre></td></tr></table></figure><br>召唤出图形化的service界面<br />按照<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388668505-d518fb03-f941-4f5c-b0f6-7f08d92ac516.png#averageHue=%23ede7e5&amp;clientId=u36e31b96-9ee5-4&amp;from=paste&amp;height=435&amp;id=uc21508a1&amp;originHeight=956&amp;originWidth=940&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=271004&amp;status=done&amp;style=none&amp;taskId=uda7225e4-f750-48cd-b154-967e9ec5ca3&amp;title=&amp;width=427.27271801184054" alt="image.png"><br />来配置<br />就能看到图上出现了一只新的小乌龟<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705388704513-fa622c00-39a1-498e-85e3-d908b340bc3e.png#averageHue=%234556fe&amp;clientId=u36e31b96-9ee5-4&amp;from=paste&amp;height=255&amp;id=u07d8973e&amp;originHeight=562&amp;originWidth=504&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=20276&amp;status=done&amp;style=none&amp;taskId=u4f0b890d-9656-4f8d-9ad6-8a5d36bee53&amp;title=&amp;width=229.09090412549747" alt="image.png"></p><p><a name="zoD2G"></a></p><h2 id="c-实现"><a href="#c-实现" class="headerlink" title="c++实现"></a>c++实现</h2><p><a name="T27RX"></a></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_client</span>();</span><br><span class="line">  ~<span class="built_in">service_client</span>();</span><br><span class="line">  ros::ServiceClient client;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_client::<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">0</span>;</span><br><span class="line">  b = <span class="number">0</span>;</span><br><span class="line">  client = nh.<span class="built_in">serviceClient</span>&lt;service_test::service_test::Request&gt;(<span class="string">&quot;a_b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">service_client::request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;request&quot;</span> &lt;&lt; endl;</span><br><span class="line">  service_test::service_test req;</span><br><span class="line">  req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  <span class="keyword">if</span> (client.<span class="built_in">call</span>(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;request falied&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  a++;</span><br><span class="line">  b += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">service_client::~<span class="built_in">service_client</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_client&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_client is started&quot;</span>);</span><br><span class="line">  service_client service_client;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    service_client.<span class="built_in">request</span>();</span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里用一个类写了一下这个东西，实现了一个a+b的不断请求<br />注意一下里面的核心语句：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serviceClient&lt;service_test::service_test::Request&gt;(&quot;a+b&quot;);</span><br></pre></td></tr></table></figure><br>这里定义了最重要的服务名<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">req.request.numb1 = a;</span><br><span class="line">  req.request.numb2 = b;</span><br><span class="line">  if (client.call(req))</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot;+&quot; &lt;&lt; b &lt;&lt; &quot;=&quot; &lt;&lt; req.response.sum &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>这里以req为媒介去询问并获得数据<br><a name="rS9TQ"></a></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;service_test/service_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">service_server</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/* data */</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">service_server</span>(<span class="comment">/* args */</span>);</span><br><span class="line">  ~<span class="built_in">service_server</span>();</span><br><span class="line">  ros::ServiceServer server;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">service_server::<span class="built_in">service_server</span>(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">  server = nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">service_server::requestCallback</span><span class="params">(service_test::service_test::Request &amp;request, service_test::service_test::Response &amp;response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a request is handled&quot;</span> &lt;&lt; endl;</span><br><span class="line">  response.sum = request.numb1 + request.numb2;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service_server::~<span class="built_in">service_server</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;service_server&quot;</span>);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service_server is started&quot;</span>);</span><br><span class="line">  service_server server;</span><br><span class="line">  <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里核心为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">advertiseService</span>(<span class="string">&quot;a_b&quot;</span>, &amp;service_server::requestCallback, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><br>这里前面是名字，后面有返回参数，不过这个this我看了半天也没明白是什么，我看如果没有写类的话这里好像只有两个参数，所以我大胆猜测这个是用来指向类的一个东西？<br><a name="RRsNw"></a></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>再cmakelists中加入<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(service_client src/service_client.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_client</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_client $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(service_server src/service_server.cpp)  </span><br><span class="line"><span class="built_in">target_link_libraries</span>(service_server</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;) </span><br><span class="line"><span class="built_in">add_dependencies</span>(service_server $&#123;catkin_EXPORTED_TARGETS&#125;)</span><br></pre></td></tr></table></figure><br>然后编译运行<br />效果：<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705392274716-e9b41739-0415-4df2-964b-0a2a2bb01b27.png#averageHue=%231e1a1a&amp;clientId=ue763d424-91f3-4&amp;from=paste&amp;height=440&amp;id=u37dec1cb&amp;originHeight=968&amp;originWidth=1456&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=257893&amp;status=done&amp;style=none&amp;taskId=uf53eabec-6008-468b-a83f-f7a4cd72232&amp;title=&amp;width=661.8181674736594" alt="image.png"><br><a name="OpNbK"></a></p><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><p><a name="sOxSw"></a></p><h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> service_test, service_testResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addCallback</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="built_in">sum</span> = req.numb1 + req.numb2</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;a request is being handled&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> service_testResponse(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    <span class="comment"># 创建一个名为add_server的server，注册回调函数addCallback,返回类型为service_test</span></span><br><span class="line">    server = rospy.Service(<span class="string">&quot;add_server&quot;</span>, service_test, addCallback)</span><br><span class="line"></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;server is Ready.&quot;</span>)</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实具体思路和c++很相似，就有个坑，第五行那两个，我本来以为只要自定义两个当作输入输出就行了，后来发现好像不大行，必须严格按照他这个格式。<br><a name="Mphok"></a></p><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_test.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_two_ints_client</span>(<span class="params">x, y</span>):</span><br><span class="line">    rospy.wait_for_service(<span class="string">&quot;add_server&quot;</span>)</span><br><span class="line">    add_two_ints = rospy.ServiceProxy(<span class="string">&quot;add_server&quot;</span>, service_test)</span><br><span class="line">    resp = add_two_ints(x, y)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;sum:%lf&quot;</span>, resp.<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;add_client&quot;</span>)</span><br><span class="line">    x = <span class="number">0.1585</span></span><br><span class="line">    y = <span class="number">15.21</span></span><br><span class="line">    add_two_ints_client(x, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这位更是十分简洁，没啥问题。记得和srv里文件一定就行了。<br />说起来为啥C语言要搞成.h而python只要srv呢（<br><a name="DPKCw"></a></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果<img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705478826907-6a743179-d0cd-490d-be0c-760eb509f9b5.png#averageHue=%231e1b1a&amp;clientId=ubbf6ae85-b225-4&amp;from=paste&amp;height=492&amp;id=u874c5b1f&amp;originHeight=984&amp;originWidth=1476&amp;originalType=binary&amp;ratio=2.200000047683716&amp;rotation=0&amp;showTitle=false&amp;size=191244&amp;status=done&amp;style=none&amp;taskId=ufb54405b-e108-494f-a287-1060d7db19b&amp;title=&amp;width=738" alt="image.png"></h3><p><a name="gMt1l"></a></p><h1 id="param"><a href="#param" class="headerlink" title="param"></a>param</h1><p><a name="QUW9p"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>举个栗子，我现在手里有一组数据，现在很多个节点都在想要得到我这个数据，如果使用前面的两种通讯方式，我开个topic在里面公麦喊数据显然不太合理，或者再开一个服务器呢？看起来好像不错，但是我们要维持这个端口一方面得一直开着这个节点，另一方面要不断的对外输出数据还得自己手写，而且各种数据类型还都不好处理。这个时候就需要我们的参数服务器登场了。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705485702889-26424fa6-e2ba-4130-ae19-545ad789e272.png#averageHue=%23f5f5f5&amp;clientId=u670af268-3edf-4&amp;from=paste&amp;height=280&amp;id=u95f2ebc6&amp;originHeight=559&amp;originWidth=1024&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=43576&amp;status=done&amp;style=none&amp;taskId=ufb874013-3788-41b9-8c63-bc7cf6c85c4&amp;title=&amp;width=512" alt="image.png"><br />在这里总计有三个角色，但是实际操作起来的时候，我们并不需要向之前一样像master注册身份，而是只要连接到master之后就可以进行全部的操作。<br />当然了为了书写的方便我们在实现中依旧将get和set分开写。值得注意的是，参数服务器不随着set的关闭而关闭，而是随着roscore的启动一直存在。<br><a name="aKczn"></a></p><h2 id="c-的实现"><a href="#c-的实现" class="headerlink" title="c++的实现"></a>c++的实现</h2><p><a name="UUER6"></a></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_set&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    string name = <span class="string">&quot;vbot&quot;</span>;</span><br><span class="line">    string geometry = <span class="string">&quot;rectangle&quot;</span>;</span><br><span class="line">    <span class="type">double</span> wheel_radius = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">int</span> wheel_num = <span class="number">4</span>;</span><br><span class="line">    <span class="type">bool</span> vision = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>&#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 设置参数</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;vbot&#x27;</span>);               <span class="comment">// 字符串, 机器人的名字，char*</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);         <span class="comment">// 字符串, 形状，string</span></span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius); <span class="comment">// 车轮半径double</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);        <span class="comment">// 车轮数量int</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;vision&quot;</span>, vision);              <span class="comment">// 是否具有视觉bool</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;base_size&quot;</span>, base_size);        <span class="comment">// 三维体积vector</span></span><br><span class="line">    param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);        <span class="comment">// 传感器的id，map</span></span><br><span class="line">    <span class="comment">// 验证是否设置成功</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get name&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get geometry&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_radius&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get wheel_num&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get base_size&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;rosparam get sensor_id&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们描述了一个机器人，将这个机器人的各个参数传入了参数服务器<br />值得说明的是，这里用了两种写法来写入数据，一种是用NodeHandle，一种直接调用了param里的函数<br />另外system这里不知道为什么会给个warning，无视就行了<br><a name="OjksJ"></a></p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ros;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_get&quot;</span>);</span><br><span class="line">  NodeHandle nh;</span><br><span class="line">  <span class="comment">// 修改参数</span></span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;mybot&quot;</span>); <span class="comment">// 字符串, char*</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; base_size = &#123;<span class="number">0.2</span>, <span class="number">0.04</span>&#125;;</span><br><span class="line">  nh.<span class="built_in">setParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size); <span class="comment">// vector</span></span><br><span class="line">  map&lt;string, <span class="type">int</span>&gt; sensor_id = &#123;&#123;<span class="string">&quot;camera&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;laser&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">  sensor_id.<span class="built_in">insert</span>(&#123;<span class="string">&quot;ultrasonic&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line">  param::<span class="built_in">set</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id); <span class="comment">// map</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line"></span><br><span class="line">  string name;</span><br><span class="line">  string geometry;</span><br><span class="line">  <span class="type">double</span> wheel_radius;</span><br><span class="line">  <span class="type">int</span> wheel_num;</span><br><span class="line">  <span class="type">bool</span> vision;</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;geometry&quot;</span>, geometry);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_radius&quot;</span>, wheel_radius);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;wheel_num&quot;</span>, wheel_num);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;vision&quot;</span>, vision);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;base_size&quot;</span>, base_size);</span><br><span class="line">  nh.<span class="built_in">getParam</span>(<span class="string">&quot;sensor_id&quot;</span>, sensor_id);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, name: %s, geometry: %s, wheel_radius: %lf, wheel: %d, vision: %s, base_size: (%lf, %lf)&quot;</span>,</span><br><span class="line">           name.<span class="built_in">c_str</span>(), geometry.<span class="built_in">c_str</span>(), wheel_radius, wheel_num, vision ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>,</span><br><span class="line">           base_size[<span class="number">0</span>], base_size[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> sensor : sensor_id)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;ros::NodeHandle getParam, %s_id: %d&quot;</span>, sensor.first.<span class="built_in">c_str</span>(), sensor.second);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除参数</span></span><br><span class="line"></span><br><span class="line">  nh.<span class="built_in">deleteParam</span>(<span class="string">&quot;vision&quot;</span>);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;rosparam get vision&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里好像也没有什么要说明的了，大家看看就行了<br><a name="PVfKq"></a></p><h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(param_set src/param_set.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(param_get src/param_get.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_set</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(param_get</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="X1725"></a></p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>param函数直接返回值，不存在则返回default_val，getparamcached函数好象是getparam的进阶版，加了个记搜？getparamnames返回所有值，以vector形式给出。<br><a name="EWhdA"></a></p><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705486990088-41376b0a-9140-4996-8f12-a6679c204d01.png#averageHue=%231f1b1b&amp;clientId=u670af268-3edf-4&amp;from=paste&amp;height=506&amp;id=uf0ed96e3&amp;originHeight=1012&amp;originWidth=1508&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=247069&amp;status=done&amp;style=none&amp;taskId=u607c6b38-a903-4ac5-ab4b-8f6db920f4c&amp;title=&amp;width=754" alt="image.png"><br><a name="dsWxB"></a></p><h2 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h2><p><a name="mnReF"></a></p><h3 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure><p><a name="pLckx"></a></p><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_hello_world_set&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vbot&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;geometry&quot;</span>, <span class="string">&quot;rectangle&quot;</span>)  <span class="comment"># 字符串, string</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_radius&quot;</span>, <span class="number">0.1</span>)  <span class="comment"># double</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;wheel_num&quot;</span>, <span class="number">4</span>)  <span class="comment"># int</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;vision&quot;</span>, <span class="literal">True</span>)  <span class="comment"># bool</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;base_size&quot;</span>, [<span class="number">0.7</span>, <span class="number">0.6</span>, <span class="number">0.3</span>])  <span class="comment"># list</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;sensor_id&quot;</span>, &#123;<span class="string">&quot;camera&quot;</span>: <span class="number">0</span>, <span class="string">&quot;laser&quot;</span>: <span class="number">2</span>&#125;)  <span class="comment"># dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证是否设置成功</span></span><br><span class="line">    os.system(<span class="string">&quot;rosparam get name&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get geometry&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_radius&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get wheel_num&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get vision&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get base_size&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;rosparam get sensor_id&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个实在是没啥好讲的，看代码就行了（<br><a name="OTwIA"></a></p><h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h1><p><a name="JC3y8"></a></p><h2 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h2><p>在实际中，有的时候通讯的时间是非常长的，而在通讯过程中，我们需要掌握中间值，比如我们要下载一个东西，我们可能时不时就要看一看下载进度，这个时候进度就是所需要的反馈feedback值<br />Action在结构上几乎和服务service相似，所以我暂时将其理解为service with feedback(?)<br><a name="yurY8"></a></p><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>说实话这个实现有点阴间，我也只是把教程里的那个东西实现了一下，要自己纯手搓感觉不好实现（<br><a name="fAysR"></a></p><h3 id="文件分层："><a href="#文件分层：" class="headerlink" title="文件分层："></a>文件分层：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559399543-95ef64ac-bbf9-47a2-a75d-de38c50c3d9c.png#averageHue=%23060504&amp;clientId=ucf2197ff-0c36-4&amp;from=paste&amp;height=74&amp;id=ub74f1fe7&amp;originHeight=370&amp;originWidth=468&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=41409&amp;status=done&amp;style=none&amp;taskId=u7efe1ed1-fea5-401f-9729-b13df614435&amp;title=&amp;width=93.6" alt="image.png"><br><a name="CiRbu"></a></p><h3 id="laundry-action"><a href="#laundry-action" class="headerlink" title="laundry.action"></a>laundry.action</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># goal，洗衣类型 1:开始快洗;2:开始高温洗;3:开始浸泡洗</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_type</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># result，洗涤结果</span></span><br><span class="line"><span class="string">string</span> <span class="string">wash_result</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># feedback，洗涤的进度</span></span><br><span class="line"><span class="string">uint8</span> <span class="string">wash_percent</span></span><br></pre></td></tr></table></figure><p><a name="YMVMz"></a></p><h3 id="cmake-1"><a href="#cmake-1" class="headerlink" title="cmake"></a>cmake</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(action_test)</span><br><span class="line"><span class="comment"># catkin构建时依赖的组件包</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line"><span class="comment"># include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 配置action源文件，FILES将引用当前功能包目录的action目录中的*.action文件，自动生成一个头文件（*.h）</span></span><br><span class="line">add_action_files(</span><br><span class="line">  FILES</span><br><span class="line">  Laundry.action</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成消息时依赖于std_msgs、actionlib_msgs</span></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">  actionlib_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行时依赖，描述了库、catkin构建依赖项和系统依赖的功能包</span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES action_test</span></span><br><span class="line"> CATKIN_DEPENDS roscpp rospy std_msgs actionlib actionlib_msgs </span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(action_client src/action_client.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(action_server src/action_server.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建库和可执行文件之前，预先生成依赖消息</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(action_client <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(action_server <span class="variable">$&#123;$&#123;PROJECT_NAME&#125;</span>_EXPORTED_TARGETS&#125; <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点构建选项，配置目标链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_client</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(action_server</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="mf7uX"></a></p><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/client/simple_action_client.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionClient&lt;action_test::LaundryAction&gt; ActionClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doneCb</span><span class="params">(<span class="type">const</span> actionlib::SimpleClientGoalState &amp;state, <span class="type">const</span> action_test::LaundryResultConstPtr &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state.state_ == state.SUCCEEDED)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;反馈结果:%s&quot;</span>, result-&gt;wash_result.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;任务失败！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">activeCb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;动作已经被激活....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feedbackCb</span><span class="params">(<span class="type">const</span> action_test::LaundryFeedbackConstPtr &amp;feedback)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;洗涤进度为:%d%s&quot;</span>, feedback-&gt;wash_percent, <span class="string">&quot;%&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.实例化action客户端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作的名称，参数3默认为true，无需再调用ros::spin()，设置为false时需手动调用</span></span><br><span class="line">  <span class="function">ActionClient <span class="title">client</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 等待服务端启动</span></span><br><span class="line">  client.<span class="built_in">waitForServer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.定义动作目标数据</span></span><br><span class="line">  action_test::LaundryGoal goal;</span><br><span class="line">  goal.wash_type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.发送目标，同时注册回调，处理反馈以及最终结果</span></span><br><span class="line">  <span class="comment">// 参数1是转换为Done时处理的回调函数，参数2为转换为Active时处理的回调函数，参数3为每当收到此目标的反馈时就调用的回调函数</span></span><br><span class="line">  client.<span class="built_in">sendGoal</span>(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="s4uDJ"></a></p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;actionlib/server/simple_action_server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_test/LaundryAction.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionServer&lt;action_test::LaundryAction&gt; ActionServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.收到action的goal后调用的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeCb</span><span class="params">(<span class="type">const</span> action_test::LaundryGoalConstPtr &amp;goal, ActionServer *server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获取目标值</span></span><br><span class="line">  <span class="type">uint8_t</span> wash_type = goal-&gt;wash_type;</span><br><span class="line">  std::string wash_mode;</span><br><span class="line">  <span class="keyword">switch</span> (wash_type)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;快洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;高温洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    wash_mode = <span class="string">&quot;浸泡洗&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;目标值为%d，开始%s！&quot;</span>, wash_type, wash_mode.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应连续反馈</span></span><br><span class="line">  action_test::LaundryFeedback feedback;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    feedback.wash_percent = i;</span><br><span class="line">    server-&gt;<span class="built_in">publishFeedback</span>(feedback);</span><br><span class="line">    ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>).<span class="built_in">sleep</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反馈结果</span></span><br><span class="line">  action_test::LaundryResult result;</span><br><span class="line">  result.wash_result = wash_mode + <span class="string">&quot;完成！&quot;</span>;</span><br><span class="line">  server-&gt;<span class="built_in">setSucceeded</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置编码</span></span><br><span class="line">  <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="comment">// 1.初始化ROS节点</span></span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;action_server&quot;</span>);</span><br><span class="line">  <span class="comment">// 2.实例化ROS句柄</span></span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line">  <span class="comment">// 3.实例化action服务端对象</span></span><br><span class="line">  <span class="comment">// 参数2为动作服务器名称，参数3为当一个新目标被接收时在一个单独的线程中被调用，参数4为告诉ActionServer是否在它出现时立即开始发布</span></span><br><span class="line">  <span class="function">ActionServer <span class="title">server</span><span class="params">(nh, <span class="string">&quot;laundry&quot;</span>, boost::bind(&amp;executeCb, _1, &amp;server), <span class="literal">false</span>)</span></span>;</span><br><span class="line">  server.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Vpuri"></a></p><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39228163/1705559548910-bc235096-7d99-4292-b382-b91268dfc171.png#averageHue=%231f1b1b&amp;clientId=ucf2197ff-0c36-4&amp;from=paste&amp;height=506&amp;id=ub6200bb0&amp;originHeight=1012&amp;originWidth=1508&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=286203&amp;status=done&amp;style=none&amp;taskId=u5d1e22a4-1937-479d-8cce-5e1ec8d2b05&amp;title=&amp;width=754" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a name=&quot;J4y9t&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Topic与Message&quot;&gt;&lt;a href=&quot;#Topic与Message&quot; class=&quot;headerlink&quot; title=&quot;Topic与Message&quot;&gt;&lt;/a&gt;Topic与Message&lt;/h1&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="ROS" scheme="http://zuweicun.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>关于过年抢红包的数学模型</title>
    <link href="http://zuweicun.top/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://zuweicun.top/2024/02/09/%E5%85%B3%E4%BA%8E%E8%BF%87%E5%B9%B4%E6%8A%A2%E7%BA%A2%E5%8C%85%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-02-09T14:42:23.000Z</published>
    <updated>2024-09-16T14:18:51.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于过年抢红包的数学模型"><a href="#关于过年抢红包的数学模型" class="headerlink" title="关于过年抢红包的数学模型"></a>关于过年抢红包的数学模型</h1><h2 id="建模初衷"><a href="#建模初衷" class="headerlink" title="建模初衷"></a>建模初衷</h2><p>旧词已去，新春将至，首先祝各位新春快乐，龙年大吉！   </p><p>​     最近，我不禁留意到许多朋友在抢红包这一传统活动中屡次受挫，心生疑惑与好奇。在这个新年风俗的背后，究竟隐藏着怎样的数学模型和本源机制呢？于是，我产生了一个突发奇想的想法，希望通过构建一个专注于抢红包的数学模型，深入探讨这一活动的规律、趋势以及可能的变数。</p><span id="more"></span><p>​     这个数学模型的目标不仅仅是揭示红包金额的分配方式，更是希望通过对抢红包过程的数学建模，挖掘其中的概率学、随机性、和博弈理论等数学原理。通过精心设计模型，我们或许能够理解为何有些人总能赢得更多，而有些人却屡屡受挫的原因。这也为我们提供了一个新的视角，来看待这个看似简单却又蕴含深厚数学内涵的传统文化现象。</p><h2 id="模型雏形"><a href="#模型雏形" class="headerlink" title="模型雏形"></a>模型雏形</h2><p>​    在红包数据庞大的情况下，抢红包的机制可以近似看作是随机抽样。我们可以采用蒙特卡洛模拟方法，通过生成大量的随机样本进行统计分析，从而估算红包分配的平均情况。这种方法通过模拟多次独立的红包抢夺过程，得到了一个近似的红包金额分布，</p><p>​    这种方法的优势在于，它不仅能够在庞大的数据集上进行模拟，而且还能够灵活地应用于不同的分布类型。我们引入了参数 <code>distribution</code>，使得模拟可以选择均匀分布或正态分布等。此外，为了提高效率，我们使用了 NumPy 库生成正态分布，使模拟更加高效。</p><p>   这个模型的局限性在于它仍然是一个概率模型，通过模拟得到的结果是一种期望的近似。在实际应用中，还可以进一步考虑更复杂的因素，例如用户心理、群体行为等，以得到更准确的模拟结果。这个模型的主要目的是为了提供一个直观的近似方法，用于初步理解红包分配的规律。   </p><h2 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h2><p>生成的图像是红包金额分配的模拟结果。在这个模型中，我们进行了多次蒙特卡洛模拟，每次模拟都对同一组人数和总金额进行了10000次红包抽取。图像中的 x 轴表示抢红包的人数，y 轴表示每个人抢到的红包平均金额。</p><p>通过这个图像，我们可以观察到在给定的总金额和人数下，每个人抢到的红包平均金额的分布情况。在模拟的多次试验中，我们得到了多个平均分布曲线，每条曲线代表一次模拟的结果。这样的可视化展示使我们能够更清晰地了解红包分配的随机性和不确定性。</p><p>在图像中，如果某个人数下的平均金额分布较为集中，说明在这种情况下，大多数人抢到的金额差异不大。相反，如果分布较为分散，说明抢到的金额存在较大的差异。</p><p><img src="Figure_1.png" alt="Figure_1"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simulate_red_packet</span>(<span class="params">total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span></span>):</span><br><span class="line">    all_results = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):  <span class="comment"># 模拟10000次抢红包</span></span><br><span class="line">            remaining_amount = total_amount</span><br><span class="line">            remaining_people = total_people</span><br><span class="line">            red_packet = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total_people - <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 随机生成一个红包金额</span></span><br><span class="line">                <span class="keyword">if</span> distribution == <span class="string">&#x27;uniform&#x27;</span>:</span><br><span class="line">                    amount = random.uniform(<span class="number">0.01</span>, remaining_amount - remaining_people * <span class="number">0.01</span>)</span><br><span class="line">                <span class="keyword">elif</span> distribution == <span class="string">&#x27;normal&#x27;</span>:</span><br><span class="line">                    amount = <span class="built_in">max</span>(<span class="number">0.01</span>, np.random.normal(remaining_amount / remaining_people, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid distribution type&quot;</span>)</span><br><span class="line"></span><br><span class="line">                red_packet.append(amount)</span><br><span class="line">                remaining_amount -= amount</span><br><span class="line">                remaining_people -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后一个红包的金额等于剩余的金额</span></span><br><span class="line">            red_packet.append(remaining_amount)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 随机打乱红包顺序</span></span><br><span class="line">            random.shuffle(red_packet)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录每个人抢到的金额</span></span><br><span class="line">            results.append(red_packet)</span><br><span class="line"></span><br><span class="line">        all_results.append(results)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_results</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_results</span>(<span class="params">all_results</span>):</span><br><span class="line">    average_amounts_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> results <span class="keyword">in</span> all_results:</span><br><span class="line">        average_amounts = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(results[<span class="number">0</span>])):</span><br><span class="line">            total_amount = <span class="built_in">sum</span>(result[i] <span class="keyword">for</span> result <span class="keyword">in</span> results)</span><br><span class="line">            average_amount = total_amount / <span class="built_in">len</span>(results)</span><br><span class="line">            average_amounts.append(average_amount)</span><br><span class="line"></span><br><span class="line">        average_amounts_list.append(average_amounts)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> average_amounts_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">average_amounts_list, num_simulations</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_simulations):</span><br><span class="line">        plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(average_amounts_list[i]) + <span class="number">1</span>), average_amounts_list[i], label=<span class="string">f&#x27;Simulation <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Person&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Average Amount&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Red Packet Distribution with Varying Data Amount&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    total_amount = <span class="number">100</span>  <span class="comment"># 总金额</span></span><br><span class="line">    total_people = <span class="number">10</span>  <span class="comment"># 总人数</span></span><br><span class="line">    num_simulations = <span class="number">5</span>  <span class="comment"># 模拟次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟均匀分布下的抢红包情况</span></span><br><span class="line">    all_results_uniform = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line">    average_amounts_uniform = analyze_results(all_results_uniform)</span><br><span class="line">    plot_distribution(average_amounts_uniform, num_simulations)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟正态分布下的抢红包情况</span></span><br><span class="line">    all_results_normal = simulate_red_packet(total_amount, total_people, num_simulations, distribution=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">    average_amounts_normal = analyze_results(all_results_normal)</span><br><span class="line">    plot_distribution(average_amounts_normal, num_simulations)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>我们可以建立一个简单的数学模型，其中包含三个变量：引诱红包的金额量（<code>enticing_amount</code>）、引诱的群聊数量（<code>group_count</code>）、和最终净红包的回报率（<code>return_rate</code>）。我们可以假设这些变量之间存在某种线性关系。</p><p><strong><em>Net_Red_Packet=enticing_amount×group_count×return_rate+noise</em></strong></p><p>其中，<em>noise</em> 表示模型中的随机噪声，可以包含一些不可预测的因素。</p><p>为了使用神经网络构建模型，我们可以将其视为一个回归问题。我们的输入特征为引诱红包的金额量、引诱的群聊数量，输出为最终净红包的回报率。</p><p><img src="Figure_3.png" alt="Figure_2"></p><p>可以看到在epoch接近100时，尽管有一点波动，在之后训练损失值已经趋于稳定。</p><p><img src="Figure_2.png" alt="Figure_3"></p><p>在以上可视化图像中不难发现，红包金额有以下几个特点：</p><ol><li><strong>随机性主导分配：</strong> 由于红包的随机性，抢到红包的金额呈现出随机分布的特征。这符合我们对红包抢够的直观认知，即每个人抢到的金额具有不确定性。</li><li><strong>平均金额趋向：</strong> 随着模拟次数的增加，我们观察到平均金额有向某个数值趋近的趋势。这可能是由于模型中设置的金额范围和总人数等参数导致的。在实际情况中，红包金额的平均分配可能受到更多因素的影响，例如红包金额设置、群聊人数等。</li><li><strong>模型的应用范围：</strong> 这个模型在一定程度上反映了红包随机分配的特性，但并不涵盖所有情况。实际中，红包分配还可能受到人为干预、算法调整等因素的影响，这些因素并未在模型中考虑。</li></ol><h2 id="模型总结"><a href="#模型总结" class="headerlink" title="模型总结"></a>模型总结</h2><ol><li><p><strong>更复杂的模型：</strong> 在实际应用中，可以考虑引入更多的因素，如用户关系、历史抢红包记录等，构建更为复杂的数学模型，以更准确地描述红包分配的机制。</p></li><li><p><strong>算法优化：</strong> 针对特定场景，可以优化红包分配的算法，以达到更好的用户体验。这可能需要对模型进行细致的参数调整和算法改进。</p></li><li><p><strong>社会学和心理学因素：</strong> 考虑到红包活动是一种社交行为，未来的研究可以引入社会学和心理学的因素，深入探讨红包背后的社交动机和心理机制。</p><p><strong>以及，可以适当考虑人品问题。</strong></p><p>（本文章无任何研究意义，仅供娱乐，相关可视化代码已经发布到Github上）</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于过年抢红包的数学模型&quot;&gt;&lt;a href=&quot;#关于过年抢红包的数学模型&quot; class=&quot;headerlink&quot; title=&quot;关于过年抢红包的数学模型&quot;&gt;&lt;/a&gt;关于过年抢红包的数学模型&lt;/h1&gt;&lt;h2 id=&quot;建模初衷&quot;&gt;&lt;a href=&quot;#建模初衷&quot; class=&quot;headerlink&quot; title=&quot;建模初衷&quot;&gt;&lt;/a&gt;建模初衷&lt;/h2&gt;&lt;p&gt;旧词已去，新春将至，首先祝各位新春快乐，龙年大吉！   &lt;/p&gt;
&lt;p&gt;​     最近，我不禁留意到许多朋友在抢红包这一传统活动中屡次受挫，心生疑惑与好奇。在这个新年风俗的背后，究竟隐藏着怎样的数学模型和本源机制呢？于是，我产生了一个突发奇想的想法，希望通过构建一个专注于抢红包的数学模型，深入探讨这一活动的规律、趋势以及可能的变数。&lt;/p&gt;</summary>
    
    
    
    <category term="屎山" scheme="http://zuweicun.top/categories/%E5%B1%8E%E5%B1%B1/"/>
    
    
    <category term="屎山" scheme="http://zuweicun.top/tags/%E5%B1%8E%E5%B1%B1/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习</title>
    <link href="http://zuweicun.top/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zuweicun.top/2024/01/12/OpenCV%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-01-12T15:57:55.000Z</published>
    <updated>2025-04-10T15:15:25.119Z</updated>
    
    <content type="html"><![CDATA[<p>经过长达一天的重装和环境配置，正式开始OpenCV的学习。</p><span id="more"></span><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/Star_ID/article/details/122656593">OpenCV入门【C++版】_opencv c++入门-CSDN博客</a></p><p><a href="https://oldpan.me/archives/use-vscode-cmake-tools-build-project">利用VScode和cmake编译构建C++工程代码 - Oldpan的个人博客</a></p><p><a href="https://blog.csdn.net/qq_41921826/article/details/129145473">OpenCV - C++实战（05） — 颜色检测_c++图像色素带识别-CSDN博客</a></p><h2 id="基本-（图片-amp-视频）操作"><a href="#基本-（图片-amp-视频）操作" class="headerlink" title="基本 （图片&amp;视频）操作"></a>基本 （图片&amp;视频）操作</h2><p>首先在opencv中创建一个文件夹mytest，用于存放后续的测试程序,并创建程序test1（后续同理）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mytest</span><br><span class="line">cd mytest</span><br><span class="line">gedit test1.cpp</span><br></pre></td></tr></table></figure><p>找一张图片（好友丑照）命名为1.jpg存放于这个目录中用于后续测试（蹂躏）。</p><h3 id="1-图片腐蚀"><a href="#1-图片腐蚀" class="headerlink" title="1 图片腐蚀"></a>1 图片腐蚀</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat element =<span class="built_in">getStructuringElement</span>(MORPH_RECT,<span class="built_in">Size</span>(<span class="number">15</span>,<span class="number">15</span>));</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">erode</span>(srcImage,dstImage,element);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]腐蚀操作&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能很简单，就是一个腐蚀操作。</p><p>在终端输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ test1.cpp -o test1 `pkg-config --cflags --libs opencv`</span><br><span class="line">./test1</span><br></pre></td></tr></table></figure><p>显示原图和腐蚀操作图。</p><p>效果展示：</p><p><img src="1.png" alt="1"></p><p>完美运行。</p><h3 id="2-图像模糊"><a href="#2-图像模糊" class="headerlink" title="2.图像模糊"></a>2.图像模糊</h3><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage;</span><br><span class="line">    <span class="built_in">blur</span>(srcImage,dstImage,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好理解，载入原图之后调用一次blur函数，最后显示效果图。</p><p>效果如下：</p><p><img src="2.png" alt="2"></p><h3 id="3-Canny边缘检测"><a href="#3-Canny边缘检测" class="headerlink" title="3  Canny边缘检测"></a>3  Canny边缘检测</h3><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat srcImage =<span class="built_in">imread</span>(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[原始图]&quot;</span>,srcImage);</span><br><span class="line">    Mat dstImage,edge,grayImage;<span class="comment">//参数定义</span></span><br><span class="line">    dstImage.<span class="built_in">create</span>(srcImage.<span class="built_in">size</span>(),srcImage.<span class="built_in">type</span>());</span><br><span class="line">    <span class="comment">//创建与src同类型大小的矩阵（dest）</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(srcImage,grayImage,COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//将原图像转换为灰度图像</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">blur</span>(grayImage,edge,<span class="built_in">Size</span>(<span class="number">3</span>,<span class="number">3</span>));<span class="comment">//3x3内核降噪</span></span><br><span class="line">    <span class="built_in">Canny</span>(edge,edge,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>);<span class="comment">//运行Canny算子</span></span><br><span class="line">    dstImage = edge; <span class="comment">//将Canny算子的结果赋值给dstImage</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;[效果图]&quot;</span>,dstImage);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyAllWindows</span>(); <span class="comment">//释放所有窗口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="3.png" alt="3"></p><h3 id="4-读取视频"><a href="#4-读取视频" class="headerlink" title="4.读取视频"></a>4.读取视频</h3><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="string">&quot;1.avi&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;<span class="comment">//定义Mat变量储存每一帧</span></span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);<span class="comment">//延迟30ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-调取摄像头采集视频"><a href="#5-调取摄像头采集视频" class="headerlink" title="5.调取摄像头采集视频"></a>5.调取摄像头采集视频</h3><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码:"></a>示例代码:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    Mat edges;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture&gt;&gt;frame;<span class="comment">//读取当前帧</span></span><br><span class="line">        <span class="built_in">cvtColor</span>(frame,edges,COLOR_BGR2GRAY);<span class="comment">//灰度转换</span></span><br><span class="line">        <span class="built_in">blur</span>(edges,edges,<span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>));</span><br><span class="line">        <span class="built_in">Canny</span>(edges,edges,<span class="number">1</span>,<span class="number">31</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;读取视频&quot;</span>,frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（其实就是把Videocapture中的视频源改为参数0）</p><h3 id="6-灰度转化"><a href="#6-灰度转化" class="headerlink" title="6.灰度转化"></a>6.灰度转化</h3><p>图片有多种色彩模式，主要就是包括位图模式，灰度模式，RGB模式，CMYK模式和HSB模式。这里就不详细展开了。值得注意的有两个概念，就是图片的深度和通道，深度表示一个图片的一个像素有几位，通道则表示一个图像由几层颜色表示，一般由单通道（灰度），三通道（RGB）以及四通道（RGB+透明度）表示。</p><p>在opencv中我们一般采用cvtColor这个函数来转换图像的灰度。</p><p><img src="4.png" alt="4"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="type">void</span> <span class="title">cvtColor</span><span class="params">(InputArray src, OutputArray dst, <span class="type">int</span> code, <span class="type">int</span> dstCn=<span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>这里给出函数的定义和常用的几个转换标识</p><h2 id="图像裁剪和缩放"><a href="#图像裁剪和缩放" class="headerlink" title="图像裁剪和缩放"></a>图像裁剪和缩放</h2><p>可以参考</p><p><a href="https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc=%7B%22request%5Fid%22%3A%22170480359916800185832024%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=170480359916800185832024&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120584785-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv图像裁剪和缩放&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/ZBC010/article/details/120584785?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170480359916800185832024%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170480359916800185832024&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120584785-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA%E5%92%8C%E7%BC%A9%E6%94%BE&amp;spm=1018.2226.3001.4187</a></p><h3 id="图像尺寸缩放："><a href="#图像尺寸缩放：" class="headerlink" title="图像尺寸缩放："></a>图像尺寸缩放：</h3><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">( InputArray src, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function"> OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">             Size dsize, <span class="comment">//调整成的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fx = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">double</span> fy = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> interpolation = INTER_LINEAR </span></span></span><br><span class="line"><span class="params"><span class="function">             )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h4><ul><li>src：输入的图像，Mat类</li><li>dst：输出的图像，当参数dsize不为0时，dst的大小由dsize决定；否则，它的大小由参数fx和fy决定</li><li>dsize：输出图像的大小，写成Size(宽，高)（单位：像素）</li><li>fx和fy：水平/竖直方向上的缩放比例</li><li>interpolation：插值方法。取值如下：<br>INTER_NEAREST————-最近邻插值<br>INTER_LINEAR————-双线性插值（默认设置）<br>INTER_AREA————-使用像素区域关系进行重采样<br>INTER_CUBIC————-4x4像素邻域的双三次插值<br>INTER_LANCZOS4————-8x8像素邻域的Lanczos插值</li><li>注意：参数dsize和参数(fx, fy)不能够同时为0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    Mat outImg;</span><br><span class="line">    <span class="built_in">resize</span>(img, outImg, <span class="built_in">Size</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="number">0.8</span>, <span class="number">0.8</span>);<span class="comment">//宽和高都变为原来的0.8倍</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;改变尺寸后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h3><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453d.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;opencv_world453.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;D:\\My Bags\\图片\\Test.jpg&quot;</span>);</span><br><span class="line">    <span class="function">Rect <span class="title">cropArea</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    Mat outImg = <span class="built_in">img</span>(cropArea);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;裁剪后&quot;</span>, outImg);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图像绘制和文字输出"><a href="#图像绘制和文字输出" class="headerlink" title="图像绘制和文字输出"></a>图像绘制和文字输出</h2><p>参考资料：<a href="https://blog.csdn.net/k673656/article/details/129227483?ops_request_misc=%7B%22request%5Fid%22%3A%22170480417316800213038610%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170480417316800213038610&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-129227483-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv图形绘制和文字绘制&amp;spm=1018.2226.3001.4187">Opencv图形绘制与文字输出_opencv mat 显示文字-CSDN博客</a></p><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(InputOutputArray img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>其中center表示中心位置，radius表示半径，thikness可以表示厚度，-1表示填充，与可以表示位FILLED</p><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> 值得注意的是，还可以使用RECT来绘制，函数如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Rect(x,y,width,height), <span class="type">const</span> Scalar&amp; color, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="输入文字"><a href="#输入文字" class="headerlink" title="输入文字"></a>输入文字</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">putText</span><span class="params">( InputOutputArray img, <span class="type">const</span> String&amp; text, Point org, <span class="type">int</span> fontFace, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">double</span> fontScale, Scalar color, <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">bool</span> bottomLeftOrigin = <span class="literal">false</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>img表示初始的文字，text表示文字内容，org表示文字的左下角坐标，fontface表示字体类型，fontscale表示字体大小，最后以为表示图像数据的原点是左下角还是左上角。</p><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><p>首先，对几何变换做个简单了解。打开任意一个图像编辑器，一般可以有对图像进行放大、缩小、旋转等操作，这类操作改变了原图中各区域的空间关系。对于这类操作，通常称为图像的<strong>几何变换</strong>。</p><p>一般而言，完成一张图像的几何变换需要<strong>两个独立的算法</strong>：<strong>首先</strong>，需要一个算法实现空间坐标变换，用它描述每个像素如何从初始位置移动到终止位置；<strong>其次</strong>，还需要一个<strong>插值算法</strong>完成输出图像的每个像素的灰度值。</p><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><h4 id="仿射矩阵"><a href="#仿射矩阵" class="headerlink" title="仿射矩阵"></a>仿射矩阵</h4><p>对于空间变换的仿射矩阵有两种计算方式，分别是<strong>方程组法</strong>和<strong>矩阵相乘法</strong>。</p><p><strong>(1) 方程组法</strong></p><p>仿射变换矩阵有六个未知数，所以需要三组对应位置坐标，构造出由六个方程组成的方程组即可解六个未知数。<br>举例：如果(0,0) 、(200,0) 、(0,200)这三个坐标通过某仿射变换矩阵A分别转换为(0,0) 、(100,0) 、(0,100)，则可利用这三组对应坐标构造出六个方程，求解出A。</p><p>对于C++的API函数getAffineTransform()输入参数有两种方式，第一种方式是将原位置坐标和对应的变换后的坐标分别保存在Point2f数组中，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Point2f src[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">200</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">200</span>) &#125;;</span><br><span class="line">Point2f dst[] = &#123; <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">0</span>),<span class="built_in">Point2f</span>(<span class="number">100</span>,<span class="number">0</span>), <span class="built_in">Point2f</span>(<span class="number">0</span>,<span class="number">100</span>) &#125;;</span><br><span class="line"></span><br><span class="line">Mat A = <span class="built_in">getAffineTransform</span>(src,dst);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; A&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值A仍然是2行3列的矩阵，指的是<strong>仿射变换矩阵的前两行</strong>。需要注意的是，数据类型是CV_64F而<strong>不是</strong>CV_32F。</p><p>第二种方式是<strong>将原位置坐标和对应的变换后的坐标保存在</strong>Mat中，<strong>每一行代表一个坐标，数据类型必须是</strong>CV_32F，否则会报错，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mat A = <span class="built_in">getAffineTransform</span>(src, dst);</span><br><span class="line">cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用矩阵相乘法计算仿射矩阵，<strong>前提是需要知道基本仿射变换步骤</strong>.</p><p><strong>需要注意的是</strong>，虽然先缩放再平移，但是仿射变换矩阵是<strong>平移仿射矩阵乘以缩放仿射矩阵，而不是缩放仿射矩阵乘以平移仿射矩阵</strong>，即等式右边的运算是从右向左进行的。</p><p>在<a href="https://so.csdn.net/so/search?q=OpenCV&amp;spm=1001.2101.3001.7020">OpenCV</a>中是通过“*”运算符或者gemm函数来实现矩阵的乘法的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Mat src = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//缩放矩阵</span></span><br><span class="line">Mat dst = (<span class="built_in">Mat_</span>&lt;<span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>,<span class="number">1</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//平移矩阵</span></span><br><span class="line"></span><br><span class="line">Mat A;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gemm</span>(src,dst,<span class="number">1.0</span>,<span class="built_in">Mat</span>(),<span class="number">0</span>,A,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透射变换"><a href="#透射变换" class="headerlink" title="透射变换"></a>透射变换</h3><p>仿射变换是在平面上的线性变换加平移，根据其性质可知变换后平行四边形依然是平行四边形，不改变直线的平行关系。透射变换即中心投影变换，利用透视中心、像点、目标点三点共线的条件,按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p><p> 透视变换是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射。</p><p>移动投影中心和承影面，可得到各种形状的变换。（有点像《三体》里的二向箔）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cv::getPerspectiveTransform</span> <span class="params">(<span class="type">const</span> Point2f src[], <span class="type">const</span> Point2f dst[])</span></span></span><br></pre></td></tr></table></figure><p><strong>返回相应 4 个点对的 3x3 透视变换</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpPerspective</span> <span class="params">(InputArray src, OutputArray dst, InputArray M, Size dsize, <span class="type">int</span> flags=INTER_LINEAR, <span class="type">int</span> borderMode=BORDER_CONSTANT, <span class="type">const</span> Scalar &amp;borderValue=Scalar())</span></span></span><br></pre></td></tr></table></figure><p><strong>对图像应用透视变换</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> w = <span class="number">250</span>, h = <span class="number">350</span>;</span><br><span class="line">Mat matrix, imgWarp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string path = <span class="string">&quot;Resources/cards.jpg&quot;</span>;</span><br><span class="line">Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line"></span><br><span class="line">Point2f src[<span class="number">4</span>] = &#123; &#123;<span class="number">529</span>, <span class="number">142</span>&#125;, &#123;<span class="number">771</span>, <span class="number">190</span>&#125;, &#123;<span class="number">405</span>, <span class="number">395</span>&#125;, &#123;<span class="number">674</span>, <span class="number">457</span>&#125; &#125;;</span><br><span class="line">Point2f dst[<span class="number">4</span>] = &#123; &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;, &#123;w, <span class="number">0.0f</span>&#125;, &#123;<span class="number">0.0f</span>, h&#125;, &#123;w, h&#125; &#125;;</span><br><span class="line"></span><br><span class="line">matrix = <span class="built_in">getPerspectiveTransform</span>(src, dst);</span><br><span class="line"><span class="built_in">warpPerspective</span>(img, imgWarp, matrix, <span class="built_in">Point</span>(w, h));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">circle</span>(img, src[i], <span class="number">10</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), FILLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;ImageWarp&quot;</span>, imgWarp);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：文档扫描应该就是这种变换。</p><h2 id="颜色检测："><a href="#颜色检测：" class="headerlink" title="颜色检测："></a>颜色检测：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::inRange</span> <span class="params">(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)</span></span></span><br></pre></td></tr></table></figure><p>检查数组元素是否位于其他两个数组的元素之间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::namedWindow</span> <span class="params">(<span class="type">const</span> String &amp;winname, <span class="type">int</span> flags = WINDOW_AUTOSIZE)</span></span></span><br></pre></td></tr></table></figure><p><strong>创建一个窗口</strong>。函数namedWindow创建一个可用作图像和轨迹栏占位符的窗口。创建的窗口由它们的名称引用。如果同名的窗口已经存在，则该函数不执行任何操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cv::createTrackbar</span> <span class="params">(<span class="type">const</span> String &amp;trackbarname, <span class="type">const</span> String &amp;winname, <span class="type">int</span> *value, <span class="type">int</span> count, TrackbarCallback onChange = <span class="number">0</span>, <span class="type">void</span> *userdata = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>创建一个</strong>trackbar<strong>并将其附加到指定窗口</strong>。函数createTrackbar创建一个具有指定名称和范围的trackbar（滑块或范围控件），分配一个变量值作为与trackbar同步的位置，并指定回调函数onChange为 在跟踪栏位置变化时被调用。创建的轨迹栏显示在指定的窗口winname中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Mat imgHSV, mask;</span><br><span class="line"><span class="type">int</span> hmin = <span class="number">0</span>, smin = <span class="number">110</span>, vmin = <span class="number">153</span>;</span><br><span class="line"><span class="type">int</span> hmax = <span class="number">19</span>, smax = <span class="number">240</span>, vmax = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string path = <span class="string">&quot;resources/lambo.png&quot;</span>;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(path);</span><br><span class="line">    <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Trackbars&quot;</span>, (<span class="number">640</span>, <span class="number">200</span>));</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmin, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Hue Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;hmax, <span class="number">179</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Sat Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;smax, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Min&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmin, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;Val Max&quot;</span>, <span class="string">&quot;Trackbars&quot;</span>, &amp;vmax, <span class="number">2555</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">Scalar <span class="title">lower</span><span class="params">(hmin, smin, vmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">upper</span><span class="params">(hmax, smax, vmax)</span></span>;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, lower, upper, mask);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image HSV&quot;</span>, imgHSV);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Image Mask&quot;</span>, mask);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目实操"><a href="#项目实操" class="headerlink" title="项目实操"></a>项目实操</h2><h4 id="参考资料：-1"><a href="#参考资料：-1" class="headerlink" title="参考资料："></a>参考资料：</h4><p><a href="https://hitwhlc.yuque.com/tosania">@23沈晨阳</a></p><p>此处为语雀内容卡片，点击链接查看：<a href="https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt">https://hitwhlc.yuque.com/smartcar/daily/zg04pi54zig4rqbt</a></p><p><a href="https://blog.csdn.net/qq_40344790/article/details/127653557?ops_request_misc=%7B%22request%5Fid%22%3A%22170481303716800188516338%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=170481303716800188516338&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv红绿灯识别检测c%2B%2B&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_40344790/article/details/127653557?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170481303716800188516338%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170481303716800188516338&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127653557-null-null.142^v99^pc_search_result_base6&amp;utm_term=opencv%E7%BA%A2%E7%BB%BF%E7%81%AF%E8%AF%86%E5%88%AB%E6%A3%80%E6%B5%8Bc%2B%2B&amp;spm=1018.2226.3001.4187</a></p><h4 id="任务内容："><a href="#任务内容：" class="headerlink" title="任务内容："></a>任务内容：</h4><h5 id="OpenCV红绿灯检测"><a href="#OpenCV红绿灯检测" class="headerlink" title="OpenCV红绿灯检测"></a>OpenCV红绿灯检测</h5><ul><li>使用<strong>c++</strong>版本的opencv对视频进行处理</li><li>读取TrafficLight.mp4</li><li>检测交通信号灯颜色，并在图像中标出红绿灯位置（中间数字无需检测）</li><li>将信号灯颜色以字符串输出到图像左上角</li><li>将处理后的视频输出为result.avi，示例为压缩包内“输出示例.avi”</li><li><p>可以进行创新，给大家的视频只是一个示例</p></li><li><p>在语雀中创建文档，完整记录自己的实现方式</p></li><li>将代码、result.avi放入同一压缩包内上传到语雀中</li><li>将result.avi直接传入语雀中，其他人可以直接查看的那种</li><li>提交截止时间：下周一例会前(2.14)</li></ul><h4 id="完成思路："><a href="#完成思路：" class="headerlink" title="完成思路："></a>完成思路：</h4><p>1.将视频的每一帧处理，（高斯模糊，边缘检测，膨胀….），增强特征点的提取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对二值化后的图像进行高斯模糊</span></span><br><span class="line">    <span class="built_in">GaussianBlur</span>(imgDil, imgDil, <span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对图像进行Canny边缘检测</span></span><br><span class="line">    <span class="built_in">Canny</span>(imgDil, imgDil, <span class="number">25</span>, <span class="number">75</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义膨胀操作的内核</span></span><br><span class="line">    Mat kernel = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对Canny边缘检测后的图像进行膨胀</span></span><br><span class="line">    <span class="built_in">dilate</span>(imgDil, imgDil, kernel);</span><br></pre></td></tr></table></figure><p>2.由于红绿灯是由许多小像素点组成的，可能会造成误判，故需要检测一下轮廓过滤出最大的画出矩形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找图像中的轮廓</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="built_in">findContours</span>(imgDil, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储轮廓的多边形逼近和轮廓的矩形边界</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; <span class="built_in">conPoly</span>(contours.<span class="built_in">size</span>());</span><br><span class="line"><span class="function">vector&lt;Rect&gt; <span class="title">boundRect</span><span class="params">(contours.size())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储最大轮廓的相关信息</span></span><br><span class="line"><span class="type">double</span> maxx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> choose = <span class="number">0</span>, ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，找到最大的符合条件的轮廓</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>) &gt; maxx)</span><br><span class="line">    &#123;</span><br><span class="line">        maxx = <span class="built_in">contourArea</span>(contours[i]) / <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        choose = i;</span><br><span class="line">        <span class="keyword">if</span> (maxx &gt; <span class="number">20</span> &amp;&amp; <span class="built_in">contourArea</span>(contours[i]) &gt; <span class="number">2000</span>)</span><br><span class="line">            ok = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有轮廓，绘制最大的轮廓及相关信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (choose == i &amp;&amp; ok == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算轮廓的多边形逼近</span></span><br><span class="line">        <span class="type">double</span> peri = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">approxPolyDP</span>(contours[i], conPoly[i], <span class="number">0.02</span> * peri, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算轮廓的矩形边界</span></span><br><span class="line">        boundRect[i] = <span class="built_in">boundingRect</span>(conPoly[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形边界</span></span><br><span class="line">        <span class="built_in">rectangle</span>(img, boundRect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">225</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在矩形边界的左上角绘制文本</span></span><br><span class="line">        <span class="built_in">putText</span>(img, c, boundRect[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">1.5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">100</span>), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于颜色的识别：</li></ul><p>由于inrange函数的局限性，最好将图像转换成HSV颜色空间，相比于RGB颜色空间，HSV颜色空间更适合处理颜色分割和阈值操作。在HSV中，颜色范围可以更容易地通过阈值进行调整，因为色调和明度是分开的。</p><p>使用HSV颜色空间是为了更容易地确定图像中红色和绿色的区域。对于交通灯的颜色检测，通常更关注颜色的种类而不是其亮度或深浅，因此使用HSV更为合适。</p><p>主函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 视频文件路径</span></span><br><span class="line">    string path = <span class="string">&quot;1.avi&quot;</span>;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">cap</span><span class="params">(path)</span></span>;</span><br><span class="line">    Mat img;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧数</span></span><br><span class="line">    <span class="type">int</span> cnt = cap.<span class="built_in">get</span>(CAP_PROP_FRAME_COUNT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取视频帧的大小</span></span><br><span class="line">    Size sizeReturn = <span class="built_in">Size</span>(cap.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH), cap.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建输出视频的写入对象，设置输出视频文件名、编码方式、帧率和大小</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), cap.get(CAP_PROP_FPS), sizeReturn)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历视频的每一帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取当前帧</span></span><br><span class="line">        cap &gt;&gt; img;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换当前帧为HSV颜色空间</span></span><br><span class="line">        Mat imgHSV;</span><br><span class="line">        <span class="built_in">cvtColor</span>(img, imgHSV, COLOR_BGR2HSV);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义绿色和红色的HSV阈值范围</span></span><br><span class="line">        <span class="function">Scalar <span class="title">g_lower</span><span class="params">(h_gmin, s_gmin, v_gmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">g_upper</span><span class="params">(h_gmax, s_gmax, v_gmax)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_lower</span><span class="params">(h_rmin, s_rmin, v_rmin)</span></span>;</span><br><span class="line">        <span class="function">Scalar <span class="title">r_upper</span><span class="params">(h_rmax, s_rmax, v_rmax)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过HSV阈值得到绿色和红色的掩码</span></span><br><span class="line">        Mat g_mask, r_mask;</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, g_lower, g_upper, g_mask);</span><br><span class="line">        <span class="built_in">inRange</span>(imgHSV, r_lower, r_upper, r_mask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对绿色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workg</span>(g_mask, img, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对红色掩码进行目标识别和标记</span></span><br><span class="line">        <span class="built_in">workr</span>(r_mask, img, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将处理后的帧写入输出视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(img);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;img&quot;</span>, img);</span><br><span class="line">    <span class="comment">// 释放视频捕捉对象和写入对象</span></span><br><span class="line">    cap.<span class="built_in">release</span>();</span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来是不用学人脸识别的，感觉好玩所以写了个基于摄像头输入源的人脸识别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CascadeClassifier faceCascade;</span><br><span class="line">faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function">VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">Mat img;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cap.<span class="built_in">read</span>(img);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">1</span>);</span><br><span class="line">vector&lt;Rect&gt; face;</span><br><span class="line">faceCascade.<span class="built_in">detectMultiScale</span>(img, face);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(img, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="built_in">putText</span>(img, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后来感觉不够，完全可以基于主屏幕输入画面进行人脸识别，方便帮舍友识别出藏在床底下的老王（bushi）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgcodecs.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/objdetect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;X11/Xutil.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Display* display = <span class="built_in">XOpenDisplay</span>(<span class="literal">NULL</span>); <span class="comment">// 打开X11显示</span></span><br><span class="line">    Screen* screen = <span class="built_in">DefaultScreenOfDisplay</span>(display); <span class="comment">// 获取默认屏幕</span></span><br><span class="line">    <span class="type">int</span> width = screen-&gt;width; <span class="comment">// 获取屏幕的宽度</span></span><br><span class="line">    <span class="type">int</span> height = screen-&gt;height; <span class="comment">// 获取屏幕的高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载人脸检测分类器</span></span><br><span class="line">    CascadeClassifier faceCascade;</span><br><span class="line">    faceCascade.<span class="built_in">load</span>(<span class="string">&quot;/usr/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (faceCascade.<span class="built_in">empty</span>()) &#123; cout &lt;&lt; <span class="string">&quot;Load Error&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建VideoWriter对象，用于将每一帧屏幕图像写入视频文件</span></span><br><span class="line">    <span class="function">VideoWriter <span class="title">writer</span><span class="params">(<span class="string">&quot;out.mp4&quot;</span>, cv::VideoWriter::fourcc(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;v&#x27;</span>), <span class="number">30</span>, Size(width, height))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取屏幕的XImage对象</span></span><br><span class="line">        XImage* ximage = <span class="built_in">XGetImage</span>(display, <span class="built_in">DefaultRootWindow</span>(display), <span class="number">0</span>, <span class="number">0</span>, width, height, AllPlanes, ZPixmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为OpenCV的Mat对象</span></span><br><span class="line">        <span class="function">cv::Mat <span class="title">image</span><span class="params">(height, width, CV_8UC4, ximage-&gt;data)</span></span>; <span class="comment">// 创建Mat对象</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(image, image, cv::COLOR_BGRA2BGR); <span class="comment">// 转换为BGR格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕图像上进行人脸检测和标注</span></span><br><span class="line">        vector&lt;Rect&gt; face;</span><br><span class="line">        faceCascade.<span class="built_in">detectMultiScale</span>(image, face);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; face.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">rectangle</span>(image, face[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">putText</span>(image, <span class="string">&quot;a people&quot;</span>, face[i].<span class="built_in">tl</span>(), FONT_HERSHEY_DUPLEX, <span class="number">0.75</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">69</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示屏幕图像</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Screen&quot;</span>, image);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将修改后的图像写入视频文件</span></span><br><span class="line">        writer.<span class="built_in">write</span>(image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">XDestroyImage</span>(ximage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭X11显示</span></span><br><span class="line">    <span class="built_in">XCloseDisplay</span>(display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放VideoCapture对象和VideoWriter对象的资源</span></span><br><span class="line">    writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经过长达一天的重装和环境配置，正式开始OpenCV的学习。&lt;/p&gt;</summary>
    
    
    
    <category term="718" scheme="http://zuweicun.top/categories/718/"/>
    
    
    <category term="OpenCV" scheme="http://zuweicun.top/tags/OpenCV/"/>
    
  </entry>
  
</feed>
