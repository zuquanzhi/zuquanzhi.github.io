<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全之の博客</title>
  
  <subtitle>Be Someone Interesting</subtitle>
  <link href="https://blog.zuquanzhi.top/atom.xml" rel="self"/>
  
  <link href="https://blog.zuquanzhi.top/"/>
  <updated>2025-12-06T14:32:40.000Z</updated>
  <id>https://blog.zuquanzhi.top/</id>
  
  <author>
    <name>ZU Quanzhi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一篇VLA综述阅读</title>
    <link href="https://blog.zuquanzhi.top/2025/12/06/64154/"/>
    <id>https://blog.zuquanzhi.top/2025/12/06/64154/</id>
    <published>2025-12-06T14:32:40.000Z</published>
    <updated>2025-12-06T14:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文链接：</strong><a href="https://arxiv.org/abs/2510.07077">Vision-Language-Action Models for Robotics: A Review Towards Real-World Applications</a></p><p>如果用一句话概括这篇《Vision‑Language‑Action Models for Robotics: A Review Towards Real‑World Applications》，那就是：<strong>它第一次用“全栈视角”认真回答——到底怎样把大模型真正变成会干活的机器人。</strong></p><p>很多文章谈“让 LLM 控制机器人”，停留在高层规划：模型输出“去拿红杯子”，下面是另一个控制模块去执行。作者认为，这还称不上真正的 <strong>Vision‑Language‑Action（VLA） 模型</strong>。他们给了一个非常严格的定义：</p><blockquote><p>“VLA 模型以视觉观测和自然语言指令为必需输入，并<strong>直接输出控制命令</strong>；只做技能索引的高层策略不算 VLA。” </p></blockquote><p>这篇文章的野心，就是在这个定义之上，给出 VLA 领域从<strong>挑战 → 架构 → 模态处理 → 训练与数据 → 机器人平台 → 评测与实践指南</strong>的一条完整主线（见论文第 2 页图 1）。</p><p>下面我按“读者视角”来拆解这篇综述：它到底在讲什么？我们能学什么？如果你在做具身智能/机器人产品，这篇文章能直接帮你<strong>做架构和路线的选型</strong>。</p><hr><h2 id="一、VLA-想解决什么问题？"><a href="#一、VLA-想解决什么问题？" class="headerlink" title="一、VLA 想解决什么问题？"></a>一、VLA 想解决什么问题？</h2><p>论文一开头就指出一个现实：<strong>早期把 LLM/VLM 接进机器人的工作，大多是“高层想一想，低层照做做”</strong>。</p><blockquote><p>“早期工作把 LLM 和 VLM 与底层策略解耦，只负责任务推理或选择预定义动作原语；这在少量预定义任务上有效，却难以泛化到更广任务。” </p></blockquote><p>这带来几个痛点：</p><ul><li>每个新任务都要重新收集示教、重训策略；</li><li>改一个机器人平台（不同机械臂、移动底盘），现有模型很难复用；</li><li>模型“知道很多”，但大部分知识没办法落实到低层控制。</li></ul><p>于是，<strong>VLA 的核心目标</strong>就是：在大规模数据上<strong>联合学习视觉‑语言‑动作</strong>，得到一种“通用策略”，能：</p><ul><li>在<strong>新任务</strong>上，用极少甚至零样本适配；</li><li>跨 <strong>物体、环境和机器人形体（embodiment）</strong> 迁移；</li><li>最终降低真实部署时的<strong>每任务成本</strong>。</li></ul><p>如果把这件事做成，对产业落地的好处也相当大了：</p><ul><li>仓储、制造、家政、医疗的场景里，可以<strong>用一套方法支撑很多 SKU / 场景 / 流程</strong>；</li><li>硬件厂商可以围绕统一的 VLA 接口共享数据和模型，而不是各自搞封闭系统（<strong>生态构建</strong>）；</li><li>有可能出现“云端 VLA + 边缘低成本机器人”的 <strong>Robot‑as‑a‑Service</strong> 模式。</li></ul><hr><h2 id="二、从-CLIPort-到-GR00T：VLA-架构的时间线"><a href="#二、从-CLIPort-到-GR00T：VLA-架构的时间线" class="headerlink" title="二、从 CLIPort 到 GR00T：VLA 架构的时间线"></a>二、从 CLIPort 到 GR00T：VLA 架构的时间线</h2><p>论文在第 4 页给了一张非常关键的时间线（图 2），把代表性工作连成一条“进化史”：</p><blockquote><p>CLIPort → Gato/VIMA → RT‑1/RT‑2/RT‑X/OpenVLA → Octo/RDT‑1B/π0 → LAPA/π0.5/GR00T N1</p></blockquote><p>这条时间线其实对应了<strong>接口风格的变化</strong>，我们可以分几代来看：</p><h3 id="2-1-第一代：CNN-端到端-——-桌面玩家-CLIPort"><a href="#2-1-第一代：CNN-端到端-——-桌面玩家-CLIPort" class="headerlink" title="2.1 第一代：CNN 端到端 —— 桌面玩家 CLIPort"></a>2.1 第一代：CNN 端到端 —— 桌面玩家 CLIPort</h3><p><strong>CLIPort</strong> 是最早真正意义上的 VLA 之一：</p><ul><li>用 <strong>CLIP</strong> 提取图像 + 文本特征；</li><li>结合 <strong>Transporter Network</strong> 预测“在哪里抓、放到哪里”；</li><li>实现在桌面环境下的多对象操作。</li></ul><p>局限也很明显：CNN + MLP 架构对模态统一能力有限、扩展到多任务/多平台困难。</p><h3 id="2-2-第二代：Transformer-序列模型-——-“万能序列机”Gato-VIMA"><a href="#2-2-第二代：Transformer-序列模型-——-“万能序列机”Gato-VIMA" class="headerlink" title="2.2 第二代：Transformer 序列模型 —— “万能序列机”Gato / VIMA"></a>2.2 第二代：Transformer 序列模型 —— “万能序列机”Gato / VIMA</h3><p>接下来是 <strong>Gato</strong> 和 <strong>VIMA</strong> 这一类，把一切都 token 化：</p><ul><li>图像切 patch → 视觉 token；</li><li>文本 → 文本 token；</li><li>动作（离散化后）→ 动作 token；</li><li>全部拼成一个序列，丢进 <strong>decoder‑only Transformer</strong> 里自回归预测。</li></ul><p>Gato 展示了“一模型多任务”的可能性：聊天、VQA、游戏操作、机器人控制都能干，但机器人部分技能仍然有限。VIMA 则在仿真中展示了指令 + 目标图像的组合泛化能力。</p><h3 id="2-3-第三代：现实世界-VLM-主干-——-RT‑系列-amp-OpenVLA"><a href="#2-3-第三代：现实世界-VLM-主干-——-RT‑系列-amp-OpenVLA" class="headerlink" title="2.3 第三代：现实世界 VLM 主干 —— RT‑系列 &amp; OpenVLA"></a>2.3 第三代：现实世界 VLM 主干 —— RT‑系列 &amp; OpenVLA</h3><p>真正把 VLA 推向现实的，是 <strong>RT‑1/RT‑2/RT‑X</strong>：</p><ul><li><p><strong>RT‑1</strong>：</p><ul><li>EfficientNet 提视觉，Universal Sentence Encoder 提语言；</li><li>用 TokenLearner 压缩视觉 token；</li><li>decoder‑only Transformer <strong>一次性预测全部动作 token</strong>（非自回归）；</li><li>在 13 台 Google 机器人上收集了 13 万条轨迹、700+ 任务。</li></ul></li><li><p><strong>RT‑2</strong>：</p><ul><li>直接用 <strong>PaLM‑E / PaLI‑X 等 VLM</strong> 做 backbone；</li><li>一边做互联网视觉‑语言任务，一边做机器人 BC 训练；</li><li>泛化到新物体、新环境的能力大幅提升。</li></ul></li><li><p><strong>RT‑X</strong>：</p><ul><li>用多实验室、多机器人联合数据训练，</li><li>证明了“跨 embodiment 大一统”的可行性。</li></ul></li></ul><p>基于 RT‑2 结构，<strong>OpenVLA</strong> 用 PrismaticVLM + DINOv2 + SigLIP 作为视觉‑语言主干，在 Open‑X Embodiment（OXE）上全模型微调，在多个 benchmark 上超过 RT‑2 和 Octo，成为目前开源的“主流 VLA 架构”。</p><h3 id="2-4-第四代：扩散-Flow-Diffusion-Transformer-——-Octo、RDT‑1B、π0"><a href="#2-4-第四代：扩散-Flow-Diffusion-Transformer-——-Octo、RDT‑1B、π0" class="headerlink" title="2.4 第四代：扩散 / Flow / Diffusion Transformer —— Octo、RDT‑1B、π0"></a>2.4 第四代：扩散 / Flow / Diffusion Transformer —— Octo、RDT‑1B、π0</h3><p>当大家发现离散动作 token 在控制频率与平滑度上有先天不足后，一条新路线出现了：<strong>用生成模型直接生成连续动作</strong>。</p><ul><li><strong>Octo</strong>：第一个把 <strong>Diffusion Policy</strong> 引入 VLA 的公开开源系统。视觉 + 文本 token 过 Transformer 得到 readout，再用扩散模型生成动作序列。</li><li><strong>RDT‑1B</strong>：更激进，直接用 <strong>Diffusion Transformer (DiT)</strong> 做 backbone，扩散过程嵌在整个 Transformer 中。</li><li><strong>π0</strong>：用 <strong>Flow Matching + PaliGemma</strong>，把动作头做成 flow 模型，一次输出整段动作 chunk，最高支持 50Hz 控制，兼顾平滑与实时。</li></ul><h3 id="2-5-第五代：潜在动作-分层策略-——-LAPA、π0-5、GR00T-N1"><a href="#2-5-第五代：潜在动作-分层策略-——-LAPA、π0-5、GR00T-N1" class="headerlink" title="2.5 第五代：潜在动作 + 分层策略 —— LAPA、π0.5、GR00T N1"></a>2.5 第五代：潜在动作 + 分层策略 —— LAPA、π0.5、GR00T N1</h3><p>最新一代则开始把<strong>人类视频、潜在动作和分层控制</strong>统筹到 VLA 体系里：</p><ul><li><strong>LAPA</strong>：从视频中学习离散的潜在动作 token，用 VQ‑VAE 压缩“当前图像 → N 步之后图像”的差异，把它当作动作再重建未来图像，从而在<strong>没有显式机器人 action 的人类视频</strong>上预训练。</li><li><strong>π0.5</strong>：把高层离散动作 token（FAST）和低层 flow 控制统一在一套网络里，既能做 CoT 式的高层决策，又能输出连续控制。</li><li><strong>GR00T N1</strong>：更进一步，把 LAPA 的潜在动作、RDT‑1B 的 Diffusion Transformer、π0 的 flow 控制，做成一个<strong>多阶段策略结构</strong>，用世界模型生成多样轨迹，再在此基础上学可泛化的策略。</li></ul><blockquote><p>从这条进化线可以看到：<strong>LLM 控机器人只是起点，现在的主战场其实在“如何生成连续动作 + 如何用巨大的人类/机器人视频数据训练”。</strong></p></blockquote><hr><h2 id="三、三个硬伤：数据、embodiment-和算力"><a href="#三、三个硬伤：数据、embodiment-和算力" class="headerlink" title="三、三个硬伤：数据、embodiment 和算力"></a>三、三个硬伤：数据、embodiment 和算力</h2><p>论文第二节给 VLA 列了三宗原罪，这也是落地项目时必然会撞的墙。</p><h3 id="3-1-数据：三模态对齐的稀缺"><a href="#3-1-数据：三模态对齐的稀缺" class="headerlink" title="3.1 数据：三模态对齐的稀缺"></a>3.1 数据：三模态对齐的稀缺</h3><blockquote><p>“满足视觉、语言、动作三模态对齐的大规模数据集极其有限；机器人示教数据语言多样性差、任务范围窄，采集昂贵。” </p></blockquote><ul><li>视觉‑语言数据：COCO、LAION 之类有海量图文，但<strong>没动作</strong>。</li><li>机器人数据：QT‑Opt、RT‑1、RoboNet 等有动作，但<strong>语言贫乏</strong>、任务窄。</li><li>加更多模态（触觉、音频、3D）后，稀缺程度乘以 N。</li></ul><h3 id="3-2-Embodiment：不同架构之间的翻译难"><a href="#3-2-Embodiment：不同架构之间的翻译难" class="headerlink" title="3.2 Embodiment：不同架构之间的翻译难"></a>3.2 Embodiment：不同架构之间的翻译难</h3><p>机器人千奇百怪：只有机械臂 vs 带轮子 vs 四足 vs 人形；关节 DOF、连杆、传感器都不同。</p><blockquote><p>“跨 embodiment 的策略迁移依然是重大难题；同样问题在人类 → 机器人迁移上更为严重。” </p></blockquote><p>这就引出 UniAct、CrossFormer 这类工作：通过统一 token 表示或者潜在动作空间，把不同身体映射到共享表示上。</p><h3 id="3-3-计算：长序列-高频视觉的成本"><a href="#3-3-计算：长序列-高频视觉的成本" class="headerlink" title="3.3 计算：长序列 + 高频视觉的成本"></a>3.3 计算：长序列 + 高频视觉的成本</h3><p>VLA 大多基于 Transformer，不但要吃语言 token，还要吃高分辨率、多帧图像、可能还有 3D/触觉；序列长度和维度直接爆炸，训练和推理都极其耗算。</p><p>于是出现一堆算力区救火的方法：</p><ul><li>TokenLearner、Perceiver Resampler、Q‑Former 等视觉 token 压缩模块；</li><li>RTC、VLA‑Cache、层级早停（DeeR‑VLA）等推理时优化技术。</li></ul><hr><h2 id="四、模型设计全景：三大类架构-七种-sensorimotor"><a href="#四、模型设计全景：三大类架构-七种-sensorimotor" class="headerlink" title="四、模型设计全景：三大类架构 + 七种 sensorimotor"></a>四、模型设计全景：三大类架构 + 七种 sensorimotor</h2><p>作者最硬核的贡献之一，是给出了一个<strong>非常系统的 VLA 架构分类图谱</strong>（图 3–6）。</p><h3 id="4-1-三大架构家族"><a href="#4-1-三大架构家族" class="headerlink" title="4.1 三大架构家族"></a>4.1 三大架构家族</h3><ol><li><p><strong>Sensorimotor model（传感‑运动模型）</strong></p><ul><li>直接从视觉 + 语言 → 动作；</li><li>可以是单层（flat）或分层（hierarchical）；</li><li>是现在最主流的一类。</li></ul></li><li><p><strong>World model（世界模型）</strong></p><ul><li>先预测未来观测（图像/latent），再由逆动力学模型或策略生成动作；</li><li>支持规划、长时序推理。</li></ul></li><li><p><strong>Affordance‑based model（可供性模型）</strong></p><ul><li>先预测“哪里能抓/能放/能走”等可供性，再规划动作。</li></ul></li></ol><h3 id="4-2-七种-sensorimotor-架构（图-4）"><a href="#4-2-七种-sensorimotor-架构（图-4）" class="headerlink" title="4.2 七种 sensorimotor 架构（图 4）"></a>4.2 七种 sensorimotor 架构（图 4）</h3><div class="table-container"><table><thead><tr><th>型号</th><th>主干</th><th>动作输出</th><th>代表</th></tr></thead><tbody><tr><td>(1) Transformer + 离散 action token</td><td>Transformer</td><td>离散 token</td><td>Gato, VIMA, RT‑1 等</td></tr><tr><td>(2) Transformer + Diffusion 头</td><td>Transformer</td><td>扩散连续动作</td><td>Octo, NoMAD</td></tr><tr><td>(3) Diffusion Transformer</td><td>DiT</td><td>扩散连续动作</td><td>RDT‑1B, LBM 等</td></tr><tr><td>(4) VLM + 离散 token</td><td>预训练 VLM</td><td>离散 token</td><td>RT‑2, OpenVLA, GR‑1 等</td></tr><tr><td>(5) VLM + Diffusion 头</td><td>预训练 VLM</td><td>扩散连续动作</td><td>Diffusion‑VLA, DexVLA 等</td></tr><tr><td>(6) VLM + Flow 头</td><td>预训练 VLM</td><td>Flow 连续动作</td><td>π0, GraspVLA 等</td></tr><tr><td>(7) VLM + Diffusion Transformer</td><td>VLM + DiT</td><td>分层连续动作</td><td>GR00T N1, CogACT 等</td></tr></tbody></table></div><p>这相当于给你一份<strong>架构选型菜单</strong>：</p><ul><li>任务较短、频率不高 → (4) 类离散 token 架构；</li><li>要 50Hz 高频、平滑控制 → (6) Flow Matching；</li><li>要世界模型 + 分层规划 → (7) VLM + Diffusion Transformer。</li></ul><h3 id="4-3-世界模型-amp-可供性"><a href="#4-3-世界模型-amp-可供性" class="headerlink" title="4.3 世界模型 &amp; 可供性"></a>4.3 世界模型 &amp; 可供性</h3><p><strong>世界模型（Fig.5）</strong> 大致三种玩法：</p><ol><li>预测未来图像/视频，再用 IDM 反推动作（UniPi, DreamGen, SuSIE 等）；</li><li>从视频学潜在动作 token，供 VLA 使用（LAPA, UniVLA, UniSkill）；</li><li>在 sensorimotor 模型里，顺便预测未来观测（GR‑1/2/3, 3D‑VLA）。</li></ol><p><strong>可供性模型（Fig.6）</strong> 也是三条线：</p><ol><li>用 GPT‑4 + OWL‑ViT + SAM 这类 VLM，先产出 <strong>Affordance / Constraint Map</strong>，再 MPC 控制（VoxPoser, LERF‑TOGO 等）；</li><li>从人类视频里自动抽取“接触点+轨迹”（VRB, HRP, VidBot）；</li><li>把可供性模块嵌进 VLA 主体（CLIPort, RoboGround, Chain‑of‑Affordance）。</li></ol><hr><h2 id="五、数据-amp-训练：从-Ego4D-到-OXE，再到自动标注和增强"><a href="#五、数据-amp-训练：从-Ego4D-到-OXE，再到自动标注和增强" class="headerlink" title="五、数据 &amp; 训练：从 Ego4D 到 OXE，再到自动标注和增强"></a>五、数据 &amp; 训练：从 Ego4D 到 OXE，再到自动标注和增强</h2><h3 id="5-1-真实机器人数据：OXE-amp-AgiBot-World"><a href="#5-1-真实机器人数据：OXE-amp-AgiBot-World" class="headerlink" title="5.1 真实机器人数据：OXE &amp; AgiBot World"></a>5.1 真实机器人数据：OXE &amp; AgiBot World</h3><p>表 1（第 19 页）列出了当前主流真实机器人数据集：</p><ul><li><strong>RT‑1</strong>：130K 轨迹，12 个技能，700+ 任务，13 台 Google 机器人。</li><li><strong>OXE (Open‑X Embodiment)</strong>：1.4M 轨迹，527 技能，160,266 任务，22 种机器人。</li><li><strong>AgiBot World</strong>：1M 轨迹，87 技能，217 任务，100+ 台 AgiBot G1。</li></ul><p>这些数字强烈暗示一个事实：<strong>泛化 ≈ 足够大的、多平台、多任务数据</strong>。</p><h3 id="5-2-人类视频-amp-自监督潜在动作"><a href="#5-2-人类视频-amp-自监督潜在动作" class="headerlink" title="5.2 人类视频 &amp; 自监督潜在动作"></a>5.2 人类视频 &amp; 自监督潜在动作</h3><p>为了缓解机器人数据昂贵的问题，论文强调了各类 egocentric 数据集（Ego4D、EPIC‑KITCHENS、HOI4D 等）在 VLA 预训练中的价值。</p><p>关键是用世界模型/潜在动作学习，把“无显式动作标签”的人类视频变成可用信号，如 LAPA/UniVLA/UniSkill 那样。</p><h3 id="5-3-自动标注-amp-生成式增强：数据“增值流水线”"><a href="#5-3-自动标注-amp-生成式增强：数据“增值流水线”" class="headerlink" title="5.3 自动标注 &amp; 生成式增强：数据“增值流水线”"></a>5.3 自动标注 &amp; 生成式增强：数据“增值流水线”</h3><p>论文专门用了一个小节讲<strong>数据增强</strong>：</p><ul><li>视觉增强：CACTI、GenAug、ROSIE 用 Stable Diffusion / Imagen Editor 改背景、改纹理、加干扰物，在不破坏几何结构和可供性的前提下提升鲁棒性；DreamGen 用视频 world model + IDM 做合成轨迹。</li><li>语言增强：DIAL 用小规模 seed，LLM 生成大量改写，再用 VLM 匹配轨迹，构建大规模指令标注数据。</li><li>动作增强：CCIL 等方法用局部动力学模型合成“纠错”轨迹，缓解分布外状态问题。</li></ul><p>而在标注流水线方面，ECoT、EMMA‑X、NILS、RoboMIND 综合用 GroundingDINO + SAM + Gemini/GPT‑4 等，把原始视频自动切分成子任务、加状态/指令描述，大幅减少人力。</p><hr><h2 id="六、评测与落地：RobotPlatform、baseline-amp-amp-Safety"><a href="#六、评测与落地：RobotPlatform、baseline-amp-amp-Safety" class="headerlink" title="六、评测与落地：RobotPlatform、baseline &amp;&amp; Safety"></a>六、评测与落地：RobotPlatform、baseline &amp;&amp; Safety</h2><h3 id="6-1-仿真-benchmark：LIBERO-ManiSkill-Habitat-RLBench…"><a href="#6-1-仿真-benchmark：LIBERO-ManiSkill-Habitat-RLBench…" class="headerlink" title="6.1 仿真 benchmark：LIBERO / ManiSkill / Habitat / RLBench…"></a>6.1 仿真 benchmark：LIBERO / ManiSkill / Habitat / RLBench…</h3><p>表 2（第 23 页）把主流仿真基准梳理成一张表，包括任务类型、场景数量、模态和物理引擎等信息。</p><p>大致可以归类：</p><ul><li>MuJoCo 系：robosuite/robomimic/RoboCasa/LIBERO 等；</li><li>PhysX/SAPIEN 系：ManiSkill 1–3、ManiSkill‑HAB、RoboTwin；</li><li>PyBullet 系：Ravens/VIMA‑BENCH/LoHoRavens/CALVIN；</li><li>V‑REP 系：RLBench/COLOSSEUM；</li><li>Unity 系：AI2‑THOR/CHORES。</li></ul><p>特别是 <strong>LIBERO</strong>（130 个自然语言操控任务）与 <strong>COLOSSEUM</strong>（20 任务、14 种环境扰动），已成为 VLA 评测的“新标准”。</p><p>同时，SIMPLER 和 RoboArena 开始解决“仿真 vs 现实” 的 gap：</p><ul><li><strong>SIMPLER</strong>：强调 real‑to‑sim 评测的高相关性设计。</li><li><strong>RoboArena</strong>：在 7 所大学真实机器人上进行分布式 pairwise 评测，构建更公平的排行榜。</li></ul><h3 id="6-2-真实机器人：从机械臂到人形"><a href="#6-2-真实机器人：从机械臂到人形" class="headerlink" title="6.2 真实机器人：从机械臂到人形"></a>6.2 真实机器人：从机械臂到人形</h3><p>论文第 7 节详细罗列了 VLA 中常见的机器人平台：</p><ul><li>Manipulator：Franka、UR、KUKA、xArm、WidowX/ViperX、ALOHA 系列……</li><li>Gripper / Hand：两指夹爪、四指 LEAP hand、五指 Shadow hand 等；</li><li>Mobile：LoCoBot、Hello Stretch、Google Robot、AgiBot G1 等；</li><li>Quadruped：Unitree Go1/Go2、Spot、ANYmal；</li><li>Humanoid：Fourier GR‑1、Unitree G1/H1、Booster T1 等。</li></ul><p>这些平台上的代表应用包括：</p><ul><li>Shake‑VLA：机器人摇鸡尾酒；</li><li>RoboNurse‑VLA：手术器械传递；</li><li>TrackVLA/NaVILA：四足在野外导航；</li><li>EgoVLA/GO‑1：家庭场景下的人形/四足操控。</li></ul><h3 id="6-3-安全与失败恢复：VLA-的现实考卷"><a href="#6-3-安全与失败恢复：VLA-的现实考卷" class="headerlink" title="6.3 安全与失败恢复：VLA 的现实考卷"></a>6.3 安全与失败恢复：VLA 的现实考卷</h3><p>作者在第 IX 节专门讨论了安全与故障恢复：</p><ul><li>当前 VLA 很少显式处理意外人类出现、碰撞风险等安全场景；</li><li>多数系统缺乏系统性的<strong>失败检测</strong>和<strong>重规划机制</strong>；</li><li>SAFE、Agentic Robot、LoHoVLA、FOREWARN 等开始用世界模型或层级架构来预测失败、触发恢复。</li></ul><blockquote><p>简单说，现在 VLA 还比较莽，要进工厂/医院/家庭，<strong>安全与可控性，会成为下一个大主题</strong>。</p></blockquote><hr><h2 id="七、拿来主义的玩法"><a href="#七、拿来主义的玩法" class="headerlink" title="七、拿来主义的玩法"></a>七、拿来主义的玩法</h2><p>站在一个想做研究或产品的人角度，我觉得这篇综述可以直接变成几个非常实用的 checklist：</p><h3 id="7-1-架构选型-checklist"><a href="#7-1-架构选型-checklist" class="headerlink" title="7.1 架构选型 checklist"></a>7.1 架构选型 checklist</h3><p>根据论文图 4–6，可以为自己的项目做一个三步选型：</p><ol><li><strong>任务属性</strong>：短 vs 长时序、控制频率、有无复杂接触？</li><li><strong>数据类型</strong>：有多少机器人轨迹？有无大量人类视频？有无 3D/触觉？</li><li><strong>算力预算</strong>：训练与部署的 GPU 规模和实时性要求？</li></ol><p>然后在七类 sensorimotor + 三类 world model + 三类 affordance 模型里挑组合，例如：</p><ul><li>仓储拣选 + 机械臂 + 中低频控制 → VLM + 离散 action token（RT‑2/OpenVLA 风格）；</li><li>倒水/擦桌子 + 高速轨迹 → VLM + Flow Matching 头（π0）；</li><li>人形/四足 + 大量人类视频 → 世界模型 + 潜在动作（LAPA/UniVLA）+ VLM 头。</li></ul><h3 id="7-2-数据策略：NOT-ONLY“多采点示教”"><a href="#7-2-数据策略：NOT-ONLY“多采点示教”" class="headerlink" title="7.2 数据策略：NOT ONLY“多采点示教”"></a>7.2 数据策略：NOT ONLY“多采点示教”</h3><p>论文给了很多可以直接工程化的思路：</p><ul><li>用人类 egocentric 视频 + 潜在动作学习扩充数据；</li><li>用 Stable Diffusion / 世界模型做 <strong>视觉风格增强</strong>，提升 domain generalization；</li><li>用 GroundingDINO + SAM + LLM 搭一套自动标注流水线，把“干净的小数据集合”扩展成“多标注的大数据”。</li></ul><p>这几乎是一条现成的 <strong>数据增值 pipeline</strong>。</p><h3 id="7-3-训练-recipe：如何不把预训练-VLM-训练废"><a href="#7-3-训练-recipe：如何不把预训练-VLM-训练废" class="headerlink" title="7.3 训练 recipe：如何不把预训练 VLM 训练废"></a>7.3 训练 recipe：如何不把预训练 VLM 训练废</h3><p>作者明确推荐了<strong>梯度隔离</strong>和分阶段训练：</p><ol><li><p>预训练阶段：</p><ul><li>用人类视频 + 多机器人数据，训练世界模型/潜在动作和 VLA 主干；</li><li>尽量冻结或部分冻结 VLM backbone，避免随机动作头梯度破坏已有表示。</li></ul></li><li><p>后训练阶段：</p><ul><li>在你的高质量机器人数据上，</li><li>只训练动作头或用 LoRA 微调；</li><li>如算力允许，再做有限次 full fine‑tune。</li></ul></li></ol><p>推理阶段，可以启用 RTC / VLA‑Cache / 层级早停等等小 trick，显著降低延迟。</p><h3 id="7-4-背景知识"><a href="#7-4-背景知识" class="headerlink" title="7.4 背景知识"></a>7.4 背景知识</h3><p>问了下GPT相关的概念，它推荐我顺带阅读以下背景知识，在这里贴一下。</p><ul><li><strong>Transformer &amp; Diffusion/Flow Matching</strong> 的基本原理；</li><li>CLIP、SigLIP、DINOv2、BLIP‑2、LLaVA 这些 VLM/MLLM 的结构；</li><li>机器人运动学与控制接口（位置/速度/力控）；</li><li>行为克隆、DAgger、Diffusion Policy、Offline RL 等模仿/强化学习基础；</li><li>点云/体素/NeRF/高斯 Splatting 等 3D 表示。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;论文链接：&lt;/strong&gt;&lt;a href=&quot;https://arxiv.org/abs/2510.07077&quot;&gt;Vision-Language-Action Models for Robotics: A Review Towards Real-World </summary>
      
    
    
    
    <category term="科研" scheme="https://blog.zuquanzhi.top/categories/%E7%A7%91%E7%A0%94/"/>
    
    
    <category term="VLA" scheme="https://blog.zuquanzhi.top/tags/VLA/"/>
    
  </entry>
  
  <entry>
    <title>缓存机制深度解析：Golang 实现与优化</title>
    <link href="https://blog.zuquanzhi.top/2025/10/21/55306/"/>
    <id>https://blog.zuquanzhi.top/2025/10/21/55306/</id>
    <published>2025-10-21T09:04:13.000Z</published>
    <updated>2025-10-21T09:04:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-LRU-缓存概述"><a href="#1-LRU-缓存概述" class="headerlink" title="1. LRU 缓存概述"></a>1. LRU 缓存概述</h2><p>LRU（Least Recently Used，最近最少使用）是一种经典的缓存淘汰策略。其核心思想是：<strong>当缓存空间不足时，优先淘汰最久未被访问的数据</strong>。</p><p>LRU 缓存广泛应用于操作系统（如页面置换）、数据库（如缓冲池）、Web 服务器（如 HTTP 缓存）以及各类应用系统中，用于在有限内存中高效管理热点数据。</p><hr><h2 id="2-LRU-缓存的核心操作"><a href="#2-LRU-缓存的核心操作" class="headerlink" title="2. LRU 缓存的核心操作"></a>2. LRU 缓存的核心操作</h2><p>一个标准的 LRU 缓存需支持以下操作：</p><ul><li><strong>Get(key)</strong>：获取 key 对应的值；若 key 不存在，返回 -1（或其他约定值）。访问后，该 key 应被标记为“最近使用”。</li><li><strong>Put(key, value)</strong>：插入或更新 key-value 对。若缓存已满，则淘汰最久未使用的项。</li></ul><p><strong>时间复杂度要求</strong>：</p><ul><li>Get 和 Put 操作均需 <strong>O(1)</strong> 时间复杂度。</li></ul><hr><h2 id="3-数据结构选择"><a href="#3-数据结构选择" class="headerlink" title="3. 数据结构选择"></a>3. 数据结构选择</h2><p>要实现 O(1) 的 Get 和 Put，需结合两种数据结构：</p><h3 id="3-1-哈希表（map）"><a href="#3-1-哈希表（map）" class="headerlink" title="3.1 哈希表（map）"></a>3.1 哈希表（map）</h3><ul><li>提供 O(1) 的 key 查找。</li><li>存储 key 到链表节点的映射。</li></ul><h3 id="3-2-双向链表（Doubly-Linked-List）"><a href="#3-2-双向链表（Doubly-Linked-List）" class="headerlink" title="3.2 双向链表（Doubly Linked List）"></a>3.2 双向链表（Doubly Linked List）</h3><ul><li>头部：最近使用的元素。</li><li>尾部：最久未使用的元素。</li><li>支持 O(1) 的节点插入（头插）、删除（尾删）和移动（移到头部）。</li></ul><blockquote><p><strong>为什么用双向链表？</strong><br>单向链表无法在 O(1) 时间内删除尾节点（需遍历到倒数第二个节点）。双向链表通过 <code>tail.prev</code> 可直接定位前驱节点。</p></blockquote><hr><h2 id="4-Golang-实现详解"><a href="#4-Golang-实现详解" class="headerlink" title="4. Golang 实现详解"></a>4. Golang 实现详解</h2><h3 id="4-1-定义数据结构"><a href="#4-1-定义数据结构" class="headerlink" title="4.1 定义数据结构"></a>4.1 定义数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lru</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node 表示双向链表的节点</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="type">int</span></span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    prev  *Node</span><br><span class="line">    next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LRUCache 是 LRU 缓存结构</span></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    capacity <span class="type">int</span>           <span class="comment">// 缓存容量</span></span><br><span class="line">    cache    <span class="keyword">map</span>[<span class="type">int</span>]*Node <span class="comment">// 哈希表：key -&gt; Node</span></span><br><span class="line">    head     *Node         <span class="comment">// 虚拟头节点</span></span><br><span class="line">    tail     *Node         <span class="comment">// 虚拟尾节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-初始化"><a href="#4-2-初始化" class="headerlink" title="4.2 初始化"></a>4.2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewLRUCache 创建一个新的 LRU 缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUCache</span><span class="params">(capacity <span class="type">int</span>)</span></span> *LRUCache &#123;</span><br><span class="line">    <span class="comment">// 创建虚拟头尾节点，简化边界处理</span></span><br><span class="line">    head := &amp;Node&#123;&#125;</span><br><span class="line">    tail := &amp;Node&#123;&#125;</span><br><span class="line">    head.next = tail</span><br><span class="line">    tail.prev = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;LRUCache&#123;</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node),</span><br><span class="line">        head:     head,</span><br><span class="line">        tail:     tail,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-辅助方法：链表操作"><a href="#4-3-辅助方法：链表操作" class="headerlink" title="4.3 辅助方法：链表操作"></a>4.3 辅助方法：链表操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addToHead 将节点插入到头部（head 之后）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> addToHead(node *Node) &#123;</span><br><span class="line">    node.prev = lru.head</span><br><span class="line">    node.next = lru.head.next</span><br><span class="line">    lru.head.next.prev = node</span><br><span class="line">    lru.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeNode 从链表中移除指定节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeNode(node *Node) &#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moveToHead 将节点移动到头部（先移除，再插入头部）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *Node) &#123;</span><br><span class="line">    lru.removeNode(node)</span><br><span class="line">    lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// removeTail 移除尾部节点（tail 之前），并返回该节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeTail() *Node &#123;</span><br><span class="line">    last := lru.tail.prev</span><br><span class="line">    lru.removeNode(last)</span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-核心方法：Get"><a href="#4-4-核心方法：Get" class="headerlink" title="4.4 核心方法：Get"></a>4.4 核心方法：Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get 获取 key 对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node, exists := lru.cache[key]; exists &#123;</span><br><span class="line">        <span class="comment">// 访问后移到头部（标记为最近使用）</span></span><br><span class="line">        lru.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-核心方法：Put"><a href="#4-5-核心方法：Put" class="headerlink" title="4.5 核心方法：Put"></a>4.5 核心方法：Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put 插入或更新 key-value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> node, exists := lru.cache[key]; exists &#123;</span><br><span class="line">        <span class="comment">// key 已存在：更新值，并移到头部</span></span><br><span class="line">        node.value = value</span><br><span class="line">        lru.moveToHead(node)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// key 不存在：创建新节点</span></span><br><span class="line">        newNode := &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">        lru.cache[key] = newNode</span><br><span class="line">        lru.addToHead(newNode)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否超出容量</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt; lru.capacity &#123;</span><br><span class="line">            <span class="comment">// 淘汰尾部节点</span></span><br><span class="line">            tail := lru.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(lru.cache, tail.key) <span class="comment">// 从哈希表中删除</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-关键设计细节解析"><a href="#5-关键设计细节解析" class="headerlink" title="5. 关键设计细节解析"></a>5. 关键设计细节解析</h2><h3 id="6-1-虚拟头尾节点（Sentinel-Nodes）"><a href="#6-1-虚拟头尾节点（Sentinel-Nodes）" class="headerlink" title="6.1 虚拟头尾节点（Sentinel Nodes）"></a>6.1 虚拟头尾节点（Sentinel Nodes）</h3><ul><li>避免处理空链表的边界情况。</li><li>插入/删除操作无需判断 <code>prev</code> 或 <code>next</code> 是否为 nil。</li></ul><h3 id="6-2-时间复杂度保证"><a href="#6-2-时间复杂度保证" class="headerlink" title="6.2 时间复杂度保证"></a>6.2 时间复杂度保证</h3><div class="table-container"><table><thead><tr><th>操作</th><th>哈希表</th><th>链表操作</th><th>总体</th></tr></thead><tbody><tr><td>Get</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>Put（更新）</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>Put（插入）</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><h3 id="6-3-空间复杂度"><a href="#6-3-空间复杂度" class="headerlink" title="6.3 空间复杂度"></a>6.3 空间复杂度</h3><ul><li><strong>O(N)</strong>，其中 N 为缓存容量（哈希表 + 链表节点）。</li></ul><hr><blockquote><p><strong>延伸阅读</strong>：  </p><ul><li>LFU（Least Frequently Used）缓存  </li><li>ARC（Adaptive Replacement Cache）  </li><li>Redis 的 LRU 实现（近似 LRU）</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-LRU-缓存概述&quot;&gt;&lt;a href=&quot;#1-LRU-缓存概述&quot; class=&quot;headerlink&quot; title=&quot;1. LRU 缓存概述&quot;&gt;&lt;/a&gt;1. LRU 缓存概述&lt;/h2&gt;&lt;p&gt;LRU（Least Recently Used，最近最少使用）是一种经典</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LRU" scheme="https://blog.zuquanzhi.top/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>gin的中间件机制</title>
    <link href="https://blog.zuquanzhi.top/2025/09/27/44434/"/>
    <id>https://blog.zuquanzhi.top/2025/09/27/44434/</id>
    <published>2025-09-27T07:19:44.000Z</published>
    <updated>2025-12-09T11:34:01.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中间件的概念和原理"><a href="#中间件的概念和原理" class="headerlink" title="中间件的概念和原理"></a>中间件的概念和原理</h2><h3 id="What-is-中间件"><a href="#What-is-中间件" class="headerlink" title="What is 中间件"></a>What is 中间件</h3><p>在Web应用开发中，中间件（Middleware）是位于应用程序与服务器之间的软件组件，能够拦截HTTP请求和响应，并执行特定的逻辑处理。<br>说通俗一点就是，在开始做你真正想做的事之前，要把一些杂活先干完。例如鉴权登录、身份验证、日志记录等等等等。</p><h3 id="Why-is-中间件"><a href="#Why-is-中间件" class="headerlink" title="Why is 中间件"></a>Why is 中间件</h3><p>中间件的核心思想是 <strong>分层处理</strong> 和 <strong>职责分离</strong>。<br>通过将通用的、与业务无关的逻辑抽象出来，放在中间件中处理，可以让业务代码更加 简洁、专注、易于维护。<br>同时，中间件采用 链式调用 的方式，形成一个处理管道，请求依次经过各个中间件，每个中间件都可以在请求到达业务逻辑之前或之后执行特定的操作。<br>这样做一定程度上可以避免屎山产生，对于整个项目的架构和可拓展性起着很重要的作用。</p><h3 id="How-is-中间件"><a href="#How-is-中间件" class="headerlink" title="How is 中间件"></a>How is 中间件</h3><p>Gin的中间件工作原理基于责任链模式（Chain of Responsibility Pattern）。这种设计模式允许多个处理器依次处理同一个请求，每个处理器专注于自己的职责领域。<br>说白了就是挨个问一遍，谁能干谁干，干不了就甩给下家。每一层只关心自己那一档子事，能处理就处理，不能处理就把业务原封不动往下传，直到有人搞定为止。（像极了某些效率低下的臃肿团队）</p><p>在Gin中，每个中间件可以执行以下操作：</p><ul><li>前置操作：在请求处理前执行某些逻辑</li><li>流程控制：通过调用c.Next()将控制权传递给下一个中间件</li><li>后置操作：在下游中间件执行完毕后继续执行操作</li><li>中断处理：通过调用c.Abort()终止后续中间件的执行</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                            HTTP请求                                  │</span><br><span class="line">└───────────────────────────────┬─────────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line">┌───────────────────────────────▼─────────────────────────────────────┐</span><br><span class="line">│              中间件<span class="number">1</span>前置逻辑（如：请求日志记录开始）                    │</span><br><span class="line">└───────────────────────────────┬─────────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line">                                │  c.<span class="keyword">Next</span>()调用</span><br><span class="line">                                │</span><br><span class="line">┌───────────────────────────────▼─────────────────────────────────────┐</span><br><span class="line">│                中间件<span class="number">2</span>前置逻辑（如：身份验证）                         │</span><br><span class="line">└───────────────────────────────┬─────────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line">                                │  c.<span class="keyword">Next</span>()调用</span><br><span class="line">                                │</span><br><span class="line">┌───────────────────────────────▼─────────────────────────────────────┐</span><br><span class="line">│                最终处理函数（如：获取用户列表）                        │</span><br><span class="line">└───────────────────────────────┬─────────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line">                                │  处理函数返回</span><br><span class="line">                                │</span><br><span class="line">┌───────────────────────────────▼─────────────────────────────────────┐</span><br><span class="line">│                 中间件<span class="number">2</span>后置逻辑（如：记录操作日志）                    │</span><br><span class="line">└───────────────────────────────┬─────────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line">                                │  返回到中间件<span class="number">1</span></span><br><span class="line">                                │</span><br><span class="line">┌───────────────────────────────▼─────────────────────────────────────┐</span><br><span class="line">│               中间件<span class="number">1</span>后置逻辑（如：计算响应时间）                      │</span><br><span class="line">└───────────────────────────────┬─────────────────────────────────────┘</span><br><span class="line">                                │</span><br><span class="line">┌───────────────────────────────▼─────────────────────────────────────┐</span><br><span class="line">│                          HTTP响应                                    │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="Gin-中间件的类型"><a href="#Gin-中间件的类型" class="headerlink" title="Gin 中间件的类型"></a>Gin 中间件的类型</h2><ol><li>全局中间件：应用于所有路由，在任何路由处理之前执行。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局中间件：应用于所有路由</span></span><br><span class="line">router.Use(Logger())</span><br></pre></td></tr></table></figure></li><li>路由组中间件：只应用于特定路由组内的路由<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由组中间件：只应用于authorized组</span></span><br><span class="line">authorized := router.Group(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">authorized.Use(AuthRequired())</span><br></pre></td></tr></table></figure></li><li>单个路由中间件<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个路由中间件：只应用于此路由</span></span><br><span class="line">router.GET(<span class="string">&quot;/benchmark&quot;</span>, MyBenchLogger(), benchEndpoint)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Gin-内置的中间件"><a href="#Gin-内置的中间件" class="headerlink" title="Gin 内置的中间件"></a>Gin 内置的中间件</h2><p>Gin 框架虽然以“轻量”著称，但也贴心地提供了一些<strong>开箱即用的中间件</strong>，帮助开发者快速实现常见功能。这些中间件都位于 <code>gin</code> 包或官方扩展库 <code>github.com/gin-contrib</code> 中。</p><h3 id="1-Logger-——-请求日志记录"><a href="#1-Logger-——-请求日志记录" class="headerlink" title="1. Logger() —— 请求日志记录"></a>1. <code>Logger()</code> —— 请求日志记录</h3><p>这是最常用的中间件之一，自动记录每个 HTTP 请求的基本信息（方法、路径、状态码、耗时等）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.Use(gin.Logger())</span><br></pre></td></tr></table></figure><p>输出示例：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GIN] <span class="number">2025</span>/<span class="number">09</span>/<span class="number">27</span> - <span class="number">15</span>:<span class="number">30</span>:<span class="number">45</span> | <span class="type">200</span> |    <span class="type">1</span><span class="number">.2</span>ms |       <span class="type">127</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> | <span class="type">GET</span>      <span class="string">&quot;/api/users&quot;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>💡 提示：生产环境中更推荐使用结构化日志（如 <code>zap</code> + 自定义中间件），但开发阶段 <code>Logger()</code> 足够好用。</p></blockquote><hr><h3 id="2-Recovery-——-崩溃恢复"><a href="#2-Recovery-——-崩溃恢复" class="headerlink" title="2. Recovery() —— 崩溃恢复"></a>2. <code>Recovery()</code> —— 崩溃恢复</h3><p>当你的 handler 中发生 panic 时，<code>Recovery()</code> 能捕获异常，防止整个服务崩溃，并返回 500 错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.Use(gin.Recovery())</span><br></pre></td></tr></table></figure><p>默认会打印 panic 堆栈到 stderr，你也可以自定义恢复逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.Use(gin.CustomRecovery(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context, recovered <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    c.String(<span class="number">500</span>, <span class="string">&quot;服务器开小差了，请稍后再试~&quot;</span>)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><hr><h3 id="3-其他常用官方中间件（来自-gin-contrib）"><a href="#3-其他常用官方中间件（来自-gin-contrib）" class="headerlink" title="3. 其他常用官方中间件（来自 gin-contrib）"></a>3. 其他常用官方中间件（来自 <code>gin-contrib</code>）</h3><p>Gin 官方维护了一系列高质量中间件，需单独安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-contrib/cors</span><br><span class="line">go get github.com/gin-contrib/static</span><br><span class="line">go get github.com/gin-contrib/sse</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>中间件</th><th>作用</th></tr></thead><tbody><tr><td><code>cors</code></td><td>处理跨域请求（CORS）</td></tr><tr><td><code>static</code></td><td>提供静态文件服务（如前端资源）</td></tr><tr><td><code>gzip</code></td><td>自动压缩响应体（节省带宽）</td></tr><tr><td><code>secure</code></td><td>添加安全相关的 HTTP 头（如 XSS 保护）</td></tr><tr><td><code>timeout</code></td><td>为路由设置超时控制</td></tr></tbody></table></div><p><strong>示例：启用 CORS</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-contrib/cors&quot;</span></span><br><span class="line"></span><br><span class="line">router.Use(cors.Default()) <span class="comment">// 允许所有来源（仅开发环境！）</span></span><br></pre></td></tr></table></figure></p><blockquote><p>⚠️ 注意：<code>cors.Default()</code> 仅用于开发！生产环境应配置具体域名。</p></blockquote><hr><h2 id="自定义中间件实战"><a href="#自定义中间件实战" class="headerlink" title="自定义中间件实战"></a>自定义中间件实战</h2><p>中间件的本质就是一个 <strong><code>func(c *gin.Context)</code></strong> 类型的函数。下面通过几个例子展示如何编写实用中间件。</p><h3 id="示例-1：鉴权中间件（AuthRequired）"><a href="#示例-1：鉴权中间件（AuthRequired）" class="headerlink" title="示例 1：鉴权中间件（AuthRequired）"></a>示例 1：鉴权中间件（AuthRequired）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthRequired</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        token := c.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">&quot;Bearer secret123&quot;</span> &#123;</span><br><span class="line">            c.AbortWithStatusJSON(<span class="number">401</span>, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: <span class="string">&quot;未授权，请提供有效 token&quot;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证通过，继续</span></span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">admin := router.Group(<span class="string">&quot;/admin&quot;</span>)</span><br><span class="line">admin.Use(AuthRequired())</span><br><span class="line">&#123;</span><br><span class="line">    admin.GET(<span class="string">&quot;/users&quot;</span>, listUsers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="示例-2：请求耗时统计中间件"><a href="#示例-2：请求耗时统计中间件" class="headerlink" title="示例 2：请求耗时统计中间件"></a>示例 2：请求耗时统计中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequestTime</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        start := time.Now()</span><br><span class="line">        </span><br><span class="line">        c.Next() <span class="comment">// 等待下游处理完成</span></span><br><span class="line">        </span><br><span class="line">        duration := time.Since(start)</span><br><span class="line">        c.Header(<span class="string">&quot;X-Response-Time&quot;</span>, duration.String())</span><br><span class="line">        log.Printf(<span class="string">&quot;[%s] %s %s → %v&quot;</span>, </span><br><span class="line">            c.Request.Method, </span><br><span class="line">            c.Request.URL.Path, </span><br><span class="line">            c.Writer.Status(), </span><br><span class="line">            duration)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个中间件会在响应头中加入 <code>X-Response-Time</code>，同时打印日志，方便性能分析。</p><hr><h3 id="示例-3：防重复提交（基于内存-过期时间）"><a href="#示例-3：防重复提交（基于内存-过期时间）" class="headerlink" title="示例 3：防重复提交（基于内存 + 过期时间）"></a>示例 3：防重复提交（基于内存 + 过期时间）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    requestCache = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]time.Time)</span><br><span class="line">    cacheMutex   = sync.RWMutex&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreventDuplicateRequest</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        key := c.ClientIP() + c.Request.URL.Path + c.Request.UserAgent()</span><br><span class="line">        </span><br><span class="line">        cacheMutex.Lock()</span><br><span class="line">        <span class="keyword">defer</span> cacheMutex.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> t, exists := requestCache[key]; exists &amp;&amp; time.Since(t) &lt; <span class="number">2</span>*time.Second &#123;</span><br><span class="line">            c.AbortWithStatusJSON(<span class="number">429</span>, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;请求太频繁，请稍后再试&quot;</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        requestCache[key] = time.Now()</span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间件使用实践"><a href="#中间件使用实践" class="headerlink" title="中间件使用实践"></a>中间件使用实践</h2><h3 id="1-中间件顺序很重要！"><a href="#1-中间件顺序很重要！" class="headerlink" title="1. 中间件顺序很重要！"></a>1. <strong>中间件顺序很重要！</strong></h3><p>Gin 中间件是<strong>从注册顺序依次执行前置逻辑，再逆序执行后置逻辑</strong>。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.Use(Logger(), Recovery(), AuthRequired())</span><br></pre></td></tr></table></figure><p>执行顺序：</p><ol><li>Logger 前置</li><li>Recovery 前置</li><li>AuthRequired 前置</li><li>Handler 执行</li><li>AuthRequired 后置（几乎没有）</li><li>Recovery 后置（处理 panic）</li><li>Logger 后置（记录耗时）</li></ol><blockquote><p>建议顺序：<code>Recovery → Logger → Auth → RateLimit → Handler</code></p></blockquote><hr><h3 id="2-不要滥用全局中间件"><a href="#2-不要滥用全局中间件" class="headerlink" title="2. 不要滥用全局中间件"></a>2. <strong>不要滥用全局中间件</strong></h3><p>全局中间件会对<strong>每一个请求</strong>生效，包括静态资源、健康检查等。不必要的中间件会拖慢性能。</p><p><strong>反例：</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.Use(AuthRequired()) <span class="comment">// 所有路由都要登录？包括 /health？</span></span><br></pre></td></tr></table></figure></p><p><strong>正例：</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">api := router.Group(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">api.Use(AuthRequired()) <span class="comment">// 只保护 API 路由</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="3-中间件应尽量无状态、幂等"><a href="#3-中间件应尽量无状态、幂等" class="headerlink" title="3. 中间件应尽量无状态、幂等"></a>3. <strong>中间件应尽量无状态、幂等</strong></h3><p>避免在中间件中修改请求体（<code>c.Request.Body</code> 只能读一次），如需多次读取，可使用 <code>c.GetRawData()</code> 或封装 <code>io.TeeReader</code>。</p><hr><h3 id="4-合理使用-c-Abort-和-c-Next"><a href="#4-合理使用-c-Abort-和-c-Next" class="headerlink" title="4. 合理使用 c.Abort() 和 c.Next()"></a>4. <strong>合理使用 c.Abort() 和 c.Next()</strong></h3><ul><li><code>c.Next()</code>：继续执行下一个中间件（通常放在前置逻辑后）</li><li><code>c.Abort()</code>：立即终止后续中间件和 handler（常用于鉴权失败）</li><li><code>c.AbortWithStatusJSON()</code>：终止并返回 JSON 响应（推荐）</li></ul><hr><p>Gin 的中间件机制是其强大灵活性的核心之一。它用极简的 API 实现了强大的<strong>请求处理管道</strong>，让开发者可以像搭积木一样组合功能。</p><ul><li><strong>理解责任链模式</strong>是掌握中间件的关键；</li><li><strong>善用内置中间件</strong>能快速搭建基础能力；</li><li><strong>自定义中间件</strong>让你轻松集成业务逻辑；</li><li><strong>注意顺序与性能</strong>，避免“中间件陷阱”。</li></ul><p>当你能把日志、鉴权、限流、监控等横切关注点优雅地封装进中间件，你的 Go 项目就已经走在了<strong>清晰、可维护、可扩展</strong>的正道上。</p><blockquote><p>🌈 <strong>“好的中间件，让业务代码只关心业务。”</strong></p></blockquote><hr><p><strong>参考链接：</strong></p><ul><li><a href="https://gin-gonic.com/docs/middleware/">Gin 官方文档 - Middleware</a></li><li><a href="https://github.com/gin-contrib">gin-contrib 中间件仓库</a></li><li><a href="https://blog.csdn.net/gophertribe/article/details/146546615">gin框架从入门到精通</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;中间件的概念和原理&quot;&gt;&lt;a href=&quot;#中间件的概念和原理&quot; class=&quot;headerlink&quot; title=&quot;中间件的概念和原理&quot;&gt;&lt;/a&gt;中间件的概念和原理&lt;/h2&gt;&lt;h3 id=&quot;What-is-中间件&quot;&gt;&lt;a href=&quot;#What-is-中间件&quot; c</summary>
      
    
    
    
    <category term="Golang" scheme="https://blog.zuquanzhi.top/categories/Golang/"/>
    
    
    <category term="Golang" scheme="https://blog.zuquanzhi.top/tags/Golang/"/>
    
    <category term="中间件" scheme="https://blog.zuquanzhi.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>深入解析Go中Slice底层实现</title>
    <link href="https://blog.zuquanzhi.top/2025/09/22/59604/"/>
    <id>https://blog.zuquanzhi.top/2025/09/22/59604/</id>
    <published>2025-09-22T05:17:44.000Z</published>
    <updated>2025-12-09T11:33:11.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Slice的底层数据结构"><a href="#一、Slice的底层数据结构" class="headerlink" title="一、Slice的底层数据结构"></a>一、Slice的底层数据结构</h2><p>切片是 Go 中的一种基本的数据结构，是对底层数组的一个动态、灵活的视图。使用这种结构可以用来管理数据集合。切片的设计想法是由动态数组概念而来，为了开发者可以更加方便的使一个数据结构可以自动增加和减少。但是切片本身并不是动态数据或者数组指针。</p><p>在golang runtime中，slice的实现并不是一个指针，而是一组结构体:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go 中的定义</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 指向底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span>            <span class="comment">// 当前长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span>            <span class="comment">// 容量（从起始位置到底层数组末尾的元素个数）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。</p><p>切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C++ 中的 Vector 类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。</p><p>给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个长度可变的数组。</p><h2 id="二、内存布局"><a href="#二、内存布局" class="headerlink" title="二、内存布局"></a>二、内存布局</h2><p>假设我们有<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// s 指向 arr[1] 到 arr[3]</span></span><br></pre></td></tr></table></figure><br>则内存布局如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">底层数组 arr:</span><br><span class="line">索引:  0   1   2   3   4   5</span><br><span class="line">值:   [0][1][2][3][4][5]</span><br><span class="line">       ↑           ↑</span><br><span class="line">       |___________|</span><br><span class="line">           s 的范围（len=3）</span><br><span class="line"></span><br><span class="line">s 的结构：</span><br><span class="line">- array → 指向 arr[1] 的地址</span><br><span class="line">- len   = 3</span><br><span class="line">- cap   = 5 （因为从 arr[1] 到 arr[5] 共 5 个元素）</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>cap = len(arr) - start_index = 6 - 1 = 5</strong></p></blockquote><hr><h2 id="三、关键操作的底层行为"><a href="#三、关键操作的底层行为" class="headerlink" title="三、关键操作的底层行为"></a>三、关键操作的底层行为</h2><h3 id="1-创建切片（字面量或-make）"><a href="#1-创建切片（字面量或-make）" class="headerlink" title="1. 创建切片（字面量或 make）"></a>1. 创建切片（字面量或 make）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>Go 会在堆上分配一个底层数组 <code>[10, 20, 30]</code></li><li>创建一个 slice 结构体：<ul><li><code>array</code> → 指向该数组首地址</li><li><code>len = 3</code></li><li><code>cap = 3</code></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li>分配一个长度为 5 的底层数组（初始化为 0）</li><li>slice 结构体：<ul><li><code>array</code> → 指向数组首地址</li><li><code>len = 2</code></li><li><code>cap = 5</code></li></ul></li></ul><hr><h3 id="2-切片操作（s-i-j-）"><a href="#2-切片操作（s-i-j-）" class="headerlink" title="2. 切片操作（s[i:j]）"></a>2. 切片操作（s[i:j]）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := a[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><ul><li><code>b.array = a.array + 1 * sizeof(int)</code>（指针偏移）</li><li><code>b.len = 4 - 1 = 3</code></li><li><code>b.cap = a.cap - 1 = 6 - 1 = 5</code></li></ul><blockquote><p><strong>不复制数据！只是调整指针和长度/容量。</strong></p></blockquote><p>验证代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    b := a[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a 地址: %p, len=%d, cap=%d\n&quot;</span>, &amp;a[<span class="number">0</span>], <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;b 地址: %p, len=%d, cap=%d\n&quot;</span>, &amp;b[<span class="number">0</span>], <span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 b 影响 a</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;修改 b[0] 后 a =&quot;</span>, a) <span class="comment">// [0 999 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 地址: 0xc0000140c0, <span class="attribute">len</span>=6, <span class="attribute">cap</span>=6</span><br><span class="line">b 地址: 0xc0000140c8, <span class="attribute">len</span>=3, <span class="attribute">cap</span>=5</span><br><span class="line">修改 b[0] 后 a = [0 999 2 3 4 5]</span><br></pre></td></tr></table></figure></p><blockquote><p><code>b</code> 的起始地址比 <code>a</code> 大 8 字节（64 位系统，int 占 8 字节），说明指针偏移。</p></blockquote><hr><h3 id="3-append-的底层逻辑"><a href="#3-append-的底层逻辑" class="headerlink" title="3. append 的底层逻辑"></a>3. <code>append</code> 的底层逻辑</h3><p><code>append</code> 的伪代码逻辑如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []T, elements ...T)</span></span> []T &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(slice)+<span class="built_in">len</span>(elements) &gt; <span class="built_in">cap</span>(slice) &#123;</span><br><span class="line">        <span class="comment">// 容量不足，需要扩容</span></span><br><span class="line">        newCap := growCap(<span class="built_in">cap</span>(slice), <span class="built_in">len</span>(slice), <span class="built_in">len</span>(elements))</span><br><span class="line">        newSlice := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(slice), newCap)</span><br><span class="line">        <span class="built_in">copy</span>(newSlice, slice) <span class="comment">// 复制旧数据</span></span><br><span class="line">        slice = newSlice</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新元素追加到 slice[len(slice):]</span></span><br><span class="line">    <span class="built_in">copy</span>(slice[<span class="built_in">len</span>(slice):], elements)</span><br><span class="line">    slice.<span class="built_in">len</span> += <span class="built_in">len</span>(elements)</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩容策略（Go-1-18-）："><a href="#扩容策略（Go-1-18-）：" class="headerlink" title="扩容策略（Go 1.18+）："></a>扩容策略（Go 1.18+）：</h4><ul><li>如果 <code>cap &lt; 1024</code>：新容量 ≈ 2 * 旧容量</li><li>如果 <code>cap &gt;= 1024</code>：每次增加约 1/4 容量（直到满足需求）</li></ul><blockquote><p>实际策略更复杂，考虑内存对齐等。</p></blockquote><p>示例：观察扩容</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;初始: len=%d, cap=%d\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;追加 %d 后: len=%d, cap=%d\n&quot;</span>, i, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始: <span class="attribute">len</span>=0, <span class="attribute">cap</span>=0</span><br><span class="line">追加 0 后: <span class="attribute">len</span>=1, <span class="attribute">cap</span>=1</span><br><span class="line">追加 1 后: <span class="attribute">len</span>=2, <span class="attribute">cap</span>=2</span><br><span class="line">追加 2 后: <span class="attribute">len</span>=3, <span class="attribute">cap</span>=4</span><br><span class="line">追加 3 后: <span class="attribute">len</span>=4, <span class="attribute">cap</span>=4</span><br><span class="line">追加 4 后: <span class="attribute">len</span>=5, <span class="attribute">cap</span>=8</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p><blockquote><p>可见容量按 1→2→4→8 增长（指数增长）。</p></blockquote><hr><h3 id="4-copy-的底层行为"><a href="#4-copy-的底层行为" class="headerlink" title="4. copy 的底层行为"></a>4. <code>copy</code> 的底层行为</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">src := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">n := <span class="built_in">copy</span>(dst, src)</span><br></pre></td></tr></table></figure><ul><li>底层调用 <code>memmove</code>（或类似）复制 <code>min(len(dst), len(src))</code> 个元素</li><li><strong>不改变 dst 的 len/cap，只改内容</strong></li></ul><hr><h2 id="四、使用-unsafe-观察-slice-结构（高级）"><a href="#四、使用-unsafe-观察-slice-结构（高级）" class="headerlink" title="四、使用 unsafe 观察 slice 结构（高级）"></a>四、使用 <code>unsafe</code> 观察 slice 结构（高级）</h2><blockquote><p>⚠️ 仅用于学习，生产代码避免使用 <code>unsafe</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice s: %v\n&quot;</span>, s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 slice 强制转换为结构体指针</span></span><br><span class="line">    <span class="keyword">type</span> sliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">        ptr <span class="type">uintptr</span></span><br><span class="line">        <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">        <span class="built_in">cap</span> <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h := (*sliceHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;ptr: 0x%x, len: %d, cap: %d\n&quot;</span>, h.ptr, h.<span class="built_in">len</span>, h.<span class="built_in">cap</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 ptr 指向第一个元素</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;s[0] 地址: %p\n&quot;</span>, &amp;s[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">slice</span> s:<span class="meta"> [10 20 30]</span></span><br><span class="line"><span class="attribute">ptr</span>: <span class="number">0</span>xc0000140c0, len: <span class="number">3</span>, cap: <span class="number">3</span></span><br><span class="line"><span class="attribute">s</span>[<span class="number">0</span>] 地址: <span class="number">0</span>xc0000140c0</span><br></pre></td></tr></table></figure></p><blockquote><p><code>ptr</code> 与 <code>&amp;s[0]</code> 地址一致，验证了 slice 的指针指向底层数组首元素。</p></blockquote><hr><blockquote><p>引用</p><ul><li><a href="https://halfrost.com/go_slice/#toc-1">深入解析 Go 中 Slice 底层实现</a></li><li><a href="https://chat.qwen.ai/">Qwen</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Slice的底层数据结构&quot;&gt;&lt;a href=&quot;#一、Slice的底层数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、Slice的底层数据结构&quot;&gt;&lt;/a&gt;一、Slice的底层数据结构&lt;/h2&gt;&lt;p&gt;切片是 Go 中的一种基本的数据结构，是对底</summary>
      
    
    
    
    <category term="Golang" scheme="https://blog.zuquanzhi.top/categories/Golang/"/>
    
    
    <category term="Golang" scheme="https://blog.zuquanzhi.top/tags/Golang/"/>
    
    <category term="Slice" scheme="https://blog.zuquanzhi.top/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>搭建Docker私有镜像站</title>
    <link href="https://blog.zuquanzhi.top/2025/09/17/7375/"/>
    <id>https://blog.zuquanzhi.top/2025/09/17/7375/</id>
    <published>2025-09-17T10:44:21.000Z</published>
    <updated>2025-09-17T13:30:58.692Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://goharbor.io/docs/2.13.0/install-config/">Harbor &ndash; Harbor Installation and Configuration</a></p><p>技术难度一般，因为它本身就是一个容器在跑，当成<a href="https://www.docker.com/">docker.io</a>用就好。</p><p><h3 id="cfc90029"><font style="color:rgb(25, 27, 31);">1、什么是</font><a href="https://zhida.zhihu.com/search?content_id=245844410&amp;content_type=Article&amp;match_order=1&amp;q=Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93&amp;zhida_source=entity"><font style="color:rgb(9, 64, 142);">Docker私有仓库</font></a><font style="color:rgb(25, 27, 31);"></font></h3></p><font style="color:rgb(25, 27, 31);">Docker私有仓库是用于存储和管理Docker镜像的私有存储库。Docker默认会有一个公共的仓库</font>[<font style="color:rgb(9, 64, 142);">Docker Hub</font>](https://zhida.zhihu.com/search?content_id=245844410&content_type=Article&match_order=1&q=Docker+Hub&zhida_source=entity)<font style="color:rgb(25, 27, 31);">，而与Docker Hub不同，私有仓库是受限访问的，只有授权用户才能够上传、下载和管理其中的镜像。这种私有仓库可以部署在本地云环境中，用于组织内部开发、测试和生产环境中的容器镜像管理。保证数据安全性。</font><p><h3 id="c74ebac1"><font style="color:rgb(25, 27, 31);">2、Docker有哪些私有仓库</font></h3><br><strong><font style="color:rgb(25, 27, 31);">以下是一些常见的Docker私有仓库：</font></strong><font style="color:rgb(25, 27, 31);">  </font></p><ul><li><strong><font style="color:rgb(25, 27, 31);">Harbor</font></strong><font style="color:rgb(25, 27, 31);">：作为一个企业级的Docker Registry服务，Harbor提供了安全、可信赖的镜像存储和管理功能。它支持RBAC权限控制、镜像复制、镜像签名、漏洞扫描等功能。</font></li><li><a href="https://zhida.zhihu.com/search?content_id=245844410&amp;content_type=Article&amp;match_order=1&amp;q=Docker+Trusted+Registry&amp;zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">Docker Trusted Registry</font></strong></a><strong><font style="color:rgb(25, 27, 31);"> </font>**</strong><font style="color:rgb(25, 27, 31);">(DTR)</font>**<font style="color:rgb(25, 27, 31);">：由Docker官方推出的企业级Docker私有仓库服务，与Docker Engine紧密集成，支持高度的安全性和可靠性。</font></li><li><a href="https://zhida.zhihu.com/search?content_id=245844410&amp;content_type=Article&amp;match_order=1&amp;q=Portus&amp;zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">Portus</font></strong></a><font style="color:rgb(25, 27, 31);">：一个开源的Docker镜像管理和认证服务，提供用户管理、团队管理、镜像审核等功能，与Docker Registry兼容。</font></li><li><strong><font style="color:rgb(25, 27, 31);">Nexus Repository Manager</font></strong><font style="color:rgb(25, 27, 31);">：虽然主要是用于构建和管理Java组件，但也可以用作Docker私有仓库。它具有强大的存储管理和权限控制功能。</font></li><li><a href="https://zhida.zhihu.com/search?content_id=245844410&amp;content_type=Article&amp;match_order=1&amp;q=GitLab+Container+Registry&amp;zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">GitLab Container Registry</font></strong></a><font style="color:rgb(25, 27, 31);">：GitLab集成了容器注册表功能，允许您存储、管理和分发Docker镜像。这是GitLab自带的功能，无需额外部署。</font></li><li><a href="https://zhida.zhihu.com/search?content_id=245844410&amp;content_type=Article&amp;match_order=1&amp;q=AWS+Elastic+Container+Registry&amp;zhida_source=entity"><strong><font style="color:rgb(9, 64, 142);">AWS Elastic Container Registry</font></strong></a><strong><font style="color:rgb(25, 27, 31);"> (ECR)</font></strong><font style="color:rgb(25, 27, 31);">：如果使用AWS云服务，可以考虑使用AWS ECR作为私有仓库。它与AWS的其他服务集成紧密，对AWS用户来说是一个方便的选择。</font></li></ul><font style="color:rgb(25, 27, 31);">本篇使用Harbor搭建Docker私有仓库。</font><p><h3 id="f69114e1"><font style="color:rgb(25, 27, 31);">3、Harbor简介</font></h3></p><font style="color:rgb(25, 27, 31);">Harbor是一个开源的企业级Docker Registry服务，它提供了一个安全、可信赖的仓库来存储和管理Docker镜像。Harbor翻译为中文名称为"庇护；居住;"。可以理解为是Docker镜像的"居住环境"或者是镜像的"庇护所"。Harbor最初由</font>[<font style="color:rgb(9, 64, 142);">VMware</font>](https://zhida.zhihu.com/search?content_id=245844410&content_type=Article&match_order=1&q=VMware&zhida_source=entity)<font style="color:rgb(25, 27, 31);">公司开发，旨在解决企业级Docker镜像管理的安全和可信任性问题。VMware于2016年发布，在2017年，VMware将Harbor开源，这使得更广泛的社区和组织可以自由地使用和贡献代码。Harbor是一个成熟、功能丰富且安全可靠的企业级Docker Registry服务，为企业容器化应用的部署和管理提供了强大的支持。</font><font style="color:rgb(25, 27, 31);"></font><font style="color:rgb(25, 27, 31);">Harbor官网地址：</font>[Harbor (goharbor.io)](https://link.zhihu.com/?target=https%3A//goharbor.io/)<font style="color:rgb(25, 27, 31);"></font><font style="color:rgb(25, 27, 31);">Github开源地址：</font>[https://github.com/goharbor/harbor](https://link.zhihu.com/?target=https%3A//github.com/goharbor/harbor)<font style="color:rgb(25, 27, 31);"></font><p><h3 id="fabbg"><font style="color:rgb(25, 27, 31);">4、Harbor下载</font></h3></p><p><h4 id="sa11I"><font style="color:rgb(25, 27, 31);">4.1、通过Linux命令下载</font></h4><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/goharbor/harbor/releases/download/v2.10.0/harbor-offline-installer-v2.10.0.tgz</span><br></pre></td></tr></table></figure></p><p><h4 id="sMZzM"><font style="color:rgb(25, 27, 31);">4.2、GitHub下载</font></h4></p><font style="color:rgb(25, 27, 31);">下载地址：</font>[https://github.com/goharbor/harbor/releases](https://link.zhihu.com/?target=https%3A//github.com/goharbor/harbor/releases)<font style="color:rgb(25, 27, 31);"> 下载离线版本</font><p><h4 id="x1kRL"><font style="color:rgb(25, 27, 31);">4.3、解压</font></h4></p><font style="color:rgb(25, 27, 31);">解压文件</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v2.10.0.tgz</span><br></pre></td></tr></table></figure><p><h3 id="cff1f693"><font style="color:rgb(25, 27, 31);">5、启动Harbor</font></h3></p><p><h4 id="aeMOB"><font style="color:rgb(25, 27, 31);">5.1、修改配置文件</font></h4></p><font style="color:rgb(25, 27, 31);">复制</font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">harbor.yml.tmpl</font>`<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">文件并重命名为</font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">harbor.yml</font>`<font style="color:rgb(25, 27, 31);">修改此配置文件，需要设置hostname、端口、数据库密码等。</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp harbor.yml.tmpl harbor.yml #拷贝</span><br><span class="line"></span><br><span class="line">vim harbor.yml</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">修改配置文件：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#修改hostname的值，如果没有域名就使用本机IP地址</span><br><span class="line">hostname: 192.168.1.7</span><br><span class="line"></span><br><span class="line">#配置启动端口号</span><br><span class="line"># http related config </span><br><span class="line">http:</span><br><span class="line">  # port for http, default is 80. If https enabled, this port will redirect to https port</span><br><span class="line">  port: 5000</span><br><span class="line"></span><br><span class="line"># 如果没有申请证书，需要隐藏https</span><br><span class="line">#https:</span><br><span class="line">  # https port for harbor, default is 443</span><br><span class="line">#  port: 443</span><br><span class="line">  # The path of cert and key files for nginx</span><br><span class="line">#  certificate: /your/certificate/path</span><br><span class="line">#  private_key: /your/private/key/path</span><br><span class="line"></span><br><span class="line">#启动成功后，admin用户登录密码</span><br><span class="line"># Remember Change the admin password from UI after launching Harbor.</span><br><span class="line">harbor_admin_password: AdminHarbor12345</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">  </font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887672226-5d48f300-e744-4018-b494-3cc55009e72a.png" alt=""></p><font style="color:rgb(25, 27, 31);"></font><p><h4 id="lp6U4"><font style="color:rgb(25, 27, 31);">5.2、启动</font></h4></p><font style="color:rgb(25, 27, 31);">配置文件修改成功后，执行</font><font style="color:rgb(25, 27, 31);"> </font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">install.sh</font>`<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">脚本进行安装harbor</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">启动报错：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Step 0]: checking if docker is installed ...</span><br><span class="line"></span><br><span class="line">Note: docker version: 26.1.3</span><br><span class="line"></span><br><span class="line">[Step 1]: checking docker-compose is installed ...</span><br><span class="line">/opt/harbor/common.sh: line 119: docker-compose: command not found</span><br><span class="line">✖ Failed to parse docker-compose version.</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">可以看到，该服务器安装的 </font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">docker</font>`<font style="color:rgb(25, 27, 31);"> 没有安装 </font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">docker-compose</font>`<font style="color:rgb(25, 27, 31);"> 插件</font><p><h4 id="s2Evh"><font style="color:rgb(25, 27, 31);">5.3、安装docker-compose</font></h4></p><font style="color:rgb(25, 27, 31);"></font><font style="color:rgb(25, 27, 31);">进入</font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">docker-compose</font>`<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">官网下载执行文件，地址：</font><font style="color:rgb(25, 27, 31);"> </font>[https://github.com/docker/compose](https://link.zhihu.com/?target=https%3A//github.com/docker/compose)<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">下载成功后，把可执行文件加入</font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">Linux</font>`<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">系统命令目录</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp docker-compose-linux-x86_64 /usr/local/bin/</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">重命名：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv docker-compose-linux-x86_64 docker-compose</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">授权：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">执行命令查看是否安装成功：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">如果需要卸载，直接删除即可：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">  </font><p><h4 id="rijkf"><font style="color:rgb(25, 27, 31);">5.4、再次启动</font></h4></p><font style="color:rgb(25, 27, 31);"></font><font style="color:rgb(25, 27, 31);">再次执行 </font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">./install.sh</font>`<font style="color:rgb(25, 27, 31);"></font><font style="color:rgb(25, 27, 31);">提示安装成功。接下来就可以访问Harbor了。访问IP+端口：192.168.1.7:5000  </font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887524392-a8babaab-f73e-4c9e-a606-8b41a41620a9.png" alt=""></p><font style="color:rgb(25, 27, 31);">访问成功，由于Harbor是通过docker管理的，所以启动非常方便。如果首页访问成功说明Docker私有仓库已经部署成功了。</font><p><h3 id="a3896d11"><font style="color:rgb(25, 27, 31);">6、Harbor Web页面操作说明</font></h3></p><font style="color:rgb(25, 27, 31);">默认用户名是admin，密码是启动时设置的密码：</font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">herodocker</font>`<font style="color:rgb(25, 27, 31);">登录成功进入主页面了。从系统首页可以看到系统分为三个菜单：项目、日志、系统管理。</font><p><h4 id="ICD5n"><font style="color:rgb(25, 27, 31);">6.1、项目</font></h4></p><font style="color:rgb(25, 27, 31);">项目管理顾名思义就是用来管理项目的。可以为每一个开发项目创建一个私有项目库，然后把Docker镜像存储到指定的项目中，为每个项目实现项目镜像隔离。创建项目的时候，Harbor提供了公开库（public repository）和私有库（private repository）两种类型的镜像存储空间。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887710628-c2d36d33-63c8-42de-a689-0836c5ad27be.png" alt=""></p><font style="color:rgb(25, 27, 31);">通过详情信息可以看到：</font>**<font style="color:rgb(25, 27, 31);">公开库中的镜像是对所有用户可见和可访问的，任何人都可以查看和拉取其中的镜像。而私有库中的镜像则需要登录才能访问控制，只有被授权的用户或团队才能够查看、拉取和推送镜像。</font>**<font style="color:rgb(25, 27, 31);"> 可以根据需要创建相关的项目。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887725468-c6afde0b-24a4-4004-84dc-5ff44bfff990.png" alt=""></p><font style="color:rgb(25, 27, 31);">项目创建成功后，可以点击进入项目。在里面可以为每个项目单独设置不同的配置信息。可以为每一个项目添加成员信息。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887888761-3c1d162f-1f40-40a7-a10d-bb09ede9461d.png" alt=""></p><font style="color:rgb(25, 27, 31);"></font><font style="color:rgb(25, 27, 31);">角色权限说明：</font><ul><li><strong><font style="color:rgb(25, 27, 31);">项目管理员（Project Administrator）：</font></strong><font style="color:rgb(25, 27, 31);">拥有项目的最高权限，可以对项目进行全面管理，包括创建和删除项目、管理项目成员和权限、配置项目属性、查看项目日志等。</font></li><li><strong><font style="color:rgb(25, 27, 31);">维护人员（Maintainer）：</font></strong><font style="color:rgb(25, 27, 31);">类似于项目管理员，但权限稍低，通常用于协助管理项目，可以进行项目的部分管理操作，如添加和删除镜像、配置镜像的复制和同步规则等。</font></li><li><strong><font style="color:rgb(25, 27, 31);">开发者（Developer）：</font></strong><font style="color:rgb(25, 27, 31);">具有对项目中镜像仓库的读写权限，可以拉取、推送和删除镜像，以及管理部分项目配置，但不能进行项目管理操作。</font></li><li><strong><font style="color:rgb(25, 27, 31);">访客（Guest）：</font></strong><font style="color:rgb(25, 27, 31);">只具有对项目中镜像仓库的只读权限，可以查看镜像和元数据，但无法对镜像进行修改或删除操作。通常用于分享项目或镜像给外部团队或用户。</font></li><li><strong><font style="color:rgb(25, 27, 31);">受限访客（Restricted Guest）：</font></strong><font style="color:rgb(25, 27, 31);">是一种更加受限的访客角色，通常用于提供给外部用户或系统，具有对项目中镜像仓库的只读权限，但可能会限制访问的部分内容或功能。</font></li></ul><font style="color:rgb(25, 27, 31);">在右上角显示推送命令，可以通过提示命令进行docker镜像推送。  </font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887750856-cf536081-6d18-466b-89bc-e548677de0de.png" alt=""></p><p><h4 id="OiITA"><font style="color:rgb(25, 27, 31);">6.2、日志</font></h4></p><font style="color:rgb(25, 27, 31);">日志菜单就是记录用户操作日志信息的。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887807171-0f832730-5888-44c8-b68e-61bc93271bfb.png" alt=""></p><p><h4 id="G7nR4"><font style="color:rgb(25, 27, 31);">6.3、系统管理</font></h4></p><font style="color:rgb(25, 27, 31);">系统管理主要用来管理Harbor用户人员信息、镜像仓库的各种配置、权限和系统设置。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887795137-edf4b00f-b495-4a2c-93ca-c0bd54a8566b.png" alt=""></p><p><h3 id="269793c3"><font style="color:rgb(25, 27, 31);">7、Docker命令使用私有仓库</font></h3></p><p><h4 id="jlXTW"><font style="color:rgb(25, 27, 31);">7.1、登录</font></h4></p><font style="color:rgb(25, 27, 31);">首先登录私有仓库地址：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login  -u admin -p AdminHarbor12345 http://192.168.1.7:5000</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">会报错：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">Error response from daemon: Get &quot;https://192.168.1.7:5000/v2/&quot;: proxyconnect tcp: dial tcp 192.168.65.7:3128: connect: connection refused</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">docker认为这个地址是不安全的，所以需要在docker守护进程配置文件中把该地址加入安全范围。</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://ejes884z.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;1g&quot;, &quot;max-file&quot;:&quot;3&quot;&#125;,</span><br><span class="line">  &quot;live-restore&quot;: true,</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.1.7:5000&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># insecure-registries 不安全的注册表配置一些不安全的地址信息，让Docker认为是安全的。多个地址使用 &quot;,&quot; 分割</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">加入配置成功后，再次登录。</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">通过输出发现登录成功。认证信息存储在 </font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">~/.docker/config.json</font>`<font style="color:rgb(25, 27, 31);"> 文件中，只要登录信息存在，登录会一直生效不需要每次推送拉取之前都登录。</font><p><h4 id="wLrO2"><font style="color:rgb(25, 27, 31);">7.2、推送</font></h4></p><font style="color:rgb(25, 27, 31);">重新命名镜像名称</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 94543a6c1aef 192.168.1.7:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">推送</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.42.7:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">查看Harbor仓库，推送成功。</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887844513-431188a8-de89-4ea7-9c28-53077ae43235.png" alt=""></p><p><h4 id="P7j4R"><font style="color:rgb(25, 27, 31);">7.3、拉取</font></h4></p><font style="color:rgb(25, 27, 31);">通过另一台服务器，使用</font><font style="color:rgb(25, 27, 31);"> </font>`<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">docker pull</font>`<font style="color:rgb(25, 27, 31);">拉取镜像从私有仓库拉取镜像：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.1.7:5000/blog_project/nginx:1.26.0</span><br></pre></td></tr></table></figure><font style="color:rgb(25, 27, 31);">拉取成功</font><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1746887025819-15347766-b057-429c-86d4-6272efc29bc2.png" alt=""></p><font style="color:rgb(25, 27, 31);">查看下载数，发现已经更新了。</font><font style="color:rgb(25, 27, 31);"></font>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://goharbor.io/docs/2.13.0/install-config/&quot;&gt;Harbor &amp;ndash; Harbor Installation and Configuration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;技术难度一般，因为它本身就是一</summary>
      
    
    
    
    <category term="工具" scheme="https://blog.zuquanzhi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="docker" scheme="https://blog.zuquanzhi.top/tags/docker/"/>
    
    <category term="镜像" scheme="https://blog.zuquanzhi.top/tags/%E9%95%9C%E5%83%8F/"/>
    
    <category term="容器化" scheme="https://blog.zuquanzhi.top/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>cpolar实现内网穿透</title>
    <link href="https://blog.zuquanzhi.top/2025/09/17/63383/"/>
    <id>https://blog.zuquanzhi.top/2025/09/17/63383/</id>
    <published>2025-09-17T10:30:30.000Z</published>
    <updated>2025-09-17T13:30:58.689Z</updated>
    
    <content type="html"><![CDATA[<p>对于某些经常喜欢在宿舍干实验室活又没钱开公网的家伙比较有用，下面以ubuntu为例</p><p><h2 id="4d2ac073"><font style="color:rgb(10, 10, 10);">1. 安装cpolar内网穿透</font></h2></p><p><h3 id="c1c09284"><font style="color:rgb(17, 17, 17);">1.1 安装cpolar</font></h3></p><font style="color:rgb(12, 12, 12);">在Ubuntu上打开终端，执行命令</font><font style="color:rgb(12, 12, 12);">首先，我们需要安装curl：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure><ul><li><font style="color:rgb(12, 12, 12);">国内安装（支持一键自动安装脚本）</font></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:<span class="comment">//www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash </span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722104110-65e35921-4f0d-4537-ba93-ad39f02a92f0.png" alt=""></p><font style="color:rgb(12, 12, 12);">安装成功，如下界面所示</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722103770-e40612a5-12a5-4a56-b2ef-6f0d1d8bbf9e.png" alt=""></p><ul><li><font style="color:rgb(12, 12, 12);">或国外安装使用，通过短连接安装方式</font></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https:<span class="comment">//git.io/cpolar | sudo </span></span><br></pre></td></tr></table></figure><p><h3 id="457383a7"><font style="color:rgb(17, 17, 17);">1.2 正常显示版本号即安装成功</font></h3><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar version</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722103744-f2c58c68-f1cb-4b14-a0b8-a24769bf1d47.png" alt=""></p><p><h3 id="6c3524a2"><font style="color:rgb(17, 17, 17);">1.3 token认证</font></h3></p><font style="color:rgb(12, 12, 12);">登录</font>[<font style="color:rgb(12, 12, 12);">cpolar官网后台</font>](https://dashboard.cpolar.com/get-started)<font style="color:rgb(12, 12, 12);">，点击左侧的验证，查看自己的认证token，之后将token贴在命令行里</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar authtoken xxxxxxx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722104829-5d90b361-8725-40d6-8865-e53ffc4cefef.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722104320-06e6b152-a413-4ce8-b718-8a8e24a59f0e.png" alt=""></p><p><h3 id="0b53538d"><font style="color:rgb(17, 17, 17);">1.4 简单穿透测试一下</font></h3><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar http <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722104385-08d9d5b3-e70c-4bd6-a69c-264f2777734d.png" alt=""></p><p><em><font style="color:rgb(12, 12, 12);">可以看到有正常生成相应的公网地址，测试穿透本地8080端口成功，按</font></em><code>_&lt;font style=&quot;color:rgb(32, 128, 173);&quot;&gt;Ctrl+C&lt;/font&gt;_</code><em><font style="color:rgb(12, 12, 12);">返回</font></em></p><p><h3 id="7e27ba31"><font style="color:rgb(17, 17, 17);">1.5 将cpolar配置为后台服务并开机自启动</font></h3><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable cpolar</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722104827-aafc06ae-9ab5-489a-be32-539e342aa4a1.png" alt=""></p><p><h3 id="cd209ac1"><font style="color:rgb(17, 17, 17);">1.6 启动服务</font></h3><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start cpolar</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722104919-8bdccfb1-0034-44d9-82a4-ed85c452d81a.png" alt=""></p><p><h3 id="2a5b214c"><font style="color:rgb(17, 17, 17);">1.7 查看服务状态</font></h3><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status cpolar</span><br></pre></td></tr></table></figure></p><font style="color:rgb(12, 12, 12);">正常显示为</font>`<font style="color:rgb(32, 128, 173);">active</font>`<font style="color:rgb(12, 12, 12);">，为正常在线状态</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722104935-03de3dd3-7983-4a92-8d75-3d75a306c0b7.png" alt=""></p><p><h3 id="63783964"><font style="color:rgb(17, 17, 17);">1.8 登录cpolar Web UI管理界面</font></h3></p><font style="color:rgb(12, 12, 12);">在浏览器上访问本地9200端口，【</font>[<font style="color:rgb(12, 12, 12);">127.0.0.1:9200</font>](https://www.cpolar.com/blog/127.0.0.1:9200)<font style="color:rgb(12, 12, 12);">】使用cpolar邮箱账号登录cpolar Web UI管理界面</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722105461-2f3c48fd-4601-4889-8861-7c41c103b8cc.png" alt=""></p><font style="color:rgb(12, 12, 12);">登陆成功,接下来就可以在Web UI界面创建隧道、编辑隧道、配置隧道、获取生成的公网地址，查看系统状态等操作了。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722105544-76fe56ce-5421-4af4-998b-836a4cef4eef.png" alt=""></p><p><h2 id="ux2f9">2.公网ssh访问</h2></p><font style="color:rgb(12, 12, 12);">我们在Ubuntu系统下登录cpolar，在cpolar的Web-UI界面左侧找到“隧道管理”项，在下拉菜单中点击“创建隧道”。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722306629-7889ad20-7467-4ff0-aef3-298644b6d627.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722307017-b787ec76-668f-42ad-9c80-d7adf11c481f.png" alt=""></p><font style="color:rgb(12, 12, 12);">这里我们需要对TCP隧道进行一些调整和设置：</font><ul><li><font style="color:rgb(12, 12, 12);">对建立的TCP隧道进行命名，这里我们将隧道名称写为ssh（名称可自定义）；</font></li><li><font style="color:rgb(12, 12, 12);">数据协议选择“TCP”协议；</font></li><li><font style="color:rgb(12, 12, 12);">本地地址为端口22；</font></li><li><font style="color:rgb(12, 12, 12);">端口类型为可选择“临时TCP端口”。</font></li></ul><font style="color:rgb(12, 12, 12);">在相关信息填写完毕后，即可点击下方的“创建”按钮，建立新的SSH隧道。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722306925-92107dd3-0521-4ff3-af2b-150665e901cf.png" alt=""></p><font style="color:rgb(12, 12, 12);">在SSH隧道创建成功后，我们转回“在线隧道列表”界面，查看我们刚建立起的数据隧道相关信息。在这里，我们需要复制一段连接信息：“1.tcp.cpolar.io:XXXXX（XXXXX为数字端口号，每个隧道号码均不相同，前缀tcp://不必复制）”。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722307173-7b0d76df-5ff9-418d-8207-1a4a1d988d43.png" alt=""></p><font style="color:rgb(12, 12, 12);">再将这段链接信息粘贴到其他系统的命令行界面，对应的命令为：</font><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p XXXXX 用户名@<span class="number">1.</span>tcp.cpolar.io</span><br></pre></td></tr></table></figure><font style="color:rgb(12, 12, 12);">（其中，X为cpolar生成的端口号，用户名需替换为主机用户名）。需要注意的是，在数字端口号之前，一定要添加“（空格）-p（空格）”，否则无法连接隧道；其次是“ssh -p XXXXX 用户名@”之后，必须输入复制客户端生成的tcp地址。</font><font style="color:rgb(12, 12, 12);">在输入正确的连接命令后，会出现两个提示信息，一是确认Ubuntu系统的连接提示信息，我们只要输入“yes”即可；二是要求输入Ubuntu系统密码（如果Ubuntu设置了密码）。</font><p><img src="https://cdn.nlark.com/yuque/0/2024/png/39221021/1730722307116-a82242af-a6f6-4e8e-86ee-28787498665c.png" alt=""></p><font style="color:rgb(12, 12, 12);">在vscode里同理</font>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于某些经常喜欢在宿舍干实验室活又没钱开公网的家伙比较有用，下面以ubuntu为例&lt;/p&gt;
&lt;p&gt;&lt;h2 id=&quot;4d2ac073&quot;&gt;&lt;font style=&quot;color:rgb(10, 10, 10);&quot;&gt;1. 安装cpolar内网穿透&lt;/font&gt;&lt;/h2&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="工具" scheme="https://blog.zuquanzhi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="cpolar" scheme="https://blog.zuquanzhi.top/tags/cpolar/"/>
    
    <category term="内网穿透" scheme="https://blog.zuquanzhi.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Agent时代基础设施--MCP协议介绍</title>
    <link href="https://blog.zuquanzhi.top/2025/04/11/43814/"/>
    <id>https://blog.zuquanzhi.top/2025/04/11/43814/</id>
    <published>2025-04-10T16:00:06.000Z</published>
    <updated>2025-04-10T16:43:54.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-MCP"><a href="#What-is-MCP" class="headerlink" title="What is MCP"></a>What is MCP</h2><p>MCP (Model Context Protocol)是一种开放协议，用于标准化应用程序如何向大型语言模型（LLMs）提供上下文。可以将 MCP 想象为 AI 应用的 typec 接口。正如 typec 提供了一种标准化的方式将您的设备连接到各种外设和配件，MCP 也提供了一种标准化的方式，将 AI 模型连接到不同的数据源和工具。</p><p>MCP 协议由 Anthropic 在 2024 年 11 月底推出：</p><ul><li>官方文档：<a href="https://modelcontextprotocol.io/introduction">Introduction</a></li><li>GitHub 仓库：<a href="https://github.com/modelcontextprotocol">https://github.com/modelcontextprotocol</a></li></ul><p>MCP 集成教学：</p><ul><li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/git">Git</a> - Git 读取、操作、搜索。</li><li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/github">Github</a> - Repo 管理、文件操作和 GitHub API 集成。</li><li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/google-maps">Google Maps</a> - 集成 Google Map 获取位置信息。</li><li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/postgres">PostgreSQL</a> - 只读数据库查询。</li><li><a href="https://github.com/modelcontextprotocol/servers/blob/main/src/slack">Slack</a> - Slack 消息发送和查询。</li></ul><p><strong><a href="https://mcp.so/">MCP导航站</a></strong></p><h2 id="Why-is-MCP"><a href="#Why-is-MCP" class="headerlink" title="Why is MCP"></a>Why is MCP</h2><p>举个栗子，在过去，为了让大模型等 AI 应用使用我们的数据，要么复制粘贴，要么上传下载，非常麻烦。</p><p>即使是最强大模型也会受到数据隔离的限制，形成信息孤岛，要做出更强大的模型，每个新数据源都需要自己重新定制实现，使真正互联的系统难以扩展，存在很多的局限性。</p><p>从最初的 chatgpt，到后来的 cursor，copilot chatroom，再到现在耳熟能详的 agent，实际上，从用户交互的角度去观察，你会发现目前的大模型产品经历了如下的变化：</p><p><img src="image.png" alt=""></p><ul><li>chatbot<ul><li>只会聊天的程序。</li><li>工作流程：你输入问题，它给你这个问题的解决方案，但是具体执行还需要你自己去。</li><li>代表工作：deepseek，chatgpt</li></ul></li><li>composer<ul><li>稍微会帮你干活的实习生，仅限于写代码。</li><li>工作流程：你输入问题，它会给你帮你生成解决问题的代码，并且自动填入代码编辑器的编译区，你只需要审核确认即可。</li><li>代表工作：cursor，copilot</li></ul></li><li>agent<ul><li>私人秘书。</li><li>工作流程：你输入问题，它生成这个问题的解决方案，并在征询了你的同意后全自动执行。</li><li>代表工作：AutoGPT，Manus，Open Manus</li></ul></li></ul><p>为了实现 agent，也就需要让 LLM 可以自如灵活地操作所有软件甚至物理世界的机器人，于是需要定义统一的上下文协议与之上统一工作流。MCP(model context protocol) 就是解决这套方案的应运而生的基础协议。</p><p>而 MCP 服务器就是为了实现 AI Agent 的自动化而存在的。它是一个中间层，告诉 AI Agent 当前有哪些可用的服务、API 和数据源。AI Agent 根据服务器提供的信息决定是否调用某个服务，并通过 Function Calling 执行相应的函数。</p><p>现在，MCP 可以直接在 AI 与数据（包括本地数据和互联网数据）之间架起一座桥梁，通过 MCP 服务器和 MCP 客户端，大家只要都遵循这套协议，就能实现“万物互联”。</p><p>有了MCP，可以和数据和文件系统、开发工具、Web 和浏览器自动化、生产力和通信、各种社区生态能力全部集成，实现强大的协作工作能力，它的价值远不可估量。</p><blockquote><p>Anthropic 对于 MCP 的必要性给出的解释：MCP 帮助您在 LLMs 之上构建 agent 和复杂的工作流程。LLMs 经常需要与数据和工具集成，而 MCP 提供了以下支持：</p><ul><li>一系列不断增长的预构建集成，您的 LLM 可以直接接入这些集成。</li><li>在 LLM 提供商和供应商之间灵活切换。</li><li>在基础设施内保护数据的最佳实践。</li></ul></blockquote><p>看到这里你可能有一个问题，在 23 年 OpenAI 发布 GPT function calling 的时候，不是也是可以实现类似的功能吗？我们之前博客介绍的 AI Agent，不就是用来集成不同的服务吗？为什么又出现了 MCP。</p><h3 id="Function-Calling、AI-Agent-和-MCP-的区别"><a href="#Function-Calling、AI-Agent-和-MCP-的区别" class="headerlink" title="Function Calling、AI Agent 和 MCP 的区别"></a>Function Calling、AI Agent 和 MCP 的区别</h3><h4 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h4><p>Function Calling 是指 AI 模型根据上下文自动调用函数的机制。它充当了 AI 模型与外部系统之间的桥梁。不同模型的 Function Calling 实现方式各异，代码集成方式也各不相同，由不同的 AI 模型平台定义和实现。  </p><p>如果使用 Function Calling，需要通过代码为 LLM 提供一组函数，并明确描述函数的输入和输出。这样，LLM 就可以根据清晰的结构化数据进行推理并执行函数。  </p><p>Function Calling 的缺点在于难以处理多轮对话和复杂需求，更适合边界清晰、描述明确的任务。如果任务繁多，Function Calling 的代码会变得难以维护。  </p><h4 id="Model-Context-Protocol-MCP"><a href="#Model-Context-Protocol-MCP" class="headerlink" title="Model Context Protocol (MCP)"></a>Model Context Protocol (MCP)</h4><p>MCP 是一种标准化协议，类似于电子设备中的 Type-C 接口（既能充电又能传输数据），使 AI 模型能够与不同的 API 和数据源无缝交互。  </p><p>MCP 的目标是取代碎片化的 Agent 代码集成，从而让 AI 系统更加可靠和高效。通过建立通用标准，服务商可以基于协议推出自己的 AI 能力，帮助开发者更快地构建更强大的 AI 应用。开发者无需重复造轮子，通过开源项目即可构建强大的 AI Agent 生态。  </p><p>MCP 能够在不同应用和服务之间保持上下文，从而增强整体自主执行任务的能力。可以理解为，MCP 将不同任务分层处理，每一层都提供特定的能力、描述和限制。MCP 客户端根据任务需求判断是否调用某项能力，并通过每层的输入和输出，构建出一个能够处理复杂、多步对话和统一上下文的 Agent。  </p><h4 id="AI-Agent"><a href="#AI-Agent" class="headerlink" title="AI Agent"></a>AI Agent</h4><p>AI Agent 是一个智能系统，能够自主运行以实现特定目标。传统的 AI 聊天仅提供建议或需要手动执行任务，而 AI Agent 则可以分析具体情况、做出决策并自行采取行动。  </p><p>AI Agent 可以利用 MCP 提供的功能描述来理解更多上下文，并在不同平台和服务上自动执行任务。  </p><hr><h2 id="MCP-的工作原理"><a href="#MCP-的工作原理" class="headerlink" title="MCP 的工作原理"></a>MCP 的工作原理</h2><p>先来看一下 MCP 的整体架构：<br><img src="image-1.png" alt="">  </p><ul><li><p><strong>MCP 主机（MCP Hosts）</strong><br>指希望通过 MCP 访问数据的程序，例如 Claude Desktop、集成开发环境（IDE）或其他 AI 工具。  </p></li><li><p><strong>MCP 客户端（MCP Clients）</strong><br>是与服务器保持 1:1 连接的协议客户端，负责与 MCP 服务器通信。  </p></li><li><p><strong>MCP 服务器（MCP Servers）</strong><br>是轻量级程序，每个服务器通过标准化的 Model Context Protocol 暴露特定功能。  </p></li><li><p><strong>本地数据源（Local Data Sources）</strong><br>指 MCP 服务器可以安全访问的计算机文件、数据库和服务。  </p></li><li><p><strong>远程服务（Remote Services）</strong><br>指 MCP 服务器可以通过互联网连接的外部系统（例如通过 API 访问的服务）。  </p></li></ul><p>整个 MCP 协议的核心在于服务器（Server）。对于熟悉计算机网络的人来说，主机（Host）和客户端（Client）的概念并不陌生，易于理解。</p><h2 id="MCP的工作流程"><a href="#MCP的工作流程" class="headerlink" title="MCP的工作流程"></a>MCP的工作流程</h2><p>从工作流程上看，MCP 确实与 LSP（Language Server Protocol）非常相似。实际上，目前的 MCP 和 LSP 一样，也是基于 JSON-RPC 2.0 进行数据传输的（可以通过 Stdio 或基于 SSE 实现）。这种设计选择并非偶然，而是为了充分利用 JSON-RPC 的灵活性和高效性，同时借鉴了 LSP 在开发工具领域的成功经验。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这里引用一下锦恢大佬的图：<br>假设我们的软件已经支持了 MCP 客户端，那么当我们的软件启动时，它会经历如下的步骤：<br><img src="image-2.png" alt="">  </p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>假设，你是一位 C语言工程师，你现在想要让 agent 自动完成一个项目的编译，那么执行流程如下：<br><img src="image-3.png" alt="">  </p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://kirigaya.cn/blog/article?seq=299">锦恢的博客</a></li><li><a href="https://guangzhengli.com/blog/zh/model-context-protocol#mcp-%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%BA%90">MCP终极指南</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;What-is-MCP&quot;&gt;&lt;a href=&quot;#What-is-MCP&quot; class=&quot;headerlink&quot; title=&quot;What is MCP&quot;&gt;&lt;/a&gt;What is MCP&lt;/h2&gt;&lt;p&gt;MCP (Model Context Protocol)是一种开放协</summary>
      
    
    
    
    <category term="大模型" scheme="https://blog.zuquanzhi.top/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="大模型" scheme="https://blog.zuquanzhi.top/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="Agent" scheme="https://blog.zuquanzhi.top/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>一文教你学会看多目标检测中的指标</title>
    <link href="https://blog.zuquanzhi.top/2025/03/16/58849/"/>
    <id>https://blog.zuquanzhi.top/2025/03/16/58849/</id>
    <published>2025-03-15T16:18:59.000Z</published>
    <updated>2025-12-09T11:32:14.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、从找东西说起——理解检测任务"><a href="#一、从找东西说起——理解检测任务" class="headerlink" title="一、从找东西说起——理解检测任务"></a>一、从找东西说起——理解检测任务</h2><p>想象你在玩一个”找物品”的游戏：房间里藏着10个不同种类的玩具，你需要用手机拍照后圈出每个玩具的位置并说出名称。目标检测任务就类似这个过程，需要完成两个核心目标：</p><ol><li><strong>找到物品位置</strong>：用矩形框或者各种奇形怪状的圈准确框住物体（定位）</li><li><strong>认出物品类别</strong>：正确说出物品名称（分类）</li></ol><p>评估系统好坏时，既不能漏掉目标（如找到8个但漏了2个），也不能乱标位置（如把猫的框画到狗身上），更不能乱起名字（<strong>如把坤哥说成牢大</strong>）。这就是mAP指标要解决的问题。<br><img src="laoda.png" alt="只因你太美"></p><h2 id="二、核心概念拆解"><a href="#二、核心概念拆解" class="headerlink" title="二、核心概念拆解"></a>二、核心概念拆解</h2><h3 id="2-1-IoU"><a href="#2-1-IoU" class="headerlink" title="2.1 IoU"></a>2.1 IoU</h3><p>判断预测框是否正确的标准就像交朋友：</p><ul><li><strong>IoU（交并比）</strong>：计算预测框与真实框的”亲密指数”</li><li>计算方式：重叠面积 ÷ 合并后的总面积</li><li>通过阈值判断是否达标（通常0.5为及格线）<script type="math/tex; mode=display">IoU = \frac{Area(B_{pred} \cap B_{gt})}{Area(B_{pred} \cup B_{gt})}</script></li></ul><p><img src="iou.png" alt="IoU"></p><h3 id="2-2-预测结果分类"><a href="#2-2-预测结果分类" class="headerlink" title="2.2 预测结果分类"></a>2.2 预测结果分类</h3><div class="table-container"><table><thead><tr><th>类型</th><th>判断标准</th><th>现实类比</th></tr></thead><tbody><tr><td>TP</td><td>框的位置正确（IoU≥阈值）且名称正确</td><td>正确找到朋友并叫对名字</td></tr><tr><td>FP</td><td>框的位置错误 或 名称错误</td><td>认错人 或 把路人当朋友</td></tr><tr><td>FN</td><td>真实存在但未被检测到</td><td>真正的朋友站在面前却没认出来</td></tr></tbody></table></div><h3 id="2-3-混淆矩阵衍生指标"><a href="#2-3-混淆矩阵衍生指标" class="headerlink" title="2.3 混淆矩阵衍生指标"></a>2.3 混淆矩阵衍生指标</h3><div class="table-container"><table><thead><tr><th>指标名称</th><th>公式</th><th>物理意义</th></tr></thead><tbody><tr><td>精确率 (Precision)</td><td>$P=\frac{TP}{TP+FP}$</td><td>预测阳性样本的真实阳性率</td></tr><tr><td>召回率 (Recall)</td><td>$R=\frac{TP}{TP+FN}$</td><td>真实阳性样本的检出率</td></tr><tr><td>F1分数 (F1 Score)</td><td>$F1=\frac{2PR}{P+R}$</td><td>精确率与召回率的调和平均</td></tr><tr><td>误检率 (False Positive Rate)</td><td>$FPR=\frac{FP}{FP+TN}$</td><td>负样本被误判为正的比例</td></tr></tbody></table></div><h3 id="2-4-系统效率指标"><a href="#2-4-系统效率指标" class="headerlink" title="2.4 系统效率指标"></a>2.4 系统效率指标</h3><div class="table-container"><table><thead><tr><th>指标名称</th><th>测量方式</th><th>应用场景</th></tr></thead><tbody><tr><td>FPS (Frames Per Second)</td><td>每秒处理帧数</td><td>实时检测系统</td></tr><tr><td>内存占用 (Memory Usage)</td><td>显存/内存消耗量</td><td>嵌入式设备部署</td></tr><tr><td>FLOPs (Floating Point Operations)</td><td>浮点运算次数</td><td>算法复杂度评估</td></tr></tbody></table></div><h2 id="三、mAP的计算逻辑"><a href="#三、mAP的计算逻辑" class="headerlink" title="三、mAP的计算逻辑"></a>三、mAP的计算逻辑</h2><h3 id="3-1-从单个类别说起（AP计算）"><a href="#3-1-从单个类别说起（AP计算）" class="headerlink" title="3.1 从单个类别说起（AP计算）"></a>3.1 从单个类别说起（AP计算）</h3><p>假设现在只检测”猫”这个类别：</p><p><strong>一步步解析</strong>：</p><ol><li><strong>收集检测结果</strong>：记录所有预测框的置信度（把握程度）</li><li><strong>排序</strong>：按置信度从高到低排队</li><li><strong>逐级评估</strong>：<ul><li>从最有把握的预测开始检查</li><li>每个预测点形成一对（召回率，精确率）</li></ul></li><li><strong>绘制PR曲线</strong>：连接所有评估点形成的曲线</li><li><strong>计算曲线下面积</strong>：面积越大说明综合表现越好</li></ol><script type="math/tex; mode=display">AP = \int_{0}^{1} P(R) dR</script><p><img src="image.png" alt="PR曲线示意图：曲线越凸向右上角越好"></p><h3 id="3-2-扩展到多类别（mAP）"><a href="#3-2-扩展到多类别（mAP）" class="headerlink" title="3.2 扩展到多类别（mAP）"></a>3.2 扩展到多类别（mAP）</h3><p>当需要检测多个类别时（如猫、狗、鸟）：</p><ol><li>对每个类别单独计算AP值</li><li>所有AP值的平均就是mAP</li><li>优势：平衡各类别的表现差异</li></ol><script type="math/tex; mode=display">mAP = \frac{1}{N}\sum_{i=1}^{N} AP_i</script><h2 id="四、置信度"><a href="#四、置信度" class="headerlink" title="四、置信度"></a>四、置信度</h2><h3 id="4-1-置信度的数学本质"><a href="#4-1-置信度的数学本质" class="headerlink" title="4.1 置信度的数学本质"></a>4.1 置信度的数学本质</h3><p>置信度是模型对预测结果的综合信心值，由两个核心因素构成：</p><script type="math/tex; mode=display">\text{置信度} = \underbrace{P(\text{类别})}_{\text{分类置信度}} \times \underbrace{IoU}_{\text{定位准确度}}</script><p>其中：</p><ul><li>P(类别) 是模型对物体类别的分类置信度，通常是通过softmax或sigmoid等激活函数计算得到的。</li><li>IoU 则是检测框与真实框的重叠度，反映了定位的准确性。</li></ul><p><img src="conf.png" alt="置信度"></p><p>置信度反映了模型对预测结果的总体信任程度。高置信度意味着模型不仅准确识别了物体的类别，而且对其位置也有较高的确定性。</p><h3 id="4-2-置信度的影响因素"><a href="#4-2-置信度的影响因素" class="headerlink" title="4.2 置信度的影响因素"></a>4.2 置信度的影响因素</h3><p>置信度的高低直接影响目标检测的性能，特别是在多目标检测场景下，如何合理设置置信度阈值是提升模型效果的关键。</p><ul><li><p><strong>分类置信度</strong>：分类置信度越高，模型越能准确地识别物体的类别。分类置信度通常受到训练数据质量、模型结构以及超参数调整等因素的影响。如果模型在某个类别的预测上过于保守或过于激进，可能会影响最终的检测效果。</p></li><li><p><strong>定位准确度（IoU）</strong>：定位的准确度直接决定了模型的检测框是否与真实框高度重合。IoU值过低的预测框通常会被认为是错误的，这就需要通过调节IoU的阈值来权衡误报（FP）与漏报（FN）之间的关系。</p></li></ul><h3 id="4-3-置信度与检测结果"><a href="#4-3-置信度与检测结果" class="headerlink" title="4.3 置信度与检测结果"></a>4.3 置信度与检测结果</h3><p>在实际应用中，目标检测模型会输出每个检测框的置信度值。这个置信度值的高低可以用来做进一步的筛选与决策：</p><ol><li><p><strong>置信度筛选</strong>：设置一个阈值，只有置信度超过该阈值的预测框才会被认为是有效的。这有助于减少错误的检测框（例如将一个非物体框判定为目标）。</p></li><li><p><strong>多目标检测中的置信度问题</strong>：在多目标检测场景中，可能会存在多个物体的检测框与置信度接近的情况。此时，需要通过后处理算法（如非极大值抑制NMS）来消除冗余框，保留最具代表性的检测框。</p></li><li><p><strong>多类别的置信度权衡</strong>：在多类别检测中，每个类别的置信度也不同，因此需要综合考虑每个类别的分类置信度与位置准确度，确保模型对所有类别的均衡检测。</p></li></ol><h3 id="4-4-置信度与mAP的关系"><a href="#4-4-置信度与mAP的关系" class="headerlink" title="4.4 置信度与mAP的关系"></a>4.4 置信度与mAP的关系</h3><p>mAP（mean Average Precision）是评估目标检测模型整体表现的重要指标，而置信度直接影响AP的计算。每个类别的AP计算依赖于预测框的置信度，过低的置信度可能导致许多错误的FP（假阳性）或漏报FN（假阴性），从而导致AP和mAP下降。</p><ul><li><strong>高置信度</strong>：一般能提高TP（真阳性）数量，降低FP和FN数量，从而提高模型的整体精度（AP）。</li><li><strong>低置信度</strong>：会使得模型更多地遗漏真实目标（FN），或错误地识别目标（FP），降低AP，从而影响mAP。</li></ul><p>因此，调整置信度阈值，以平衡检测精度和召回率，是优化目标检测模型性能的重要步骤。</p><h3 id="4-5-置信度阈值的选择"><a href="#4-5-置信度阈值的选择" class="headerlink" title="4.5 置信度阈值的选择"></a>4.5 置信度阈值的选择</h3><p>在实际应用中，设置合理的置信度阈值至关重要。过高的阈值可能导致漏检（FN），而过低的阈值则可能导致误检（FP）。通常通过<strong>Precision-Recall曲线</strong>来选择合适的阈值，使得模型在给定的任务和数据集上取得最佳的平衡。</p><ul><li><strong>高阈值</strong>：减少误报（FP），但可能增加漏检（FN）。</li><li><strong>低阈值</strong>：减少漏检（FN），但可能增加误报（FP）。</li></ul><h2 id="五、给指标检测人的”防杠声明”"><a href="#五、给指标检测人的”防杠声明”" class="headerlink" title="五、给指标检测人的”防杠声明”"></a>五、给指标检测人的”防杠声明”</h2><p>看完这篇博客的你，现在应该：</p><p>🕶️ 能对着PR曲线指点江山：”这个曲线不够翘啊，建议回炉重造”<br>📸 看到误检的猫猫狗狗会冷笑：”呵，FP+1”<br>🤖 跟人battle模型性能时：”先看看mAP@0.5:0.95再说话”</p><p>不过记住：  </p><ul><li>当甲方爸爸说”我全都要”时 → 建议ta把IoU阈值设为0.9  </li><li>当产品经理催”再提点准确率”时 → 请ta先标注2000张测试集  </li><li>当算法同学甩锅”标注有问题”时 → 请ta背诵本文第2.2节  </li><li><strong>但是当学长说你模型练的不行，那就是你真的菜还得多练</strong></li></ul><p>最后送给各位CV人一个灵魂拷问：<br><strong>如果坤坤的篮球被检测成只因，这算TP还是FP？</strong>  </p><p>（答案提示：取决于你的训练集有没有加入律师函警告样本 🤫）</p><blockquote><p>| <em>本文不生产指标，只做指标的搬运工</em><br>| <em>—— 鲁迅（并没有说过）</em></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、从找东西说起——理解检测任务&quot;&gt;&lt;a href=&quot;#一、从找东西说起——理解检测任务&quot; class=&quot;headerlink&quot; title=&quot;一、从找东西说起——理解检测任务&quot;&gt;&lt;/a&gt;一、从找东西说起——理解检测任务&lt;/h2&gt;&lt;p&gt;想象你在玩一个”找物品”的游</summary>
      
    
    
    
    <category term="机器人/计算机视觉" scheme="https://blog.zuquanzhi.top/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="多目标检测" scheme="https://blog.zuquanzhi.top/tags/%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    <category term="YOLO" scheme="https://blog.zuquanzhi.top/tags/YOLO/"/>
    
    <category term="计算机视觉" scheme="https://blog.zuquanzhi.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>树莓派配合公网服务器frp转发实现内网穿透</title>
    <link href="https://blog.zuquanzhi.top/2025/02/23/14348/"/>
    <id>https://blog.zuquanzhi.top/2025/02/23/14348/</id>
    <published>2025-02-22T16:16:45.000Z</published>
    <updated>2025-09-17T13:30:58.693Z</updated>
    
    <content type="html"><![CDATA[<p>相信不少的同学都遇到过一个很麻烦的事情——实验室用的服务器只有连上实验室的内网后才能使用，一旦外出开impart或者回家后，就不能进入实验室的服务器继续玩耍（卷）了。这个时候怎么办呢？<br>如果你没有一个公网服务器又不想花钱，cpolar是你的最佳选择，但是如果你有事情就变得完全不一样了——<strong>frp的优雅永不过时</strong>。</p><ul><li><a href="https://gofrp.org/">FRP 项目官网</a></li><li><a href="https://github.com/fatedier/frp">GitHub 仓库</a></li><li><a href="https://gofrp.org/docs/">项目文档</a></li></ul><h3 id="frp是什么？"><a href="#frp是什么？" class="headerlink" title="frp是什么？"></a>frp是什么？</h3><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h3 id="为什么使用-frp-？"><a href="#为什么使用-frp-？" class="headerlink" title="为什么使用 frp ？"></a>为什么使用 frp ？</h3><p>通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p><ul><li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li><li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li><li>代理组间的负载均衡。</li><li>端口复用，多个服务通过同一个服务端端口暴露。</li><li>多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。</li><li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li><li>服务端和客户端 UI 页面。<h2 id="食材"><a href="#食材" class="headerlink" title="食材"></a>食材</h2>为了达到这个目的，在硬件上，我们的读者需要准备如下三件东西：</li></ul><p>一台公网服务器，它的 IP 可以在任何能上网的机器上被 ping 到。<br>一台实验室服务器，它只能在实验室内网被访问。<br>一台你自己的电脑，它能 ping 到公网服务器，但是当你带着它出去玩时，它无法 ping 到实验室服务器。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们记我们的公网服务器为 <code>pub</code> (public server)，实验室服务器为 <code>loc</code> (local server)。我们在 pub 和 loc 上同时下载对应操作系统和芯片指令集的<a href="https://github.com/fatedier/frp/releases">编译版本</a>：</p><p>不过考虑到大部分的服务器都是 x86 芯片的 linux，所以可以直接下载解压如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.55.1/</span>frp_0.<span class="number">55.1</span>_linux_amd64.tar.gz</span><br><span class="line">tar -xvf frp_0.<span class="number">55.1</span>_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>进入 frp_0.55.1_linux_amd64 后，我们会看到如下几个文件：</p><ul><li>frpc： frp 客户端执行程序</li><li>frpc.toml：frp 客户端配置文件</li><li>frps：frp 服务端执行程序</li><li>frps.toml：frp 服务端配置文件</li><li>LICENSE：frp 软件开源协议，不用管<br><img src="image.png" alt="从锦恢大佬那里偷的图"></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为了让我们可以在外部能够访问 <code>loc</code>，我们先来实现 SSH 协议的内网穿透。<br>首先在 <code>pub</code> 上，进入解压后的 <code>frp</code> 文件夹。修改 <code>frps.toml</code> 如下：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bindPort</span> <span class="operator">=</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure><br>bindPort 用于和 frpc 进行绑定。<br>在后台执行如下指令：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/frps -c ./</span>frps.toml</span><br></pre></td></tr></table></figure><br>输出如下日志，代表 frps 启动成功：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">58.972</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[frps/root.go:105]</span> frps uses config file: ./frps<span class="selector-class">.toml</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:225]</span> frps tcp listen on <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:292]</span> http service listen on <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">56</span>:<span class="number">59.041</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[frps/root.go:114]</span> frps started successfully</span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.775</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/service.go:563]</span> <span class="selector-attr">[11abba605bc7fe77]</span> client login info: ip <span class="selector-attr">[58.211.218.74:64089]</span> version <span class="selector-attr">[0.55.1]</span> hostname <span class="selector-attr">[]</span> os <span class="selector-attr">[linux]</span> arch <span class="selector-attr">[amd64]</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.806</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[proxy/tcp.go:82]</span> <span class="selector-attr">[11abba605bc7fe77]</span> <span class="selector-attr">[ssh]</span> tcp proxy listen port <span class="selector-attr">[7001]</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">03</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">12.806</span> <span class="selector-attr">[I]</span> <span class="selector-attr">[server/control.go:401]</span> <span class="selector-attr">[11abba605bc7fe77]</span> new proxy <span class="selector-attr">[ssh]</span> type <span class="selector-attr">[tcp]</span> success</span><br></pre></td></tr></table></figure></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>下载适用于树莓派的arm64架构的frp文件包：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/fatedier/</span>frp<span class="regexp">/releases/</span>download<span class="regexp">/v0.35.1/</span>frp_0.<span class="number">35.1</span>_linux_arm64.tar.gz</span><br><span class="line">sudo tar -zxvf frp_0.<span class="number">35.1</span>_linux_arm64.tar.gz</span><br><span class="line"><span class="comment"># 文件名可能会有不同，用ls -a命令查看</span></span><br></pre></td></tr></table></figure><br>编辑其中的frpc.ini文件：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><br>按如下参数说明修改配置文件：</p><ul><li><p>server_addr：服务器的IP地址；</p></li><li><p>server_port：服务器端的端口，与服务端配置文件的bind_port端口相同；</p></li><li><p>local_ip：要在公网访问的本地设备的地址，这里指客户端本机，填127.0.0.1即可；</p></li><li><p>local_port：本地设备要暴露的端口，即理解为提供服务的端口</p></li><li><p>remote_port：在外网的访问端口，此端口上的流量会被转发到本地设备对应的local_port端口上</p></li></ul><p><strong>还有别忘了在服务器防火墙上放行remote_port端口</strong></p><p>配置文件中默认有一个ssh的访问配置，如果我们还想让其他的端口在外网访问到，那就可以照猫画虎来添加一个配置。比如在外网用公网ip的8888端口访问本地设备的80端口，就可以这样写：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[http]</span>                  <span class="comment"># 名字自定，写在方括号里面</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span></span><br></pre></td></tr></table></figure><br>然后启动服务<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/frps -c ./</span>frps.ini</span><br></pre></td></tr></table></figure><br>大功告成。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>以上配置完成，就可以在外网访问本地的服务了，访问方式是：服务器的IP地址/域名:端口。此处端口为客户端配置文件中的remote_port端口。<br>（如果想挂在后台或者开机自启动可以写个小脚本或者挂在终端工具上（如sceen），这里就不细说了。）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kirigaya.cn/blog/article?seq=192">https://kirigaya.cn/blog/article?seq=192</a></li><li><a href="https://www.wlplove.com/archives/33/#1.%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2frp">https://www.wlplove.com/archives/33/#1.%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2frp</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信不少的同学都遇到过一个很麻烦的事情——实验室用的服务器只有连上实验室的内网后才能使用，一旦外出开impart或者回家后，就不能进入实验室的服务器继续玩耍（卷）了。这个时候怎么办呢？&lt;br&gt;如果你没有一个公网服务器又不想花钱，cpolar是你的最佳选择，但是如果你有事情就</summary>
      
    
    
    
    <category term="工具" scheme="https://blog.zuquanzhi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="内网穿透" scheme="https://blog.zuquanzhi.top/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    <category term="frp转发" scheme="https://blog.zuquanzhi.top/tags/frp%E8%BD%AC%E5%8F%91/"/>
    
    <category term="树莓派" scheme="https://blog.zuquanzhi.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>YOLOv3深入学习</title>
    <link href="https://blog.zuquanzhi.top/2025/01/07/1343/"/>
    <id>https://blog.zuquanzhi.top/2025/01/07/1343/</id>
    <published>2025-01-07T08:30:02.000Z</published>
    <updated>2025-09-17T13:30:58.689Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于yolov3对于目标识别界的重大开创性，跳过1、2两个版本直接学习yolov3，同时也作为后续版本的基石入门。</p><hr><h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><h3 id="1-YOLOv3的核心思想"><a href="#1-YOLOv3的核心思想" class="headerlink" title="1. YOLOv3的核心思想"></a>1. YOLOv3的核心思想</h3><p>YOLOv3（You Only Look Once version 3）是一种单阶段目标检测算法，其核心思想是将目标检测问题转化为一个回归问题。与传统的两阶段检测方法（如R-CNN系列）不同，YOLOv3通过单次前向传播直接预测目标的边界框和类别概率，从而实现高效的目标检测。</p><p>YOLOv3的主要特点包括：</p><ul><li><strong>单次前向传播</strong>：输入图像经过一次网络前向传播即可得到检测结果。</li><li><strong>多尺度预测</strong>：通过不同尺度的特征图检测不同大小的目标。</li><li><strong>锚点机制</strong>：使用预定义的锚点（anchors）来辅助预测边界框。</li></ul><hr><h3 id="2-YOLOv3的网络结构"><a href="#2-YOLOv3的网络结构" class="headerlink" title="2. YOLOv3的网络结构"></a>2. YOLOv3的网络结构</h3><p>YOLOv3的网络结构可以分为三个部分：<strong>Backbone（骨干网络）</strong>、<strong>Neck（特征融合部分）**</strong>和<strong>**Head（检测头）</strong>。</p><h4 id="2-1-Backbone：Darknet-53"><a href="#2-1-Backbone：Darknet-53" class="headerlink" title="2.1 Backbone：Darknet-53"></a>2.1 Backbone：Darknet-53</h4><p>YOLOv3的骨干网络是Darknet-53，它是一个包含53个卷积层的深度卷积神经网络。Darknet-53借鉴了ResNet的思想，使用了残差连接（Residual Connections）来缓解深层网络的梯度消失问题。</p><p>Darknet-53的主要特点：</p><ul><li>使用1x1和3x3卷积层提取特征。</li><li>使用残差块（Residual Block）来构建深层网络。</li><li>输出三个不同尺度的特征图（13x13、26x26、52x52），用于多尺度预测。</li></ul><h4 id="2-2-Neck：特征金字塔网络（FPN）"><a href="#2-2-Neck：特征金字塔网络（FPN）" class="headerlink" title="2.2 Neck：特征金字塔网络（FPN）"></a>2.2 Neck：特征金字塔网络（FPN）</h4><p>YOLOv3通过特征金字塔网络（Feature Pyramid Network, FPN）实现多尺度特征融合。FPN将深层特征图（包含语义信息）与浅层特征图（包含细节信息）进行融合，从而增强网络对不同尺度目标的检测能力。</p><p>FPN的工作流程：</p><ul><li>从深层特征图开始，逐步上采样并与浅层特征图融合。</li><li>最终生成三个不同尺度的特征图（13x13、26x26、52x52），分别用于检测大、中、小目标。</li></ul><h4 id="2-3-Head：检测头"><a href="#2-3-Head：检测头" class="headerlink" title="2.3 Head：检测头"></a>2.3 Head：检测头</h4><p>检测头是YOLOv3的输出部分，负责预测边界框和类别概率。每个尺度的特征图都会预测固定数量的边界框（通常是3个），每个边界框包含以下信息：</p><ul><li>边界框的中心坐标（x, y）。</li><li>边界框的宽度和高度（w, h）。</li><li>目标存在的置信度（confidence）。</li><li>类别概率（class probabilities）。</li></ul><hr><h3 id="3-多尺度预测"><a href="#3-多尺度预测" class="headerlink" title="3. 多尺度预测"></a>3. 多尺度预测</h3><p>YOLOv3在三个不同尺度的特征图上进行预测：</p><ul><li><strong>13x13特征图</strong>：用于检测大目标。</li><li><strong>26x26特征图</strong>：用于检测中等目标。</li><li><strong>52x52特征图</strong>：用于检测小目标。</li></ul><p>每个尺度的特征图会被划分为若干网格（grid cell），每个网格负责预测固定数量的边界框。例如，13x13特征图会被划分为13x13个网格，每个网格预测3个边界框。</p><hr><h3 id="4-锚点机制"><a href="#4-锚点机制" class="headerlink" title="4. 锚点机制"></a>4. 锚点机制</h3><p>YOLOv3使用锚点（anchors）来辅助预测边界框。锚点是一组预定义的边界框尺寸，用于帮助网络更好地预测不同大小和形状的目标。</p><p>锚点的作用：</p><ul><li>每个尺度的特征图使用不同的锚点尺寸。例如，13x13特征图使用较大的锚点，52x52特征图使用较小的锚点。</li><li>网络预测的边界框是基于锚点的偏移量，而不是直接预测边界框的绝对坐标。</li></ul><hr><h3 id="5-边界框的编码与解码"><a href="#5-边界框的编码与解码" class="headerlink" title="5. 边界框的编码与解码"></a>5. 边界框的编码与解码</h3><p>YOLOv3通过编码和解码的方式将预测的边界框与真实边界框进行匹配。</p><h4 id="5-1-编码（Encoding）"><a href="#5-1-编码（Encoding）" class="headerlink" title="5.1 编码（Encoding）"></a>5.1 编码（Encoding）</h4><p>在训练时，需要将真实的边界框（ground truth）编码为网络输出的格式。</p><p>假设我们有一个真实的边界框$ (x, y, w, h) $，对应的锚点为$ (p_w, p_h) $，则编码后的边界框为：</p><ul><li>$ tx = (x - cx) / stride $</li><li>$ ty = (y - cy) / stride $</li><li>$ tw = log(w / p_w) $</li><li>$ th = log(h / p_h) $</li></ul><p>其中，$ (cx, cy) $是当前网格的左上角坐标，$ (tx, ty) $是中心偏移量，$ (tw, th) $是缩放比例，$ stride $是特征图的步长。</p><h4 id="5-2-解码（Decoding）"><a href="#5-2-解码（Decoding）" class="headerlink" title="5.2 解码（Decoding）"></a>5.2 解码（Decoding）</h4><p>在推理时，需要将网络输出的边界框解码为实际的坐标。假设网络输出为$ (tx, ty, tw, th) $，对应的锚点为$ (p_w, p_h) $，则解码后的边界框为：</p><ul><li>$ x = (sigmoid(tx) + cx) * stride $</li><li>$ y = (sigmoid(ty) + cy) * stride $</li><li>$ w = exp(tw) * p_w $</li><li>$ h = exp(th) * p_h $</li></ul><hr><h3 id="6-损失函数"><a href="#6-损失函数" class="headerlink" title="6. 损失函数"></a>6. 损失函数</h3><p>YOLOv3的损失函数由三部分组成：</p><ul><li><strong>定位损失（Localization Loss）</strong>：计算预测边界框与真实边界框之间的误差，通常使用均方误差（MSE）。</li><li><strong>置信度损失（Confidence Loss）</strong>：计算预测的置信度与真实值之间的误差，通常使用二元交叉熵（Binary Cross-Entropy）。</li><li><strong>分类损失（Classification Loss）</strong>：计算预测的类别概率与真实类别之间的误差，通常使用交叉熵（Cross-Entropy）。</li></ul><hr><h3 id="7-训练与推理"><a href="#7-训练与推理" class="headerlink" title="7. 训练与推理"></a>7. 训练与推理</h3><h4 id="7-1-训练"><a href="#7-1-训练" class="headerlink" title="7.1 训练"></a>7.1 训练</h4><p>在训练时，YOLOv3通过以下步骤进行优化：</p><ol><li>输入图像经过网络前向传播，得到三个尺度的预测结果。</li><li>将预测结果与真实标签进行匹配，计算损失。</li><li>使用反向传播更新网络参数。</li></ol><h4 id="7-2-推理"><a href="#7-2-推理" class="headerlink" title="7.2 推理"></a>7.2 推理</h4><p>在推理时，YOLOv3通过以下步骤生成检测结果：</p><ol><li>输入图像经过网络前向传播，得到三个尺度的预测结果。</li><li>对预测的边界框进行解码，得到实际的坐标。</li><li>使用非极大值抑制（NMS）去除重叠的边界框，得到最终的检测结果。</li></ol><hr><h2 id="细节实现"><a href="#细节实现" class="headerlink" title="细节实现"></a>细节实现</h2><h3 id="1-网络输出的结构"><a href="#1-网络输出的结构" class="headerlink" title="1. 网络输出的结构"></a>1. 网络输出的结构</h3><p>YOLOv3的网络输出是三个尺度的特征图（13x13、26x26、52x52），每个尺度的特征图会预测固定数量的边界框（通常是3个）。每个边界框的输出包含以下信息：</p><ul><li><strong>边界框的中心坐标偏移量（tx, ty）</strong>：相对于当前网格的偏移量。</li><li><strong>边界框的宽度和高度缩放量（tw, th）</strong>：相对于锚点的缩放量。</li><li><strong>目标存在的置信度（confidence）</strong>：表示当前边界框包含目标的概率。</li><li><strong>类别概率（class probabilities）</strong>：表示目标属于每个类别的概率。</li></ul><p>假设每个尺度预测3个边界框，类别数为C，则每个尺度的输出维度为：</p><ul><li>13x13尺度的输出维度：<code>13 x 13 x 3 x (5 + C)</code></li><li>26x26尺度的输出维度：<code>26 x 26 x 3 x (5 + C)</code></li><li>52x52尺度的输出维度：<code>52 x 52 x 3 x (5 + C)</code></li></ul><p>其中，<code>5</code>表示边界框的4个坐标值（tx, ty, tw, th）和1个置信度，<code>C</code>表示类别数。</p><hr><h3 id="2-后处理计算"><a href="#2-后处理计算" class="headerlink" title="2. 后处理计算"></a>2. 后处理计算</h3><p>后处理计算的目的是将网络的原始输出转换为实际的边界框坐标和类别信息。具体步骤如下：</p><h4 id="2-1-解码边界框坐标"><a href="#2-1-解码边界框坐标" class="headerlink" title="2.1 解码边界框坐标"></a>2.1 解码边界框坐标</h4><p>网络的输出是边界框的偏移量和缩放量，需要通过解码将其转换为实际的边界框坐标。</p><p>假设网络的输出为$ (tx, ty, tw, th) $，对应的锚点为$ (a_w, a_h) $，当前网格的左上角坐标为$ (cx, cy) $，特征图的步长为$ stride $，则解码后的边界框坐标为：</p><ul><li><strong>中心坐标</strong>：<ul><li>$   x = (sigmoid(tx) + cx) * stride $</li><li>$   y = (sigmoid(ty) + cy) * stride $</li></ul></li><li><strong>宽度和高度</strong>：<ul><li>$   w = exp(tw) * p_w $</li><li>$   h = exp(th) * p_h $</li></ul></li></ul><p>其中，$ sigmoid $函数用于将偏移量限制在0到1之间，确保边界框的中心位于当前网格内。</p><h4 id="2-2-计算置信度和类别概率"><a href="#2-2-计算置信度和类别概率" class="headerlink" title="2.2 计算置信度和类别概率"></a>2.2 计算置信度和类别概率</h4><p>网络的输出还包括置信度和类别概率，需要通过以下步骤进行处理：</p><ul><li><strong>置信度</strong>：直接使用$ sigmoid $函数将输出值转换为概率值，表示当前边界框包含目标的概率。</li><li><strong>类别概率</strong>：对每个类别的输出值应用$ sigmoid $函数，得到每个类别的概率值。</li></ul><h4 id="2-3-过滤低置信度的边界框"><a href="#2-3-过滤低置信度的边界框" class="headerlink" title="2.3 过滤低置信度的边界框"></a>2.3 过滤低置信度的边界框</h4><p>为了减少计算量，通常会过滤掉置信度低于某个阈值（如0.5）的边界框。只有置信度高于阈值的边界框才会进入下一步处理。</p><h4 id="2-4-非极大值抑制（NMS）"><a href="#2-4-非极大值抑制（NMS）" class="headerlink" title="2.4 非极大值抑制（NMS）"></a>2.4 非极大值抑制（NMS）</h4><p>非极大值抑制（Non-Maximum Suppression, NMS）用于去除重叠的边界框，保留最优的检测结果。NMS的具体步骤如下：</p><ol><li>对所有边界框按置信度从高到低排序。</li><li>选择置信度最高的边界框，将其加入最终结果列表。</li><li>计算该边界框与其余边界框的交并比（IoU）。</li><li>删除IoU高于某个阈值（如0.5）的边界框。</li><li>重复步骤2-4，直到所有边界框都被处理。</li></ol><hr><h3 id="3-置信度的计算"><a href="#3-置信度的计算" class="headerlink" title="3. 置信度的计算"></a>3. 置信度的计算</h3><p>置信度（confidence）是网络输出的一个重要部分，表示当前边界框包含目标的概率。置信度的计算步骤如下：</p><ol><li><strong>网络输出</strong>：网络输出的置信度是一个标量值（通常记为$ t_conf $），范围是任意的（未经过激活函数处理）。</li><li><strong>Sigmoid激活</strong>：为了将置信度转换为概率值，需要对$ t_conf $应用Sigmoid函数：<br>$ \text{confidence} = \sigma(t_conf) = \frac{1}{1 + e^{-t_conf}} $<br>这样，置信度的值被限制在0到1之间。</li><li><strong>置信度的意义</strong>：置信度表示当前边界框内是否存在目标。如果置信度接近1，说明边界框内很可能存在目标；如果接近0，则说明边界框内很可能没有目标。</li></ol><hr><h3 id="3-1-类别概率的计算"><a href="#3-1-类别概率的计算" class="headerlink" title="3.1 类别概率的计算"></a>3.1 类别概率的计算</h3><p>类别概率（class probabilities）表示目标属于每个类别的概率。</p><ol><li><strong>网络输出</strong>：网络输出的类别概率是一个长度为$ C $的向量（$ C $为类别数），记为$ t_class $。每个值表示对应类别的得分（未经过激活函数处理）。</li><li><strong>Sigmoid激活</strong>：对$ t_class $中的每个值应用$ Sigmoid $函数，将其转换为概率值：<br>$ \text{class_prob}_i = \sigma(t_class_i) = \frac{1}{1 + e^{-t_class_i}} $<br>这样，每个类别的概率值被限制在0到1之间。</li><li><strong>类别概率的意义</strong>：$ class_prob_i $表示目标属于第$ i $个类别的概率。YOLOv3使用$ Sigmoid $函数而不是$ Softmax $函数，因此每个类别的概率是独立的，可以同时预测多个类别（适用于多标签分类任务）。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736055615050-19591ae5-d726-49fa-9129-d6f5e1fd6af6.png" alt=""></p><hr><h3 id="3-2-过滤低置信度的边界框"><a href="#3-2-过滤低置信度的边界框" class="headerlink" title="3.2 过滤低置信度的边界框"></a>3.2 过滤低置信度的边界框</h3><p>在得到置信度和类别概率后，通常需要过滤掉低置信度的边界框，以减少计算量并提高检测结果的可靠性。具体步骤如下：</p><ol><li><strong>设置置信度阈值</strong>：通常设置一个置信度阈值（如0.5），只有置信度高于该阈值的边界框才会被保留。</li><li><strong>过滤边界框</strong>：遍历所有边界框，保留置信度高于阈值的边界框，丢弃低于阈值的边界框。</li></ol><hr><h3 id="3-3-非极大值抑制（NMS）"><a href="#3-3-非极大值抑制（NMS）" class="headerlink" title="3.3 非极大值抑制（NMS）"></a>3.3 非极大值抑制（NMS）</h3><p>非极大值抑制（Non-Maximum Suppression, NMS）是目标检测中常用的后处理步骤，用于去除重叠的边界框，保留最优的检测结果。NMS的具体步骤如下：</p><ol><li><strong>按置信度排序</strong>：将所有边界框按置信度从高到低排序。</li><li><strong>选择最高置信度的边界框</strong>：从排序后的列表中选择置信度最高的边界框，将其加入最终结果列表。</li><li><strong>计算交并比（IoU）</strong>：计算该边界框与其余所有边界框的交并比（Intersection over Union, IoU）。IoU的计算公式为：<br>$ \text{IoU} = \frac{\text{Area of Intersection}}{\text{Area of Union}} $<br>其中，<code>Area of Intersection</code>是两个边界框的交集面积，<code>Area of Union</code>是两个边界框的并集面积。</li><li><strong>去除重叠边界框</strong>：删除与当前边界框IoU高于某个阈值（如0.5）的边界框。</li><li><strong>重复步骤2-4</strong>：重复上述过程，直到所有边界框都被处理。</li></ol><hr><h3 id="3-具体示例"><a href="#3-具体示例" class="headerlink" title="3. 具体示例"></a>3. 具体示例</h3><p>假设我们有一个13x13尺度的输出，类别数为80，锚点为<code>(10, 13), (16, 30), (33, 23)</code>，特征图的步长为32。</p><h4 id="3-1-网络输出"><a href="#3-1-网络输出" class="headerlink" title="3.1 网络输出"></a>3.1 网络输出</h4><p>网络的输出维度为<code>13 x 13 x 3 x 85</code>，其中<code>85 = 5 + 80</code>（5表示边界框的4个坐标值和1个置信度，80表示类别数）。</p><h4 id="3-2-解码边界框"><a href="#3-2-解码边界框" class="headerlink" title="3.2 解码边界框"></a>3.2 解码边界框</h4><p>对于每个网格和每个锚点，解码边界框的步骤如下：</p><ol><li>提取$ (tx, ty, tw, th) $和置信度、类别概率。</li><li>使用$ Sigmoid $函数计算中心坐标偏移量：<ul><li>$ x = (\sigma(tx) + cx) \times 32 $</li><li>$   y = (\sigma(ty) + cy) \times 32  $</li></ul></li><li>使用指数函数计算宽度和高度：<ul><li>$ w = \exp(tw) \times a_w $</li><li>$  h = \exp(th) \times a_h  $</li></ul></li><li>将边界框坐标转换为$ (x_min, y_min, x_max, y_max) $格式：<ul><li>$    x_{\text{min}} = x - w / 2  $</li><li>$    y_{\text{min}} = y - h / 2  $</li><li>$    x_{\text{max}} = x + w / 2  $</li><li>$ y_{\text{max}} = y + h / 2  $</li></ul></li></ol><h4 id="3-3-置信度和类别概率的计算"><a href="#3-3-置信度和类别概率的计算" class="headerlink" title="3.3 置信度和类别概率的计算"></a>3.3 置信度和类别概率的计算</h4><ol><li>对置信度$ t_conf $应用$ Sigmoid $函数：<br>$ \text{confidence} = \sigma(t_conf) $</li><li>对类别概率$ t_class $应用$ Sigmoid $函数：<br>$ \text{class_prob}_i = \sigma(t_class_i) $</li></ol><h4 id="3-4-过滤和NMS"><a href="#3-4-过滤和NMS" class="headerlink" title="3.4 过滤和NMS"></a>3.4 过滤和NMS</h4><ol><li>过滤掉置信度低于0.5的边界框。</li><li>对剩余的边界框按置信度排序。</li><li>使用NMS去除重叠的边界框，保留最优的检测结果。</li></ol><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><hr><h3 id="1-网络架构：Darknet-53"><a href="#1-网络架构：Darknet-53" class="headerlink" title="1. 网络架构：Darknet-53"></a>1. 网络架构：Darknet-53</h3><p>YOLOv3的骨干网络是Darknet-53，这是一个53层的卷积神经网络（CNN），借鉴了ResNet的残差结构，但设计更为轻量化和高效。</p><h4 id="1-1-Darknet-53的结构"><a href="#1-1-Darknet-53的结构" class="headerlink" title="1.1 Darknet-53的结构"></a>1.1 Darknet-53的结构</h4><ul><li><strong>输入</strong>：YOLOv3的输入图像尺寸通常为416x416（或其他尺寸，如608x608）。</li><li><strong>卷积层</strong>：Darknet-53主要由卷积层、批量归一化（Batch Normalization）和Leaky ReLU激活函数组成。<ul><li>卷积层：使用3x3和1x1卷积核，3x3卷积用于提取特征，1x1卷积用于调整通道数。</li><li>批量归一化：加速训练并提高模型稳定性。</li><li>Leaky ReLU：激活函数，公式为 $  f(x) = \max(x, 0.1x)  $，避免梯度消失。</li></ul></li><li><strong>残差块（Residual Block）</strong>：Darknet-53的核心组件是残差块，每个残差块包含两个3x3卷积层和一个跳跃连接（Shortcut Connection）。<ul><li>跳跃连接将输入直接加到输出上，缓解梯度消失问题，使网络能够训练得更深。</li><li>Darknet-53共有23个残差块。</li></ul></li></ul><h4 id="1-2-Darknet-53的特点"><a href="#1-2-Darknet-53的特点" class="headerlink" title="1.2 Darknet-53的特点"></a>1.2 Darknet-53的特点</h4><ul><li><strong>深度</strong>：53层网络，比YOLOv2的Darknet-19更深，但比ResNet-152更轻量。</li><li><strong>效率</strong>：Darknet-53在ImageNet分类任务上达到了与ResNet-152相当的精度，但速度更快。</li><li><strong>多尺度特征提取</strong>：Darknet-53通过不同层提取不同尺度的特征，为后续的多尺度预测提供支持。</li></ul><hr><h3 id="2-多尺度预测"><a href="#2-多尺度预测" class="headerlink" title="2. 多尺度预测"></a>2. 多尺度预测</h3><p>YOLOv3在三个不同尺度的特征图上进行目标检测，分别对应13x13、26x26和52x52的特征图。这种多尺度设计使其能够检测不同大小的目标。</p><h4 id="2-1-特征金字塔网络（FPN）"><a href="#2-1-特征金字塔网络（FPN）" class="headerlink" title="2.1 特征金字塔网络（FPN）"></a>2.1 特征金字塔网络（FPN）</h4><p>YOLOv3借鉴了特征金字塔网络（Feature Pyramid Network, FPN）的思想，通过上采样和特征融合实现多尺度预测。</p><ul><li><strong>上采样（Upsampling）</strong>：将低分辨率的特征图通过插值方法（如双线性插值）放大到高分辨率。</li><li><strong>特征融合</strong>：将上采样后的特征图与来自浅层的特征图进行拼接（Concatenation），结合低级特征（细节信息）和高级特征（语义信息）。<ul><li>例如，13x13的特征图通过上采样得到26x26的特征图，然后与Darknet-53中间层的26x26特征图拼接。</li></ul></li></ul><h4 id="2-2-三个尺度的预测"><a href="#2-2-三个尺度的预测" class="headerlink" title="2.2 三个尺度的预测"></a>2.2 三个尺度的预测</h4><ul><li><strong>13x13特征图</strong>：用于检测大目标。</li><li><strong>26x26特征图</strong>：用于检测中等目标。</li><li><strong>52x52特征图</strong>：用于检测小目标。</li></ul><p>每个尺度的特征图都会输出预测结果，包括边界框坐标、置信度和类别概率。</p><hr><h3 id="3-锚框（Anchor-Boxes）机制"><a href="#3-锚框（Anchor-Boxes）机制" class="headerlink" title="3. 锚框（Anchor Boxes）机制"></a>3. 锚框（Anchor Boxes）机制</h3><p>YOLOv3使用锚框（Anchor Boxes）来预测目标的边界框。锚框是预定义的边界框，用于捕捉不同形状和尺寸的目标。</p><h4 id="3-1-锚框的选择"><a href="#3-1-锚框的选择" class="headerlink" title="3.1 锚框的选择"></a>3.1 锚框的选择</h4><ul><li><strong>K-means聚类</strong>：YOLOv3使用K-means聚类算法从训练数据集中自动学习锚框的尺寸。<ul><li>对训练集中所有目标的边界框进行聚类，得到9个聚类中心（即9个锚框）。</li><li>这些锚框被分配到三个尺度上，每个尺度分配3个锚框。</li></ul></li><li><strong>锚框的尺寸</strong>：不同尺度的锚框尺寸不同，例如：<ul><li>13x13尺度的锚框较大，适合检测大目标。</li><li>52x52尺度的锚框较小，适合检测小目标。</li></ul></li></ul><h4 id="3-2-锚框的预测"><a href="#3-2-锚框的预测" class="headerlink" title="3.2 锚框的预测"></a>3.2 锚框的预测</h4><ul><li>每个网格单元（Grid Cell）预测3个边界框，每个边界框对应一个锚框。</li><li>每个边界框预测以下内容：<ul><li>边界框坐标（x, y, w, h）：x和y是中心点坐标，w和h是宽度和高度。</li><li>置信度（Confidence）：表示边界框内是否包含目标，以及预测框的准确性。</li><li>类别概率（Class Probabilities）：表示目标属于每个类别的概率。</li></ul></li></ul><hr><h3 id="4-损失函数"><a href="#4-损失函数" class="headerlink" title="4. 损失函数"></a>4. 损失函数</h3><p>以下是YOLOv3中三个损失计算函数的详细公式和解释：</p><hr><h4 id="1-坐标损失（Coordinate-Loss）"><a href="#1-坐标损失（Coordinate-Loss）" class="headerlink" title="1. 坐标损失（Coordinate Loss）"></a>1. 坐标损失（Coordinate Loss）</h4><p>坐标损失用于衡量预测的边界框坐标（中心点 (x, y) 和宽高 (w, h)）与真实边界框坐标之间的差异。YOLOv3使用均方误差（MSE）来计算坐标损失。</p><h5 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736056982107-a76914d6-e67e-4dc2-a3a9-70c511955a5f.png" alt=""></p><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>$  S^2  $：网格单元的数量（例如，13x13、26x26、52x52）。</li><li>$  B  $：每个网格单元预测的边界框数量（YOLOv3中 ( B = 3 )）。</li><li>$ \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 ( i ) 个网格单元的第 ( j ) 个边界框是否负责检测目标（如果是则为1，否则为0）。</li><li>$  x_i, y_i  $：预测的边界框中心点坐标。</li><li>$  \hat{x}_i, \hat{y}_i  $：真实的边界框中心点坐标。</li><li>$  w_i, h_i  $：预测的边界框宽度和高度。</li><li>$  \hat{w}_i, \hat{h}_i  $：真实的边界框宽度和高度。</li><li>$  \lambda_{\text{coord}}  $：坐标损失的权重（通常设置为5）。</li></ul><hr><h4 id="2-置信度损失（Confidence-Loss）"><a href="#2-置信度损失（Confidence-Loss）" class="headerlink" title="2. 置信度损失（Confidence Loss）"></a>2. 置信度损失（Confidence Loss）</h4><p>置信度损失用于衡量预测的置信度（即边界框内是否包含目标）与真实值之间的差异。YOLOv3使用二分类交叉熵损失来计算置信度损失。</p><h5 id="公式：-1"><a href="#公式：-1" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736056991829-7210b841-2fa5-4cf0-b402-bc9756a8a691.png" alt=""></p><h5 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>$  \hat{C}_i  $：预测的置信度（即边界框内包含目标的概率）。</li><li>$  \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 ( i ) 个网格单元的第 ( j ) 个边界框是否负责检测目标（如果是则为1，否则为0）。</li><li>对于负样本（不包含目标的边界框），置信度损失仅计算 $  \log(1 - \hat{C}_i)  $。</li></ul><hr><h4 id="3-类别损失（Class-Loss）"><a href="#3-类别损失（Class-Loss）" class="headerlink" title="3. 类别损失（Class Loss）"></a>3. 类别损失（Class Loss）</h4><p>类别损失用于衡量预测的类别概率与真实类别之间的差异。YOLOv3使用多分类交叉熵损失来计算类别损失。</p><h5 id="公式：-2"><a href="#公式：-2" class="headerlink" title="公式："></a>公式：</h5><p><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736057000321-c51f7efd-2012-429e-8635-d4b10122b037.png" alt=""></p><h5 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>$ p_i(c)  $：真实的类别概率（如果是类别$  c  $则为1，否则为0）。</li><li>$ \hat{p}_i(c)  $：预测的类别概率（通过$ Sigmoid $函数输出）。</li><li>$ \mathbb{1}_{ij}^{\text{obj}}  $：指示函数，表示第 $  i   $个网格单元的第$   j   $个边界框是否负责检测目标（如果是则为1，否则为0）。</li><li>$  c  $：类别索引， $ \text{classes}  $是所有类别的集合。</li></ul><hr><h4 id="4-总损失函数"><a href="#4-总损失函数" class="headerlink" title="4. 总损失函数"></a>4. 总损失函数</h4><p>YOLOv3的总损失函数是上述三个损失函数的加权和：<br><img src="https://cdn.nlark.com/yuque/0/2025/png/39221021/1736057096661-f17820de-b536-4b52-b14d-c2b662de9c8d.png" alt=""></p><h5 id="参数说明：-3"><a href="#参数说明：-3" class="headerlink" title="参数说明："></a>参数说明：</h5><ul><li>总损失函数是坐标损失、置信度损失和类别损失的总和。</li><li>每个损失函数的权重可以通过超参数调整（例如，坐标损失的权重 $  \lambda_{\text{coord}}  $ 通常设置为5）。</li></ul><hr><h3 id="5-训练与推理"><a href="#5-训练与推理" class="headerlink" title="5. 训练与推理"></a>5. 训练与推理</h3><h4 id="5-1-训练"><a href="#5-1-训练" class="headerlink" title="5.1 训练"></a>5.1 训练</h4><ul><li><strong>数据增强</strong>：使用随机裁剪、翻转、颜色抖动等技术增强数据。</li><li><strong>损失优化</strong>：通过反向传播优化损失函数，更新网络参数。</li><li><strong>预训练</strong>：Darknet-53通常在ImageNet数据集上进行预训练，然后在目标检测任务上进行微调。</li></ul><h4 id="5-2-推理"><a href="#5-2-推理" class="headerlink" title="5.2 推理"></a>5.2 推理</h4><ul><li><strong>输入图像</strong>：将图像调整为固定尺寸（如416x416）并输入网络。</li><li><strong>预测输出</strong>：网络输出三个尺度的预测结果。</li><li><strong>非极大值抑制（NMS）</strong>：去除重叠的边界框，保留置信度最高的预测框。</li></ul><hr><h2 id="代码阅读（汉化）"><a href="#代码阅读（汉化）" class="headerlink" title="代码阅读（汉化）"></a>代码阅读（汉化）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ultralytics YOLOv3 🚀, AGPL-3.0 license</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">使用自定义数据集训练YOLOv3模型。模型和数据集会自动从最新的YOLOv3版本下载。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">单GPU训练用法:</span></span><br><span class="line"><span class="string">    $ python train.py --data coco128.yaml --weights yolov5s.pt --img 640  # 从预训练模型开始训练（推荐）</span></span><br><span class="line"><span class="string">    $ python train.py --data coco128.yaml --weights &#x27;&#x27; --cfg yolov5s.yaml --img 640  # 从零开始训练</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">多GPU DDP训练用法:</span></span><br><span class="line"><span class="string">    $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 train.py --data coco128.yaml --weights yolov5s.pt --img 640 --device 0,1,2,3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">模型:     https://github.com/ultralytics/yolov5/tree/master/models</span></span><br><span class="line"><span class="string">数据集:   https://github.com/ultralytics/yolov5/tree/master/data</span></span><br><span class="line"><span class="string">教程:   https://docs.ultralytics.com/yolov5/tutorials/train_custom_data</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> comet_ml  <span class="comment"># 必须在torch之前导入（如果已安装）</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    comet_ml = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">FILE = Path(__file__).resolve()</span><br><span class="line">ROOT = FILE.parents[<span class="number">0</span>]  <span class="comment"># YOLOv3根目录</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">str</span>(ROOT) <span class="keyword">not</span> <span class="keyword">in</span> sys.path:</span><br><span class="line">    sys.path.append(<span class="built_in">str</span>(ROOT))  <span class="comment"># 将ROOT添加到PATH</span></span><br><span class="line">ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  <span class="comment"># 相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> val <span class="keyword">as</span> validate  <span class="comment"># 用于epoch结束时的mAP计算</span></span><br><span class="line"><span class="keyword">from</span> models.experimental <span class="keyword">import</span> attempt_load</span><br><span class="line"><span class="keyword">from</span> models.yolo <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> utils.autoanchor <span class="keyword">import</span> check_anchors</span><br><span class="line"><span class="keyword">from</span> utils.autobatch <span class="keyword">import</span> check_train_batch_size</span><br><span class="line"><span class="keyword">from</span> utils.callbacks <span class="keyword">import</span> Callbacks</span><br><span class="line"><span class="keyword">from</span> utils.dataloaders <span class="keyword">import</span> create_dataloader</span><br><span class="line"><span class="keyword">from</span> utils.downloads <span class="keyword">import</span> attempt_download, is_url</span><br><span class="line"><span class="keyword">from</span> utils.general <span class="keyword">import</span> (</span><br><span class="line">    LOGGER,</span><br><span class="line">    TQDM_BAR_FORMAT,</span><br><span class="line">    check_amp,</span><br><span class="line">    check_dataset,</span><br><span class="line">    check_file,</span><br><span class="line">    check_git_info,</span><br><span class="line">    check_git_status,</span><br><span class="line">    check_img_size,</span><br><span class="line">    check_requirements,</span><br><span class="line">    check_suffix,</span><br><span class="line">    check_yaml,</span><br><span class="line">    colorstr,</span><br><span class="line">    get_latest_run,</span><br><span class="line">    increment_path,</span><br><span class="line">    init_seeds,</span><br><span class="line">    intersect_dicts,</span><br><span class="line">    labels_to_class_weights,</span><br><span class="line">    labels_to_image_weights,</span><br><span class="line">    methods,</span><br><span class="line">    one_cycle,</span><br><span class="line">    print_args,</span><br><span class="line">    print_mutation,</span><br><span class="line">    strip_optimizer,</span><br><span class="line">    yaml_save,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> utils.loggers <span class="keyword">import</span> Loggers</span><br><span class="line"><span class="keyword">from</span> utils.loggers.comet.comet_utils <span class="keyword">import</span> check_comet_resume</span><br><span class="line"><span class="keyword">from</span> utils.loss <span class="keyword">import</span> ComputeLoss</span><br><span class="line"><span class="keyword">from</span> utils.metrics <span class="keyword">import</span> fitness</span><br><span class="line"><span class="keyword">from</span> utils.plots <span class="keyword">import</span> plot_evolve</span><br><span class="line"><span class="keyword">from</span> utils.torch_utils <span class="keyword">import</span> (</span><br><span class="line">    EarlyStopping,</span><br><span class="line">    ModelEMA,</span><br><span class="line">    de_parallel,</span><br><span class="line">    select_device,</span><br><span class="line">    smart_DDP,</span><br><span class="line">    smart_optimizer,</span><br><span class="line">    smart_resume,</span><br><span class="line">    torch_distributed_zero_first,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LOCAL_RANK = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;LOCAL_RANK&quot;</span>, -<span class="number">1</span>))  <span class="comment"># https://pytorch.org/docs/stable/elastic/run.html</span></span><br><span class="line">RANK = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;RANK&quot;</span>, -<span class="number">1</span>))</span><br><span class="line">WORLD_SIZE = <span class="built_in">int</span>(os.getenv(<span class="string">&quot;WORLD_SIZE&quot;</span>, <span class="number">1</span>))</span><br><span class="line">GIT_INFO = check_git_info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">hyp, opt, device, callbacks</span>):  <span class="comment"># hyp是路径/to/hyp.yaml或hyp字典</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在自定义数据集上训练YOLOv3模型并管理训练过程。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        hyp (str | dict): 超参数yaml文件的路径或超参数字典。</span></span><br><span class="line"><span class="string">        opt (argparse.Namespace): 包含训练选项的解析命令行参数。</span></span><br><span class="line"><span class="string">        device (torch.device): 加载和训练模型的设备。</span></span><br><span class="line"><span class="string">        callbacks (Callbacks): 处理训练生命周期各个阶段的回调函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    单GPU训练用法:</span></span><br><span class="line"><span class="string">        $ python train.py --data coco128.yaml --weights yolov5s.pt --img 640  # 从预训练模型开始训练（推荐）</span></span><br><span class="line"><span class="string">        $ python train.py --data coco128.yaml --weights &#x27;&#x27; --cfg yolov5s.yaml --img 640  # 从零开始训练</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    多GPU DDP训练用法:</span></span><br><span class="line"><span class="string">        $ python -m torch.distributed.run --nproc_per_node 4 --master_port 1 train.py --data coco128.yaml --weights</span></span><br><span class="line"><span class="string">            yolov5s.pt --img 640 --device 0,1,2,3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    模型: https://github.com/ultralytics/yolov5/tree/master/models</span></span><br><span class="line"><span class="string">    数据集: https://github.com/ultralytics/yolov5/tree/master/data</span></span><br><span class="line"><span class="string">    教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    示例:</span></span><br><span class="line"><span class="string">        ```python</span></span><br><span class="line"><span class="string">        from ultralytics import train</span></span><br><span class="line"><span class="string">        import argparse</span></span><br><span class="line"><span class="string">        import torch</span></span><br><span class="line"><span class="string">        from utils.callbacks import Callbacks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 示例用法</span></span><br><span class="line"><span class="string">        args = argparse.Namespace(</span></span><br><span class="line"><span class="string">            data=&#x27;coco128.yaml&#x27;,</span></span><br><span class="line"><span class="string">            weights=&#x27;yolov5s.pt&#x27;,</span></span><br><span class="line"><span class="string">            cfg=&#x27;yolov5s.yaml&#x27;,</span></span><br><span class="line"><span class="string">            img_size=640,</span></span><br><span class="line"><span class="string">            epochs=50,</span></span><br><span class="line"><span class="string">            batch_size=16,</span></span><br><span class="line"><span class="string">            device=&#x27;0&#x27;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        device = torch.device(f&#x27;cuda:&#123;args.device&#125;&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)</span></span><br><span class="line"><span class="string">        callbacks = Callbacks()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        train(hyp=&#x27;hyp.scratch.yaml&#x27;, opt=args, device=device, callbacks=callbacks)</span></span><br></pre></td></tr></table></figure><pre><code>&quot;&quot;&quot;save_dir, epochs, batch_size, weights, single_cls, evolve, data, cfg, resume, noval, nosave, workers, freeze = (    Path(opt.save_dir),    opt.epochs,    opt.batch_size,    opt.weights,    opt.single_cls,    opt.evolve,    opt.data,    opt.cfg,    opt.resume,    opt.noval,    opt.nosave,    opt.workers,    opt.freeze,)callbacks.run(&quot;on_pretrain_routine_start&quot;)# 目录w = save_dir / &quot;weights&quot;  # 权重目录(w.parent if evolve else w).mkdir(parents=True, exist_ok=True)  # 创建目录last, best = w / &quot;last.pt&quot;, w / &quot;best.pt&quot;# 超参数if isinstance(hyp, str):    with open(hyp, errors=&quot;ignore&quot;) as f:        hyp = yaml.safe_load(f)  # 加载超参数字典LOGGER.info(colorstr(&quot;超参数: &quot;) + &quot;, &quot;.join(f&quot;&#123;k&#125;=&#123;v&#125;&quot; for k, v in hyp.items()))opt.hyp = hyp.copy()  # 保存超参数到检查点# 保存运行设置if not evolve:    yaml_save(save_dir / &quot;hyp.yaml&quot;, hyp)    yaml_save(save_dir / &quot;opt.yaml&quot;, vars(opt))# 日志记录器data_dict = Noneif RANK in &#123;-1, 0&#125;:    loggers = Loggers(save_dir, weights, opt, hyp, LOGGER)  # 日志记录器实例    # 注册动作    for k in methods(loggers):        callbacks.register_action(k, callback=getattr(loggers, k))    # 处理自定义数据集工件链接    data_dict = loggers.remote_dataset    if resume:  # 如果从远程工件恢复运行        weights, epochs, hyp, batch_size = opt.weights, opt.epochs, opt.hyp, opt.batch_size# 配置plots = not evolve and not opt.noplots  # 创建图表cuda = device.type != &quot;cpu&quot;init_seeds(opt.seed + 1 + RANK, deterministic=True)with torch_distributed_zero_first(LOCAL_RANK):    data_dict = data_dict or check_dataset(data)  # 检查是否为Nonetrain_path, val_path = data_dict[&quot;train&quot;], data_dict[&quot;val&quot;]nc = 1 if single_cls else int(data_dict[&quot;nc&quot;])  # 类别数量names = &#123;0: &quot;item&quot;&#125; if single_cls and len(data_dict[&quot;names&quot;]) != 1 else data_dict[&quot;names&quot;]  # 类别名称is_coco = isinstance(val_path, str) and val_path.endswith(&quot;coco/val2017.txt&quot;)  # COCO数据集# 模型check_suffix(weights, &quot;.pt&quot;)  # 检查权重pretrained = weights.endswith(&quot;.pt&quot;)if pretrained:    with torch_distributed_zero_first(LOCAL_RANK):        weights = attempt_download(weights)  # 如果本地没有找到则下载    ckpt = torch.load(weights, map_location=&quot;cpu&quot;)  # 将检查点加载到CPU以避免CUDA内存泄漏    model = Model(cfg or ckpt[&quot;model&quot;].yaml, ch=3, nc=nc, anchors=hyp.get(&quot;anchors&quot;)).to(device)  # 创建模型    exclude = [&quot;anchor&quot;] if (cfg or hyp.get(&quot;anchors&quot;)) and not resume else []  # 排除键    csd = ckpt[&quot;model&quot;].float().state_dict()  # 检查点状态字典为FP32    csd = intersect_dicts(csd, model.state_dict(), exclude=exclude)  # 交集    model.load_state_dict(csd, strict=False)  # 加载    LOGGER.info(f&quot;从 &#123;weights&#125; 转移了 &#123;len(csd)&#125;/&#123;len(model.state_dict())&#125; 项&quot;)  # 报告else:    model = Model(cfg, ch=3, nc=nc, anchors=hyp.get(&quot;anchors&quot;)).to(device)  # 创建模型amp = check_amp(model)  # 检查AMP# 冻结freeze = [f&quot;model.&#123;x&#125;.&quot; for x in (freeze if len(freeze) &gt; 1 else range(freeze[0]))]  # 冻结的层for k, v in model.named_parameters():    v.requires_grad = True  # 训练所有层    # v.register_hook(lambda x: torch.nan_to_num(x))  # NaN转为0（注释掉以避免训练结果不稳定）    if any(x in k for x in freeze):        LOGGER.info(f&quot;冻结 &#123;k&#125;&quot;)        v.requires_grad = False# 图像大小gs = max(int(model.stride.max()), 32)  # 网格大小（最大步幅）imgsz = check_img_size(opt.imgsz, gs, floor=gs * 2)  # 验证imgsz是gs的倍数# 批量大小if RANK == -1 and batch_size == -1:  # 仅限单GPU，估计最佳批量大小    batch_size = check_train_batch_size(model, imgsz, amp)    loggers.on_params_update(&#123;&quot;batch_size&quot;: batch_size&#125;)# 优化器nbs = 64  # 名义批量大小accumulate = max(round(nbs / batch_size), 1)  # 在优化前累积损失hyp[&quot;weight_decay&quot;] *= batch_size * accumulate / nbs  # 缩放权重衰减optimizer = smart_optimizer(model, opt.optimizer, hyp[&quot;lr0&quot;], hyp[&quot;momentum&quot;], hyp[&quot;weight_decay&quot;])# 学习率调度器if opt.cos_lr:    lf = one_cycle(1, hyp[&quot;lrf&quot;], epochs)  # 余弦 1-&gt;hyp[&#39;lrf&#39;]else:    def lf(x):        &quot;&quot;&quot;线性学习率调度器函数，根据epoch比例计算衰减。&quot;&quot;&quot;        return (1 - x / epochs) * (1.0 - hyp[&quot;lrf&quot;]) + hyp[&quot;lrf&quot;]  # 线性scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)  # plot_lr_scheduler(optimizer, scheduler, epochs)# EMAema = ModelEMA(model) if RANK in &#123;-1, 0&#125; else None# 恢复best_fitness, start_epoch = 0.0, 0if pretrained:    if resume:        best_fitness, start_epoch, epochs = smart_resume(ckpt, optimizer, ema, weights, epochs, resume)    del ckpt, csd# DP模式if cuda and RANK == -1 and torch.cuda.device_count() &gt; 1:    LOGGER.warning(        &quot;警告 ⚠️ 不推荐使用DP模式，建议使用torch.distributed.run以获得最佳DDP多GPU结果。\n&quot;        &quot;请参阅多GPU教程：https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training 以开始使用。&quot;    )    model = torch.nn.DataParallel(model)# SyncBatchNormif opt.sync_bn and cuda and RANK != -1:    model = torch.nn.SyncBatchNorm.convert_sync_batchnorm(model).to(device)    LOGGER.info(&quot;使用 SyncBatchNorm()&quot;)# 训练数据加载器train_loader, dataset = create_dataloader(    train_path,    imgsz,    batch_size // WORLD_SIZE,    gs,    single_cls,    hyp=hyp,    augment=True,    cache=None if opt.cache == &quot;val&quot; else opt.cache,    rect=opt.rect,    rank=LOCAL_RANK,    workers=workers,    image_weights=opt.image_weights,    quad=opt.quad,    prefix=colorstr(&quot;训练: &quot;),    shuffle=True,    seed=opt.seed,)labels = np.concatenate(dataset.labels, 0)mlc = int(labels[:, 0].max())  # 最大标签类别assert mlc &lt; nc, f&quot;标签类别 &#123;mlc&#125; 超过了 &#123;data&#125; 中的 nc=&#123;nc&#125;。可能的类别标签是 0-&#123;nc - 1&#125;&quot;# 进程0if RANK in &#123;-1, 0&#125;:    val_loader = create_dataloader(        val_path,        imgsz,        batch_size // WORLD_SIZE * 2,        gs,        single_cls,        hyp=hyp,        cache=None if noval else opt.cache,        rect=True,        rank=-1,        workers=workers * 2,        pad=0.5,        prefix=colorstr(&quot;验证: &quot;),    )[0]    if not resume:        if not opt.noautoanchor:            check_anchors(dataset, model=model, thr=hyp[&quot;anchor_t&quot;], imgsz=imgsz)  # 运行AutoAnchor        model.half().float()  # 预降低锚点精度    callbacks.run(&quot;on_pretrain_routine_end&quot;, labels, names)# DDP模式if cuda and RANK != -1:    model = smart_DDP(model)# 模型属性nl = de_parallel(model).model[-1].nl  # 检测层数量（用于缩放超参数）hyp[&quot;box&quot;] *= 3 / nl  # 按层缩放hyp[&quot;cls&quot;] *= nc / 80 * 3 / nl  # 按类别和层缩放hyp[&quot;obj&quot;] *= (imgsz / 640) ** 2 * 3 / nl  # 按图像大小和层缩放hyp[&quot;label_smoothing&quot;] = opt.label_smoothingmodel.nc = nc  # 将类别数量附加到模型model.hyp = hyp  # 将超参数附加到模型model.class_weights = labels_to_class_weights(dataset.labels, nc).to(device) * nc  # 将类别权重附加到模型model.names = names# 开始训练t0 = time.time()nb = len(train_loader)  # 批次数量nw = max(round(hyp[&quot;warmup_epochs&quot;] * nb), 100)  # 预热迭代次数，最大（3个epoch，100次迭代）# nw = min(nw, (epochs - start_epoch) / 2 * nb)  # 将预热限制在训练的一半以下last_opt_step = -1maps = np.zeros(nc)  # 每个类别的mAPresults = (0, 0, 0, 0, 0, 0, 0)  # P, R, mAP@.5, mAP@.5-.95, val_loss(box, obj, cls)scheduler.last_epoch = start_epoch - 1  # 不要移动scaler = torch.cuda.amp.GradScaler(enabled=amp)stopper, stop = EarlyStopping(patience=opt.patience), Falsecompute_loss = ComputeLoss(model)  # 初始化损失类callbacks.run(&quot;on_train_start&quot;)LOGGER.info(    f&#39;图像大小 &#123;imgsz&#125; 训练, &#123;imgsz&#125; 验证\n&#39;    f&#39;使用 &#123;train_loader.num_workers * WORLD_SIZE&#125; 个数据加载器工作进程\n&#39;    f&quot;记录结果到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;\n&quot;    f&#39;开始训练 &#123;epochs&#125; 个epoch...&#39;)for epoch in range(start_epoch, epochs):  # epoch ------------------------------------------------------------------    callbacks.run(&quot;on_train_epoch_start&quot;)    model.train()    # 更新图像权重（可选，仅限单GPU）    if opt.image_weights:        cw = model.class_weights.cpu().numpy() * (1 - maps) ** 2 / nc  # 类别权重        iw = labels_to_image_weights(dataset.labels, nc=nc, class_weights=cw)  # 图像权重        dataset.indices = random.choices(range(dataset.n), weights=iw, k=dataset.n)  # 随机加权索引    # 更新马赛克边框（可选）    # b = int(random.uniform(0.25 * imgsz, 0.75 * imgsz + gs) // gs * gs)    # dataset.mosaic_border = [b - imgsz, -b]  # 高度，宽度边框    mloss = torch.zeros(3, device=device)  # 平均损失    if RANK != -1:        train_loader.sampler.set_epoch(epoch)    pbar = enumerate(train_loader)    LOGGER.info((&quot;\n&quot; + &quot;%11s&quot; * 7) % (&quot;Epoch&quot;, &quot;GPU_mem&quot;, &quot;box_loss&quot;, &quot;obj_loss&quot;, &quot;cls_loss&quot;, &quot;Instances&quot;, &quot;Size&quot;))    if RANK in &#123;-1, 0&#125;:        pbar = tqdm(pbar, total=nb, bar_format=TQDM_BAR_FORMAT)  # 进度条    optimizer.zero_grad()    for i, (imgs, targets, paths, _) in pbar:  # batch -------------------------------------------------------------        callbacks.run(&quot;on_train_batch_start&quot;)        ni = i + nb * epoch  # 自训练开始以来的集成批次数量        imgs = imgs.to(device, non_blocking=True).float() / 255  # uint8转为float32，0-255转为0.0-1.0        # 预热        if ni &lt;= nw:            xi = [0, nw]  # x插值            # compute_loss.gr = np.interp(ni, xi, [0.0, 1.0])  # iou损失比率（obj_loss = 1.0或iou）            accumulate = max(1, np.interp(ni, xi, [1, nbs / batch_size]).round())            for j, x in enumerate(optimizer.param_groups):                # bias lr从0.1下降到lr0，其他lr从0.0上升到lr0                x[&quot;lr&quot;] = np.interp(ni, xi, [hyp[&quot;warmup_bias_lr&quot;] if j == 0 else 0.0, x[&quot;initial_lr&quot;] * lf(epoch)])                if &quot;momentum&quot; in x:                    x[&quot;momentum&quot;] = np.interp(ni, xi, [hyp[&quot;warmup_momentum&quot;], hyp[&quot;momentum&quot;]])        # 多尺度        if opt.multi_scale:            sz = random.randrange(int(imgsz * 0.5), int(imgsz * 1.5) + gs) // gs * gs  # 大小            sf = sz / max(imgs.shape[2:])  # 缩放因子            if sf != 1:                ns = [math.ceil(x * sf / gs) * gs for x in imgs.shape[2:]]  # 新形状（拉伸到gs倍数）                imgs = nn.functional.interpolate(imgs, size=ns, mode=&quot;bilinear&quot;, align_corners=False)        # 前向传播        with torch.cuda.amp.autocast(amp):            pred = model(imgs)  # 前向传播            loss, loss_items = compute_loss(pred, targets.to(device))  # 损失按批量大小缩放            if RANK != -1:                loss *= WORLD_SIZE  # 在DDP模式下梯度在设备间平均            if opt.quad:                loss *= 4.0        # 反向传播        scaler.scale(loss).backward()        # 优化 - https://pytorch.org/docs/master/notes/amp_examples.html        if ni - last_opt_step &gt;= accumulate:            scaler.unscale_(optimizer)  # 取消梯度缩放            torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=10.0)  # 梯度裁剪            scaler.step(optimizer)  # 优化器步骤            scaler.update()            optimizer.zero_grad()            if ema:                ema.update(model)            last_opt_step = ni        # 日志        if RANK in &#123;-1, 0&#125;:            mloss = (mloss * i + loss_items) / (i + 1)  # 更新平均损失            mem = f&quot;&#123;torch.cuda.memory_reserved() / 1E9 if torch.cuda.is_available() else 0:.3g&#125;G&quot;  # (GB)            pbar.set_description(                (&quot;%11s&quot; * 2 + &quot;%11.4g&quot; * 5)                % (f&quot;&#123;epoch&#125;/&#123;epochs - 1&#125;&quot;, mem, *mloss, targets.shape[0], imgs.shape[-1])            )            callbacks.run(&quot;on_train_batch_end&quot;, model, ni, imgs, targets, paths, list(mloss))            if callbacks.stop_training:                return        # 结束批次 ------------------------------------------------------------------------------------------------    # 学习率调度器    lr = [x[&quot;lr&quot;] for x in optimizer.param_groups]  # 用于日志记录器    scheduler.step()    if RANK in &#123;-1, 0&#125;:        # mAP        callbacks.run(&quot;on_train_epoch_end&quot;, epoch=epoch)        ema.update_attr(model, include=[&quot;yaml&quot;, &quot;nc&quot;, &quot;hyp&quot;, &quot;names&quot;, &quot;stride&quot;, &quot;class_weights&quot;])        final_epoch = (epoch + 1 == epochs) or stopper.possible_stop        if not noval or final_epoch:  # 计算mAP            results, maps, _ = validate.run(                data_dict,                batch_size=batch_size // WORLD_SIZE * 2,                imgsz=imgsz,                half=amp,                model=ema.ema,                single_cls=single_cls,                dataloader=val_loader,                save_dir=save_dir,                plots=False,                callbacks=callbacks,                compute_loss=compute_loss,            )        # 更新最佳mAP        fi = fitness(np.array(results).reshape(1, -1))  # [P, R, mAP@.5, mAP@.5-.95]的加权组合        stop = stopper(epoch=epoch, fitness=fi)  # 早停检查        if fi &gt; best_fitness:            best_fitness = fi        log_vals = list(mloss) + list(results) + lr        callbacks.run(&quot;on_fit_epoch_end&quot;, log_vals, epoch, best_fitness, fi)        # 保存模型        if (not nosave) or (final_epoch and not evolve):  # 如果保存            ckpt = &#123;                &quot;epoch&quot;: epoch,                &quot;best_fitness&quot;: best_fitness,                &quot;model&quot;: deepcopy(de_parallel(model)).half(),                &quot;ema&quot;: deepcopy(ema.ema).half(),                &quot;updates&quot;: ema.updates,                &quot;optimizer&quot;: optimizer.state_dict(),                &quot;opt&quot;: vars(opt),                &quot;git&quot;: GIT_INFO,  # &#123;remote, branch, commit&#125; 如果是git仓库                &quot;date&quot;: datetime.now().isoformat(),            &#125;            # 保存最后、最佳并删除            torch.save(ckpt, last)            if best_fitness == fi:                torch.save(ckpt, best)            if opt.save_period &gt; 0 and epoch % opt.save_period == 0:                torch.save(ckpt, w / f&quot;epoch&#123;epoch&#125;.pt&quot;)            del ckpt            callbacks.run(&quot;on_model_save&quot;, last, epoch, final_epoch, best_fitness, fi)    # 早停    if RANK != -1:  # 如果是DDP训练        broadcast_list = [stop if RANK == 0 else None]        dist.broadcast_object_list(broadcast_list, 0)  # 将&#39;stop&#39;广播到所有rank        if RANK != 0:            stop = broadcast_list[0]    if stop:        break  # 必须中断所有DDP rank    # 结束epoch ----------------------------------------------------------------------------------------------------# 结束训练 -----------------------------------------------------------------------------------------------------if RANK in &#123;-1, 0&#125;:    LOGGER.info(f&quot;\n&#123;epoch - start_epoch + 1&#125; 个epoch在 &#123;(time.time() - t0) / 3600:.3f&#125; 小时内完成。&quot;)    for f in last, best:        if f.exists():            strip_optimizer(f)  # 去除优化器            if f is best:                LOGGER.info(f&quot;\n验证 &#123;f&#125;...&quot;)                results, _, _ = validate.run(                    data_dict,                    batch_size=batch_size // WORLD_SIZE * 2,                    imgsz=imgsz,                    model=attempt_load(f, device).half(),                    iou_thres=0.65 if is_coco else 0.60,  # 最佳pycocotools在iou 0.65                    single_cls=single_cls,                    dataloader=val_loader,                    save_dir=save_dir,                    save_json=is_coco,                    verbose=True,                    plots=plots,                    callbacks=callbacks,                    compute_loss=compute_loss,                )  # 使用图表验证最佳模型                if is_coco:                    callbacks.run(&quot;on_fit_epoch_end&quot;, list(mloss) + list(results) + lr, epoch, best_fitness, fi)    callbacks.run(&quot;on_train_end&quot;, last, best, epoch, results)torch.cuda.empty_cache()return results</code></pre><p>def parse_opt(known=False):<br>    “””<br>    解析命令行参数以配置YOLO模型的训练。</p><pre><code>参数:    known (bool): 仅解析已知参数的标志，默认为False。返回:    (argparse.Namespace): 解析后的命令行参数。示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">options = parse_opt()</span><br><span class="line"><span class="built_in">print</span>(options.weights)</span><br></pre></td></tr></table></figure>注意:    * 默认权重路径为 &#39;yolov3-tiny.pt&#39;。    * 设置 `known` 为True以仅解析已知参数，适用于部分参数解析。参考:    * 模型: https://github.com/ultralytics/yolov5/tree/master/models    * 数据集: https://github.com/ultralytics/yolov5/tree/master/data    * 训练教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data&quot;&quot;&quot;parser = argparse.ArgumentParser()parser.add_argument(&quot;--weights&quot;, type=str, default=ROOT / &quot;yolov3-tiny.pt&quot;, help=&quot;初始权重路径&quot;)parser.add_argument(&quot;--cfg&quot;, type=str, default=&quot;&quot;, help=&quot;模型yaml路径&quot;)parser.add_argument(&quot;--data&quot;, type=str, default=ROOT / &quot;data/coco128.yaml&quot;, help=&quot;数据集yaml路径&quot;)parser.add_argument(&quot;--hyp&quot;, type=str, default=ROOT / &quot;data/hyps/hyp.scratch-low.yaml&quot;, help=&quot;超参数路径&quot;)parser.add_argument(&quot;--epochs&quot;, type=int, default=100, help=&quot;总训练epoch数&quot;)parser.add_argument(&quot;--batch-size&quot;, type=int, default=16, help=&quot;所有GPU的总批量大小，-1表示自动批量&quot;)parser.add_argument(&quot;--imgsz&quot;, &quot;--img&quot;, &quot;--img-size&quot;, type=int, default=640, help=&quot;训练、验证图像大小（像素）&quot;)parser.add_argument(&quot;--rect&quot;, action=&quot;store_true&quot;, help=&quot;矩形训练&quot;)parser.add_argument(&quot;--resume&quot;, nargs=&quot;?&quot;, const=True, default=False, help=&quot;恢复最近的训练&quot;)parser.add_argument(&quot;--nosave&quot;, action=&quot;store_true&quot;, help=&quot;仅保存最终检查点&quot;)parser.add_argument(&quot;--noval&quot;, action=&quot;store_true&quot;, help=&quot;仅在最终epoch验证&quot;)parser.add_argument(&quot;--noautoanchor&quot;, action=&quot;store_true&quot;, help=&quot;禁用AutoAnchor&quot;)parser.add_argument(&quot;--noplots&quot;, action=&quot;store_true&quot;, help=&quot;不保存任何图表文件&quot;)parser.add_argument(&quot;--evolve&quot;, type=int, nargs=&quot;?&quot;, const=300, help=&quot;超参数进化x代&quot;)parser.add_argument(&quot;--bucket&quot;, type=str, default=&quot;&quot;, help=&quot;gsutil存储桶&quot;)parser.add_argument(&quot;--cache&quot;, type=str, nargs=&quot;?&quot;, const=&quot;ram&quot;, help=&quot;图像缓存 ram/disk&quot;)parser.add_argument(&quot;--image-weights&quot;, action=&quot;store_true&quot;, help=&quot;使用加权图像选择进行训练&quot;)parser.add_argument(&quot;--device&quot;, default=&quot;&quot;, help=&quot;cuda设备，例如 0 或 0,1,2,3 或 cpu&quot;)parser.add_argument(&quot;--multi-scale&quot;, action=&quot;store_true&quot;, help=&quot;图像大小变化 +/- 50%%&quot;)parser.add_argument(&quot;--single-cls&quot;, action=&quot;store_true&quot;, help=&quot;将多类数据训练为单类&quot;)parser.add_argument(&quot;--optimizer&quot;, type=str, choices=[&quot;SGD&quot;, &quot;Adam&quot;, &quot;AdamW&quot;], default=&quot;SGD&quot;, help=&quot;优化器&quot;)parser.add_argument(&quot;--sync-bn&quot;, action=&quot;store_true&quot;, help=&quot;使用SyncBatchNorm，仅在DDP模式下可用&quot;)parser.add_argument(&quot;--workers&quot;, type=int, default=8, help=&quot;最大数据加载器工作进程数（DDP模式下每rank）&quot;)parser.add_argument(&quot;--project&quot;, default=ROOT / &quot;runs/train&quot;, help=&quot;保存到project/name&quot;)parser.add_argument(&quot;--name&quot;, default=&quot;exp&quot;, help=&quot;保存到project/name&quot;)parser.add_argument(&quot;--exist-ok&quot;, action=&quot;store_true&quot;, help=&quot;允许现有project/name，不递增&quot;)parser.add_argument(&quot;--quad&quot;, action=&quot;store_true&quot;, help=&quot;四倍数据加载器&quot;)parser.add_argument(&quot;--cos-lr&quot;, action=&quot;store_true&quot;, help=&quot;余弦学习率调度器&quot;)parser.add_argument(&quot;--label-smoothing&quot;, type=float, default=0.0, help=&quot;标签平滑epsilon&quot;)parser.add_argument(&quot;--patience&quot;, type=int, default=100, help=&quot;早停耐心（无改进的epoch数）&quot;)parser.add_argument(&quot;--freeze&quot;, nargs=&quot;+&quot;, type=int, default=[0], help=&quot;冻结层：backbone=10, first3=0 1 2&quot;)parser.add_argument(&quot;--save-period&quot;, type=int, default=-1, help=&quot;每x个epoch保存检查点（如果小于1则禁用）&quot;)parser.add_argument(&quot;--seed&quot;, type=int, default=0, help=&quot;全局训练种子&quot;)parser.add_argument(&quot;--local_rank&quot;, type=int, default=-1, help=&quot;自动DDP多GPU参数，不要修改&quot;)# 日志记录器参数parser.add_argument(&quot;--entity&quot;, default=None, help=&quot;实体&quot;)parser.add_argument(&quot;--upload_dataset&quot;, nargs=&quot;?&quot;, const=True, default=False, help=&#39;上传数据，&quot;val&quot;选项&#39;)parser.add_argument(&quot;--bbox_interval&quot;, type=int, default=-1, help=&quot;设置边界框图像记录间隔&quot;)parser.add_argument(&quot;--artifact_alias&quot;, type=str, default=&quot;latest&quot;, help=&quot;数据集工件的版本&quot;)return parser.parse_known_args()[0] if known else parser.parse_args()</code></pre><p>def main(opt, callbacks=Callbacks()):<br>    “””<br>    主训练/进化脚本，处理模型检查、DDP设置、训练和超参数进化。</p><pre><code>参数:    opt (argparse.Namespace): 解析后的命令行选项。    callbacks (Callbacks, 可选): 处理训练事件的回调对象。默认为Callbacks()。返回:    None异常:    AssertionError: 如果某些约束被违反（例如，当特定选项与DDP训练不兼容时）。注意:   - 有关使用DDP进行多GPU训练的教程：https://docs.ultralytics.com/yolov5/tutorials/multi_gpu_training示例:    单GPU训练:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python train.py --data coco128.yaml --weights yolov5s.pt --img <span class="number">640</span>  <span class="comment"># 从预训练模型开始训练（推荐）</span></span><br><span class="line">$ python train.py --data coco128.yaml --weights <span class="string">&#x27;&#x27;</span> --cfg yolov5s.yaml --img <span class="number">640</span>  <span class="comment"># 从零开始训练</span></span><br></pre></td></tr></table></figure>    多GPU DDP训练:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m torch.distributed.run --nproc_per_node <span class="number">4</span> --master_port <span class="number">1</span> train.py --data coco128.yaml \</span><br><span class="line">--weights yolov5s.pt --img <span class="number">640</span> --device <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>    模型: https://github.com/ultralytics/yolov5/tree/master/models    数据集: https://github.com/ultralytics/yolov5/tree/master/data    教程: https://docs.ultralytics.com/yolov5/tutorials/train_custom_data&quot;&quot;&quot;if RANK in &#123;-1, 0&#125;:    print_args(vars(opt))    check_git_status()    check_requirements(ROOT / &quot;requirements.txt&quot;)# 恢复（从指定或最近的last.pt）if opt.resume and not check_comet_resume(opt) and not opt.evolve:    last = Path(check_file(opt.resume) if isinstance(opt.resume, str) else get_latest_run())    opt_yaml = last.parent.parent / &quot;opt.yaml&quot;  # 训练选项yaml    opt_data = opt.data  # 原始数据集    if opt_yaml.is_file():        with open(opt_yaml, errors=&quot;ignore&quot;) as f:            d = yaml.safe_load(f)    else:        d = torch.load(last, map_location=&quot;cpu&quot;)[&quot;opt&quot;]    opt = argparse.Namespace(**d)  # 替换    opt.cfg, opt.weights, opt.resume = &quot;&quot;, str(last), True  # 恢复    if is_url(opt_data):        opt.data = check_file(opt_data)  # 避免HUB恢复认证超时else:    opt.data, opt.cfg, opt.hyp, opt.weights, opt.project = (        check_file(opt.data),        check_yaml(opt.cfg),        check_yaml(opt.hyp),        str(opt.weights),        str(opt.project),    )  # 检查    assert len(opt.cfg) or len(opt.weights), &quot;必须指定 --cfg 或 --weights&quot;    if opt.evolve:        if opt.project == str(ROOT / &quot;runs/train&quot;):  # 如果默认项目名称，重命名为runs/evolve            opt.project = str(ROOT / &quot;runs/evolve&quot;)        opt.exist_ok, opt.resume = opt.resume, False  # 将resume传递给exist_ok并禁用resume    if opt.name == &quot;cfg&quot;:        opt.name = Path(opt.cfg).stem  # 使用model.yaml作为名称    opt.save_dir = str(increment_path(Path(opt.project) / opt.name, exist_ok=opt.exist_ok))# DDP模式device = select_device(opt.device, batch_size=opt.batch_size)if LOCAL_RANK != -1:    msg = &quot;与YOLOv3多GPU DDP训练不兼容&quot;    assert not opt.image_weights, f&quot;--image-weights &#123;msg&#125;&quot;    assert not opt.evolve, f&quot;--evolve &#123;msg&#125;&quot;    assert opt.batch_size != -1, f&quot;自动批量 --batch-size -1 &#123;msg&#125;, 请传递有效的 --batch-size&quot;    assert opt.batch_size % WORLD_SIZE == 0, f&quot;--batch-size &#123;opt.batch_size&#125; 必须是 WORLD_SIZE 的倍数&quot;    assert torch.cuda.device_count() &gt; LOCAL_RANK, &quot;DDP命令的CUDA设备不足&quot;    torch.cuda.set_device(LOCAL_RANK)    device = torch.device(&quot;cuda&quot;, LOCAL_RANK)    dist.init_process_group(backend=&quot;nccl&quot; if dist.is_nccl_available() else &quot;gloo&quot;)# 训练if not opt.evolve:    train(opt.hyp, opt, device, callbacks)# 超参数进化（可选）else:    # 超参数进化元数据（突变比例0-1，下限，上限）    meta = &#123;        &quot;lr0&quot;: (1, 1e-5, 1e-1),  # 初始学习率（SGD=1E-2, Adam=1E-3）        &quot;lrf&quot;: (1, 0.01, 1.0),  # 最终OneCycleLR学习率（lr0 * lrf）        &quot;momentum&quot;: (0.3, 0.6, 0.98),  # SGD动量/Adam beta1        &quot;weight_decay&quot;: (1, 0.0, 0.001),  # 优化器权重衰减        &quot;warmup_epochs&quot;: (1, 0.0, 5.0),  # 预热epoch数（可以是小数）        &quot;warmup_momentum&quot;: (1, 0.0, 0.95),  # 预热初始动量        &quot;warmup_bias_lr&quot;: (1, 0.0, 0.2),  # 预热初始偏差学习率        &quot;box&quot;: (1, 0.02, 0.2),  # 框损失增益        &quot;cls&quot;: (1, 0.2, 4.0),  # 类别损失增益        &quot;cls_pw&quot;: (1, 0.5, 2.0),  # 类别BCELoss正样本权重        &quot;obj&quot;: (1, 0.2, 4.0),  # 目标损失增益（按像素缩放）        &quot;obj_pw&quot;: (1, 0.5, 2.0),  # 目标BCELoss正样本权重        &quot;iou_t&quot;: (0, 0.1, 0.7),  # IoU训练阈值        &quot;anchor_t&quot;: (1, 2.0, 8.0),  # 锚点倍数阈值        &quot;anchors&quot;: (2, 2.0, 10.0),  # 每个输出网格的锚点数量（0表示忽略）        &quot;fl_gamma&quot;: (0, 0.0, 2.0),  # 焦点损失gamma（efficientDet默认gamma=1.5）        &quot;hsv_h&quot;: (1, 0.0, 0.1),  # 图像HSV-Hue增强（比例）        &quot;hsv_s&quot;: (1, 0.0, 0.9),  # 图像HSV-Saturation增强（比例）        &quot;hsv_v&quot;: (1, 0.0, 0.9),  # 图像HSV-Value增强（比例）        &quot;degrees&quot;: (1, 0.0, 45.0),  # 图像旋转（+/- 度）        &quot;translate&quot;: (1, 0.0, 0.9),  # 图像平移（+/- 比例）        &quot;scale&quot;: (1, 0.0, 0.9),  # 图像缩放（+/- 增益）        &quot;shear&quot;: (1, 0.0, 10.0),  # 图像剪切（+/- 度）        &quot;perspective&quot;: (0, 0.0, 0.001),  # 图像透视（+/- 比例），范围0-0.001        &quot;flipud&quot;: (1, 0.0, 1.0),  # 图像上下翻转（概率）        &quot;fliplr&quot;: (0, 0.0, 1.0),  # 图像左右翻转（概率）        &quot;mosaic&quot;: (1, 0.0, 1.0),  # 图像马赛克（概率）        &quot;mixup&quot;: (1, 0.0, 1.0),  # 图像混合（概率）        &quot;copy_paste&quot;: (1, 0.0, 1.0),    &#125;  # 分段复制粘贴（概率）    with open(opt.hyp, errors=&quot;ignore&quot;) as f:        hyp = yaml.safe_load(f)  # 加载超参数字典        if &quot;anchors&quot; not in hyp:  # 如果hyp.yaml中注释了anchors            hyp[&quot;anchors&quot;] = 3    if opt.noautoanchor:        del hyp[&quot;anchors&quot;], meta[&quot;anchors&quot;]    opt.noval, opt.nosave, save_dir = True, True, Path(opt.save_dir)  # 仅在最终epoch验证/保存    # ei = [isinstance(x, (int, float)) for x in hyp.values()]  # 可进化的索引    evolve_yaml, evolve_csv = save_dir / &quot;hyp_evolve.yaml&quot;, save_dir / &quot;evolve.csv&quot;    if opt.bucket:        # 如果存在则下载evolve.csv        subprocess.run(            [                &quot;gsutil&quot;,                &quot;cp&quot;,                f&quot;gs://&#123;opt.bucket&#125;/evolve.csv&quot;,                str(evolve_csv),            ]        )    for _ in range(opt.evolve):  # 进化代数        if evolve_csv.exists():  # 如果evolve.csv存在：选择最佳超参数并突变            # 选择父代            parent = &quot;single&quot;  # 父代选择方法：&#39;single&#39; 或 &#39;weighted&#39;            x = np.loadtxt(evolve_csv, ndmin=2, delimiter=&quot;,&quot;, skiprows=1)            n = min(5, len(x))  # 考虑的前n个结果            x = x[np.argsort(-fitness(x))][:n]  # 前n个突变            w = fitness(x) - fitness(x).min() + 1e-6  # 权重（总和 &gt; 0）            if parent == &quot;single&quot; or len(x) == 1:                # x = x[random.randint(0, n - 1)]  # 随机选择                x = x[random.choices(range(n), weights=w)[0]]  # 加权选择            elif parent == &quot;weighted&quot;:                x = (x * w.reshape(n, 1)).sum(0) / w.sum()  # 加权组合            # 突变            mp, s = 0.8, 0.2  # 突变概率，sigma            npr = np.random            npr.seed(int(time.time()))            g = np.array([meta[k][0] for k in hyp.keys()])  # 增益 0-1            ng = len(meta)            v = np.ones(ng)            while all(v == 1):  # 突变直到发生变化（防止重复）                v = (g * (npr.random(ng) &lt; mp) * npr.randn(ng) * npr.random() * s + 1).clip(0.3, 3.0)            for i, k in enumerate(hyp.keys()):  # plt.hist(v.ravel(), 300)                hyp[k] = float(x[i + 7] * v[i])  # 突变        # 限制在范围内        for k, v in meta.items():            hyp[k] = max(hyp[k], v[1])  # 下限            hyp[k] = min(hyp[k], v[2])  # 上限            hyp[k] = round(hyp[k], 5)  # 有效数字        # 训练突变        results = train(hyp.copy(), opt, device, callbacks)        callbacks = Callbacks()        # 写入突变结果        keys = (            &quot;metrics/precision&quot;,            &quot;metrics/recall&quot;,            &quot;metrics/mAP_0.5&quot;,            &quot;metrics/mAP_0.5:0.95&quot;,            &quot;val/box_loss&quot;,            &quot;val/obj_loss&quot;,            &quot;val/cls_loss&quot;,        )        print_mutation(keys, results, hyp.copy(), save_dir, opt.bucket)    # 绘制结果    plot_evolve(evolve_csv)    LOGGER.info(        f&#39;超参数进化完成 &#123;opt.evolve&#125; 代\n&#39;        f&quot;结果保存到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;\n&quot;        f&#39;使用示例: $ python train.py --hyp &#123;evolve_yaml&#125;&#39;    )</code></pre><p>def run(**kwargs):<br>    “””<br>    使用指定配置运行YOLOv3模型的训练过程。</p><pre><code>参数:    data (str): 数据集YAML文件的路径。    weights (str): 预训练权重文件的路径或 &#39;&#39; 表示从零开始训练。    cfg (str): 模型配置文件的路径。    hyp (str): 超参数YAML文件的路径。    epochs (int): 总训练epoch数。    batch_size (int): 所有GPU的总批量大小。    imgsz (int): 训练和验证的图像大小（像素）。    rect (bool): 使用矩形训练以更好地保留宽高比。    resume (bool | str): 如果为True，则恢复最近的训练，如果为字符串，则从特定检查点恢复训练。    nosave (bool): 仅保存最终检查点，不保存中间检查点。    noval (bool): 仅在最终epoch验证模型性能。    noautoanchor (bool): 禁用自动锚点生成。    noplots (bool): 不保存任何图表。    evolve (int): 超参数进化的代数。    bucket (str): 用于保存运行工件的Google Cloud Storage存储桶名称。    cache (str | None): 缓存图像以加快训练速度（&#39;ram&#39; 或 &#39;disk&#39;）。    image_weights (bool): 使用加权图像选择进行训练。    device (str): 用于训练的设备，例如 &#39;0&#39; 表示第一个GPU或 &#39;cpu&#39; 表示CPU。    multi_scale (bool): 使用多尺度训练。    single_cls (bool): 将多类数据集训练为单类。    optimizer (str): 使用的优化器（&#39;SGD&#39;, &#39;Adam&#39;, 或 &#39;AdamW&#39;）。    sync_bn (bool): 使用同步批归一化（仅在DDP模式下可用）。    workers (int): 最大数据加载器工作进程数（DDP模式下每rank）。    project (str): 输出目录的位置。    name (str): 运行的唯一名称。    exist_ok (bool): 允许现有输出目录。    quad (bool): 使用四倍数据加载器。    cos_lr (bool): 使用余弦学习率调度器。    label_smoothing (float): 标签平滑epsilon。    patience (int): 早停耐心（无改进的epoch数）。    freeze (list[int]): 冻结的层列表，例如 [0] 表示仅冻结第一层。    save_period (int): 每 &#39;save_period&#39; 个epoch保存检查点（如果小于1则禁用）。    seed (int): 全局训练种子以确保可重复性。    local_rank (int): 用于自动DDP多GPU参数解析，不要修改。返回:    None示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> run</span><br><span class="line">run(data=<span class="string">&#x27;coco128.yaml&#x27;</span>, weights=<span class="string">&#x27;yolov5m.pt&#x27;</span>, imgsz=<span class="number">320</span>, epochs=<span class="number">100</span>, batch_size=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>注意:    - 确保数据集YAML文件和初始权重可访问。    - 参考 [Ultralytics YOLOv5 仓库](https://github.com/ultralytics/yolov5) 获取模型和数据配置。    - 使用 [训练教程](https://docs.ultralytics.com/yolov5/tutorials/train_custom_data) 进行自定义数据集训练。&quot;&quot;&quot;opt = parse_opt(True)for k, v in kwargs.items():    setattr(opt, k, v)main(opt)return opt</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    opt = parse_opt()<br>    main(opt)<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta"># Ultralytics YOLOv3 🚀, AGPL-3.0 license</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">在图像、视频、目录、通配符、YouTube、网络摄像头、流媒体等上运行 YOLOv3 检测推理。</span><br><span class="line"></span><br><span class="line">用法 - 来源:</span><br><span class="line">    $ python detect.py --weights yolov5s.pt --source <span class="number">0</span>                               <span class="meta"># 网络摄像头</span></span><br><span class="line">                                                     img.jpg                         <span class="meta"># 图像</span></span><br><span class="line">                                                     vid.mp4                         <span class="meta"># 视频</span></span><br><span class="line">                                                     screen                          <span class="meta"># 截图</span></span><br><span class="line">                                                     path/                           <span class="meta"># 目录</span></span><br><span class="line">                                                     list.txt                        <span class="meta"># 图像列表</span></span><br><span class="line">                                                     list.streams                    <span class="meta"># 流媒体列表</span></span><br><span class="line">                                                     &#x27;path/*.jpg&#x27;                    <span class="meta"># 通配符</span></span><br><span class="line">                                                     &#x27;https://youtu.be/LNwODJXcvt4&#x27;  <span class="meta"># YouTube</span></span><br><span class="line">                                                     &#x27;rtsp://example.com/media.mp4&#x27;  <span class="meta"># RTSP, RTMP, HTTP 流</span></span><br><span class="line"></span><br><span class="line">用法 - 格式:</span><br><span class="line">    $ python detect.py --weights yolov5s.pt                 <span class="meta"># PyTorch</span></span><br><span class="line">                                 yolov5s.torchscript        <span class="meta"># TorchScript</span></span><br><span class="line">                                 yolov5s.onnx               <span class="meta"># ONNX Runtime 或 OpenCV DNN with --dnn</span></span><br><span class="line">                                 yolov5s_openvino_model     <span class="meta"># OpenVINO</span></span><br><span class="line">                                 yolov5s.engine             <span class="meta"># TensorRT</span></span><br><span class="line">                                 yolov5s.mlmodel            <span class="meta"># CoreML (macOS-only)</span></span><br><span class="line">                                 yolov5s_saved_model        <span class="meta"># TensorFlow SavedModel</span></span><br><span class="line">                                 yolov5s.pb                 <span class="meta"># TensorFlow GraphDef</span></span><br><span class="line">                                 yolov5s.tflite             <span class="meta"># TensorFlow Lite</span></span><br><span class="line">                                 yolov5s_edgetpu.tflite     <span class="meta"># TensorFlow Edge TPU</span></span><br><span class="line">                                 yolov5s_paddle_model       <span class="meta"># PaddlePaddle</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">import argparse</span><br><span class="line">import os</span><br><span class="line">import platform</span><br><span class="line">import sys</span><br><span class="line">from pathlib import Path</span><br><span class="line"></span><br><span class="line">import torch</span><br><span class="line"></span><br><span class="line">FILE = Path(__file__).resolve()</span><br><span class="line">ROOT = FILE.parents[<span class="number">0</span>]  <span class="meta"># YOLOv3 根目录</span></span><br><span class="line">if str(ROOT) not in sys.path:</span><br><span class="line">    sys.path.append(str(ROOT))  <span class="meta"># 将 ROOT 添加到 PATH</span></span><br><span class="line">ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  <span class="meta"># 相对路径</span></span><br><span class="line"></span><br><span class="line">from ultralytics.utils.plotting import Annotator, colors, save_one_box</span><br><span class="line"></span><br><span class="line">from models.common import DetectMultiBackend</span><br><span class="line">from utils.dataloaders import IMG_FORMATS, VID_FORMATS, LoadImages, LoadScreenshots, LoadStreams</span><br><span class="line">from utils.general import (</span><br><span class="line">    LOGGER,</span><br><span class="line">    Profile,</span><br><span class="line">    check_file,</span><br><span class="line">    check_img_size,</span><br><span class="line">    check_imshow,</span><br><span class="line">    check_requirements,</span><br><span class="line">    colorstr,</span><br><span class="line">    cv2,</span><br><span class="line">    increment_path,</span><br><span class="line">    non_max_suppression,</span><br><span class="line">    print_args,</span><br><span class="line">    scale_boxes,</span><br><span class="line">    strip_optimizer,</span><br><span class="line">    xyxy2xywh,</span><br><span class="line">)</span><br><span class="line">from utils.torch_utils import select_device, smart_inference_mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@smart_inference_mode()</span><br><span class="line">def run(</span><br><span class="line">    weights=ROOT / <span class="string">&quot;yolov5s.pt&quot;</span>,  <span class="meta"># 模型路径或 Triton URL</span></span><br><span class="line">    source=ROOT / <span class="string">&quot;data/images&quot;</span>,  <span class="meta"># 文件/目录/URL/通配符/截图/0(网络摄像头)</span></span><br><span class="line">    data=ROOT / <span class="string">&quot;data/coco128.yaml&quot;</span>,  <span class="meta"># 数据集.yaml 路径</span></span><br><span class="line">    imgsz=(<span class="number">640</span>, <span class="number">640</span>),  <span class="meta"># 推理尺寸 (高度, 宽度)</span></span><br><span class="line">    conf_thres=<span class="number">0.25</span>,  <span class="meta"># 置信度阈值</span></span><br><span class="line">    iou_thres=<span class="number">0.45</span>,  <span class="meta"># NMS IOU 阈值</span></span><br><span class="line">    max_det=<span class="number">1000</span>,  <span class="meta"># 每张图像的最大检测数</span></span><br><span class="line">    device=<span class="string">&quot;&quot;</span>,  <span class="meta"># CUDA 设备，例如 0 或 0,1,2,3 或 cpu</span></span><br><span class="line">    view_img=False,  <span class="meta"># 显示结果</span></span><br><span class="line">    save_txt=False,  <span class="meta"># 将结果保存到 *.txt</span></span><br><span class="line">    save_conf=False,  <span class="meta"># 在 --save-txt 标签中保存置信度</span></span><br><span class="line">    save_crop=False,  <span class="meta"># 保存裁剪的预测框</span></span><br><span class="line">    nosave=False,  <span class="meta"># 不保存图像/视频</span></span><br><span class="line">    classes=None,  <span class="meta"># 按类别过滤：--class 0 或 --class 0 2 3</span></span><br><span class="line">    agnostic_nms=False,  <span class="meta"># 类别无关的 NMS</span></span><br><span class="line">    augment=False,  <span class="meta"># 增强推理</span></span><br><span class="line">    visualize=False,  <span class="meta"># 可视化特征</span></span><br><span class="line">    update=False,  <span class="meta"># 更新所有模型</span></span><br><span class="line">    project=ROOT / <span class="string">&quot;runs/detect&quot;</span>,  <span class="meta"># 将结果保存到 project/name</span></span><br><span class="line">    name=<span class="string">&quot;exp&quot;</span>,  <span class="meta"># 将结果保存到 project/name</span></span><br><span class="line">    exist_ok=False,  <span class="meta"># 允许现有 project/name，不递增</span></span><br><span class="line">    line_thickness=<span class="number">3</span>,  <span class="meta"># 边界框厚度 (像素)</span></span><br><span class="line">    hide_labels=False,  <span class="meta"># 隐藏标签</span></span><br><span class="line">    hide_conf=False,  <span class="meta"># 隐藏置信度</span></span><br><span class="line">    half=False,  <span class="meta"># 使用 FP16 半精度推理</span></span><br><span class="line">    dnn=False,  <span class="meta"># 使用 OpenCV DNN 进行 ONNX 推理</span></span><br><span class="line">    vid_stride=<span class="number">1</span>,  <span class="meta"># 视频帧率步长</span></span><br><span class="line">):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    在各种输入源（如图像、视频、流媒体、YouTube URL）上运行 YOLOv3 检测推理。</span><br><span class="line"></span><br><span class="line">    参数:</span><br><span class="line">        weights (str <span class="string">| Path): 模型权重文件路径或 Triton URL (默认: &#x27;yolov5s.pt&#x27;)。</span></span><br><span class="line">        source (str <span class="string">| Path): 输入数据源，如文件、目录、URL、通配符模式或设备标识符 (默认: &#x27;data/images&#x27;)。</span></span><br><span class="line">        data (str <span class="string">| Path): 数据集 YAML 文件路径 (默认: &#x27;data/coco128.yaml&#x27;)。</span></span><br><span class="line">        imgsz (tuple[int, int]): 推理尺寸，格式为 (高度, 宽度) (默认: (<span class="number">640</span>, <span class="number">640</span>))。</span><br><span class="line">        conf_thres (float): 检测的置信度阈值 (默认: <span class="number">0.25</span>)。</span><br><span class="line">        iou_thres (float): 非最大抑制 (NMS) 的交并比 (IOU) 阈值 (默认: <span class="number">0.45</span>)。</span><br><span class="line">        max_det (int): 每张图像的最大检测数 (默认: <span class="number">1000</span>)。</span><br><span class="line">        device (str): CUDA 设备标识符，例如 &#x27;0&#x27;, &#x27;0,1,2,3&#x27;, 或 &#x27;cpu&#x27; (默认: &#x27;&#x27;)。</span><br><span class="line">        view_img (bool): 是否在推理过程中显示结果 (默认: False)。</span><br><span class="line">        save_txt (bool): 是否将检测结果保存到文本文件 (默认: False)。</span><br><span class="line">        save_conf (bool): 是否在文本标签中保存检测置信度 (默认: False)。</span><br><span class="line">        save_crop (bool): 是否保存裁剪的检测框 (默认: False)。</span><br><span class="line">        nosave (bool): 是否防止保存带有检测结果的图像或视频 (默认: False)。</span><br><span class="line">        classes (list[int] <span class="string">| None): 按类别索引过滤，例如 [0, 2, 3] (默认: None)。</span></span><br><span class="line">        agnostic_nms (bool): 是否执行类别无关的 NMS (默认: False)。</span><br><span class="line">        augment (bool): 是否应用增强推理 (默认: False)。</span><br><span class="line">        visualize (bool): 是否可视化特征图 (默认: False)。</span><br><span class="line">        update (bool): 是否更新所有模型 (默认: False)。</span><br><span class="line">        project (str <span class="string">| Path): 结果保存的项目目录路径 (默认: &#x27;runs/detect&#x27;)。</span></span><br><span class="line">        name (str): 项目目录中的特定运行名称 (默认: &#x27;exp&#x27;)。</span><br><span class="line">        exist_ok (bool): 是否允许现有 project/name 目录而不递增运行索引 (默认: False)。</span><br><span class="line">        line_thickness (int): 边界框线条的厚度 (像素) (默认: <span class="number">3</span>)。</span><br><span class="line">        hide_labels (bool): 是否在结果中隐藏标签 (默认: False)。</span><br><span class="line">        hide_conf (bool): 是否在结果中隐藏置信度 (默认: False)。</span><br><span class="line">        half (bool): 是否使用半精度 (FP16) 进行推理 (默认: False)。</span><br><span class="line">        dnn (bool): 是否使用 OpenCV DNN 进行 ONNX 推理 (默认: False)。</span><br><span class="line">        vid_stride (int): 视频帧率的步长 (默认: <span class="number">1</span>)。</span><br><span class="line"></span><br><span class="line">    返回:</span><br><span class="line">        None</span><br><span class="line"></span><br><span class="line">    注意:</span><br><span class="line">        该函数支持多种输入源，如图像文件、视频文件、目录、URL 模式、网络摄像头流和 YouTube 链接。它还支持多种模型格式，包括 PyTorch、ONNX、OpenVINO、TensorRT、CoreML、TensorFlow、PaddlePaddle 等。结果可以实时显示或保存到指定目录。使用命令行参数修改函数的行为。</span><br><span class="line"></span><br><span class="line">    示例:</span><br><span class="line">        ```python</span><br><span class="line">        <span class="meta"># 在图像上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;data/images/bus.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># 在视频上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;data/videos/video.mp4&#x27;, view_img=True)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># 在网络摄像头上运行 YOLOv3 推理</span></span><br><span class="line">        run(weights=&#x27;yolov5s.pt&#x27;, source=&#x27;0&#x27;, view_img=True)</span><br></pre></td></tr></table></figure><br>    “””<br>    source = str(source)<br>    save_img = not nosave and not source.endswith(“.txt”)  # 保存推理图像<br>    is_file = Path(source).suffix[1:] in (IMG_FORMATS + VID_FORMATS)<br>    is_url = source.lower().startswith((“rtsp://“, “rtmp://“, “http://“, “https://“))<br>    webcam = source.isnumeric() or source.endswith(“.streams”) or (is_url and not is_file)<br>    screenshot = source.lower().startswith(“screen”)<br>    if is_url and is_file:<br>        source = check_file(source)  # 下载</p><pre><code># 目录save_dir = increment_path(Path(project) / name, exist_ok=exist_ok)  # 递增运行(save_dir / &quot;labels&quot; if save_txt else save_dir).mkdir(parents=True, exist_ok=True)  # 创建目录# 加载模型device = select_device(device)model = DetectMultiBackend(weights, device=device, dnn=dnn, data=data, fp16=half)stride, names, pt = model.stride, model.names, model.ptimgsz = check_img_size(imgsz, s=stride)  # 检查图像尺寸# 数据加载器bs = 1  # 批量大小if webcam:    view_img = check_imshow(warn=True)    dataset = LoadStreams(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)    bs = len(dataset)elif screenshot:    dataset = LoadScreenshots(source, img_size=imgsz, stride=stride, auto=pt)else:    dataset = LoadImages(source, img_size=imgsz, stride=stride, auto=pt, vid_stride=vid_stride)vid_path, vid_writer = [None] * bs, [None] * bs# 运行推理model.warmup(imgsz=(1 if pt or model.triton else bs, 3, *imgsz))  # 预热seen, windows, dt = 0, [], (Profile(), Profile(), Profile())for path, im, im0s, vid_cap, s in dataset:    with dt[0]:        im = torch.from_numpy(im).to(model.device)        im = im.half() if model.fp16 else im.float()  # uint8 转换为 fp16/32        im /= 255  # 0 - 255 转换为 0.0 - 1.0        if len(im.shape) == 3:            im = im[None]  # 扩展为批量维度    # 推理    with dt[1]:        visualize = increment_path(save_dir / Path(path).stem, mkdir=True) if visualize else False        pred = model(im, augment=augment, visualize=visualize)    # NMS    with dt[2]:        pred = non_max_suppression(pred, conf_thres, iou_thres, classes, agnostic_nms, max_det=max_det)    # 第二阶段分类器 (可选)    # pred = utils.general.apply_classifier(pred, classifier_model, im, im0s)    # 处理预测结果    for i, det in enumerate(pred):  # 每张图像        seen += 1        if webcam:  # 批量大小 &gt;= 1            p, im0, frame = path[i], im0s[i].copy(), dataset.count            s += f&quot;&#123;i&#125;: &quot;        else:            p, im0, frame = path, im0s.copy(), getattr(dataset, &quot;frame&quot;, 0)        p = Path(p)  # 转换为 Path        save_path = str(save_dir / p.name)  # im.jpg        txt_path = str(save_dir / &quot;labels&quot; / p.stem) + (&quot;&quot; if dataset.mode == &quot;image&quot; else f&quot;_&#123;frame&#125;&quot;)  # im.txt        s += &quot;&#123;:g&#125;x&#123;:g&#125; &quot;.format(*im.shape[2:])  # 打印字符串        gn = torch.tensor(im0.shape)[[1, 0, 1, 0]]  # 归一化增益 whwh        imc = im0.copy() if save_crop else im0  # 用于保存裁剪        annotator = Annotator(im0, line_width=line_thickness, example=str(names))        if len(det):            # 将框从 img_size 缩放到 im0 尺寸            det[:, :4] = scale_boxes(im.shape[2:], det[:, :4], im0.shape).round()            # 打印结果            for c in det[:, 5].unique():                n = (det[:, 5] == c).sum()  # 每个类别的检测数                s += f&quot;&#123;n&#125; &#123;names[int(c)]&#125;&#123;&#39;s&#39; * (n &gt; 1)&#125;, &quot;  # 添加到字符串            # 写入结果            for *xyxy, conf, cls in reversed(det):                if save_txt:  # 写入文件                    xywh = (xyxy2xywh(torch.tensor(xyxy).view(1, 4)) / gn).view(-1).tolist()  # 归一化 xywh                    line = (cls, *xywh, conf) if save_conf else (cls, *xywh)  # 标签格式                    with open(f&quot;&#123;txt_path&#125;.txt&quot;, &quot;a&quot;) as f:                        f.write((&quot;%g &quot; * len(line)).rstrip() % line + &quot;\n&quot;)                if save_img or save_crop or view_img:  # 添加边界框到图像                    c = int(cls)  # 整数类别                    label = None if hide_labels else (names[c] if hide_conf else f&quot;&#123;names[c]&#125; &#123;conf:.2f&#125;&quot;)                    annotator.box_label(xyxy, label, color=colors(c, True))                if save_crop:                    save_one_box(xyxy, imc, file=save_dir / &quot;crops&quot; / names[c] / f&quot;&#123;p.stem&#125;.jpg&quot;, BGR=True)        # 流式结果        im0 = annotator.result()        if view_img:            if platform.system() == &quot;Linux&quot; and p not in windows:                windows.append(p)                cv2.namedWindow(str(p), cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)  # 允许窗口调整大小 (Linux)                cv2.resizeWindow(str(p), im0.shape[1], im0.shape[0])            cv2.imshow(str(p), im0)            cv2.waitKey(1)  # 1 毫秒        # 保存结果 (带检测的图像)        if save_img:            if dataset.mode == &quot;image&quot;:                cv2.imwrite(save_path, im0)            else:  # &#39;video&#39; 或 &#39;stream&#39;                if vid_path[i] != save_path:  # 新视频                    vid_path[i] = save_path                    if isinstance(vid_writer[i], cv2.VideoWriter):                        vid_writer[i].release()  # 释放之前的视频写入器                    if vid_cap:  # 视频                        fps = vid_cap.get(cv2.CAP_PROP_FPS)                        w = int(vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))                        h = int(vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))                    else:  # 流                        fps, w, h = 30, im0.shape[1], im0.shape[0]                    save_path = str(Path(save_path).with_suffix(&quot;.mp4&quot;))  # 强制结果视频为 *.mp4 后缀                    vid_writer[i] = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*&quot;mp4v&quot;), fps, (w, h))                vid_writer[i].write(im0)    # 打印时间 (仅推理)    LOGGER.info(f&quot;&#123;s&#125;&#123;&#39;&#39; if len(det) else &#39;(no detections), &#39;&#125;&#123;dt[1].dt * 1E3:.1f&#125;ms&quot;)# 打印结果t = tuple(x.t / seen * 1e3 for x in dt)  # 每张图像的速度LOGGER.info(f&quot;Speed: %.1fms 预处理, %.1fms 推理, %.1fms NMS 每张图像 at shape &#123;(1, 3, *imgsz)&#125;&quot; % t)if save_txt or save_img:    s = f&quot;\n&#123;len(list(save_dir.glob(&#39;labels/*.txt&#39;)))&#125; 标签保存到 &#123;save_dir / &#39;labels&#39;&#125;&quot; if save_txt else &quot;&quot;    LOGGER.info(f&quot;结果保存到 &#123;colorstr(&#39;bold&#39;, save_dir)&#125;&#123;s&#125;&quot;)if update:    strip_optimizer(weights[0])  # 更新模型 (修复 SourceChangeWarning)</code></pre><p>def parse_opt():<br>    “””<br>    解析并返回用于运行 YOLOv3 模型检测的命令行选项。</p><pre><code>参数:    --weights (list[str]): 模型路径或 Triton URL。默认: ROOT / &quot;yolov3-tiny.pt&quot;。    --source (str): 输入数据源，如文件/目录/URL/通配符/截图/0(网络摄像头)。默认: ROOT / &quot;data/images&quot;。    --data (str): 可选的数据集.yaml 路径。默认: ROOT / &quot;data/coco128.yaml&quot;。    --imgsz (list[int]): 推理尺寸，格式为高度, 宽度。接受多个值。默认: [640]。    --conf-thres (float): 预测的置信度阈值。默认: 0.25。    --iou-thres (float): 非最大抑制 (NMS) 的交并比 (IoU) 阈值。默认: 0.45。    --max-det (int): 每张图像的最大检测数。默认: 1000。    --device (str): CUDA 设备标识符，例如 &quot;0&quot; 或 &quot;0,1,2,3&quot; 或 &quot;cpu&quot;。默认: &quot;&quot; (自动选择)。    --view-img (bool): 显示结果。默认: False。    --save-txt (bool): 将结果保存到 *.txt 文件。默认: False。    --save-conf (bool): 在文本标签中保存置信度分数。默认: False。    --save-crop (bool): 保存裁剪的预测框。默认: False。    --nosave (bool): 不保存带有检测结果的图像/视频。默认: False。    --classes (list[int] | None): 按类别过滤结果，例如 [0, 2, 3]。默认: None。    --agnostic-nms (bool): 执行类别无关的 NMS。默认: False。    --augment (bool): 应用增强推理。默认: False。    --visualize (bool): 可视化特征图。默认: False。    --update (bool): 更新所有模型。默认: False。    --project (str): 保存结果的目录；结果保存到 &quot;project/name&quot;。默认: ROOT / &quot;runs/detect&quot;。    --name (str): 特定运行的名称；结果保存到 &quot;project/name&quot;。默认: &quot;exp&quot;。    --exist-ok (bool): 允许结果保存到现有目录而不递增。默认: False。    --line-thickness (int): 边界框线条的厚度 (像素)。默认: 3。    --hide-labels (bool): 隐藏检测结果中的标签。默认: False。    --hide-conf (bool): 隐藏标签中的置信度分数。默认: False。    --half (bool): 使用 FP16 半精度推理。默认: False。    --dnn (bool): 使用 OpenCV DNN 后端进行 ONNX 推理。默认: False。    --vid-stride (int): 视频输入的帧率步长。默认: 1。返回:    argparse.Namespace: 解析的命令行参数，用于 YOLOv3 推理配置。示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">options = parse_opt()</span><br><span class="line">run(**<span class="built_in">vars</span>(options))</span><br></pre></td></tr></table></figure>&quot;&quot;&quot;parser = argparse.ArgumentParser()parser.add_argument(    &quot;--weights&quot;, nargs=&quot;+&quot;, type=str, default=ROOT / &quot;yolov3-tiny.pt&quot;, help=&quot;模型路径或 triton URL&quot;)parser.add_argument(&quot;--source&quot;, type=str, default=ROOT / &quot;data/images&quot;, help=&quot;文件/目录/URL/通配符/截图/0(网络摄像头)&quot;)parser.add_argument(&quot;--data&quot;, type=str, default=ROOT / &quot;data/coco128.yaml&quot;, help=&quot;(可选) 数据集.yaml 路径&quot;)parser.add_argument(&quot;--imgsz&quot;, &quot;--img&quot;, &quot;--img-size&quot;, nargs=&quot;+&quot;, type=int, default=[640], help=&quot;推理尺寸 h,w&quot;)parser.add_argument(&quot;--conf-thres&quot;, type=float, default=0.25, help=&quot;置信度阈值&quot;)parser.add_argument(&quot;--iou-thres&quot;, type=float, default=0.45, help=&quot;NMS IoU 阈值&quot;)parser.add_argument(&quot;--max-det&quot;, type=int, default=1000, help=&quot;每张图像的最大检测数&quot;)parser.add_argument(&quot;--device&quot;, default=&quot;&quot;, help=&quot;cuda 设备，例如 0 或 0,1,2,3 或 cpu&quot;)parser.add_argument(&quot;--view-img&quot;, action=&quot;store_true&quot;, help=&quot;显示结果&quot;)parser.add_argument(&quot;--save-txt&quot;, action=&quot;store_true&quot;, help=&quot;将结果保存到 *.txt&quot;)parser.add_argument(&quot;--save-conf&quot;, action=&quot;store_true&quot;, help=&quot;在 --save-txt 标签中保存置信度&quot;)parser.add_argument(&quot;--save-crop&quot;, action=&quot;store_true&quot;, help=&quot;保存裁剪的预测框&quot;)parser.add_argument(&quot;--nosave&quot;, action=&quot;store_true&quot;, help=&quot;不保存图像/视频&quot;)parser.add_argument(&quot;--classes&quot;, nargs=&quot;+&quot;, type=int, help=&quot;按类别过滤：--classes 0 或 --classes 0 2 3&quot;)parser.add_argument(&quot;--agnostic-nms&quot;, action=&quot;store_true&quot;, help=&quot;类别无关的 NMS&quot;)parser.add_argument(&quot;--augment&quot;, action=&quot;store_true&quot;, help=&quot;增强推理&quot;)parser.add_argument(&quot;--visualize&quot;, action=&quot;store_true&quot;, help=&quot;可视化特征&quot;)parser.add_argument(&quot;--update&quot;, action=&quot;store_true&quot;, help=&quot;更新所有模型&quot;)parser.add_argument(&quot;--project&quot;, default=ROOT / &quot;runs/detect&quot;, help=&quot;将结果保存到 project/name&quot;)parser.add_argument(&quot;--name&quot;, default=&quot;exp&quot;, help=&quot;将结果保存到 project/name&quot;)parser.add_argument(&quot;--exist-ok&quot;, action=&quot;store_true&quot;, help=&quot;允许现有 project/name 目录而不递增&quot;)parser.add_argument(&quot;--line-thickness&quot;, default=3, type=int, help=&quot;边界框厚度 (像素)&quot;)parser.add_argument(&quot;--hide-labels&quot;, default=False, action=&quot;store_true&quot;, help=&quot;隐藏标签&quot;)parser.add_argument(&quot;--hide-conf&quot;, default=False, action=&quot;store_true&quot;, help=&quot;隐藏置信度&quot;)parser.add_argument(&quot;--half&quot;, action=&quot;store_true&quot;, help=&quot;使用 FP16 半精度推理&quot;)parser.add_argument(&quot;--dnn&quot;, action=&quot;store_true&quot;, help=&quot;使用 OpenCV DNN 进行 ONNX 推理&quot;)parser.add_argument(&quot;--vid-stride&quot;, type=int, default=1, help=&quot;视频帧率步长&quot;)opt = parser.parse_args()opt.imgsz *= 2 if len(opt.imgsz) == 1 else 1  # 扩展print_args(vars(opt))return opt</code></pre><p>def main(opt):<br>    “””<br>    运行 YOLO 模型的入口点；检查需求并使用解析的选项调用 <code>run</code>。</p><pre><code>参数:    opt (argparse.Namespace): 解析的命令行选项，包括：        - weights (str | list of str): 模型权重路径或 Triton 服务器 URL。        - source (str): 输入源，可以是文件、目录、URL、通配符、截图或网络摄像头索引。        - data (str): 数据集配置文件路径 (.yaml)。        - imgsz (tuple of int): 推理图像尺寸，格式为 (高度, 宽度)。        - conf_thres (float): 检测的置信度阈值。        - iou_thres (float): 非最大抑制 (NMS) 的交并比 (IoU) 阈值。        - max_det (int): 每张图像的最大检测数。        - device (str): 运行推理的设备；选项为 CUDA 设备 id(s) 或 &#39;cpu&#39;。        - view_img (bool): 显示推理结果的标志。        - save_txt (bool): 将检测结果保存为 .txt 格式。        - save_conf (bool): 在 .txt 标签中保存检测置信度。        - save_crop (bool): 保存裁剪的边界框预测。        - nosave (bool): 不保存带有检测结果的图像/视频。        - classes (list of int): 按类别过滤结果，例如 --class 0 2 3。        - agnostic_nms (bool): 使用类别无关的 NMS。        - augment (bool): 启用增强推理。        - visualize (bool): 可视化特征图。        - update (bool): 在推理过程中更新模型。        - project (str): 保存结果的目录。        - name (str): 结果目录的名称。        - exist_ok (bool): 允许现有 project/name 目录而不递增。        - line_thickness (int): 边界框线条的厚度。        - hide_labels (bool): 在边界框上隐藏类别标签。        - hide_conf (bool): 在边界框上隐藏置信度分数。        - half (bool): 使用 FP16 半精度推理。        - dnn (bool): 使用 OpenCV DNN 后端进行 ONNX 推理。        - vid_stride (int): 视频帧率步长。返回:    None示例:    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    opt = parse_opt()</span><br><span class="line">    main(opt)</span><br></pre></td></tr></table></figure>注意:    将此函数作为使用 YOLO 进行对象检测的入口点，支持多种输入源，如图像、视频、目录、网络摄像头、流媒体等。该函数确保检查所有需求，并通过调用 `run` 函数启动检测过程。&quot;&quot;&quot;check_requirements(ROOT / &quot;requirements.txt&quot;, exclude=(&quot;tensorboard&quot;, &quot;thop&quot;))run(**vars(opt))</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    opt = parse_opt()<br>    main(opt)<br>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;鉴于yolov3对于目标识别界的重大开创性，跳过1、2两个版本直接学习yolov3，同时也作为后续版本的基石入门。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;主要原理&quot;&gt;&lt;a href=&quot;#主要原理&quot; class=&quot;headerlink&quot; title=&quot;主要原理&quot;&gt;&lt;/a&gt;主要原理</summary>
      
    
    
    
    <category term="机器人/计算机视觉" scheme="https://blog.zuquanzhi.top/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="YOLO 目标识别" scheme="https://blog.zuquanzhi.top/tags/YOLO-%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>近世代数</title>
    <link href="https://blog.zuquanzhi.top/2024/11/16/14347/"/>
    <id>https://blog.zuquanzhi.top/2024/11/16/14347/</id>
    <published>2024-11-16T13:30:20.000Z</published>
    <updated>2025-08-21T13:42:26.228Z</updated>
    
    <content type="html"><![CDATA[<p><img src="第 1 页.png" alt=""><br><img src="第 2 页.png" alt=""><br><img src="第 3 页.png" alt=""><br><img src="第 4 页.png" alt=""><br><img src="第 5 页.png" alt=""><br><img src="第 6 页.png" alt=""><br><img src="第 7 页.png" alt=""><br><img src="第 8 页.png" alt=""><br><img src="第 9 页.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;第 1 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;第 2 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;第 3 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;第 4 页.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=</summary>
      
    
    
    
    <category term="数学基础" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="近世代数" scheme="https://blog.zuquanzhi.top/tags/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>vim从入门到入土</title>
    <link href="https://blog.zuquanzhi.top/2024/10/15/25909/"/>
    <id>https://blog.zuquanzhi.top/2024/10/15/25909/</id>
    <published>2024-10-15T12:31:14.000Z</published>
    <updated>2025-08-21T13:42:26.222Z</updated>
    
    <content type="html"><![CDATA[<p>首先声明我的vscode坚定拥护者身份，奈何十年老古董实在带不动，不得不重新捡起vim开始朴素（装逼）生活。<br><span id="more"></span></p><h2 id="1-什么是-Vim？"><a href="#1-什么是-Vim？" class="headerlink" title="1. 什么是 Vim？"></a>1. 什么是 Vim？</h2><p>Vim 是一个强大的文本编辑器，基于经典的 vi 编辑器。它的核心设计理念是高效编辑文本，特别适合程序员和技术用户 <strong>(高逼格用户)</strong>。</p><p>与大多数文本编辑器不同，Vim 的操作基于模式切换，它拥有多个操作模式，使你能够在插入、编辑、命令等操作之间快速切换。</p><p><strong><em>Vim vs Vi：Vim 是 vi 的增强版，提供了更多的功能，如多级撤销、语法高亮、扩展的脚本支持等。</em></strong></p><h2 id="2-Vim-的主要模式"><a href="#2-Vim-的主要模式" class="headerlink" title="2. Vim 的主要模式"></a>2. Vim 的主要模式</h2><p>Vim 的操作基于不同的模式，主要有以下几种模式：<br><strong>1.普通模式 (Normal Mode)：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">默认进入的模式，用于导航和操作文本。</span><br><span class="line">进入方式：启动 Vim 后默认进入，或按 Esc 回到普通模式。</span><br><span class="line">常用命令：</span><br><span class="line">h：向左移动光标。</span><br><span class="line">j：向下移动光标。</span><br><span class="line">k：向上移动光标。</span><br><span class="line">l：向右移动光标。</span><br><span class="line"><span class="selector-tag">dd</span>：删除当前行。</span><br><span class="line">yy：复制当前行。</span><br><span class="line"><span class="selector-tag">p</span>：在光标之后粘贴。</span><br></pre></td></tr></table></figure><br><strong>2.插入模式 (Insert Mode)：</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于编辑文本，类似于普通文本编辑器的输入状态。</span><br><span class="line">进入方式：按 <span class="selector-tag">i</span> 或 <span class="selector-tag">a</span> 进入。</span><br><span class="line">退出方式：按 Esc 退出插入模式，回到普通模式。</span><br></pre></td></tr></table></figure><br><strong>3.可视模式 (Visual Mode)：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用于选择文本块。</span><br><span class="line">进入方式：按 v 进入。</span><br><span class="line">常用操作：</span><br><span class="line">y：复制选中的文本。</span><br><span class="line">d：删除选中的文本。</span><br><span class="line"><span class="selector-tag">p</span>：粘贴选中的文本。</span><br></pre></td></tr></table></figure><p><strong>4.命令行模式 (Command-Line Mode)：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用于执行命令，如保存、退出、查找等。</span><br><span class="line">进入方式：按 : 进入。</span><br><span class="line">常用命令：</span><br><span class="line"><span class="symbol">:w</span>：保存文件。</span><br><span class="line"><span class="symbol">:q</span>：退出文件。</span><br><span class="line"><span class="symbol">:wq</span>：保存并退出。</span><br><span class="line"><span class="symbol">:q!</span>：强制退出（不保存修改）。</span><br></pre></td></tr></table></figure><h2 id="3-基本操作指南"><a href="#3-基本操作指南" class="headerlink" title="3. 基本操作指南"></a>3. 基本操作指南</h2><h3 id="3-1-移动光标"><a href="#3-1-移动光标" class="headerlink" title="3.1 移动光标"></a>3.1 移动光标</h3><p>Vim 的基本光标移动是基于 h、j、k、l 四个键，可以用来代替方向键。此外，Vim 提供了更多强大的导航功能：</p><pre><code>w：跳转到下一个单词的开头。b：跳转到上一个单词的开头。gg：跳转到文件开头。G：跳转到文件末尾。Ctrl + f：向下翻页。Ctrl + b：向上翻页。</code></pre><h3 id="3-2-插入和编辑文本"><a href="#3-2-插入和编辑文本" class="headerlink" title="3.2 插入和编辑文本"></a>3.2 插入和编辑文本</h3><p>在普通模式下，通过按以下键进入插入模式以编辑文本：</p><pre><code>i：在光标前插入文本。I：在当前行的行首插入文本。a：在光标后插入文本。A：在当前行的行尾插入文本。o：在光标下方新建一行并插入。O：在光标上方新建一行并插入。</code></pre><h3 id="3-3-删除文本"><a href="#3-3-删除文本" class="headerlink" title="3.3 删除文本"></a>3.3 删除文本</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x：删除光标所在的字符。</span><br><span class="line"><span class="built_in">dd</span>：删除当前行。</span><br><span class="line">d + 移动命令：根据移动命令删除内容，例如 <span class="built_in">dw</span> 删除到下一个单词开头，d$ 删除到行尾。</span><br></pre></td></tr></table></figure><h3 id="3-4-复制和粘贴"><a href="#3-4-复制和粘贴" class="headerlink" title="3.4 复制和粘贴"></a>3.4 复制和粘贴</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yy：复制当前行。</span><br><span class="line">y + 移动命令：复制指定范围的内容，例如 yw 复制到下一个单词开头。</span><br><span class="line"><span class="selector-tag">p</span>：在光标后粘贴内容。</span><br><span class="line"><span class="selector-tag">P</span>：在光标前粘贴内容。</span><br></pre></td></tr></table></figure><h3 id="3-5-撤销和重做"><a href="#3-5-撤销和重做" class="headerlink" title="3.5 撤销和重做"></a>3.5 撤销和重做</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u：撤销上一步操作。</span><br><span class="line">Ctrl + <span class="built_in">r</span>：重做撤销的操作。</span><br></pre></td></tr></table></figure><h2 id="4-Vim-高级操作"><a href="#4-Vim-高级操作" class="headerlink" title="4. Vim 高级操作"></a>4. Vim 高级操作</h2><h3 id="4-1-查找和替换"><a href="#4-1-查找和替换" class="headerlink" title="4.1 查找和替换"></a>4.1 查找和替换</h3><p>Vim 提供了强大的查找和替换功能：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/pattern：向前查找 pattern。</span><br><span class="line"><span class="string">?p</span>attern：向后查找 pattern。</span><br><span class="line">n：跳转到下一个匹配项。</span><br><span class="line">N：跳转到上一个匹配项。</span><br><span class="line"><span class="symbol">:s/old/new/g</span>：将当前行中的 old 替换为 new。</span><br><span class="line"><span class="symbol">:%s/old/new/g</span>：将整个文件中的 old 替换为 new。</span><br></pre></td></tr></table></figure></p><h3 id="4-2-多文件和窗口操作"><a href="#4-2-多文件和窗口操作" class="headerlink" title="4.2 多文件和窗口操作"></a>4.2 多文件和窗口操作</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:e</span> filename：打开一个新文件。</span><br><span class="line"><span class="symbol">:vsp</span> filename：垂直分屏打开文件。</span><br><span class="line"><span class="symbol">:sp</span> filename：水平分屏打开文件。</span><br><span class="line"><span class="title class_">Ctrl</span> + w + h/j/k/l：在不同窗口间切换。</span><br></pre></td></tr></table></figure><h3 id="4-3-宏录制与回放"><a href="#4-3-宏录制与回放" class="headerlink" title="4.3 宏录制与回放"></a>4.3 宏录制与回放</h3><p>Vim 支持录制操作的宏，可以将常用操作记录下来并反复执行：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">q</span> + 字母：开始录制宏到指定的字母键（如 <span class="selector-tag">q</span> <span class="selector-tag">a</span> 开始录制到 <span class="selector-tag">a</span>）。</span><br><span class="line">执行所需操作。</span><br><span class="line"><span class="selector-tag">q</span>：停止录制。</span><br><span class="line">@<span class="selector-tag">a</span>：回放录制的宏 <span class="selector-tag">a</span>。</span><br></pre></td></tr></table></figure></p><h2 id="5-Vim-的配置"><a href="#5-Vim-的配置" class="headerlink" title="5. Vim 的配置"></a>5. Vim 的配置</h2><p>Vim 可以通过编辑 .vimrc 文件进行自定义，这个文件通常位于用户的主目录下。通过编辑 .vimrc，你可以为 Vim 添加一些个性化的配置，以提高编辑效率。以下是一些常用配置选项：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>        <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>     <span class="comment">&quot; 设置 Tab 键宽度为 4 个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>  <span class="comment">&quot; 设置自动缩进为 4 个空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab     <span class="comment">&quot; 将 Tab 转换为空格</span></span><br><span class="line"><span class="keyword">set</span> cursorline    <span class="comment">&quot; 高亮当前行</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>         <span class="comment">&quot; 启用语法高亮</span></span><br><span class="line"><span class="keyword">set</span> relativenumber <span class="comment">&quot; 显示相对行号</span></span><br></pre></td></tr></table></figure></p><h2 id="6-常用-Vim-插件"><a href="#6-常用-Vim-插件" class="headerlink" title="6. 常用 Vim 插件"></a>6. 常用 Vim 插件</h2><p>Vim 的强大之处还在于其插件支持，可以通过插件扩展其功能。以下是一些常用的 Vim 插件：</p><ol><li>NerdTree：文件浏览器插件，允许你在 Vim 中以树状结构浏览文件。</li><li>Vim-Airline：美化状态栏，提供更丰富的状态信息。</li><li>Fzf：强大的文件搜索工具，能够快速定位和打开文件。</li><li>YouCompleteMe：代码自动补全插件，支持多种编程语言的补全。</li><li>Syntastic：语法检查工具，能够帮助你及时发现代码中的错误。</li></ol><p>可以通过 Vim 的插件管理工具（如 Vundle 或 Pathogen）来安装和管理这些插件。</p><h2 id="7-如何退出-Vim"><a href="#7-如何退出-Vim" class="headerlink" title="7. 如何退出 Vim"></a>7. 如何退出 Vim</h2><p>退出 Vim 是初学者经常遇到的问题。以下是几种退出方式：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:q</span>：退出（无修改时）。</span><br><span class="line"><span class="symbol">:wq</span> 或 <span class="title class_">ZZ</span>：保存并退出。</span><br><span class="line"><span class="symbol">:q!</span>：强制退出（不保存修改）。</span><br><span class="line"><span class="symbol">:wq!</span>：强制保存并退出。</span><br></pre></td></tr></table></figure></p><p>掌握了这些内容基本就足够在服务器终端上大展身手了，网上有很多大佬开发了各种各样的vim插件（说实话vim的最终解就是vscode），以后可能会继续更新这些插件配置相关内容</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先声明我的vscode坚定拥护者身份，奈何十年老古董实在带不动，不得不重新捡起vim开始朴素（装逼）生活。&lt;br&gt;</summary>
    
    
    
    <category term="工具" scheme="https://blog.zuquanzhi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vim" scheme="https://blog.zuquanzhi.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>nth_element函数深入</title>
    <link href="https://blog.zuquanzhi.top/2024/10/02/47436/"/>
    <id>https://blog.zuquanzhi.top/2024/10/02/47436/</id>
    <published>2024-10-02T14:48:02.000Z</published>
    <updated>2025-08-21T13:42:26.221Z</updated>
    
    <content type="html"><![CDATA[<p><code>nth_element</code> 是 C++ 标准模板库 (STL) 中的一个非常有用的算法，它的功能是对范围内的元素进行部分排序，使得第 <code>n</code> 小的元素排到指定位置，其前面的元素都小于等于它，后面的元素都大于等于它，但前后的元素不一定是完全排序的。</p><p><code>nth_element</code> 算法基于<a href="http://blog.zuquanzhi.top/2024/10/02/快排/">快速排序</a>，时间复杂度在平均情况下是 O(n)，最坏情况是 O(n^2)，但通过随机化选取枢轴可以避免最坏情况的频繁发生。</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nth_element</span><span class="params">(RandomIt first, RandomIt nth, RandomIt last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>first</code>: 范围的起始迭代器。</li><li><code>nth</code>: 指定要找到的第 n 小元素的迭代器。</li><li><code>last</code>: 范围的结束迭代器（不包括 <code>last</code> 指向的元素）。</li><li><code>comp</code>: 可选的自定义比较器，用于自定义排序规则。</li></ul><h3 id="nth-element-的核心特点"><a href="#nth-element-的核心特点" class="headerlink" title="nth_element 的核心特点"></a><code>nth_element</code> 的核心特点</h3><ul><li>部分排序：<code>nth_element</code> 不会对整个数组进行完全排序，而只会确保第 <code>n</code> 小的元素排到第 <code>n</code> 位。</li><li>前后区间无序：在 <code>nth_element</code> 之后，<code>[first, nth)</code> 中的元素只会比 <code>*nth</code> 小，<code>[nth+1, last)</code> 中的元素比 <code>*nth</code> 大，但这些子区间并不会是有序的。</li></ul><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第5小的元素，并确保它位于vec[4]</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">4</span>, vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第5小的元素是：&quot;</span> &lt;&lt; vec[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;前面的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">begin</span>() + <span class="number">4</span>; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;后面的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>() + <span class="number">5</span>; it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第5小的元素是：5</span><br><span class="line">前面的元素：1<span class="number"> 2 </span>4<span class="number"> 3 </span></span><br><span class="line">后面的元素：10<span class="number"> 7 </span>9<span class="number"> 8 </span>6 </span><br></pre></td></tr></table></figure></p><p>在这个示例中，<code>nth_element</code> 保证 <code>vec[4]</code> 是第 5 小的元素（因为从 0 开始计数），并且前 4 个元素小于等于 5，后面的元素大于等于 5，但前后部分的元素是无序的。</p><h3 id="nth-element-的应用场景"><a href="#nth-element-的应用场景" class="headerlink" title="nth_element 的应用场景"></a><code>nth_element</code> 的应用场景</h3><ol><li><strong>Top K 问题</strong>：你可以用 <code>nth_element</code> 来高效找到数组中前 K 大（或前 K 小）元素，而不需要对整个数组排序。</li><li><strong>中位数查找</strong>：用 <code>nth_element</code> 可以高效找到无序数组中的中位数，避免排序的 O(n log n) 时间开销。</li><li><strong>数据过滤</strong>：可以用 <code>nth_element</code> 来过滤掉过大或过小的元素，只保留前面或后面的一部分。</li></ol><h3 id="nth-element-与完整排序的对比"><a href="#nth-element-与完整排序的对比" class="headerlink" title="nth_element 与完整排序的对比"></a><code>nth_element</code> 与完整排序的对比</h3><p>相比 <code>std::sort</code> 或 <code>std::partial_sort</code>，<code>nth_element</code> 只确保第 <code>n</code> 小的元素在正确位置，并且左右部分并不保证是有序的。这使得它在需要部分排序的场景下更加高效。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>nth_element</code> 实际上是基于快速选择 (Quickselect) 算法的变种。它采用与快速排序类似的分区策略，只不过在每次分区后，它仅处理包含第 <code>n</code> 小元素的那一部分。这使得它比对整个数组进行完全排序更快。</p><ol><li>选取一个枢轴元素，并将比它小的元素放到左边，大的放到右边。</li><li>如果 <code>n</code> 恰好是枢轴的位置，则排序结束。</li><li>如果 <code>n</code> 小于枢轴的位置，则递归处理左半部分；如果 <code>n</code> 大于枢轴的位置，则递归处理右半部分。</li></ol><h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><p>可以通过自定义比较器改变 <code>nth_element</code> 的排序规则。例如，按照降序排列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义比较器：从大到小排序</span></span><br><span class="line">    std::<span class="built_in">nth_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">4</span>, vec.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第5大的元素是：&quot;</span> &lt;&lt; vec[<span class="number">4</span>] &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;nth_element&lt;/code&gt; 是 C++ 标准模板库 (STL) 中的一个非常有用的算法，它的功能是对范围内的元素进行部分排序，使得第 &lt;code&gt;n&lt;/code&gt; 小的元素排到指定位置，其前面的元素都小于等于它，后面的元素都大于等于它，但前后的元素不一</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="STL" scheme="https://blog.zuquanzhi.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>快排</title>
    <link href="https://blog.zuquanzhi.top/2024/10/02/12326/"/>
    <id>https://blog.zuquanzhi.top/2024/10/02/12326/</id>
    <published>2024-10-02T13:54:45.000Z</published>
    <updated>2025-08-21T13:42:26.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速排序（Quick-Sort）的C-实现"><a href="#快速排序（Quick-Sort）的C-实现" class="headerlink" title="快速排序（Quick Sort）的C++实现"></a>快速排序（Quick Sort）的C++实现</h3><h4 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h4><p>快速排序是一种基于 <strong>分治法</strong> 的高效排序算法。通过选择一个“基准”（pivot），快速排序将序列分成两个子序列，分别递归地进行排序。在平均情况下，时间复杂度为 ( O(n \log n) )，且具有较小的常数因子，在实际中通常比其他排序算法更快。</p><h4 id="2-算法步骤"><a href="#2-算法步骤" class="headerlink" title="2. 算法步骤"></a>2. 算法步骤</h4><ol><li><strong>选择基准值（Pivot）</strong>: 通常选择序列中的第一个元素或中间元素作为基准值。</li><li><strong>分区（Partitioning）</strong>: 将序列中的元素按照基准值划分成两部分：左侧部分小于基准值，右侧部分大于基准值。</li><li><strong>递归调用</strong>: 对左侧和右侧的子序列分别进行快速排序。</li><li><strong>结束条件</strong>: 当子序列的长度为1或0时，不再递归。</li></ol><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h4><h5 id="标准的递归实现："><a href="#标准的递归实现：" class="headerlink" title="标准的递归实现："></a>标准的递归实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，返回基准值的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];  <span class="comment">// 基准值</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 从右向左找小于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = arr[high];  <span class="comment">// 将小于基准值的元素移动到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左向右找大于基准值的元素</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[high] = arr[low];  <span class="comment">// 将大于基准值的元素移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;  <span class="comment">// 基准值归位</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回基准值的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(arr, low, high);  <span class="comment">// 划分序列</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pivotIndex - <span class="number">1</span>);  <span class="comment">// 递归排序左半部分</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, high);  <span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">29</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-细节分析"><a href="#4-细节分析" class="headerlink" title="4. 细节分析"></a>4. 细节分析</h4><ol><li><p><strong>选择基准值</strong>: 代码中选择了第一个元素作为基准值 <code>pivot</code>，在某些情况下（如已排序的数组）会导致最坏的时间复杂度 ( O(n^2) )。通过随机选择基准值或选择中间元素，可以提高算法在特定输入下的效率。</p></li><li><p><strong>分区过程</strong>: </p><ul><li>从右向左找第一个小于基准值的元素，放在左侧；</li><li>从左向右找第一个大于基准值的元素，放在右侧；</li><li>这个过程不断交替进行，直到左右两侧交叉，最后将基准值归位。</li></ul></li><li><p><strong>递归调用</strong>: 快速排序通过递归实现对左右两个子序列的排序。由于每次递归调用的数组长度缩小，因此在平均情况下递归深度为 ( \log n )。</p></li><li><p><strong>时间复杂度</strong>:</p><ul><li><strong>最优时间复杂度</strong>: 当每次划分都非常均匀时，递归深度为 ( \log n )，每次分区的代价为 ( O(n) )，因此时间复杂度为 ( O(n \log n) )。</li><li><strong>最坏时间复杂度</strong>: 当数组已经有序或接近有序时，每次划分都导致极端不平衡的分区，递归深度为 ( O(n) )，时间复杂度为 ( O(n^2) )。</li></ul></li><li><p><strong>空间复杂度</strong>: 快速排序是 <strong>原地排序</strong> 算法，因此空间复杂度仅为递归调用时的栈空间，最优情况下为 ( O(\log n) )，最坏情况下为 ( O(n) )。</p></li></ol><h4 id="5-迭代实现"><a href="#5-迭代实现" class="headerlink" title="5. 迭代实现"></a>5. 迭代实现</h4><p>使用递归容易导致栈溢出问题，在此基础上可以使用栈手动模拟递归过程，进行迭代实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">    <span class="built_in">Range</span>(<span class="type">int</span> s, <span class="type">int</span> e) : <span class="built_in">start</span>(s), <span class="built_in">end</span>(e) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数与递归版相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) --high;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) ++low;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代实现的快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortIterative</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;Range&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(<span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Range range = stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; range.end) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = <span class="built_in">partition</span>(arr, range.start, range.end);</span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(range.start, pivot - <span class="number">1</span>));</span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">Range</span>(pivot + <span class="number">1</span>, range.end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">29</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSortIterative</span>(arr);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;排序结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;快速排序（Quick-Sort）的C-实现&quot;&gt;&lt;a href=&quot;#快速排序（Quick-Sort）的C-实现&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quick Sort）的C++实现&quot;&gt;&lt;/a&gt;快速排序（Quick Sort）的C++实现</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="STL" scheme="https://blog.zuquanzhi.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的深度思考和总结</title>
    <link href="https://blog.zuquanzhi.top/2024/10/02/63385/"/>
    <id>https://blog.zuquanzhi.top/2024/10/02/63385/</id>
    <published>2024-10-02T12:51:56.000Z</published>
    <updated>2025-08-21T13:42:26.227Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-数据结构的本质"><a href="#1-数据结构的本质" class="headerlink" title="1.数据结构的本质"></a>1.数据结构的本质</h4><p>数据结构的本质其实就是<strong>链表和数组</strong>，其他复杂的数据结构不过是这些基本结构的高级抽象。无论是树、栈、队列，还是更高级的图结构，归根结底都是基于数组或链表构建的。它们通过底层的实现细节和不同的逻辑组织方式，提供了更易用的API接口。</p><span id="more"></span><p><img src="DataStructure.png" alt="DataStructure"></p><p>比如，<strong>树</strong>这种数据结构，既可以用数组来实现，也可以用链表构建。数组的优势在于可以通过索引快速访问，节省空间，而链表的优势则在于高效的插入和删除操作。但链表由于使用指针，会占用更多的空间。</p><p>我们可以从<strong>Redis</strong>的实现上看到这一点，它内部有字符串、集合等数据结构，每一种数据类型都有不同的实现方式。其实，我们自己也可以根据具体的业务场景，设计并实现出个性化的数据结构，并定义一些适合当前业务需求的API接口。</p><p>语言层面也为我们提供了丰富的数据结构工具。比如在<strong>Python</strong>中，除了常用的字典和列表外，还可以通过<code>collections</code>模块找到一些更灵活和高效的数据类型，如<code>defaultdict</code>、双端队列<code>deque</code>、计数器<code>Counter</code>等。<strong>Java</strong>的<code>java.util</code>包中也包含了大量用于扩展基础数据结构的工具类。</p><p>综上所述，数据结构的底层其实就是<strong>数组和链表</strong>。无论是集合还是字典，都是通过哈希函数来将元素映射到具体的存储位置上。</p><h4 id="那么，算法的本质是什么？"><a href="#那么，算法的本质是什么？" class="headerlink" title="那么，算法的本质是什么？"></a>那么，算法的本质是什么？</h4><p>算法的本质其实就是<strong>穷举</strong>。但穷举并不是那么简单的，它需要做到两点：<strong>不漏</strong>和<strong>聪明的穷举</strong>。</p><p>计算机与人类解决问题的思维方式完全不同。人类可能通过一个公式就能解决问题，而计算机则依赖<strong>计算能力</strong>不断进行尝试，直到得到结果。计算机最大的优点就是速度快、不怕累。因此，算法就是用<strong>计算机语言</strong>把人的问题转化为机器能够执行的程序，通过不断的尝试来解决。</p><h5 id="1-不漏"><a href="#1-不漏" class="headerlink" title="1. 不漏"></a>1. <strong>不漏</strong></h5><p>“不漏”指的是算法给出的解答必须是完整的。比如很多组合问题常用<strong>回溯算法</strong>来解决，算法需要确保所有可能的解都被考虑到，没有遗漏。</p><h5 id="2-聪明的穷举"><a href="#2-聪明的穷举" class="headerlink" title="2. 聪明的穷举"></a>2. <strong>聪明的穷举</strong></h5><p>“聪明的穷举”就是通过优化策略来提高效率。最简单的算法可能是暴力破解，但它通常效率低下。为了提高效率，我们需要进行优化，而所有的优化手段，归根结底都是为了<strong>更聪明地穷举</strong>。</p><p>举个例子，<strong>双指针</strong>和<strong>滑动窗口</strong>技巧就是为了在穷举过程中减少不必要的时间消耗。相比于传统的双重循环，它们能显著提高时间效率。同样的，有时可以选择更合适的数据结构来减少穷举，比如使用双链表代替单链表，可以节省一定的操作步骤。</p><p>在算法设计中，还有一些优化技巧，比如<strong>剪枝</strong>，即在遍历树时提早终止不必要的分支；又比如<strong>记忆化搜索</strong>，通过缓存中间结果来避免重复计算。</p><h2 id="综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同"><a href="#综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同" class="headerlink" title="综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同"></a><strong>综上所述，数据结构其实就是在说程序存储和读取数据的方法，算法则是在说计算方法不同导致的资源占用和效率不同</strong></h2><h4 id="2-线性数据结构"><a href="#2-线性数据结构" class="headerlink" title="2. 线性数据结构"></a>2. <strong>线性数据结构</strong></h4><h5 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a><strong>数组 (Array)</strong></h5><ul><li><strong>定义与特性</strong><br>数组是内存中连续分配的元素集合，支持常数时间的随机访问。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 定义一个包含5个整数的数组</span></span><br><span class="line"><span class="type">int</span> element = arr[<span class="number">2</span>];  <span class="comment">// 访问索引为2的元素</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">10</span>;  <span class="comment">// 修改索引为1的元素</span></span><br></pre></td></tr></table></figure></li><li><strong>优缺点分析</strong>  <ul><li>优点：支持常数时间的随机访问，适合查找场景。</li><li>缺点：插入和删除操作需要移动大量元素，效率较低。</li></ul></li><li><strong>典型应用场景与变体</strong>  <ul><li><strong>动态数组</strong>：大小可动态变化的数组，如C++中的<code>std::vector</code>。  </li><li><strong>稀疏矩阵</strong>：存储少量非零元素的矩阵，节省内存。</li></ul></li></ul><h5 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表 (Linked List)"></a><strong>链表 (Linked List)</strong></h5><ul><li><strong>定义与特性</strong><br>链表是由一系列节点组成的，每个节点包含数据和指向下一个节点的指针。支持高效的插入和删除操作。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* head = <span class="literal">nullptr</span>;  <span class="comment">// 创建一个空链表</span></span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node&#123;<span class="number">10</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 创建一个新节点</span></span><br><span class="line">head = newNode;  <span class="comment">// 将新节点作为链表头部</span></span><br></pre></td></tr></table></figure></li><li><strong>单链表与双链表</strong>  <ul><li><strong>单链表</strong>：每个节点仅指向下一个节点。</li><li><strong>双链表</strong>：每个节点同时指向前一个和后一个节点，便于双向遍历。</li></ul></li><li><strong>优缺点分析</strong>  <ul><li>优点：插入和删除操作的时间复杂度为O(1)。</li><li>缺点：不能随机访问，查找某个元素需要遍历链表。</li></ul></li><li><strong>典型应用</strong>  <ul><li><strong>LRU缓存</strong>：使用双向链表和哈希表实现最近最少使用（Least Recently Used）缓存策略。</li><li><strong>队列</strong>：使用链表实现的队列，支持高效的入队和出队操作。</li></ul></li></ul><h5 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a><strong>栈与队列</strong></h5><ul><li><p><strong>栈 (Stack)</strong></p><ul><li><strong>定义与特性</strong><br>栈是一种后进先出（LIFO, Last In First Out）数据结构，只有栈顶元素可以被访问。常用于递归问题的处理。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> stack[MAX];</span><br><span class="line"><span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stack[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack[top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>实际应用</strong>  <ul><li><strong>递归求解</strong>：如深度优先搜索（DFS）中使用栈模拟递归。</li><li><strong>表达式求值</strong>：后缀表达式求值。</li></ul></li></ul></li><li><p><strong>队列 (Queue)</strong></p><ul><li><strong>定义与特性</strong><br>队列是一种先进先出（FIFO, First In First Out）数据结构，常用于任务调度、广度优先搜索（BFS）等场景。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> queue[MAX];</span><br><span class="line"><span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    queue[rear++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue[front++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>实际应用</strong>  <ul><li><strong>任务调度</strong>：常用于处理操作系统中的任务调度、打印队列等。</li><li><strong>广度优先搜索 (BFS)</strong>：通过队列实现层序遍历。</li></ul></li></ul></li></ul><h4 id="3-树结构"><a href="#3-树结构" class="headerlink" title="3. 树结构"></a>3. <strong>树结构</strong></h4><h5 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 (Binary Tree)"></a><strong>二叉树 (Binary Tree)</strong></h5><ul><li><strong>定义与特性</strong><br>二叉树是每个节点最多有两个子节点的树结构，子节点分别称为左子节点和右子节点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* root = <span class="keyword">new</span> TreeNode&#123;<span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 创建根节点</span></span><br><span class="line">root-&gt;left = <span class="keyword">new</span> TreeNode&#123;<span class="number">2</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 添加左子节点</span></span><br><span class="line">root-&gt;right = <span class="keyword">new</span> TreeNode&#123;<span class="number">3</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;  <span class="comment">// 添加右子节点</span></span><br></pre></td></tr></table></figure></li><li><strong>遍历方式</strong><ul><li><strong>前序遍历</strong>：根节点 -&gt; 左子树 -&gt; 右子树</li><li><strong>中序遍历</strong>：左子树 -&gt; 根节点 -&gt; 右子树</li><li><strong>后序遍历</strong>：左子树 -&gt; 右子树 -&gt; 根节点</li><li><strong>层序遍历</strong>：按层访问，常用队列实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="二叉搜索树-Binary-Search-Tree-BST"><a href="#二叉搜索树-Binary-Search-Tree-BST" class="headerlink" title="二叉搜索树 (Binary Search Tree, BST)"></a><strong>二叉搜索树 (Binary Search Tree, BST)</strong></h5><ul><li><strong>定义与特性</strong><br>二叉搜索树是一种有序二叉树，对于每个节点，其左子树的所有节点值小于该节点值，右子树的所有节点值大于该节点值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&#123;val, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>操作</strong>  <ul><li><strong>插入</strong>：新元素按照顺序插入到合适位置。</li><li><strong>查找</strong>：从根节点开始，根据大小关系查找节点。</li><li><strong>删除</strong>：删除节点时需要考虑其子节点的调整。</li></ul></li><li><strong>平衡性问题与优化</strong>  <ul><li><strong>AVL树</strong>：通过旋转保持树的平衡，确保插入、删除、查找操作时间复杂度为O(log n)。</li><li><strong>红黑树</strong>：类似AVL树，但平衡条件稍弱，插入和删除更高效。</li></ul></li></ul><h5 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 (Heap)"></a><strong>堆 (Heap)</strong></h5><ul><li><strong>定义与特性</strong><br>堆是一棵完全二叉树，分为最大堆和最小堆。最大堆中每个节点的值都大于或等于其子节点，最小堆则相反。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) largest = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) largest = right;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">        <span class="built_in">heapify</span>(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-数据结构的本质&quot;&gt;&lt;a href=&quot;#1-数据结构的本质&quot; class=&quot;headerlink&quot; title=&quot;1.数据结构的本质&quot;&gt;&lt;/a&gt;1.数据结构的本质&lt;/h4&gt;&lt;p&gt;数据结构的本质其实就是&lt;strong&gt;链表和数组&lt;/strong&gt;，其他复杂的数据结构不过是这些基本结构的高级抽象。无论是树、栈、队列，还是更高级的图结构，归根结底都是基于数组或链表构建的。它们通过底层的实现细节和不同的逻辑组织方式，提供了更易用的API接口。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://blog.zuquanzhi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Transformer架构初步</title>
    <link href="https://blog.zuquanzhi.top/2024/09/20/15915/"/>
    <id>https://blog.zuquanzhi.top/2024/09/20/15915/</id>
    <published>2024-09-20T08:20:04.000Z</published>
    <updated>2025-12-06T15:00:59.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-RNN-爬到-Transformer-山顶"><a href="#从-RNN-爬到-Transformer-山顶" class="headerlink" title="从 RNN 爬到 Transformer 山顶"></a>从 RNN 爬到 Transformer 山顶</h1><p>第一次听到 <em>Transformer</em> 的时候，我脑子里闪过三个画面：</p><ul><li>物理书里的“变压器”</li><li>变形金刚</li><li>导师嘴里那句：“现在大部分大模型都是这个架构……”</li></ul><p>然后我去翻论文《Attention is All You Need》，翻开第一眼：<br>公式一堆、结构图一堆，我当场关掉 PDF，默默记住一个结论：</p><blockquote><p>这个东西以后肯定逃不过，但今天先不学。</p></blockquote><p>直到后面真的要用到它，我才开始系统地啃。下面的内容可以看作是我这个初学者把 Transformer 从“听过名字”到“勉强理解”的过程整理。</p><hr><h2 id="一、先说结论：Transformer-到底干了件什么事？"><a href="#一、先说结论：Transformer-到底干了件什么事？" class="headerlink" title="一、先说结论：Transformer 到底干了件什么事？"></a>一、先说结论：Transformer 到底干了件什么事？</h2><p>如果只能用一句话来概括 Transformer，我现在会这样说：</p><blockquote><p><strong>以前我们处理一句话，是按时间步从左到右递推；<br>Transformer 改成了：整句一起看，通过自注意力让每个位置和所有位置建立联系。</strong></p></blockquote><p>更具体一点：</p><ul><li>RNN：依次处理 <script type="math/tex">(x_1, x_2, \dots, x_T)</script> 每一步依赖前一步的隐状态$(h_{t-1})$；</li><li>Transformer：把整段序列表示成矩阵，一次性送进若干层自注意力和前馈网络中，<strong>在每一层里，任意两个位置都可以直接交互信息</strong>。</li></ul><p>它的两个核心优势：</p><ol><li>计算上不再严格串行，<strong>可以很好地并行</strong>；</li><li>任意距离的依赖都可以通过注意力直接建模，<strong>长依赖不再需要“层层传递”</strong>。</li></ol><p>剩下的公式、结构设计，基本都是围绕这两点展开的工程实现细节。</p><hr><h2 id="二、以前的我们都是怎么处理“序列”的？"><a href="#二、以前的我们都是怎么处理“序列”的？" class="headerlink" title="二、以前的我们都是怎么处理“序列”的？"></a>二、以前的我们都是怎么处理“序列”的？</h2><p>在遇到 Transformer 之前，主流的序列建模方法是 RNN / LSTM / GRU。</p><p>典型形式是：</p><script type="math/tex; mode=display">h_t = f(x_t, h_{t-1})</script><p>每个时间步的隐状态 <script type="math/tex">(h_t)</script> 依赖当前输入<script type="math/tex">(x_t)</script>和上一个隐状态<script type="math/tex">(h_{t-1})</script>。从直觉来看，这非常符合“按顺序处理”的想法。</p><p>问题也很典型：</p><ul><li>序列一长，<strong>早期的信息要一层层往后传，容易衰减</strong>（梯度消失/信息稀释）；</li><li>每一步要等前一步算完，<strong>并行度有限</strong>；</li><li>想把模型做大、把序列拉长，训练成本会明显上升。</li></ul><p>简单说，RNN 系列的结构在“表达序列依赖”和“与现代硬件的计算模式”之间，存在一个天然的矛盾。</p><p>Transformer 的思路就是把这个矛盾拆开：顺序感不靠递推来体现，而交给其他机制（位置编码），序列关系不靠链式传递，而用注意力做全局建模。</p><hr><h2 id="三、Self-Attention：一句话里的词怎么“互相看”？"><a href="#三、Self-Attention：一句话里的词怎么“互相看”？" class="headerlink" title="三、Self-Attention：一句话里的词怎么“互相看”？"></a>三、Self-Attention：一句话里的词怎么“互相看”？</h2><h3 id="3-1-一个具体例子"><a href="#3-1-一个具体例子" class="headerlink" title="3.1 一个具体例子"></a>3.1 一个具体例子</h3><p>来看一句中文：</p><blockquote><p>“昨天我在公园看到一个人，他牵着一只看起来像猫的狗。”</p></blockquote><p>在理解这句话时：</p><ul><li>看到“他”，大多数人会自然地把它和前面的“一个人”对应起来；</li><li>看到“像猫的狗”，会把“像猫”和“狗”关联，而不是“公园像猫”。</li></ul><p>也就是说，人类在理解语句时，并不是只盯着当前位置，而是会参考整句中其他相关的位置。</p><p>Self-Attention 做的事情就是：<br><strong>让模型在计算每个位置的表示时，可以访问整个序列，根据“相关性”来决定该从哪些位置获取信息。</strong></p><h3 id="3-2-Q-K-V-到底在干什么？"><a href="#3-2-Q-K-V-到底在干什么？" class="headerlink" title="3.2 Q / K / V 到底在干什么？"></a>3.2 Q / K / V 到底在干什么？</h3><p>一开始看到 Q/K/V 我也一头雾水，后来把它们简单地整理成三个角色：</p><ul><li><strong>Q（Query）</strong>：查询向量，表示当前这个位置“想要什么信息”；</li><li><strong>K（Key）</strong>：键向量，表示序列中每个位置可以被“匹配”的特征；</li><li><strong>V（Value）</strong>：值向量，是真正要被加权聚合的信息。</li></ul><p>自注意力的计算形式是：</p><p>$[<br>\text{Attention}(Q,K,V)<br>= \text{softmax}\left(\frac{QK^\top}{\sqrt{d_k}}\right)V<br>]$</p><p>逐步理解一下：</p><ol><li>对序列每个位置 $(i)$，利用线性变换得到它的 $(Q_i, K_i, V_i)$；</li><li>对于位置 $(i)$，计算它的$ (Q_i)$ 与所有位置 $(j)$ 的 $(K_j) $的点积，得到一串相关性分数；</li><li>对这些分数做 $softmax$，得到一组权重$ ( \alpha_{ij} )$；</li><li>用这组权重对所有 $(V_j)$ 做加权求和，得到位置$ (i) $的新的表示。</li></ol><blockquote><p><strong>Self-Attention = 每个位置用自己的 Q，去匹配全序列的 K，得到权重后对全序列的 V 做加权求和。</strong></p></blockquote><p>相比 RNN 这种“链式传递”，Self-Attention 允许任意位置之间直接发生交互。</p><hr><h2 id="四、多头注意力：为什么要搞那么多“头”？"><a href="#四、多头注意力：为什么要搞那么多“头”？" class="headerlink" title="四、多头注意力：为什么要搞那么多“头”？"></a>四、多头注意力：为什么要搞那么多“头”？</h2><p>多头注意力（Multi-Head Attention）刚听上去有点吓人，其实做的事情非常机械：</p><ol><li>把输入向量先通过线性变换，分成 (h) 份不同的子空间（head）；</li><li>每个 head 在自己的子空间里独立完成一遍 Self-Attention；</li><li>把所有 head 的输出在最后一个维度拼接起来，再经过一次线性变换。</li></ol><p>形式上是：</p><p>$[<br>\text{head}_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V)<br>]$</p><p>$[<br>\text{MultiHead}(Q,K,V) = \text{Concat}(\text{head}_1,\dots,\text{head}_h)W^O<br>]$</p><p>直观含义：</p><ul><li>不同的 head 在不同的子空间中建模“相关性”，可以捕捉到不同类型的模式（比如局部关系、长距离关系、语法结构等）；</li><li>多个 head 并行计算，不会增加时间复杂度量级，只是扩大了宽度。</li></ul><p>所以，可以简化地记住：</p><blockquote><p><strong>多头注意力 = 多个自注意力并联，在不同子空间里建模，再合并。</strong></p></blockquote><hr><h2 id="五、顺序去哪了？——位置编码出场"><a href="#五、顺序去哪了？——位置编码出场" class="headerlink" title="五、顺序去哪了？——位置编码出场"></a>五、顺序去哪了？——位置编码出场</h2><p>上面说的 Self-Attention 有一个明显问题：<br>它本身对序列的顺序不敏感，只关心向量值，而不关心“第几个位置”。</p><p>如果不给模型额外的位置信息，“我 在 昨天 公园”和“公园 昨天 在 我”在它眼里只是向量排列的变化。</p><p>解决方法就是<strong>位置编码（Positional Encoding）</strong>：<br>在送入 Transformer 之前，为每个位置添加一个专门的“位置向量”。</p><p>常见做法有两类：</p><ol><li><strong>固定位置编码（正弦/余弦）</strong><br>论文中的做法是用不同频率的正弦、余弦函数生成位置向量，例如：</li></ol><script type="math/tex; mode=display">[   PE_{(pos, 2i)} = \sin\left(\frac{pos}{10000^{2i/d}}\right), \quad   PE_{(pos, 2i+1)} = \cos\left(\frac{pos}{10000^{2i/d}}\right)   ]</script><p>   这样做的一个好处是：不同位置之间的“差值”在空间中有一定结构，且可以泛化到训练长度以外的序列。</p><ol><li><p><strong>可学习位置编码 / 旋转位置编码（RoPE）等</strong></p><ul><li>可学习位置编码：把位置当成一种特殊的 embedding，训练时一并更新；</li><li>RoPE 等：通过在注意力计算中引入位置相关的旋转结构，更适合长序列。</li></ul></li></ol><p>从初学者角度，先记住一句话就够：</p><blockquote><p><strong>Transformer 自己不带顺序感，顺序信息是通过位置编码显式加进去的。</strong></p></blockquote><hr><h2 id="六、一个标准-Transformer-Block-长什么样？"><a href="#六、一个标准-Transformer-Block-长什么样？" class="headerlink" title="六、一个标准 Transformer Block 长什么样？"></a>六、一个标准 Transformer Block 长什么样？</h2><p>把前面的这些组件组合起来，一个标准的 Transformer 编码层大致包含：</p><ul><li>多头自注意力（Multi-Head Self-Attention）</li><li>前馈网络（Feed Forward Network, FFN）</li><li>残差连接（Residual Connection）</li><li>LayerNorm（层归一化）</li></ul><p>简化结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入 x</span><br><span class="line">  ↓</span><br><span class="line">[ 多头自注意力 ]</span><br><span class="line">  ↓</span><br><span class="line">残差连接 + LayerNorm</span><br><span class="line">  ↓</span><br><span class="line">[ 前馈网络 FFN ]</span><br><span class="line">  ↓</span><br><span class="line">残差连接 + LayerNorm</span><br><span class="line">  ↓</span><br><span class="line">输出</span><br></pre></td></tr></table></figure><p>稍微展开一下：</p><ol><li><strong>多头自注意力</strong>：输入序列经过 Q/K/V 投影和 attention 计算，得到新的序列表示；</li><li><strong>残差 + LayerNorm</strong>：把 attention 输出与原输入相加，再做归一化，缓解梯度问题；</li><li><strong>FFN</strong>：位置独立的前馈网络，一般是两层全连接，中间带激活（如 GELU），维度通常放大 4 倍再压回去；</li><li><strong>残差 + LayerNorm</strong>：再叠加一次，形成一层完整的 Block。</li></ol><p>多层这样的 Block 堆叠，就构成了我们常说的 Transformer Encoder/Decoder 主体结构。</p><hr><h2 id="七、Encoder-Decoder-GPT"><a href="#七、Encoder-Decoder-GPT" class="headerlink" title="七、Encoder / Decoder / GPT"></a>七、Encoder / Decoder / GPT</h2><p>原始论文里的 Transformer 是为机器翻译设计的，因此有 Encoder 和 Decoder 两部分：</p><ul><li><strong>Encoder</strong>：多层 Transformer Block，输入为源语言序列，输出为一系列上下文表示；</li><li><p><strong>Decoder</strong>：同样是多层 Block，但每一层包含：</p><ul><li>对已经生成的目标序列做 Masked Self-Attention；</li><li>对 Encoder 输出和当前目标序列做 Encoder-Decoder Attention。</li></ul></li></ul><p>整体流程大致是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入序列 → [多层 Encoder] → 中间表示 → [多层 Decoder] → 输出序列</span><br></pre></td></tr></table></figure><p>后来，在具体任务中出现了几种简化/变体：</p><ol><li><p><strong>只用 Encoder（例如 BERT）</strong></p><ul><li>擅长“理解型”任务：分类、匹配、抽取、检索等。</li></ul></li><li><p><strong>只用 Decoder（例如 GPT 系列）</strong></p><ul><li>使用 Masked Self-Attention，从左到右自回归预测下一个 token；</li><li>擅长“生成型”任务：对话、续写、代码生成等。</li></ul></li><li><p><strong>Encoder + Decoder</strong></p><ul><li>仍然主要用于翻译、摘要这类“输入一句话 / 文档，输出一句话 / 文档”的 Seq2Seq 任务。</li></ul></li></ol><p>作为初学者，我给自己定的目标是：</p><blockquote><p>先把 <strong>Self-Attention、多头、位置编码、Transformer Block</strong> 这几件事搞清楚，<br>然后能大概说清：</p><ul><li>BERT 用的是 Encoder；</li><li>GPT 用的是 Decoder，自回归预测下一个 token。</li></ul></blockquote><p>做到这一点，就已经从“只听过名字”走出了好几步。</p><hr><h2 id="八、为什么大家都在用-Transformer？（一点点宏观视角）"><a href="#八、为什么大家都在用-Transformer？（一点点宏观视角）" class="headerlink" title="八、为什么大家都在用 Transformer？（一点点宏观视角）"></a>八、为什么大家都在用 Transformer？（一点点宏观视角）</h2><p>从一个新手的角度回头看，Transformer 成为主流架构，大致有这几点原因：</p><ol><li><p><strong>计算模式和硬件高度匹配</strong></p><ul><li>主体运算是矩阵乘法和点积，可以很好地利用 GPU/TPU 的并行能力；</li><li>不需要严格按时间步串行，训练长序列和大模型都更高效。</li></ul></li><li><p><strong>表达能力强</strong></p><ul><li>自注意力允许任意两个位置直接交互，而不是依赖链式传递；</li><li>多头 + 多层堆叠，可以学习复杂的语言结构、依赖模式。</li></ul></li><li><p><strong>形式统一，适配多模态</strong></p><ul><li>文本天然是 token 序列；</li><li>图像可以被切成 patch，当成“视觉 token”（比如 ViT）；</li><li>声音、视频等也可以编码成序列，再喂给 Transformer。</li></ul></li></ol><p>从学习者视角看，最大的收益是：</p><blockquote><p><strong>理解一套结构，可以看懂一大批模型的整体框架。</strong></p></blockquote><h2 id="小结：Transformer-神坛"><a href="#小结：Transformer-神坛" class="headerlink" title="小结：Transformer 神坛"></a>小结：Transformer 神坛</h2><p>最后简单收个尾。</p><p>对我这种初学者来说，现在对 Transformer 的认识大概是：</p><ul><li>它的确是这一批模型的基础架构，值得花时间；</li><li>但它并不是玄学，而是一套<strong>很符合现代硬件和大规模数据场景的工程设计</strong>；</li><li>不需要一口气啃到各种长序列技巧、KV Cache、MoE 才算入门。</li></ul><p>我现在给自己的要求只有这几条：</p><ul><li>知道 <strong>为什么会出现 Attention/Transformer</strong>；</li><li>能解释清楚 <strong>Self-Attention + 多头 + 位置编码</strong> 在做什么；</li><li>能画出一个 <strong>Transformer Block</strong> 的大致结构；</li><li>大概知道 BERT / GPT 和原始 Transformer 之间的关系。</li></ul><p>做到这一步，再回头看那篇论文标题 <em>Attention is All You Need</em>，感觉就不再只是一个“标题党”，而是能从工程和建模的角度理解它在说什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从-RNN-爬到-Transformer-山顶&quot;&gt;&lt;a href=&quot;#从-RNN-爬到-Transformer-山顶&quot; class=&quot;headerlink&quot; title=&quot;从 RNN 爬到 Transformer 山顶&quot;&gt;&lt;/a&gt;从 RNN 爬到 Transfor</summary>
      
    
    
    
    <category term="科研" scheme="https://blog.zuquanzhi.top/categories/%E7%A7%91%E7%A0%94/"/>
    
    
    <category term="Transformer" scheme="https://blog.zuquanzhi.top/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="https://blog.zuquanzhi.top/2024/09/20/31301/"/>
    <id>https://blog.zuquanzhi.top/2024/09/20/31301/</id>
    <published>2024-09-20T08:15:29.000Z</published>
    <updated>2025-12-09T11:31:27.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h2><p>KMP 算法用于 <strong>字符串匹配</strong>，通过预处理模式串，避免重复的字符比较，从而实现高效匹配。它的时间复杂度是 <strong>O(n + m)</strong>，其中 n 是主串长度，m 是模式串长度。</p><h2 id="2-主要思想"><a href="#2-主要思想" class="headerlink" title="2. 主要思想"></a>2. 主要思想</h2><p>当模式串中的某个字符匹配失败时，利用已知的部分匹配结果，跳过不必要的比较。这是通过 <strong>部分匹配表</strong>（也称为 <strong>前缀表</strong>）实现的。</p><h2 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3. 术语解释"></a>3. 术语解释</h2><ul><li><strong>前缀</strong>：从字符串的第一个字符开始，不包含最后一个字符的子串。</li><li><strong>后缀</strong>：从字符串的最后一个字符开始，不包含第一个字符的子串。</li><li><strong>部分匹配表</strong>：记录每个字符位置前的部分字符串的最长相同前缀和后缀的长度。</li></ul><h2 id="4-部分匹配表的构建"><a href="#4-部分匹配表的构建" class="headerlink" title="4. 部分匹配表的构建"></a>4. 部分匹配表的构建</h2><p>部分匹配表记录模式串在匹配失败时，可以跳过的字符数量。假设模式串为 <code>pattern</code>，前缀表 <code>prefix[i]</code> 的值表示在 <code>pattern[0...i]</code> 中，最长相同前缀和后缀的长度。</p><p><strong>构建步骤</strong>：</p><ol><li>初始时，<code>prefix[0] = 0</code>，表示第一个字符没有前缀和后缀。</li><li>使用双指针法遍历模式串，一个指针指向当前字符，一个指向最长前缀的下一个字符。</li><li>若当前字符匹配，前缀长度加 1；否则，回退到前一个匹配的前缀位置。</li></ol><h2 id="5-KMP-主算法步骤"><a href="#5-KMP-主算法步骤" class="headerlink" title="5. KMP 主算法步骤"></a>5. KMP 主算法步骤</h2><ol><li>预处理模式串，计算其部分匹配表。</li><li>在主串中按顺序比较字符，若匹配成功，则继续比较下一个字符；若匹配失败，根据部分匹配表跳过一部分字符，减少不必要的比较。</li><li>重复步骤 2 直到找到所有匹配位置或遍历完整个主串。</li></ol><h2 id="6-KMP-代码实现"><a href="#6-KMP-代码实现" class="headerlink" title="6. KMP 代码实现"></a>6. KMP 代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表（前缀表）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computePrefixFunction</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span> m, <span class="type">int</span>* prefix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; pattern[k] != pattern[i]) &#123;</span><br><span class="line">            k = prefix[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[k] == pattern[i]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        prefix[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 主算法，返回匹配的起始位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmpSearch</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* pattern, <span class="type">int</span>* matches, <span class="type">int</span>&amp; match_count)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="type">int</span> prefix[m];</span><br><span class="line">    <span class="built_in">computePrefixFunction</span>(pattern, m, prefix);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>;</span><br><span class="line">    match_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; pattern[q] != text[i]) &#123;</span><br><span class="line">            q = prefix[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[q] == text[i]) &#123;</span><br><span class="line">            ++q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == m) &#123;</span><br><span class="line">            matches[match_count++] = i - m + <span class="number">1</span>;</span><br><span class="line">            q = prefix[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;ABABDABACDABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pattern = <span class="string">&quot;ABABCABAB&quot;</span>;</span><br><span class="line">    <span class="type">int</span> matches[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> match_count;</span><br><span class="line">    <span class="built_in">kmpSearch</span>(text, pattern, matches, match_count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (match_count == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;匹配位置：&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; match_count; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; matches[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-时间复杂度"><a href="#7-时间复杂度" class="headerlink" title="7. 时间复杂度"></a>7. 时间复杂度</h2><ul><li><strong>预处理模式串</strong>：O(m)</li><li><strong>主串匹配</strong>：O(n)<br>因此，整个算法的时间复杂度为 <strong>O(n + m)</strong>。</li></ul><h2 id="8-应用场景"><a href="#8-应用场景" class="headerlink" title="8. 应用场景"></a>8. 应用场景</h2><p>KMP 算法适用于以下场景：</p><ul><li>字符串匹配问题，例如在文本中查找某个单词或子字符串。</li><li>DNA 序列匹配等生物信息学领域。</li></ul><h2 id="9-优势"><a href="#9-优势" class="headerlink" title="9. 优势"></a>9. 优势</h2><ul><li>当模式串包含大量重复部分时，KMP 算法能显著减少比较次数，效率高于朴素的字符串匹配算法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-算法简介&quot;&gt;&lt;a href=&quot;#1-算法简介&quot; class=&quot;headerlink&quot; title=&quot;1. 算法简介&quot;&gt;&lt;/a&gt;1. 算法简介&lt;/h2&gt;&lt;p&gt;KMP 算法用于 &lt;strong&gt;字符串匹配&lt;/strong&gt;，通过预处理模式串，避免重复的字符比较，从</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://blog.zuquanzhi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>堆栈</title>
    <link href="https://blog.zuquanzhi.top/2024/09/20/62758/"/>
    <id>https://blog.zuquanzhi.top/2024/09/20/62758/</id>
    <published>2024-09-20T08:14:26.000Z</published>
    <updated>2025-08-21T13:42:26.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-堆栈笔记"><a href="#C-堆栈笔记" class="headerlink" title="C++ 堆栈笔记"></a>C++ 堆栈笔记</h2><h3 id="1-什么是堆栈？"><a href="#1-什么是堆栈？" class="headerlink" title="1. 什么是堆栈？"></a>1. 什么是堆栈？</h3><p>堆栈（Stack）是一种基础的数据结构，遵循<strong>后进先出</strong>（LIFO, Last In First Out）原则，意味着最后插入堆栈的元素最先被弹出。堆栈的使用场景非常广泛，如处理递归、括号匹配、表达式求值、回溯算法等。它通常用于管理程序的运行状态。</p><h3 id="2-堆栈的特点与应用场景"><a href="#2-堆栈的特点与应用场景" class="headerlink" title="2. 堆栈的特点与应用场景"></a>2. 堆栈的特点与应用场景</h3><h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><ul><li><strong>线性数据结构</strong>：堆栈通过一个线性方式组织元素，只有栈顶（顶部）元素可以被访问。</li><li><strong>操作受限</strong>：仅允许在栈的顶部进行插入（push）和删除（pop）操作，无法直接访问或修改栈中的其他元素。</li><li><strong>动态增长</strong>：堆栈可以动态调整大小，尤其是在使用标准库的实现时（如 C++ 中的 <code>std::stack</code>）。</li></ul><h4 id="2-2-典型应用场景"><a href="#2-2-典型应用场景" class="headerlink" title="2.2 典型应用场景"></a>2.2 典型应用场景</h4><ul><li><strong>递归调用管理</strong>：函数递归时，每次函数调用都会在堆栈中保存局部变量和返回地址，直到递归结束，再从堆栈中逐步恢复状态。</li><li><strong>表达式求值</strong>：在表达式求值过程中，特别是中缀转后缀表达式和逆波兰表达式的计算，堆栈是核心工具。</li><li><strong>括号匹配</strong>：用于检查表达式中括号是否配对，堆栈可以方便地追踪最近遇到的左括号，并在遇到右括号时进行匹配。</li><li><strong>浏览器前进/后退操作</strong>：用户在浏览网页时，前进和后退操作是典型的堆栈应用。前进操作和后退操作分别模拟两种不同的堆栈。</li></ul><h3 id="3-堆栈的操作"><a href="#3-堆栈的操作" class="headerlink" title="3. 堆栈的操作"></a>3. 堆栈的操作</h3><h4 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h4><p>堆栈的主要操作包括：</p><ul><li><strong>push</strong>：将元素插入堆栈的顶部。</li><li><strong>pop</strong>：移除堆栈顶部的元素。</li><li><strong>top（peek）</strong>：返回栈顶元素但不移除它。</li><li><strong>isEmpty</strong>：检查堆栈是否为空。</li><li><strong>size</strong>：返回堆栈中元素的数量。</li></ul><h4 id="3-2-C-标准库实现"><a href="#3-2-C-标准库实现" class="headerlink" title="3.2 C++ 标准库实现"></a>3.2 C++ 标准库实现</h4><p>C++ 提供了标准的 <code>std::stack</code> 容器来实现堆栈。以下是一个简单的例子，演示如何使用 C++ 实现堆栈的基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈操作</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示栈顶元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element after pop: &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断堆栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is not empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出堆栈大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack size: &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-C-手动实现堆栈"><a href="#4-C-手动实现堆栈" class="headerlink" title="4. C++ 手动实现堆栈"></a>4. C++ 手动实现堆栈</h3><p>除了使用标准库的堆栈，我们也可以通过数组或者链表手动实现堆栈。以下是基于数组的实现：</p><h4 id="4-1-使用数组实现堆栈"><a href="#4-1-使用数组实现堆栈" class="headerlink" title="4.1 使用数组实现堆栈"></a>4.1 使用数组实现堆栈</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> arr[MAX]; <span class="comment">// 堆栈数组</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Stack</span>() &#123; top = <span class="number">-1</span>; &#125; <span class="comment">// 初始化栈顶</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt;= MAX - <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack Overflow&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[++top] = x;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; pushed into stack&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack Underflow&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> x = arr[top--];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// peek 操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stack is Empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (top &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; s.<span class="built_in">pop</span>() &lt;&lt; <span class="string">&quot; Popped from stack&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element is &quot;</span> &lt;&lt; s.<span class="built_in">peek</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stack empty: &quot;</span> &lt;&lt; s.<span class="built_in">isEmpty</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-链表实现堆栈"><a href="#4-2-链表实现堆栈" class="headerlink" title="4.2 链表实现堆栈"></a>4.2 链表实现堆栈</h4><p>链表实现堆栈可以避免数组的固定大小限制，它具有动态扩展的能力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    StackNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">StackNode* <span class="title">newNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    StackNode* stackNode = <span class="keyword">new</span> <span class="built_in">StackNode</span>();</span><br><span class="line">    stackNode-&gt;data = data;</span><br><span class="line">    stackNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> stackNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(StackNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(StackNode** root, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    StackNode* stackNode = <span class="built_in">newNode</span>(data);</span><br><span class="line">    stackNode-&gt;next = *root;</span><br><span class="line">    *root = stackNode;</span><br><span class="line">    std::cout &lt;&lt; data &lt;&lt; <span class="string">&quot; pushed to stack\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(StackNode** root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(*root))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    StackNode* temp = *root;</span><br><span class="line">    *root = (*root)-&gt;next;</span><br><span class="line">    <span class="type">int</span> popped = temp-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> popped;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">(StackNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(root))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StackNode* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">push</span>(&amp;root, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">pop</span>(&amp;root) &lt;&lt; <span class="string">&quot; popped from stack\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Top element is &quot;</span> &lt;&lt; <span class="built_in">peek</span>(root) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-常见堆栈应用"><a href="#5-常见堆栈应用" class="headerlink" title="5. 常见堆栈应用"></a>5. 常见堆栈应用</h3><h4 id="5-1-括号匹配问题"><a href="#5-1-括号匹配问题" class="headerlink" title="5.1 括号匹配问题"></a>5.1 括号匹配问题</h4><p>堆栈可以用于括号匹配的检测，以下是一个简单的实现，用于检查括号是否匹配：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">areBracketsBalanced</span><span class="params">(<span class="type">const</span> std::string&amp; expr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : expr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> top = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> ((ch == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (ch == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                (ch == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string expr = <span class="string">&quot;&#123;[()]&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">areBracketsBalanced</span>(expr))</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Balanced\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Not Balanced\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-表达式求值"><a href="#5-2-表达式求值" class="headerlink" title="5.2 表达式求值"></a>5.2 表达式求值</h4><p>堆栈在后缀表达式（逆波兰表达式）计算中非常有用。以下是基于堆栈的后缀表达式求值实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evaluatePostfix</span><span class="params">(<span class="type">const</span> std::string&amp; expr)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : expr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> val1 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> val2 = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: s.<span class="built_in">push</span>(val2 + val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: s.<span class="built_in">push</span>(val2 - val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: s.<span class="built_in">push</span>(val2 * val1); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: s.<span class="built_in">push</span>(val2 / val1); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string expr = <span class="string">&quot;231*+9-&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; <span class="built_in">evaluatePostfix</span>(expr) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-堆栈的时间与空间复杂度"><a href="#6-堆栈的时间与空间复杂度" class="headerlink" title="6. 堆栈的时间与空间复杂度"></a>6. 堆栈的时间与空间复杂度</h3><ul><li><p><strong>时间复杂度</strong>：</p><ul><li><code>push</code> 操作：O(1)</li><li><code>pop</code> 操作：O(1)</li><li><code>peek</code> 操作：O(1)</li></ul></li><li><p><strong>空间复杂度</strong>：O(n)，其中 n 是堆栈中的元素个数。对于链表实现，额外的空间复杂度还包括链表节点的指针存储。</p></li></ul><h3 id="7-堆栈的局限性"><a href="#7-堆栈的局限性" class="headerlink" title="7. 堆栈的局限性"></a>7. 堆栈的局限性</h3><p>虽然堆栈是一种非常高效的结构，但它的局限性包括：</p><ul><li><strong>只能访问栈顶元素</strong>：堆栈限制了只能访问最顶部的元素，无法直接随机访问任何位置的元素。</li><li><strong>溢出风险</strong>：对于基于数组的实现，如果栈超过预设大小，会产生溢出问题。</li><li><strong>应用受限</strong>：对于需要随机访问或双向遍历的应用场景，堆栈并不适用。</li></ul><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>堆栈是一种重要的数据结构，广泛应用于程序运行管理和算法设计中。C++ 提供了 <code>std::stack</code> 方便我们使用堆栈，同时我们也可以基于数组或链表手动实现堆栈，来适应不同的应用场景。理解和掌握堆栈的实现和应用，有助于编写高效的算法和程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-堆栈笔记&quot;&gt;&lt;a href=&quot;#C-堆栈笔记&quot; class=&quot;headerlink&quot; title=&quot;C++ 堆栈笔记&quot;&gt;&lt;/a&gt;C++ 堆栈笔记&lt;/h2&gt;&lt;h3 id=&quot;1-什么是堆栈？&quot;&gt;&lt;a href=&quot;#1-什么是堆栈？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://blog.zuquanzhi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>顺序表（SQList）的理解与实现</title>
    <link href="https://blog.zuquanzhi.top/2024/09/20/33510/"/>
    <id>https://blog.zuquanzhi.top/2024/09/20/33510/</id>
    <published>2024-09-20T08:12:06.000Z</published>
    <updated>2025-12-09T11:33:44.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是顺序表（SQList）-s"><a href="#1-什么是顺序表（SQList）-s" class="headerlink" title="1. 什么是顺序表（SQList） ß"></a>1. 什么是顺序表（SQList） ß</h2><p>顺序表是一种常见的线性数据结构，其特点是通过一组连续的内存空间来存储数据元素。在顺序表中，每个元素都有一个直接的前驱和后继（除了第一个元素没有前驱，最后一个元素没有后继）。顺序表的操作主要包括插入、删除、查找等。</p><h2 id="2-顺序表的特点"><a href="#2-顺序表的特点" class="headerlink" title="2. 顺序表的特点"></a>2. 顺序表的特点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>访问速度快</strong>：由于元素在内存中是连续存储的，因此可以通过索引直接访问，时间复杂度为 O(1)。</li><li><strong>易于实现</strong>：使用数组或容器如 <code>std::vector</code> 可以轻松实现顺序表。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>插入和删除效率低</strong>：当在表中间插入或删除元素时，需要移动后续的所有元素，最坏情况下的时间复杂度为 O(n)。</li><li><strong>空间预分配</strong>：需要提前知道表的最大容量，否则可能会导致内存不足。</li></ul><h2 id="3-顺序表的实现"><a href="#3-顺序表的实现" class="headerlink" title="3. 顺序表的实现"></a>3. 顺序表的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 当前顺序表的实际大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SQList</span>() : <span class="built_in">size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向顺序表中添加元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> elem)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(elem);</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据索引获取元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Index out of bounds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定索引处的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Index out of bounds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elements.<span class="built_in">erase</span>(elements.<span class="built_in">begin</span>() + index);</span><br><span class="line">        --size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印顺序表的内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">get</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取顺序表的大小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SQList list;</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">2</span>);</span><br><span class="line">    list.<span class="built_in">add</span>(<span class="number">3</span>);</span><br><span class="line">    list.<span class="built_in">print</span>(); <span class="comment">// 输出: 1 2 3</span></span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">remove</span>(<span class="number">1</span>);</span><br><span class="line">    list.<span class="built_in">print</span>(); <span class="comment">// 输出: 1 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4. 时间复杂度分析"></a>4. 时间复杂度分析</h2><ul><li><strong>访问</strong>: O(1)，直接通过索引访问。</li><li><strong>插入</strong>: 最坏情况下为 O(n)，当插入位置位于表的开头或中间时。</li><li><strong>删除</strong>: 最坏情况下为 O(n)，当删除位置位于表的开头或中间时。</li><li><strong>查找</strong>: O(n)，需要遍历整个表。</li></ul><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><p>顺序表适合用于需要频繁访问但插入和删除较少的情况，例如缓存数据、静态数据集合等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是顺序表（SQList）-s&quot;&gt;&lt;a href=&quot;#1-什么是顺序表（SQList）-s&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是顺序表（SQList） ß&quot;&gt;&lt;/a&gt;1. 什么是顺序表（SQList） ß&lt;/h2&gt;&lt;p&gt;顺序表是</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://blog.zuquanzhi.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="https://blog.zuquanzhi.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>screen命令应用</title>
    <link href="https://blog.zuquanzhi.top/2024/09/18/60232/"/>
    <id>https://blog.zuquanzhi.top/2024/09/18/60232/</id>
    <published>2024-09-18T15:42:35.000Z</published>
    <updated>2025-09-17T13:30:58.690Z</updated>
    
    <content type="html"><![CDATA[<p><code>screen</code> 是一个非常强大的终端会话管理工具，它可以让你在多个终端窗口中运行任务，并在会话断开后继续保持任务的执行状态。特别适合长时间运行的任务或远程连接的任务管理。<br>对于远程服务器player简直是屠龙宝刀。</p><h3 id="常见用法："><a href="#常见用法：" class="headerlink" title="常见用法："></a>常见用法：</h3><p>以下是一些常见的 <code>screen</code> 命令和用法：</p><h4 id="1-启动新的-screen-会话"><a href="#1-启动新的-screen-会话" class="headerlink" title="1. 启动新的 screen 会话"></a>1. <strong>启动新的 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen</span><br></pre></td></tr></table></figure><ul><li>启动一个新的 <code>screen</code> 会话。在新窗口中，你可以运行任何命令。</li><li>默认情况下，<code>screen</code> 会自动分配一个会话 ID。</li></ul><h4 id="2-启动带名称的-screen-会话"><a href="#2-启动带名称的-screen-会话" class="headerlink" title="2. 启动带名称的 screen 会话"></a>2. <strong>启动带名称的 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name</span><br></pre></td></tr></table></figure><ul><li>通过 <code>-S</code> 选项为会话指定名称 <code>session_name</code>，便于管理多个会话。</li></ul><h4 id="3-分离（Detach）会话"><a href="#3-分离（Detach）会话" class="headerlink" title="3. 分离（Detach）会话"></a>3. <strong>分离（Detach）会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + D</span><br></pre></td></tr></table></figure><ul><li>使用快捷键 <code>Ctrl + A + D</code>，可以将当前会话暂时分离（detach），但命令仍会继续在后台执行。</li></ul><h4 id="4-恢复（Reattach）已分离的会话"><a href="#4-恢复（Reattach）已分离的会话" class="headerlink" title="4. 恢复（Reattach）已分离的会话"></a>4. <strong>恢复（Reattach）已分离的会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r</span><br></pre></td></tr></table></figure><ul><li>恢复上一个分离的 <code>screen</code> 会话。</li></ul><h4 id="5-查看现有-screen-会话"><a href="#5-查看现有-screen-会话" class="headerlink" title="5. 查看现有 screen 会话"></a>5. <strong>查看现有 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -<span class="built_in">ls</span></span><br></pre></td></tr></table></figure><ul><li>列出当前所有的 <code>screen</code> 会话，包括那些分离的会话。例如：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There are screens on:</span><br><span class="line">    <span class="number">1234</span><span class="selector-class">.session_name</span>    (Detached)</span><br><span class="line">    <span class="number">5678</span><span class="selector-class">.pts-0</span><span class="selector-class">.hostname</span>  (Attached)</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-恢复指定的会话"><a href="#6-恢复指定的会话" class="headerlink" title="6. 恢复指定的会话"></a>6. <strong>恢复指定的会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure><ul><li>恢复名为 <code>session_name</code> 的会话。你可以通过 <code>screen -ls</code> 查看到所有会话名称。</li></ul><h4 id="7-杀掉-screen-会话"><a href="#7-杀掉-screen-会话" class="headerlink" title="7. 杀掉 screen 会话"></a>7. <strong>杀掉 <code>screen</code> 会话</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -X -S session_name quit</span><br></pre></td></tr></table></figure><ul><li><code>-S session_name</code> 指定会话名，<code>-X quit</code> 用于杀掉该会话。</li></ul><h4 id="8-在会话中分屏操作"><a href="#8-在会话中分屏操作" class="headerlink" title="8. 在会话中分屏操作"></a>8. <strong>在会话中分屏操作</strong></h4><ul><li><p><strong>水平分屏：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + S</span><br></pre></td></tr></table></figure><p>然后使用 <code>Ctrl + A + Tab</code> 来在不同的屏幕之间切换。</p></li><li><p><strong>垂直分屏：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + |  <span class="comment"># 使用 | 进行垂直分屏</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭分屏：</strong><br>将光标聚焦到需要关闭的分屏窗口中，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + A + X</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-退出-screen-会话"><a href="#9-退出-screen-会话" class="headerlink" title="9. 退出 screen 会话"></a>9. <strong>退出 <code>screen</code> 会话</strong></h4><p>在会话窗口中直接输入 <code>exit</code>，或在分屏中通过 <code>Ctrl + A + X</code> 来关闭。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;screen&lt;/code&gt; 是一个非常强大的终端会话管理工具，它可以让你在多个终端窗口中运行任务，并在会话断开后继续保持任务的执行状态。特别适合长时间运行的任务或远程连接的任务管理。&lt;br&gt;对于远程服务器player简直是屠龙宝刀。&lt;/p&gt;
&lt;h3 id=&quot;常见</summary>
      
    
    
    
    <category term="工具" scheme="https://blog.zuquanzhi.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="命令" scheme="https://blog.zuquanzhi.top/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
